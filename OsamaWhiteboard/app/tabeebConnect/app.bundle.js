(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.APP = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    /* jshint -W117 */
    /* application specific logic */
    
    require("jquery");
    require("jquery-ui");
    require("strophe");
    require("strophe-disco");
    require("strophe-caps");
    require("tooltip");
    require("popover");
    window.toastr = require("toastr");
    require("jQuery-Impromptu");
    require("autosize");
    
    var APP =
    {
        init: function () {
            this.UI = require("./modules/UI/UI");
            this.API = require("./modules/API/API");
            this.connectionquality =
                require("./modules/connectionquality/connectionquality");
            this.statistics = require("./modules/statistics/statistics");
            this.RTC = require("./modules/RTC/RTC");
            this.desktopsharing =
                require("./modules/desktopsharing/desktopsharing");
            this.xmpp = require("./modules/xmpp/xmpp");
            this.keyboardshortcut =
                require("./modules/keyboardshortcut/keyboardshortcut");
            this.translation = require("./modules/translation/translation");
            this.settings = require("./modules/settings/Settings");
            //this.DTMF = require("./modules/DTMF/DTMF");
            this.members = require("./modules/members/MemberList");
            this.configFetch = require("./modules/config/HttpConfigFetch");
        }
    };
    
    function init() {
        
        APP.desktopsharing.init();
        APP.RTC.start();
        APP.xmpp.start();
        APP.statistics.start();
        APP.connectionquality.init();
        APP.keyboardshortcut.init();
        APP.members.start();
    }
    
    /**
     * If we have an HTTP endpoint for getting config.json configured we're going to
     * read it and override properties from config.js and interfaceConfig.js.
     * If there is no endpoint we'll just continue with initialization.
     * Keep in mind that if the endpoint has been configured and we fail to obtain
     * the config for any reason then the conference won't start and error message
     * will be displayed to the user.
     */
    function obtainConfigAndInit() {
        var roomName = APP.UI.getRoomNode();
        
        if (config.configLocation) {
            APP.configFetch.obtainConfig(
                config.configLocation, roomName,
                // Get config result callback
                function(success, error) {
                    if (success) {
                        console.log("(TIME) configuration fetched:\t",
                            window.performance.now());
                        init();
                    } else {
                        // Show obtain config error,
                        // pass the error object for report
                        APP.UI.messageHandler.openReportDialog(
                            null, "dialog.connectError", error);
                    }
                });
        } else {
            require("./modules/config/BoshAddressChoice").chooseAddress(
                config, roomName);
            
            init();
        }
    }
    
    
    $(document).on("tabeebConnect_connect", function (event) {
        console.log("(TIME) document ready:\t", window.performance.now());
        
        var URLProcessor = require("./modules/config/URLProcessor");
        URLProcessor.setConfigParametersFromUrl();
        APP.init();
        
        APP.translation.init();
        
        if(APP.API.isEnabled())
            APP.API.init();
        
        //APP.UI.start(obtainConfigAndInit);
        init();
        
        if (event.callback)
            event.callback();
    });
    
    $(window).bind('beforeunload', function () {
        if(APP.API.isEnabled())
            APP.API.dispose();
    });
    
    module.exports = APP;
    
    
},{"./modules/API/API":2,"./modules/RTC/RTC":6,"./modules/UI/UI":10,"./modules/config/BoshAddressChoice":41,"./modules/config/HttpConfigFetch":42,"./modules/config/URLProcessor":43,"./modules/connectionquality/connectionquality":45,"./modules/desktopsharing/desktopsharing":47,"./modules/keyboardshortcut/keyboardshortcut":48,"./modules/members/MemberList":49,"./modules/settings/Settings":50,"./modules/statistics/statistics":55,"./modules/translation/translation":56,"./modules/xmpp/xmpp":74,"autosize":76,"jQuery-Impromptu":82,"jquery":84,"jquery-ui":83,"popover":77,"strophe":173,"strophe-caps":174,"strophe-disco":175,"toastr":176,"tooltip":78}],2:[function(require,module,exports){
    /* global APP */
    /**
     * Implements API class that communicates with external api class
     * and provides interface to access Jitsi Meet features by external
     * applications that embed Jitsi Meet
     */
    
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    
    /**
     * List of the available commands.
     * @type {{
 *              displayName: inputDisplayNameHandler,
 *              toggleAudio: toggleAudio,
 *              toggleVideo: toggleVideo,
 *              toggleFilmStrip: toggleFilmStrip,
 *              toggleChat: toggleChat,
 *              toggleContactList: toggleContactList
 *          }}
     */
    var commands = {};
    
    function initCommands() {
        commands = {
            displayName: APP.UI.inputDisplayNameHandler,
            toggleAudio: APP.UI.toggleAudio,
            toggleVideo: APP.UI.toggleVideo,
            toggleFilmStrip: APP.UI.toggleFilmStrip,
            toggleChat: APP.UI.toggleChat,
            toggleContactList: APP.UI.toggleContactList
        };
    }
    
    
    /**
     * Maps the supported events and their status
     * (true it the event is enabled and false if it is disabled)
     * @type {{
 *              incomingMessage: boolean,
 *              outgoingMessage: boolean,
 *              displayNameChange: boolean,
 *              participantJoined: boolean,
 *              participantLeft: boolean
 *      }}
     */
    var events = {
        incomingMessage: false,
        outgoingMessage:false,
        displayNameChange: false,
        participantJoined: false,
        participantLeft: false
    };
    
    var displayName = {};
    
    /**
     * Processes commands from external application.
     * @param message the object with the command
     */
    function processCommand(message) {
        if (message.action != "execute") {
            console.error("Unknown action of the message");
            return;
        }
        for (var key in message) {
            if(commands[key])
                commands[key].apply(null, message[key]);
        }
    }
    
    /**
     * Processes events objects from external applications
     * @param event the event
     */
    function processEvent(event) {
        if (!event.action) {
            console.error("Event with no action is received.");
            return;
        }
        
        var i = 0;
        switch(event.action) {
            case "add":
                for (; i < event.events.length; i++) {
                    events[event.events[i]] = true;
                }
                break;
            case "remove":
                for (; i < event.events.length; i++) {
                    events[event.events[i]] = false;
                }
                break;
            default:
                console.error("Unknown action for event.");
        }
    }
    
    /**
     * Sends message to the external application.
     * @param object
     */
    function sendMessage(object) {
        window.parent.postMessage(JSON.stringify(object), "*");
    }
    
    /**
     * Processes a message event from the external application
     * @param event the message event
     */
    function processMessage(event) {
        var message;
        try {
            message = JSON.parse(event.data);
        } catch (e) {}
        
        if(!message.type)
            return;
        switch (message.type) {
            case "command":
                processCommand(message);
                break;
            case "event":
                processEvent(message);
                break;
            default:
                console.error("Unknown type of the message");
                return;
        }
    }
    
    function setupListeners() {
        APP.xmpp.addListener(XMPPEvents.MUC_MEMBER_JOINED, function (from) {
            API.triggerEvent("participantJoined", {jid: from});
        });
        APP.xmpp.addListener(XMPPEvents.MESSAGE_RECEIVED,
            function (from, nick, txt, myjid, stamp) {
                if (from != myjid)
                    API.triggerEvent("incomingMessage",
                        {"from": from, "nick": nick, "message": txt, "stamp": stamp});
            });
        APP.xmpp.addListener(XMPPEvents.MUC_MEMBER_LEFT, function (jid) {
            API.triggerEvent("participantLeft", {jid: jid});
        });
        APP.xmpp.addListener(XMPPEvents.DISPLAY_NAME_CHANGED,
            function (jid, newDisplayName) {
                var name = displayName[jid];
                if(!name || name != newDisplayName) {
                    API.triggerEvent("displayNameChange",
                        {jid: jid, displayname: newDisplayName});
                    displayName[jid] = newDisplayName;
                }
            });
        APP.xmpp.addListener(XMPPEvents.SENDING_CHAT_MESSAGE, function (body) {
            APP.API.triggerEvent("outgoingMessage", {"message": body});
        });
    }
    
    var API = {
        /**
         * Check whether the API should be enabled or not.
         * @returns {boolean}
         */
        isEnabled: function () {
            var hash = location.hash;
            if (hash && hash.indexOf("external") > -1 && window.postMessage)
                return true;
            return false;
        },
        /**
         * Initializes the APIConnector. Setups message event listeners that will
         * receive information from external applications that embed Jitsi Meet.
         * It also sends a message to the external application that APIConnector
         * is initialized.
         */
        init: function () {
            initCommands();
            if (window.addEventListener) {
                window.addEventListener('message',
                    processMessage, false);
            }
            else {
                window.attachEvent('onmessage', processMessage);
            }
            sendMessage({type: "system", loaded: true});
            setupListeners();
        },
        /**
         * Checks whether the event is enabled ot not.
         * @param name the name of the event.
         * @returns {*}
         */
        isEventEnabled: function (name) {
            return events[name];
        },
        
        /**
         * Sends event object to the external application that has been subscribed
         * for that event.
         * @param name the name event
         * @param object data associated with the event
         */
        triggerEvent: function (name, object) {
            if(this.isEnabled() && this.isEventEnabled(name))
                sendMessage({
                    type: "event", action: "result", event: name, result: object});
        },
        
        /**
         * Removes the listeners.
         */
        dispose: function () {
            if(window.removeEventListener) {
                window.removeEventListener("message",
                    processMessage, false);
            }
            else {
                window.detachEvent('onmessage', processMessage);
            }
        }
    };
    
    module.exports = API;
},{"../../service/xmpp/XMPPEvents":188}],3:[function(require,module,exports){
    /* global config, APP, Strophe */
    /* jshint -W101 */
    
    // cache datachannels to avoid garbage collection
    // https://code.google.com/p/chromium/issues/detail?id=405545
    var RTCEvents = require("../../service/RTC/RTCEvents");
    
    var _dataChannels = [];
    var eventEmitter = null;
    
    var DataChannels = {
        /**
         * Callback triggered by PeerConnection when new data channel is opened
         * on the bridge.
         * @param event the event info object.
         */
        onDataChannel: function (event) {
            var dataChannel = event.channel;
            
            dataChannel.onopen = function () {
                console.info("Data channel opened by the Videobridge!", dataChannel);
                
                // Code sample for sending string and/or binary data
                // Sends String message to the bridge
                //dataChannel.send("Hello bridge!");
                // Sends 12 bytes binary message to the bridge
                //dataChannel.send(new ArrayBuffer(12));
                
                eventEmitter.emit(RTCEvents.DATA_CHANNEL_OPEN);
            };
            
            dataChannel.onerror = function (error) {
                console.error("Data Channel Error:", error, dataChannel);
            };
            
            dataChannel.onmessage = function (event) {
                var data = event.data;
                // JSON
                var obj;
                
                try {
                    obj = JSON.parse(data);
                }
                catch (e) {
                    console.error(
                        "Failed to parse data channel message as JSON: ",
                        data,
                        dataChannel);
                }
                if (('undefined' !== typeof(obj)) && (null !== obj)) {
                    var colibriClass = obj.colibriClass;
                    
                    if ("DominantSpeakerEndpointChangeEvent" === colibriClass) {
                        // Endpoint ID from the Videobridge.
                        var dominantSpeakerEndpoint = obj.dominantSpeakerEndpoint;
                        
                        console.info(
                            "Data channel new dominant speaker event: ",
                            dominantSpeakerEndpoint);
                        eventEmitter.emit(RTCEvents.DOMINANTSPEAKER_CHANGED, dominantSpeakerEndpoint);
                    }
                    else if ("InLastNChangeEvent" === colibriClass) {
                        var oldValue = obj.oldValue;
                        var newValue = obj.newValue;
                        // Make sure that oldValue and newValue are of type boolean.
                        var type;
                        
                        if ((type = typeof oldValue) !== 'boolean') {
                            if (type === 'string') {
                                oldValue = (oldValue == "true");
                            } else {
                                oldValue = Boolean(oldValue).valueOf();
                            }
                        }
                        if ((type = typeof newValue) !== 'boolean') {
                            if (type === 'string') {
                                newValue = (newValue == "true");
                            } else {
                                newValue = Boolean(newValue).valueOf();
                            }
                        }
                        
                        eventEmitter.emit(RTCEvents.LASTN_CHANGED, oldValue, newValue);
                    }
                    else if ("LastNEndpointsChangeEvent" === colibriClass) {
                        // The new/latest list of last-n endpoint IDs.
                        var lastNEndpoints = obj.lastNEndpoints;
                        // The list of endpoint IDs which are entering the list of
                        // last-n at this time i.e. were not in the old list of last-n
                        // endpoint IDs.
                        var endpointsEnteringLastN = obj.endpointsEnteringLastN;
                        
                        console.info(
                            "Data channel new last-n event: ",
                            lastNEndpoints, endpointsEnteringLastN, obj);
                        eventEmitter.emit(RTCEvents.LASTN_ENDPOINT_CHANGED,
                            lastNEndpoints, endpointsEnteringLastN, obj);
                    }
                    else {
                        console.debug("Data channel JSON-formatted message: ", obj);
                        // The received message appears to be appropriately
                        // formatted (i.e. is a JSON object which assigns a value to
                        // the mandatory property colibriClass) so don't just
                        // swallow it, expose it to public consumption.
                        eventEmitter.emit("rtc.datachannel." + colibriClass, obj);
                    }
                }
            };
            
            dataChannel.onclose = function () {
                console.info("The Data Channel closed", dataChannel);
                var idx = _dataChannels.indexOf(dataChannel);
                if (idx > -1)
                    _dataChannels = _dataChannels.splice(idx, 1);
            };
            _dataChannels.push(dataChannel);
        },
        
        /**
         * Binds "ondatachannel" event listener to given PeerConnection instance.
         * @param peerConnection WebRTC peer connection instance.
         */
        init: function (peerConnection, emitter) {
            if(!config.openSctp)
                return;
            
            peerConnection.ondatachannel = this.onDataChannel;
            eventEmitter = emitter;
            
            // Sample code for opening new data channel from Jitsi Meet to the bridge.
            // Although it's not a requirement to open separate channels from both bridge
            // and peer as single channel can be used for sending and receiving data.
            // So either channel opened by the bridge or the one opened here is enough
            // for communication with the bridge.
            /*var dataChannelOptions =
             {
             reliable: true
             };
             var dataChannel
             = peerConnection.createDataChannel("myChannel", dataChannelOptions);
            
             // Can be used only when is in open state
             dataChannel.onopen = function ()
             {
             dataChannel.send("My channel !!!");
             };
             dataChannel.onmessage = function (event)
             {
             var msgData = event.data;
             console.info("Got My Data Channel Message:", msgData, dataChannel);
             };*/
        },
        
        handleSelectedEndpointEvent: function (userResource) {
            onXXXEndpointChanged("selected", userResource);
        },
        handlePinnedEndpointEvent: function (userResource) {
            onXXXEndpointChanged("pinned", userResource);
        },
        
        some: function (callback, thisArg) {
            if (_dataChannels && _dataChannels.length !== 0) {
                if (thisArg)
                    return _dataChannels.some(callback, thisArg);
                else
                    return _dataChannels.some(callback);
            } else {
                return false;
            }
        }
    };
    
    /**
     * Notifies Videobridge about a change in the value of a specific
     * endpoint-related property such as selected endpoint and pinnned endpoint.
     *
     * @param xxx the name of the endpoint-related property whose value changed
     * @param userResource the new value of the endpoint-related property after the
     * change
     */
    function onXXXEndpointChanged(xxx, userResource) {
        // Derive the correct words from xxx such as selected and Selected, pinned
        // and Pinned.
        var head = xxx.charAt(0);
        var tail = xxx.substring(1);
        var lower = head.toLowerCase() + tail;
        var upper = head.toUpperCase() + tail;
        
        // Notify Videobridge about the specified endpoint change.
        console.log(lower + ' endpoint changed: ', userResource);
        DataChannels.some(function (dataChannel) {
            if (dataChannel.readyState == 'open') {
                console.log(
                    'sending ' + lower
                    + ' endpoint changed notification to the bridge: ',
                    userResource);
                
                var jsonObject = {};
                
                jsonObject.colibriClass = (upper + 'EndpointChangedEvent');
                jsonObject[lower + "Endpoint"]
                    = (userResource ? userResource : null);
                dataChannel.send(JSON.stringify(jsonObject));
                
                return true;
            }
        });
    }
    
    module.exports = DataChannels;
    
    
},{"../../service/RTC/RTCEvents":178}],4:[function(require,module,exports){
    /* global APP */
    var StreamEventTypes = require("../../service/RTC/StreamEventTypes.js");
    var RTCEvents = require("../../service/RTC/RTCEvents");
    var RTCBrowserType = require("./RTCBrowserType");
    
    /**
     * This implements 'onended' callback normally fired by WebRTC after the stream
     * is stopped. There is no such behaviour yet in FF, so we have to add it.
     * @param stream original WebRTC stream object to which 'onended' handling
     *               will be added.
     */
    function implementOnEndedHandling(localStream) {
        var stream = localStream.getOriginalStream();
        var originalStop = stream.stop;
        stream.stop = function () {
            originalStop.apply(stream);
            if (localStream.isActive()) {
                stream.onended();
            }
        };
    }
    
    function LocalStream(stream, type, eventEmitter, videoType, isGUMStream) {
        this.stream = stream;
        this.eventEmitter = eventEmitter;
        this.type = type;
        this.videoType = videoType;
        this.isGUMStream = true;
        if(isGUMStream === false)
            this.isGUMStream = isGUMStream;
        var self = this;
        if(type == "audio") {
            this.getTracks = function () {
                return self.stream.getAudioTracks();
            };
        } else {
            this.getTracks = function () {
                return self.stream.getVideoTracks();
            };
        }
        
        APP.RTC.addMediaStreamInactiveHandler(
            this.stream,
            function () {
                self.streamEnded();
            });
        
        if (RTCBrowserType.isFirefox()) {
            implementOnEndedHandling(this);
        }
    }
    
    LocalStream.prototype.streamEnded = function () {
        this.eventEmitter.emit(StreamEventTypes.EVENT_TYPE_LOCAL_ENDED, this);
    };
    
    LocalStream.prototype.getOriginalStream = function()
    {
        return this.stream;
    };
    
    LocalStream.prototype.isAudioStream = function () {
        return this.type === "audio";
    };
    
    LocalStream.prototype.setMute = function (mute)
    {
        var isAudio = this.isAudioStream();
        var eventType = isAudio ? RTCEvents.AUDIO_MUTE : RTCEvents.VIDEO_MUTE;
        
        if ((window.location.protocol != "https:" && this.isGUMStream) ||
            (isAudio && this.isGUMStream) || this.videoType === "screen" ||
                // FIXME FF does not support 'removeStream' method used to mute
            RTCBrowserType.isFirefox()) {
            
            var tracks = this.getTracks();
            for (var idx = 0; idx < tracks.length; idx++) {
                tracks[idx].enabled = !mute;
            }
            this.eventEmitter.emit(eventType, mute);
        } else {
            if (mute) {
                APP.xmpp.removeStream(this.stream);
                APP.RTC.stopMediaStream(this.stream);
                this.eventEmitter.emit(eventType, true);
            } else {
                var self = this;
                APP.RTC.rtcUtils.obtainAudioAndVideoPermissions(
                    (this.isAudioStream() ? ["audio"] : ["video"]),
                    function (stream) {
                        if (isAudio) {
                            APP.RTC.changeLocalAudio(stream,
                                function () {
                                    self.eventEmitter.emit(eventType, false);
                                });
                        } else {
                            APP.RTC.changeLocalVideo(stream, false,
                                function () {
                                    self.eventEmitter.emit(eventType, false);
                                });
                        }
                    });
            }
        }
    };
    
    LocalStream.prototype.isMuted = function () {
        var tracks = [];
        if (this.isAudioStream()) {
            tracks = this.stream.getAudioTracks();
        } else {
            if (!this.isActive())
                return true;
            tracks = this.stream.getVideoTracks();
        }
        for (var idx = 0; idx < tracks.length; idx++) {
            if(tracks[idx].enabled)
                return false;
        }
        return true;
    };
    
    LocalStream.prototype.getId = function () {
        return this.stream.getTracks()[0].id;
    };
    
    /**
     * Checks whether the MediaStream is avtive/not ended.
     * When there is no check for active we don't have information and so
     * will return that stream is active (in case of FF).
     * @returns {boolean} whether MediaStream is active.
     */
    LocalStream.prototype.isActive = function () {
        if((typeof this.stream.active !== "undefined"))
            return this.stream.active;
        else
            return true;
    };
    
    module.exports = LocalStream;
    
},{"../../service/RTC/RTCEvents":178,"../../service/RTC/StreamEventTypes.js":180,"./RTCBrowserType":7}],5:[function(require,module,exports){
    var MediaStreamType = require("../../service/RTC/MediaStreamTypes");
    
    /**
     * Creates a MediaStream object for the given data, session id and ssrc.
     * It is a wrapper class for the MediaStream.
     *
     * @param data the data object from which we obtain the stream,
     * the peerjid, etc.
     * @param ssrc the ssrc corresponding to this MediaStream
     * @param mute the whether this MediaStream is muted
     *
     * @constructor
     */
    function MediaStream(data, ssrc, browser, eventEmitter, muted) {
        
        // XXX(gp) to minimize headaches in the future, we should build our
        // abstractions around tracks and not streams. ORTC is track based API.
        // Mozilla expects m-lines to represent media tracks.
        //
        // Practically, what I'm saying is that we should have a MediaTrack class
        // and not a MediaStream class.
        //
        // Also, we should be able to associate multiple SSRCs with a MediaTrack as
        // a track might have an associated RTX and FEC sources.
        
        this.stream = data.stream;
        this.peerjid = data.peerjid;
        this.videoType = data.videoType;
        this.ssrc = ssrc;
        this.type = (this.stream.getVideoTracks().length > 0)?
            MediaStreamType.VIDEO_TYPE : MediaStreamType.AUDIO_TYPE;
        this.muted = muted;
        this.eventEmitter = eventEmitter;
    }
    
    
    MediaStream.prototype.getOriginalStream = function() {
        return this.stream;
    };
    
    MediaStream.prototype.setMute = function (value) {
        this.stream.muted = value;
        this.muted = value;
    };
    
    module.exports = MediaStream;
    
},{"../../service/RTC/MediaStreamTypes":177}],6:[function(require,module,exports){
    /* global APP */
    var EventEmitter = require("events");
    var RTCBrowserType = require("./RTCBrowserType");
    var RTCUtils = require("./RTCUtils.js");
    var LocalStream = require("./LocalStream.js");
    var DataChannels = require("./DataChannels");
    var MediaStream = require("./MediaStream.js");
    var DesktopSharingEventTypes
        = require("../../service/desktopsharing/DesktopSharingEventTypes");
    var MediaStreamType = require("../../service/RTC/MediaStreamTypes");
    var StreamEventTypes = require("../../service/RTC/StreamEventTypes.js");
    var RTCEvents = require("../../service/RTC/RTCEvents.js");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var UIEvents = require("../../service/UI/UIEvents");
    
    var eventEmitter = new EventEmitter();
    
    
    function getMediaStreamUsage()
    {
        var result = {
            audio: true,
            video: true
        };
        
        /** There are some issues with the desktop sharing
         * when this property is enabled.
         * WARNING: We must change the implementation to start video/audio if we
         * receive from the focus that the peer is not muted.
        
         var isSecureConnection = window.location.protocol == "https:";
        
         if(config.disableEarlyMediaPermissionRequests || !isSecureConnection)
         {
        result = {
            audio: false,
            video: false
        };

    }
         **/
        
        return result;
    }
    
    var RTC = {
        // Exposes DataChannels to public consumption (e.g. jitsi-meet-torture)
        // without the necessity to require the module.
        "DataChannels": DataChannels,
        
        rtcUtils: null,
        devices: {
            audio: true,
            video: true
        },
        remoteStreams: {},
        localAudio: null,
        localVideo: null,
        addStreamListener: function (listener, eventType) {
            eventEmitter.on(eventType, listener);
        },
        addListener: function (type, listener) {
            eventEmitter.on(type, listener);
        },
        removeStreamListener: function (listener, eventType) {
            if(!(eventType instanceof StreamEventTypes))
                throw "Illegal argument";
            
            eventEmitter.removeListener(eventType, listener);
        },
        createLocalStream: function (stream, type, change, videoType,
                                     isMuted, isGUMStream) {
            
            var localStream =
                new LocalStream(stream, type, eventEmitter, videoType, isGUMStream);
            if(isMuted === true)
                localStream.setMute(true);
            
            if(type == "audio") {
                this.localAudio = localStream;
            } else {
                this.localVideo = localStream;
            }
            var eventType = StreamEventTypes.EVENT_TYPE_LOCAL_CREATED;
            if(change)
                eventType = StreamEventTypes.EVENT_TYPE_LOCAL_CHANGED;
            
            eventEmitter.emit(eventType, localStream, isMuted);
            return localStream;
        },
        createRemoteStream: function (data, ssrc) {
            var jid = data.peerjid || APP.xmpp.myJid();
            
            // check the video muted state from last stored presence if any
            var muted = false;
            var pres = APP.xmpp.getLastPresence(jid);
            if (pres && pres.videoMuted) {
                muted = pres.videoMuted;
            }
            
            var remoteStream = new MediaStream(data, ssrc,
                RTCBrowserType.getBrowserType(), eventEmitter, muted);
            
            if(!this.remoteStreams[jid]) {
                this.remoteStreams[jid] = {};
            }
            this.remoteStreams[jid][remoteStream.type]= remoteStream;
            eventEmitter.emit(StreamEventTypes.EVENT_TYPE_REMOTE_CREATED,
                remoteStream);
            return remoteStream;
        },
        getPCConstraints: function () {
            return this.rtcUtils.pc_constraints;
        },
        getUserMediaWithConstraints:function(um, success_callback,
                                             failure_callback, resolution,
                                             bandwidth, fps, desktopStream)
        {
            return this.rtcUtils.getUserMediaWithConstraints(um, success_callback,
                failure_callback, resolution, bandwidth, fps, desktopStream);
        },
        attachMediaStream:  function (elSelector, stream) {
            this.rtcUtils.attachMediaStream(elSelector, stream);
        },
        getStreamID:  function (stream) {
            return this.rtcUtils.getStreamID(stream);
        },
        getVideoSrc: function (element) {
            return this.rtcUtils.getVideoSrc(element);
        },
        setVideoSrc: function (element, src) {
            this.rtcUtils.setVideoSrc(element, src);
        },
        getVideoElementName: function () {
            return RTCBrowserType.isTemasysPluginUsed() ? 'object' : 'video';
        },
        dispose: function() {
            if (this.rtcUtils) {
                this.rtcUtils = null;
            }
        },
        stop:  function () {
            this.dispose();
        },
        start: function () {
            var self = this;
            APP.desktopsharing.addListener(
                DesktopSharingEventTypes.NEW_STREAM_CREATED,
                function (stream, isUsingScreenStream, callback) {
                    self.changeLocalVideo(stream, isUsingScreenStream, callback);
                });
            APP.xmpp.addListener(XMPPEvents.CALL_INCOMING, function(event) {
                DataChannels.init(event.peerconnection, eventEmitter);
            });
            APP.UI.addListener(UIEvents.SELECTED_ENDPOINT,
                DataChannels.handleSelectedEndpointEvent);
            APP.UI.addListener(UIEvents.PINNED_ENDPOINT,
                DataChannels.handlePinnedEndpointEvent);
            
            // In case of IE we continue from 'onReady' callback
            // passed to RTCUtils constructor. It will be invoked by Temasys plugin
            // once it is initialized.
            var onReady = function () {
                eventEmitter.emit(RTCEvents.RTC_READY, true);
                self.rtcUtils.obtainAudioAndVideoPermissions(
                    null, null, getMediaStreamUsage());
            };
            
            this.rtcUtils = new RTCUtils(this, onReady);
            
            // Call onReady() if Temasys plugin is not used
            if (!RTCBrowserType.isTemasysPluginUsed()) {
                onReady();
            }
        },
        muteRemoteVideoStream: function (jid, value) {
            var stream;
            
            if(this.remoteStreams[jid] &&
                this.remoteStreams[jid][MediaStreamType.VIDEO_TYPE]) {
                stream = this.remoteStreams[jid][MediaStreamType.VIDEO_TYPE];
            }
            
            if(!stream)
                return true;
            
            if (value != stream.muted) {
                stream.setMute(value);
                return true;
            }
            return false;
        },
        changeLocalVideo: function (stream, isUsingScreenStream, callback) {
            var oldStream = this.localVideo.getOriginalStream();
            var type = (isUsingScreenStream ? "screen" : "camera");
            var localCallback = callback;
            if(this.localVideo.isMuted() && this.localVideo.videoType !== type) {
                localCallback = function() {
                    APP.xmpp.setVideoMute(false, function(mute) {
                        eventEmitter.emit(RTCEvents.VIDEO_MUTE, mute);
                    });
                    
                    callback();
                };
            }
            // FIXME: Workaround for FF/IE/Safari
            if (stream && stream.videoStream) {
                stream = stream.videoStream;
            }
            var videoStream = this.rtcUtils.createStream(stream, true);
            this.localVideo =
                this.createLocalStream(videoStream, "video", true, type);
            // Stop the stream
            this.stopMediaStream(oldStream);
            
            APP.xmpp.switchStreams(videoStream, oldStream,localCallback);
        },
        changeLocalAudio: function (stream, callback) {
            var oldStream = this.localAudio.getOriginalStream();
            var newStream = this.rtcUtils.createStream(stream);
            this.localAudio = this.createLocalStream(newStream, "audio", true);
            // Stop the stream
            this.stopMediaStream(oldStream);
            APP.xmpp.switchStreams(newStream, oldStream, callback, true);
        },
        isVideoMuted: function (jid) {
            if (jid === APP.xmpp.myJid()) {
                var localVideo = APP.RTC.localVideo;
                return (!localVideo || localVideo.isMuted());
            } else {
                if (!APP.RTC.remoteStreams[jid] ||
                    !APP.RTC.remoteStreams[jid][MediaStreamType.VIDEO_TYPE]) {
                    return null;
                }
                return APP.RTC.remoteStreams[jid][MediaStreamType.VIDEO_TYPE].muted;
            }
        },
        setVideoMute: function (mute, callback, options) {
            if (!this.localVideo)
                return;
            
            if (mute == APP.RTC.localVideo.isMuted())
            {
                APP.xmpp.sendVideoInfoPresence(mute);
                if (callback)
                    callback(mute);
            }
            else
            {
                APP.RTC.localVideo.setMute(mute);
                APP.xmpp.setVideoMute(
                    mute,
                    callback,
                    options);
            }
        },
        setDeviceAvailability: function (devices) {
            if(!devices)
                return;
            if(devices.audio === true || devices.audio === false)
                this.devices.audio = devices.audio;
            if(devices.video === true || devices.video === false)
                this.devices.video = devices.video;
            eventEmitter.emit(RTCEvents.AVAILABLE_DEVICES_CHANGED, this.devices);
        },
        /**
         * A method to handle stopping of the stream.
         * One point to handle the differences in various implementations.
         * @param mediaStream MediaStream object to stop.
         */
        stopMediaStream: function (mediaStream) {
            mediaStream.getTracks().forEach(function (track) {
                // stop() not supported with IE
                if (track.stop) {
                    track.stop();
                }
            });
            
            // leave stop for implementation still using it
            if (mediaStream.stop) {
                mediaStream.stop();
            }
        },
        /**
         * Adds onended/inactive handler to a MediaStream.
         * @param mediaStream a MediaStream to attach onended/inactive handler
         * @param handler the handler
         */
        addMediaStreamInactiveHandler: function (mediaStream, handler) {
            if (mediaStream.addEventListener) {
                // chrome
                if(typeof mediaStream.active !== "undefined")
                    mediaStream.inactive = handler;
                else
                    mediaStream.onended = handler;
            } else {
                // themasys
                mediaStream.attachEvent('ended', function () {
                    handler(mediaStream);
                });
            }
        },
        /**
         * Removes onended/inactive handler.
         * @param mediaStream the MediaStream to remove the handler from.
         * @param handler the handler to remove.
         */
        removeMediaStreamInactiveHandler: function (mediaStream, handler) {
            if (mediaStream.removeEventListener) {
                // chrome
                if(typeof mediaStream.active !== "undefined")
                    mediaStream.inactive = null;
                else
                    mediaStream.onended = null;
            } else {
                // themasys
                mediaStream.detachEvent('ended', handler);
            }
        }
    };
    
    module.exports = RTC;
    
},{"../../service/RTC/MediaStreamTypes":177,"../../service/RTC/RTCEvents.js":178,"../../service/RTC/StreamEventTypes.js":180,"../../service/UI/UIEvents":181,"../../service/desktopsharing/DesktopSharingEventTypes":184,"../../service/xmpp/XMPPEvents":188,"./DataChannels":3,"./LocalStream.js":4,"./MediaStream.js":5,"./RTCBrowserType":7,"./RTCUtils.js":8,"events":79}],7:[function(require,module,exports){
    
    var currentBrowser;
    
    var browserVersion;
    
    var isAndroid;
    
    var RTCBrowserType = {
        
        RTC_BROWSER_CHROME: "rtc_browser.chrome",
        
        RTC_BROWSER_OPERA: "rtc_browser.opera",
        
        RTC_BROWSER_FIREFOX: "rtc_browser.firefox",
        
        RTC_BROWSER_IEXPLORER: "rtc_browser.iexplorer",
        
        RTC_BROWSER_SAFARI: "rtc_browser.safari",
        
        getBrowserType: function () {
            return currentBrowser;
        },
        
        isChrome: function () {
            return currentBrowser === RTCBrowserType.RTC_BROWSER_CHROME;
        },
        
        isOpera: function () {
            return currentBrowser === RTCBrowserType.RTC_BROWSER_OPERA;
        },
        isFirefox: function () {
            return currentBrowser === RTCBrowserType.RTC_BROWSER_FIREFOX;
        },
        
        isIExplorer: function () {
            return currentBrowser === RTCBrowserType.RTC_BROWSER_IEXPLORER;
        },
        
        isSafari: function () {
            return currentBrowser === RTCBrowserType.RTC_BROWSER_SAFARI;
        },
        isTemasysPluginUsed: function () {
            return RTCBrowserType.isIExplorer() || RTCBrowserType.isSafari();
        },
        getFirefoxVersion: function () {
            return RTCBrowserType.isFirefox() ? browserVersion : null;
        },
        
        getChromeVersion: function () {
            return RTCBrowserType.isChrome() ? browserVersion : null;
        },
        
        usesPlanB: function() {
            return RTCBrowserType.isChrome() || RTCBrowserType.isOpera() ||
                RTCBrowserType.isTemasysPluginUsed();
        },
        
        usesUnifiedPlan: function() {
            return RTCBrowserType.isFirefox();
        },
        
        /**
         * Whether the browser is running on an android device.
         */
        isAndroid: function() {
            return isAndroid;
        }
        
        // Add version getters for other browsers when needed
    };
    
    // detectOpera() must be called before detectChrome() !!!
    // otherwise Opera wil be detected as Chrome
    function detectChrome() {
        if (navigator.webkitGetUserMedia) {
            currentBrowser = RTCBrowserType.RTC_BROWSER_CHROME;
            var userAgent = navigator.userAgent.toLowerCase();
            // We can assume that user agent is chrome, because it's
            // enforced when 'ext' streaming method is set
            var ver = parseInt(userAgent.match(/chrome\/(\d+)\./)[1], 10);
            console.log("This appears to be Chrome, ver: " + ver);
            return ver;
        }
        return null;
    }
    
    function detectOpera() {
        var userAgent = navigator.userAgent;
        if (userAgent.match(/Opera|OPR/)) {
            currentBrowser = RTCBrowserType.RTC_BROWSER_OPERA;
            var version = userAgent.match(/(Opera|OPR) ?\/?(\d+)\.?/)[2];
            console.info("This appears to be Opera, ver: " + version);
            return version;
        }
        return null;
    }
    
    function detectFirefox() {
        if (navigator.mozGetUserMedia) {
            currentBrowser = RTCBrowserType.RTC_BROWSER_FIREFOX;
            var version = parseInt(
                navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
            console.log('This appears to be Firefox, ver: ' + version);
            return version;
        }
        return null;
    }
    
    function detectSafari() {
        if ((/^((?!chrome).)*safari/i.test(navigator.userAgent))) {
            currentBrowser = RTCBrowserType.RTC_BROWSER_SAFARI;
            console.info("This appears to be Safari");
            // FIXME detect Safari version when needed
            return 1;
        }
        return null;
    }
    
    function detectIE() {
        var version;
        var ua = window.navigator.userAgent;
        
        var msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            version = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        }
        
        var trident = ua.indexOf('Trident/');
        if (!version && trident > 0) {
            // IE 11 => return version number
            var rv = ua.indexOf('rv:');
            version = parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
        }
        
        var edge = ua.indexOf('Edge/');
        if (!version && edge > 0) {
            // IE 12 => return version number
            version = parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
        }
        
        if (version) {
            currentBrowser = RTCBrowserType.RTC_BROWSER_IEXPLORER;
            console.info("This appears to be IExplorer, ver: " + version);
        }
        return version;
    }
    
    function detectBrowser() {
        var version;
        var detectors = [
            detectOpera,
            detectChrome,
            detectFirefox,
            detectIE,
            detectSafari
        ];
        // Try all browser detectors
        for (var i = 0; i < detectors.length; i++) {
            version = detectors[i]();
            if (version)
                return version;
        }
        console.error("Failed to detect browser type");
        return undefined;
    }
    
    browserVersion = detectBrowser();
    isAndroid = navigator.userAgent.indexOf('Android') != -1;
    
    module.exports = RTCBrowserType;
},{}],8:[function(require,module,exports){
    /* global APP, config, require, attachMediaStream, getUserMedia,
     RTCPeerConnection, webkitMediaStream, webkitURL, webkitRTCPeerConnection,
     mozRTCIceCandidate, mozRTCSessionDescription, mozRTCPeerConnection */
    /* jshint -W101 */
    var RTCBrowserType = require("./RTCBrowserType");
    var Resolutions = require("../../service/RTC/Resolutions");
    var AdapterJS = require("./adapter.screenshare");
    
    var currentResolution = null;
    
    function getPreviousResolution(resolution) {
        if(!Resolutions[resolution])
            return null;
        var order = Resolutions[resolution].order;
        var res = null;
        var resName = null;
        for(var i in Resolutions) {
            var tmp = Resolutions[i];
            if (!res || (res.order < tmp.order && tmp.order < order)) {
                resName = i;
                res = tmp;
            }
        }
        return resName;
    }
    
    function setResolutionConstraints(constraints, resolution) {
        var isAndroid = RTCBrowserType.isAndroid();
        
        if (Resolutions[resolution]) {
            constraints.video.mandatory.minWidth = Resolutions[resolution].width;
            constraints.video.mandatory.minHeight = Resolutions[resolution].height;
        }
        else if (isAndroid) {
            // FIXME can't remember if the purpose of this was to always request
            //       low resolution on Android ? if yes it should be moved up front
            constraints.video.mandatory.minWidth = 320;
            constraints.video.mandatory.minHeight = 240;
            constraints.video.mandatory.maxFrameRate = 15;
        }
        
        if (constraints.video.mandatory.minWidth)
            constraints.video.mandatory.maxWidth =
                constraints.video.mandatory.minWidth;
        if (constraints.video.mandatory.minHeight)
            constraints.video.mandatory.maxHeight =
                constraints.video.mandatory.minHeight;
    }
    
    function getConstraints(um, resolution, bandwidth, fps, desktopStream) {
        var constraints = {audio: false, video: false};
        
        if (um.indexOf('video') >= 0) {
            // same behaviour as true
            constraints.video = { mandatory: {}, optional: [] };
            
            constraints.video.optional.push({ googLeakyBucket: true });
            
            setResolutionConstraints(constraints, resolution);
        }
        if (um.indexOf('audio') >= 0) {
            if (!RTCBrowserType.isFirefox()) {
                // same behaviour as true
                constraints.audio = { mandatory: {}, optional: []};
                // if it is good enough for hangouts...
                constraints.audio.optional.push(
                    {googEchoCancellation: true},
                    {googAutoGainControl: true},
                    {googNoiseSupression: true},
                    {googHighpassFilter: true},
                    {googNoisesuppression2: true},
                    {googEchoCancellation2: true},
                    {googAutoGainControl2: true}
                );
            } else {
                constraints.audio = true;
            }
        }
        if (um.indexOf('screen') >= 0) {
            if (RTCBrowserType.isChrome()) {
                constraints.video = {
                    mandatory: {
                        chromeMediaSource: "screen",
                        googLeakyBucket: true,
                        maxWidth: window.screen.width,
                        maxHeight: window.screen.height,
                        maxFrameRate: 3
                    },
                    optional: []
                };
            } else if (RTCBrowserType.isTemasysPluginUsed()) {
                constraints.video = {
                    optional: [
                        {
                            sourceId: AdapterJS.WebRTCPlugin.plugin.screensharingKey
                        }
                    ]
                };
            } else if (RTCBrowserType.isFirefox()) {
                constraints.video = {
                    mozMediaSource: "window",
                    mediaSource: "window"
                };
                
            } else {
                console.error(
                    "'screen' WebRTC media source is supported only in Chrome" +
                    " and with Temasys plugin");
            }
        }
        if (um.indexOf('desktop') >= 0) {
            constraints.video = {
                mandatory: {
                    chromeMediaSource: "desktop",
                    chromeMediaSourceId: desktopStream,
                    googLeakyBucket: true,
                    maxWidth: window.screen.width,
                    maxHeight: window.screen.height,
                    maxFrameRate: 3
                },
                optional: []
            };
        }
        
        if (bandwidth) {
            if (!constraints.video) {
                //same behaviour as true
                constraints.video = {mandatory: {}, optional: []};
            }
            constraints.video.optional.push({bandwidth: bandwidth});
        }
        if (fps) {
            // for some cameras it might be necessary to request 30fps
            // so they choose 30fps mjpg over 10fps yuy2
            if (!constraints.video) {
                // same behaviour as true;
                constraints.video = {mandatory: {}, optional: []};
            }
            constraints.video.mandatory.minFrameRate = fps;
        }
        
        // we turn audio for both audio and video tracks, the fake audio & video seems to work
        // only when enabled in one getUserMedia call, we cannot get fake audio separate by fake video
        // this later can be a problem with some of the tests
        if(RTCBrowserType.isFirefox() && config.firefox_fake_device)
        {
            constraints.audio = true;
            constraints.fake = true;
        }
        
        return constraints;
    }
    
    
    function RTCUtils(RTCService, onTemasysPluginReady)
    {
        var self = this;
        this.service = RTCService;
        if (RTCBrowserType.isFirefox()) {
            var FFversion = RTCBrowserType.getFirefoxVersion();
            if (FFversion >= 40) {
                this.peerconnection = mozRTCPeerConnection;
                this.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
                this.pc_constraints = {};
                this.attachMediaStream =  function (element, stream) {
                    //  srcObject is being standardized and FF will eventually
                    //  support that unprefixed. FF also supports the
                    //  "element.src = URL.createObjectURL(...)" combo, but that
                    //  will be deprecated in favour of srcObject.
                    //
                    // https://groups.google.com/forum/#!topic/mozilla.dev.media/pKOiioXonJg
                    // https://github.com/webrtc/samples/issues/302
                    if(!element[0])
                        return;
                    element[0].mozSrcObject = stream;
                    element[0].play();
                };
                this.getStreamID =  function (stream) {
                    var id = stream.id;
                    if (!id) {
                        var tracks = stream.getVideoTracks();
                        if (!tracks || tracks.length === 0) {
                            tracks = stream.getAudioTracks();
                        }
                        id = tracks[0].id;
                    }
                    return APP.xmpp.filter_special_chars(id);
                };
                this.getVideoSrc = function (element) {
                    if(!element)
                        return null;
                    return element.mozSrcObject;
                };
                this.setVideoSrc = function (element, src) {
                    if(element)
                        element.mozSrcObject = src;
                };
                window.RTCSessionDescription = mozRTCSessionDescription;
                window.RTCIceCandidate = mozRTCIceCandidate;
            } else {
                console.error(
                    "Firefox version too old: " + FFversion + ". Required >= 40.");
                window.location.href = 'unsupported_browser.html';
                return;
            }
            
        } else if (RTCBrowserType.isChrome() || RTCBrowserType.isOpera()) {
            this.peerconnection = webkitRTCPeerConnection;
            this.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
            this.attachMediaStream = function (element, stream) {
                element.attr('src', webkitURL.createObjectURL(stream));
            };
            this.getStreamID = function (stream) {
                // streams from FF endpoints have the characters '{' and '}'
                // that make jQuery choke.
                return APP.xmpp.filter_special_chars(stream.id);
            };
            this.getVideoSrc = function (element) {
                if(!element)
                    return null;
                return element.getAttribute("src");
            };
            this.setVideoSrc = function (element, src) {
                if(element)
                    element.setAttribute("src", src);
            };
            // DTLS should now be enabled by default but..
            this.pc_constraints = {'optional': [{'DtlsSrtpKeyAgreement': 'true'}]};
            if (RTCBrowserType.isAndroid()) {
                this.pc_constraints = {}; // disable DTLS on Android
            }
            if (!webkitMediaStream.prototype.getVideoTracks) {
                webkitMediaStream.prototype.getVideoTracks = function () {
                    return this.videoTracks;
                };
            }
            if (!webkitMediaStream.prototype.getAudioTracks) {
                webkitMediaStream.prototype.getAudioTracks = function () {
                    return this.audioTracks;
                };
            }
        }
        // Detect IE/Safari
        else if (RTCBrowserType.isTemasysPluginUsed()) {
            
            //AdapterJS.WebRTCPlugin.setLogLevel(
            //    AdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS.VERBOSE);
            
            AdapterJS.webRTCReady(function (isPlugin) {
                
                self.peerconnection = RTCPeerConnection;
                self.getUserMedia = getUserMedia;
                self.attachMediaStream = function (elSel, stream) {
                    
                    if (stream.id === "dummyAudio" || stream.id === "dummyVideo") {
                        return;
                    }
                    
                    attachMediaStream(elSel[0], stream);
                };
                self.getStreamID = function (stream) {
                    return APP.xmpp.filter_special_chars(stream.label);
                };
                self.getVideoSrc = function (element) {
                    if (!element) {
                        console.warn("Attempt to get video SRC of null element");
                        return null;
                    }
                    var children = element.children;
                    for (var i = 0; i !== children.length; ++i) {
                        if (children[i].name === 'streamId') {
                            return children[i].value;
                        }
                    }
                    //console.info(element.id + " SRC: " + src);
                    return null;
                };
                self.setVideoSrc = function (element, src) {
                    //console.info("Set video src: ", element, src);
                    if (!src) {
                        console.warn("Not attaching video stream, 'src' is null");
                        return;
                    }
                    AdapterJS.WebRTCPlugin.WaitForPluginReady();
                    var stream = AdapterJS.WebRTCPlugin.plugin
                        .getStreamWithId(AdapterJS.WebRTCPlugin.pageId, src);
                    attachMediaStream(element, stream);
                };
                
                onTemasysPluginReady(isPlugin);
            });
        } else {
            try {
                console.log('Browser does not appear to be WebRTC-capable');
            } catch (e) { }
            window.location.href = 'unsupported_browser.html';
        }
    }
    
    
    RTCUtils.prototype.getUserMediaWithConstraints = function(
        um, success_callback, failure_callback, resolution,bandwidth, fps,
        desktopStream) {
        currentResolution = resolution;
        
        var constraints = getConstraints(
            um, resolution, bandwidth, fps, desktopStream);
        
        console.info("Get media constraints", constraints);
        
        var self = this;
        
        try {
            this.getUserMedia(constraints,
                function (stream) {
                    console.log('onUserMediaSuccess');
                    self.setAvailableDevices(um, true);
                    success_callback(stream);
                },
                function (error) {
                    self.setAvailableDevices(um, false);
                    console.warn('Failed to get access to local media. Error ',
                        error, constraints);
                    if (failure_callback) {
                        failure_callback(error);
                    }
                });
        } catch (e) {
            console.error('GUM failed: ', e);
            if(failure_callback) {
                failure_callback(e);
            }
        }
    };
    
    RTCUtils.prototype.setAvailableDevices = function (um, available) {
        var devices = {};
        if(um.indexOf("video") != -1) {
            devices.video = available;
        }
        if(um.indexOf("audio") != -1) {
            devices.audio = available;
        }
        this.service.setDeviceAvailability(devices);
    };
    
    /**
     * We ask for audio and video combined stream in order to get permissions and
     * not to ask twice.
     */
    RTCUtils.prototype.obtainAudioAndVideoPermissions =
        function(devices, callback, usageOptions)
        {
            var self = this;
            // Get AV
            
            var successCallback = function (stream) {
                if(callback)
                    callback(stream, usageOptions);
                else
                    self.successCallback(stream, usageOptions);
            };
            
            if(!devices)
                devices = ['audio', 'video'];
            
            var newDevices = [];
            
            
            if(usageOptions)
                for(var i = 0; i < devices.length; i++) {
                    var device = devices[i];
                    if(usageOptions[device] === true)
                        newDevices.push(device);
                }
            else
                newDevices = devices;
            
            if(newDevices.length === 0) {
                successCallback();
                return;
            }
            
            if (RTCBrowserType.isFirefox() || RTCBrowserType.isTemasysPluginUsed()) {
                
                // With FF/IE we can't split the stream into audio and video because FF
                // doesn't support media stream constructors. So, we need to get the
                // audio stream separately from the video stream using two distinct GUM
                // calls. Not very user friendly :-( but we don't have many other
                // options neither.
                //
                // Note that we pack those 2 streams in a single object and pass it to
                // the successCallback method.
                var obtainVideo = function (audioStream) {
                    self.getUserMediaWithConstraints(
                        ['video'],
                        function (videoStream) {
                            return successCallback({
                                audioStream: audioStream,
                                videoStream: videoStream
                            });
                        },
                        function (error) {
                            console.error(
                                'failed to obtain video stream - stop', error);
                            self.errorCallback(error);
                        },
                        config.resolution || '360');
                };
                var obtainAudio = function () {
                    self.getUserMediaWithConstraints(
                        ['audio'],
                        function (audioStream) {
                            if (newDevices.indexOf('video') !== -1)
                                obtainVideo(audioStream);
                        },
                        function (error) {
                            console.error(
                                'failed to obtain audio stream - stop', error);
                            self.errorCallback(error);
                        }
                    );
                };
                if (newDevices.indexOf('audio') !== -1) {
                    obtainAudio();
                } else {
                    obtainVideo(null);
                }
            } else {
                this.getUserMediaWithConstraints(
                    newDevices,
                    function (stream) {
                        successCallback(stream);
                    },
                    function (error) {
                        self.errorCallback(error);
                    },
                    config.resolution || '360');
            }
        };
    
    RTCUtils.prototype.successCallback = function (stream, usageOptions) {
        // If this is FF or IE, the stream parameter is *not* a MediaStream object,
        // it's an object with two properties: audioStream, videoStream.
        if (stream && stream.getAudioTracks && stream.getVideoTracks)
            console.log('got', stream, stream.getAudioTracks().length,
                stream.getVideoTracks().length);
        this.handleLocalStream(stream, usageOptions);
    };
    
    RTCUtils.prototype.errorCallback = function (error) {
        var self = this;
        console.error('failed to obtain audio/video stream - trying audio only', error);
        var resolution = getPreviousResolution(currentResolution);
        if(typeof error == "object" && error.constraintName && error.name
            && (error.name == "ConstraintNotSatisfiedError" ||
            error.name == "OverconstrainedError") &&
            (error.constraintName == "minWidth" || error.constraintName == "maxWidth" ||
            error.constraintName == "minHeight" || error.constraintName == "maxHeight")
            && resolution)
        {
            self.getUserMediaWithConstraints(['audio', 'video'],
                function (stream) {
                    return self.successCallback(stream);
                }, function (error) {
                    return self.errorCallback(error);
                }, resolution);
        }
        else {
            self.getUserMediaWithConstraints(
                ['audio'],
                function (stream) {
                    return self.successCallback(stream);
                },
                function (error) {
                    console.error('failed to obtain audio/video stream - stop',
                        error);
                    return self.successCallback(null);
                }
            );
        }
    };
    
    RTCUtils.prototype.handleLocalStream = function(stream, usageOptions) {
        // If this is FF, the stream parameter is *not* a MediaStream object, it's
        // an object with two properties: audioStream, videoStream.
        var audioStream, videoStream;
        if(window.webkitMediaStream)
        {
            audioStream = new webkitMediaStream();
            videoStream = new webkitMediaStream();
            if(stream) {
                var audioTracks = stream.getAudioTracks();
                
                for (var i = 0; i < audioTracks.length; i++) {
                    audioStream.addTrack(audioTracks[i]);
                }
                
                var videoTracks = stream.getVideoTracks();
                
                for (i = 0; i < videoTracks.length; i++) {
                    videoStream.addTrack(videoTracks[i]);
                }
            }
        }
        else if (RTCBrowserType.isFirefox() || RTCBrowserType.isTemasysPluginUsed())
        {   // Firefox and Temasys plugin
            if (stream && stream.audioStream)
                audioStream = stream.audioStream;
            else
                audioStream = new DummyMediaStream("dummyAudio");
            
            if (stream && stream.videoStream)
                videoStream = stream.videoStream;
            else
                videoStream = new DummyMediaStream("dummyVideo");
        }
        
        var audioMuted = (usageOptions && usageOptions.audio === false),
            videoMuted = (usageOptions && usageOptions.video === false);
        
        var audioGUM = (!usageOptions || usageOptions.audio !== false),
            videoGUM = (!usageOptions || usageOptions.video !== false);
        
        
        this.service.createLocalStream(audioStream, "audio", null, null,
            audioMuted, audioGUM);
        
        this.service.createLocalStream(videoStream, "video", null, 'camera',
            videoMuted, videoGUM);
    };
    
    function DummyMediaStream(id) {
        this.id = id;
        this.label = id;
        this.stop = function() { };
        this.getAudioTracks = function() { return []; };
        this.getVideoTracks = function() { return []; };
    }
    
    RTCUtils.prototype.createStream = function(stream, isVideo) {
        var newStream = null;
        if (window.webkitMediaStream) {
            newStream = new webkitMediaStream();
            if (newStream) {
                var tracks = (isVideo ? stream.getVideoTracks() : stream.getAudioTracks());
                
                for (var i = 0; i < tracks.length; i++) {
                    newStream.addTrack(tracks[i]);
                }
            }
            
        }
        else {
            // FIXME: this is duplicated with 'handleLocalStream' !!!
            if (stream) {
                newStream = stream;
            } else {
                newStream =
                    new DummyMediaStream(isVideo ? "dummyVideo" : "dummyAudio");
            }
        }
        
        return newStream;
    };
    
    module.exports = RTCUtils;
    
},{"../../service/RTC/Resolutions":179,"./RTCBrowserType":7,"./adapter.screenshare":9}],9:[function(require,module,exports){
    /*! adapterjs - v0.12.3 - 2015-11-19 */
    
    // Adapter's interface.
    var AdapterJS = AdapterJS || {};
    
    // Browserify compatibility
    if(typeof exports !== 'undefined') {
        module.exports = AdapterJS;
    }
    
    AdapterJS.options = AdapterJS.options || {};
    
    // uncomment to get virtual webcams
    // AdapterJS.options.getAllCams = true;
    
    // uncomment to prevent the install prompt when the plugin in not yet installed
    // AdapterJS.options.hidePluginInstallPrompt = true;
    
    // AdapterJS version
    AdapterJS.VERSION = '0.12.3';
    
    // This function will be called when the WebRTC API is ready to be used
    // Whether it is the native implementation (Chrome, Firefox, Opera) or
    // the plugin
    // You may Override this function to synchronise the start of your application
    // with the WebRTC API being ready.
    // If you decide not to override use this synchronisation, it may result in
    // an extensive CPU usage on the plugin start (once per tab loaded)
    // Params:
    //    - isUsingPlugin: true is the WebRTC plugin is being used, false otherwise
    //
    AdapterJS.onwebrtcready = AdapterJS.onwebrtcready || function(isUsingPlugin) {
            // The WebRTC API is ready.
            // Override me and do whatever you want here
        };
    
    // Sets a callback function to be called when the WebRTC interface is ready.
    // The first argument is the function to callback.\
    // Throws an error if the first argument is not a function
    AdapterJS.webRTCReady = function (callback) {
        if (typeof callback !== 'function') {
            throw new Error('Callback provided is not a function');
        }
        
        if (true === AdapterJS.onwebrtcreadyDone) {
            // All WebRTC interfaces are ready, just call the callback
            callback(null !== AdapterJS.WebRTCPlugin.plugin);
        } else {
            // will be triggered automatically when your browser/plugin is ready.
            AdapterJS.onwebrtcready = callback;
        }
    };
    
    // Plugin namespace
    AdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {};
    
    // The object to store plugin information
    AdapterJS.WebRTCPlugin.pluginInfo = {
        prefix : 'Nxtec',
        plugName : 'VideoCollaborate',
        pluginId : 'plugin0',
        type : 'application/x-collaborateseismicplugin',
        onload : '__TemWebRTCReady0',
        portalLink : 'https://temasys.atlassian.net/wiki/display/TWPP/WebRTC+Plugins',
        downloadLink : null, //set below
        companyName: 'Nxtec'
    };
    if(!!navigator.platform.match(/^Mac/i)) {
        AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = 'https://www.collaborate.center/downloads/temasys/VideoCollaborate.dmg';
    }
    else if(!!navigator.platform.match(/^Win/i)) {
        AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = 'https://www.collaborate.center/downloads/temasys/VideoCollaborate.msi';
    }
    
    
    AdapterJS.WebRTCPlugin.TAGS = {
        NONE  : 'none',
        AUDIO : 'audio',
        VIDEO : 'video'
    };
    
    // Unique identifier of each opened page
    AdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2);
    
    // Use this whenever you want to call the plugin.
    AdapterJS.WebRTCPlugin.plugin = null;
    
    // Set log level for the plugin once it is ready.
    // The different values are
    // This is an asynchronous function that will run when the plugin is ready
    AdapterJS.WebRTCPlugin.setLogLevel = null;
    
    // Defines webrtc's JS interface according to the plugin's implementation.
    // Define plugin Browsers as WebRTC Interface.
    AdapterJS.WebRTCPlugin.defineWebRTCInterface = null;
    
    // This function detects whether or not a plugin is installed.
    // Checks if Not IE (firefox, for example), else if it's IE,
    // we're running IE and do something. If not it is not supported.
    AdapterJS.WebRTCPlugin.isPluginInstalled = null;
    
    // Lets adapter.js wait until the the document is ready before injecting the plugin
    AdapterJS.WebRTCPlugin.pluginInjectionInterval = null;
    
    // Inject the HTML DOM object element into the page.
    AdapterJS.WebRTCPlugin.injectPlugin = null;
    
    // States of readiness that the plugin goes through when
    // being injected and stated
    AdapterJS.WebRTCPlugin.PLUGIN_STATES = {
        NONE : 0,           // no plugin use
        INITIALIZING : 1,   // Detected need for plugin
        INJECTING : 2,      // Injecting plugin
        INJECTED: 3,        // Plugin element injected but not usable yet
        READY: 4            // Plugin ready to be used
    };
    
    // Current state of the plugin. You cannot use the plugin before this is
    // equal to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY
    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE;
    
    // True is AdapterJS.onwebrtcready was already called, false otherwise
    // Used to make sure AdapterJS.onwebrtcready is only called once
    AdapterJS.onwebrtcreadyDone = false;
    
    // Log levels for the plugin.
    // To be set by calling AdapterJS.WebRTCPlugin.setLogLevel
    /*
     Log outputs are prefixed in some cases.
     INFO: Information reported by the plugin.
     ERROR: Errors originating from within the plugin.
     WEBRTC: Error originating from within the libWebRTC library
     */
    // From the least verbose to the most verbose
    AdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {
        NONE : 'NONE',
        ERROR : 'ERROR',
        WARNING : 'WARNING',
        INFO: 'INFO',
        VERBOSE: 'VERBOSE',
        SENSITIVE: 'SENSITIVE'
    };
    
    // Does a waiting check before proceeding to load the plugin.
    AdapterJS.WebRTCPlugin.WaitForPluginReady = null;
    
    // This methid will use an interval to wait for the plugin to be ready.
    AdapterJS.WebRTCPlugin.callWhenPluginReady = null;
    
    // !!!! WARNING: DO NOT OVERRIDE THIS FUNCTION. !!!
    // This function will be called when plugin is ready. It sends necessary
    // details to the plugin.
    // The function will wait for the document to be ready and the set the
    // plugin state to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,
    // indicating that it can start being requested.
    // This function is not in the IE/Safari condition brackets so that
    // TemPluginLoaded function might be called on Chrome/Firefox.
    // This function is the only private function that is not encapsulated to
    // allow the plugin method to be called.
    __TemWebRTCReady0 = function () {
        if (document.readyState === 'complete') {
            AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;
            
            AdapterJS.maybeThroughWebRTCReady();
        } else {
            AdapterJS.WebRTCPlugin.documentReadyInterval = setInterval(function () {
                if (document.readyState === 'complete') {
                    // TODO: update comments, we wait for the document to be ready
                    clearInterval(AdapterJS.WebRTCPlugin.documentReadyInterval);
                    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;
                    
                    AdapterJS.maybeThroughWebRTCReady();
                }
            }, 100);
        }
    };
    
    AdapterJS.maybeThroughWebRTCReady = function() {
        if (!AdapterJS.onwebrtcreadyDone) {
            AdapterJS.onwebrtcreadyDone = true;
            
            if (typeof(AdapterJS.onwebrtcready) === 'function') {
                AdapterJS.onwebrtcready(AdapterJS.WebRTCPlugin.plugin !== null);
            }
        }
    };
    
    // Text namespace
    AdapterJS.TEXT = {
        PLUGIN: {
            REQUIRE_INSTALLATION: 'This website requires you to install a WebRTC-enabling plugin ' +
            'to work on this browser.',
            NOT_SUPPORTED: 'Your browser does not support WebRTC.',
            BUTTON: 'Install Now'
        },
        REFRESH: {
            REQUIRE_REFRESH: 'Please refresh page',
            BUTTON: 'Refresh Page'
        }
    };
    
    // The result of ice connection states.
    // - starting: Ice connection is starting.
    // - checking: Ice connection is checking.
    // - connected Ice connection is connected.
    // - completed Ice connection is connected.
    // - done Ice connection has been completed.
    // - disconnected Ice connection has been disconnected.
    // - failed Ice connection has failed.
    // - closed Ice connection is closed.
    AdapterJS._iceConnectionStates = {
        starting : 'starting',
        checking : 'checking',
        connected : 'connected',
        completed : 'connected',
        done : 'completed',
        disconnected : 'disconnected',
        failed : 'failed',
        closed : 'closed'
    };
    
    //The IceConnection states that has been fired for each peer.
    AdapterJS._iceConnectionFiredStates = [];
    
    
    // Check if WebRTC Interface is defined.
    AdapterJS.isDefined = null;
    
    // This function helps to retrieve the webrtc detected browser information.
    // This sets:
    // - webrtcDetectedBrowser: The browser agent name.
    // - webrtcDetectedVersion: The browser version.
    // - webrtcDetectedType: The types of webRTC support.
    //   - 'moz': Mozilla implementation of webRTC.
    //   - 'webkit': WebKit implementation of webRTC.
    //   - 'plugin': Using the plugin implementation.
    AdapterJS.parseWebrtcDetectedBrowser = function () {
        var hasMatch, checkMatch = navigator.userAgent.match(
                /(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (/trident/i.test(checkMatch[1])) {
            hasMatch = /\brv[ :]+(\d+)/g.exec(navigator.userAgent) || [];
            webrtcDetectedBrowser = 'IE';
            webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);
        } else if (checkMatch[1] === 'Chrome') {
            hasMatch = navigator.userAgent.match(/\bOPR\/(\d+)/);
            if (hasMatch !== null) {
                webrtcDetectedBrowser = 'opera';
                webrtcDetectedVersion = parseInt(hasMatch[1], 10);
            }
        }
        if (navigator.userAgent.indexOf('Safari')) {
            if (typeof InstallTrigger !== 'undefined') {
                webrtcDetectedBrowser = 'firefox';
            } else if (/*@cc_on!@*/ false || !!document.documentMode) {
                webrtcDetectedBrowser = 'IE';
            } else if (
                Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) {
                webrtcDetectedBrowser = 'safari';
            } else if (!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {
                webrtcDetectedBrowser = 'opera';
            } else if (!!window.chrome) {
                webrtcDetectedBrowser = 'chrome';
            }
        }
        if (!webrtcDetectedBrowser) {
            webrtcDetectedVersion = checkMatch[1];
        }
        if (!webrtcDetectedVersion) {
            try {
                checkMatch = (checkMatch[2]) ? [checkMatch[1], checkMatch[2]] :
                    [navigator.appName, navigator.appVersion, '-?'];
                if ((hasMatch = navigator.userAgent.match(/version\/(\d+)/i)) !== null) {
                    checkMatch.splice(1, 1, hasMatch[1]);
                }
                webrtcDetectedVersion = parseInt(checkMatch[1], 10);
            } catch (error) { }
        }
    };
    
    // To fix configuration as some browsers does not support
    // the 'urls' attribute.
    AdapterJS.maybeFixConfiguration = function (pcConfig) {
        if (pcConfig === null) {
            return;
        }
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
            if (pcConfig.iceServers[i].hasOwnProperty('urls')) {
                pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;
                delete pcConfig.iceServers[i].urls;
            }
        }
    };
    
    AdapterJS.addEvent = function(elem, evnt, func) {
        if (elem.addEventListener) { // W3C DOM
            elem.addEventListener(evnt, func, false);
        } else if (elem.attachEvent) {// OLD IE DOM
            elem.attachEvent('on'+evnt, func);
        } else { // No much to do
            elem[evnt] = func;
        }
    };
    
    AdapterJS.renderNotificationBar = function (text, buttonText, buttonLink, openNewTab, displayRefreshBar) {
        // only inject once the page is ready
        if (document.readyState !== 'complete') {
            return;
        }
        
        var w = window;
        var i = document.createElement('iframe');
        i.style.position = 'fixed';
        i.style.top = '-41px';
        i.style.left = 0;
        i.style.right = 0;
        i.style.width = '100%';
        i.style.height = '40px';
        i.style.backgroundColor = '#ffffe1';
        i.style.border = 'none';
        i.style.borderBottom = '1px solid #888888';
        i.style.zIndex = '9999999';
        if(typeof i.style.webkitTransition === 'string') {
            i.style.webkitTransition = 'all .5s ease-out';
        } else if(typeof i.style.transition === 'string') {
            i.style.transition = 'all .5s ease-out';
        }
        document.body.appendChild(i);
        c = (i.contentWindow) ? i.contentWindow :
            (i.contentDocument.document) ? i.contentDocument.document : i.contentDocument;
        c.document.open();
        c.document.write('<span style="display: inline-block; font-family: Helvetica, Arial,' +
            'sans-serif; font-size: .9rem; padding: 4px; vertical-align: ' +
            'middle; cursor: default;">' + text + '</span>');
        if(buttonText && buttonLink) {
            c.document.write('<button id="okay">' + buttonText + '</button><button id="cancel">Cancel</button>');
            c.document.close();
            
            // On click on okay
            AdapterJS.addEvent(c.document.getElementById('okay'), 'click', function(e) {
                if (!!displayRefreshBar) {
                    AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION ?
                            AdapterJS.TEXT.EXTENSION.REQUIRE_REFRESH : AdapterJS.TEXT.REFRESH.REQUIRE_REFRESH,
                        AdapterJS.TEXT.REFRESH.BUTTON, 'javascript:location.reload()');
                }
                window.open(buttonLink, !!openNewTab ? '_blank' : '_top');
                
                e.preventDefault();
                try {
                    event.cancelBubble = true;
                } catch(error) { }
                
                var pluginInstallInterval = setInterval(function(){
                    if(! isIE) {
                        navigator.plugins.refresh(false);
                    }
                    AdapterJS.WebRTCPlugin.isPluginInstalled(
                        AdapterJS.WebRTCPlugin.pluginInfo.prefix,
                        AdapterJS.WebRTCPlugin.pluginInfo.plugName,
                        function() { // plugin now installed
                            clearInterval(pluginInstallInterval);
                            AdapterJS.WebRTCPlugin.defineWebRTCInterface();
                        },
                        function() {
                            // still no plugin detected, nothing to do
                        });
                } , 500);
            });
            
            // On click on Cancel
            AdapterJS.addEvent(c.document.getElementById('cancel'), 'click', function(e) {
                w.document.body.removeChild(i);
            });
        } else {
            c.document.close();
        }
        setTimeout(function() {
            if(typeof i.style.webkitTransform === 'string') {
                i.style.webkitTransform = 'translateY(40px)';
            } else if(typeof i.style.transform === 'string') {
                i.style.transform = 'translateY(40px)';
            } else {
                i.style.top = '0px';
            }
        }, 300);
    };
    
    // -----------------------------------------------------------
    // Detected webrtc implementation. Types are:
    // - 'moz': Mozilla implementation of webRTC.
    // - 'webkit': WebKit implementation of webRTC.
    // - 'plugin': Using the plugin implementation.
    webrtcDetectedType = null;
    
    // Detected webrtc datachannel support. Types are:
    // - 'SCTP': SCTP datachannel support.
    // - 'RTP': RTP datachannel support.
    webrtcDetectedDCSupport = null;
    
    // Set the settings for creating DataChannels, MediaStream for
    // Cross-browser compability.
    // - This is only for SCTP based support browsers.
    // the 'urls' attribute.
    checkMediaDataChannelSettings =
        function (peerBrowserAgent, peerBrowserVersion, callback, constraints) {
            if (typeof callback !== 'function') {
                return;
            }
            var beOfferer = true;
            var isLocalFirefox = webrtcDetectedBrowser === 'firefox';
            // Nightly version does not require MozDontOfferDataChannel for interop
            var isLocalFirefoxInterop = webrtcDetectedType === 'moz' && webrtcDetectedVersion > 30;
            var isPeerFirefox = peerBrowserAgent === 'firefox';
            var isPeerFirefoxInterop = peerBrowserAgent === 'firefox' &&
                ((peerBrowserVersion) ? (peerBrowserVersion > 30) : false);
            
            // Resends an updated version of constraints for MozDataChannel to work
            // If other userAgent is firefox and user is firefox, remove MozDataChannel
            if ((isLocalFirefox && isPeerFirefox) || (isLocalFirefoxInterop)) {
                try {
                    delete constraints.mandatory.MozDontOfferDataChannel;
                } catch (error) {
                    console.error('Failed deleting MozDontOfferDataChannel');
                    console.error(error);
                }
            } else if ((isLocalFirefox && !isPeerFirefox)) {
                constraints.mandatory.MozDontOfferDataChannel = true;
            }
            if (!isLocalFirefox) {
                // temporary measure to remove Moz* constraints in non Firefox browsers
                for (var prop in constraints.mandatory) {
                    if (constraints.mandatory.hasOwnProperty(prop)) {
                        if (prop.indexOf('Moz') !== -1) {
                            delete constraints.mandatory[prop];
                        }
                    }
                }
            }
            // Firefox (not interopable) cannot offer DataChannel as it will cause problems to the
            // interopability of the media stream
            if (isLocalFirefox && !isPeerFirefox && !isLocalFirefoxInterop) {
                beOfferer = false;
            }
            callback(beOfferer, constraints);
        };
    
    // Handles the differences for all browsers ice connection state output.
    // - Tested outcomes are:
    //   - Chrome (offerer)  : 'checking' > 'completed' > 'completed'
    //   - Chrome (answerer) : 'checking' > 'connected'
    //   - Firefox (offerer) : 'checking' > 'connected'
    //   - Firefox (answerer): 'checking' > 'connected'
    checkIceConnectionState = function (peerId, iceConnectionState, callback) {
        if (typeof callback !== 'function') {
            console.warn('No callback specified in checkIceConnectionState. Aborted.');
            return;
        }
        peerId = (peerId) ? peerId : 'peer';
        
        if (!AdapterJS._iceConnectionFiredStates[peerId] ||
            iceConnectionState === AdapterJS._iceConnectionStates.disconnected ||
            iceConnectionState === AdapterJS._iceConnectionStates.failed ||
            iceConnectionState === AdapterJS._iceConnectionStates.closed) {
            AdapterJS._iceConnectionFiredStates[peerId] = [];
        }
        iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState];
        if (AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) < 0) {
            AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState);
            if (iceConnectionState === AdapterJS._iceConnectionStates.connected) {
                setTimeout(function () {
                    AdapterJS._iceConnectionFiredStates[peerId]
                        .push(AdapterJS._iceConnectionStates.done);
                    callback(AdapterJS._iceConnectionStates.done);
                }, 1000);
            }
            callback(iceConnectionState);
        }
        return;
    };
    
    // Firefox:
    // - Creates iceServer from the url for Firefox.
    // - Create iceServer with stun url.
    // - Create iceServer with turn url.
    //   - Ignore the transport parameter from TURN url for FF version <=27.
    //   - Return null for createIceServer if transport=tcp.
    // - FF 27 and above supports transport parameters in TURN url,
    // - So passing in the full url to create iceServer.
    // Chrome:
    // - Creates iceServer from the url for Chrome M33 and earlier.
    //   - Create iceServer with stun url.
    //   - Chrome M28 & above uses below TURN format.
    // Plugin:
    // - Creates Ice Server for Plugin Browsers
    //   - If Stun - Create iceServer with stun url.
    //   - Else - Create iceServer with turn url
    //   - This is a WebRTC Function
    createIceServer = null;
    
    // Firefox:
    // - Creates IceServers for Firefox
    //   - Use .url for FireFox.
    //   - Multiple Urls support
    // Chrome:
    // - Creates iceServers from the urls for Chrome M34 and above.
    //   - .urls is supported since Chrome M34.
    //   - Multiple Urls support
    // Plugin:
    // - Creates Ice Servers for Plugin Browsers
    //   - Multiple Urls support
    //   - This is a WebRTC Function
    createIceServers = null;
    //------------------------------------------------------------
    
    //The RTCPeerConnection object.
    RTCPeerConnection = null;
    
    // Creates RTCSessionDescription object for Plugin Browsers
    RTCSessionDescription = (typeof RTCSessionDescription === 'function') ?
        RTCSessionDescription : null;
    
    // Creates RTCIceCandidate object for Plugin Browsers
    RTCIceCandidate = (typeof RTCIceCandidate === 'function') ?
        RTCIceCandidate : null;
    
    // Get UserMedia (only difference is the prefix).
    // Code from Adam Barth.
    getUserMedia = null;
    
    // Attach a media stream to an element.
    attachMediaStream = null;
    
    // Re-attach a media stream to an element.
    reattachMediaStream = null;
    
    
    // Detected browser agent name. Types are:
    // - 'firefox': Firefox browser.
    // - 'chrome': Chrome browser.
    // - 'opera': Opera browser.
    // - 'safari': Safari browser.
    // - 'IE' - Internet Explorer browser.
    webrtcDetectedBrowser = null;
    
    // Detected browser version.
    webrtcDetectedVersion = null;
    
    // Check for browser types and react accordingly
    if (navigator.mozGetUserMedia) {
        webrtcDetectedBrowser = 'firefox';
        webrtcDetectedVersion = parseInt(navigator
            .userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
        webrtcDetectedType = 'moz';
        webrtcDetectedDCSupport = 'SCTP';
        
        RTCPeerConnection = function (pcConfig, pcConstraints) {
            AdapterJS.maybeFixConfiguration(pcConfig);
            return new mozRTCPeerConnection(pcConfig, pcConstraints);
        };
        
        // The RTCSessionDescription object.
        RTCSessionDescription = mozRTCSessionDescription;
        window.RTCSessionDescription = RTCSessionDescription;
        
        // The RTCIceCandidate object.
        RTCIceCandidate = mozRTCIceCandidate;
        window.RTCIceCandidate = RTCIceCandidate;
        
        window.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
        navigator.getUserMedia = window.getUserMedia;
        
        // Shim for MediaStreamTrack.getSources.
        MediaStreamTrack.getSources = function(successCb) {
            setTimeout(function() {
                var infos = [
                    { kind: 'audio', id: 'default', label:'', facing:'' },
                    { kind: 'video', id: 'default', label:'', facing:'' }
                ];
                successCb(infos);
            }, 0);
        };
        
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                iceServer = { url : url };
            } else if (url_parts[0].indexOf('turn') === 0) {
                if (webrtcDetectedVersion < 27) {
                    var turn_url_parts = url.split('?');
                    if (turn_url_parts.length === 1 ||
                        turn_url_parts[1].indexOf('transport=udp') === 0) {
                        iceServer = {
                            url : turn_url_parts[0],
                            credential : password,
                            username : username
                        };
                    }
                } else {
                    iceServer = {
                        url : url,
                        credential : password,
                        username : username
                    };
                }
            }
            return iceServer;
        };
        
        createIceServers = function (urls, username, password) {
            var iceServers = [];
            for (var i = 0; i < urls.length; i++) {
                var iceServer = createIceServer(urls[i], username, password);
                if (iceServer !== null) {
                    iceServers.push(iceServer);
                }
            }
            return iceServers;
        };
        
        attachMediaStream = function (element, stream) {
            element.mozSrcObject = stream;
            if (stream !== null)
                element.play();
            
            return element;
        };
        
        reattachMediaStream = function (to, from) {
            to.mozSrcObject = from.mozSrcObject;
            to.play();
            return to;
        };
        
        MediaStreamTrack.getSources = MediaStreamTrack.getSources || function (callback) {
                if (!callback) {
                    throw new TypeError('Failed to execute \'getSources\' on \'MediaStreamTrack\'' +
                        ': 1 argument required, but only 0 present.');
                }
                return callback([]);
            };
        
        // Fake get{Video,Audio}Tracks
        if (!MediaStream.prototype.getVideoTracks) {
            MediaStream.prototype.getVideoTracks = function () {
                return [];
            };
        }
        if (!MediaStream.prototype.getAudioTracks) {
            MediaStream.prototype.getAudioTracks = function () {
                return [];
            };
        }
        
        AdapterJS.maybeThroughWebRTCReady();
    } else if (navigator.webkitGetUserMedia) {
        webrtcDetectedBrowser = 'chrome';
        webrtcDetectedType = 'webkit';
        webrtcDetectedVersion = parseInt(navigator
            .userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
        // check if browser is opera 20+
        var checkIfOpera = navigator.userAgent.match(/\bOPR\/(\d+)/);
        if (checkIfOpera !== null) {
            webrtcDetectedBrowser = 'opera';
            webrtcDetectedVersion = parseInt(checkIfOpera[1], 10);
        }
        // check browser datachannel support
        if ((webrtcDetectedBrowser === 'chrome' && webrtcDetectedVersion >= 31) ||
            (webrtcDetectedBrowser === 'opera' && webrtcDetectedVersion >= 20)) {
            webrtcDetectedDCSupport = 'SCTP';
        } else if (webrtcDetectedBrowser === 'chrome' && webrtcDetectedVersion < 30 &&
            webrtcDetectedVersion > 24) {
            webrtcDetectedDCSupport = 'RTP';
        } else {
            webrtcDetectedDCSupport = '';
        }
        
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                iceServer = { 'url' : url };
            } else if (url_parts[0].indexOf('turn') === 0) {
                iceServer = {
                    'url' : url,
                    'credential' : password,
                    'username' : username
                };
            }
            return iceServer;
        };
        
        createIceServers = function (urls, username, password) {
            var iceServers = [];
            if (webrtcDetectedVersion >= 34) {
                iceServers = {
                    'urls' : urls,
                    'credential' : password,
                    'username' : username
                };
            } else {
                for (var i = 0; i < urls.length; i++) {
                    var iceServer = createIceServer(urls[i], username, password);
                    if (iceServer !== null) {
                        iceServers.push(iceServer);
                    }
                }
            }
            return iceServers;
        };
        
        RTCPeerConnection = function (pcConfig, pcConstraints) {
            if (webrtcDetectedVersion < 34) {
                AdapterJS.maybeFixConfiguration(pcConfig);
            }
            return new webkitRTCPeerConnection(pcConfig, pcConstraints);
        };
        
        window.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
        navigator.getUserMedia = window.getUserMedia;
        
        attachMediaStream = function (element, stream) {
            if (typeof element.srcObject !== 'undefined') {
                element.srcObject = stream;
            } else if (typeof element.mozSrcObject !== 'undefined') {
                element.mozSrcObject = stream;
            } else if (typeof element.src !== 'undefined') {
                element.src = (stream === null ? '' : URL.createObjectURL(stream));
            } else {
                console.log('Error attaching stream to element.');
            }
            return element;
        };
        
        reattachMediaStream = function (to, from) {
            to.src = from.src;
            return to;
        };
        
        AdapterJS.maybeThroughWebRTCReady();
    } else if (navigator.mediaDevices && navigator.userAgent.match(
            /Edge\/(\d+).(\d+)$/)) {
        webrtcDetectedBrowser = 'edge';
        
        webrtcDetectedVersion =
            parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10);
        
        // the minimum version still supported by adapter.
        webrtcMinimumVersion = 12;
        
        window.getUserMedia = navigator.getUserMedia.bind(navigator);
        
        attachMediaStream = function(element, stream) {
            element.srcObject = stream;
            return element;
        };
        reattachMediaStream = function(to, from) {
            to.srcObject = from.srcObject;
            return to;
        };
        
        AdapterJS.maybeThroughWebRTCReady();
    } else { // TRY TO USE PLUGIN
        // IE 9 is not offering an implementation of console.log until you open a console
        if (typeof console !== 'object' || typeof console.log !== 'function') {
            /* jshint -W020 */
            console = {} || console;
            // Implemented based on console specs from MDN
            // You may override these functions
            console.log = function (arg) {};
            console.info = function (arg) {};
            console.error = function (arg) {};
            console.dir = function (arg) {};
            console.exception = function (arg) {};
            console.trace = function (arg) {};
            console.warn = function (arg) {};
            console.count = function (arg) {};
            console.debug = function (arg) {};
            console.count = function (arg) {};
            console.time = function (arg) {};
            console.timeEnd = function (arg) {};
            console.group = function (arg) {};
            console.groupCollapsed = function (arg) {};
            console.groupEnd = function (arg) {};
            /* jshint +W020 */
        }
        webrtcDetectedType = 'plugin';
        webrtcDetectedDCSupport = 'plugin';
        AdapterJS.parseWebrtcDetectedBrowser();
        isIE = webrtcDetectedBrowser === 'IE';
        
        /* jshint -W035 */
        AdapterJS.WebRTCPlugin.WaitForPluginReady = function() {
            while (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {
                /* empty because it needs to prevent the function from running. */
            }
        };
        /* jshint +W035 */
        
        AdapterJS.WebRTCPlugin.callWhenPluginReady = function (callback) {
            if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {
                // Call immediately if possible
                // Once the plugin is set, the code will always take this path
                callback();
            } else {
                // otherwise start a 100ms interval
                var checkPluginReadyState = setInterval(function () {
                    if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {
                        clearInterval(checkPluginReadyState);
                        callback();
                    }
                }, 100);
            }
        };
        
        AdapterJS.WebRTCPlugin.setLogLevel = function(logLevel) {
            AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {
                AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);
            });
        };
        
        AdapterJS.WebRTCPlugin.injectPlugin = function () {
            // only inject once the page is ready
            if (document.readyState !== 'complete') {
                return;
            }
            
            // Prevent multiple injections
            if (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING) {
                return;
            }
            
            AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING;
            
            if (webrtcDetectedBrowser === 'IE' && webrtcDetectedVersion <= 10) {
                var frag = document.createDocumentFragment();
                AdapterJS.WebRTCPlugin.plugin = document.createElement('div');
                AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id="' +
                    AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '" type="' +
                    AdapterJS.WebRTCPlugin.pluginInfo.type + '" ' + 'width="1" height="1">' +
                    '<param name="pluginId" value="' +
                    AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '" /> ' +
                    '<param name="windowless" value="false" /> ' +
                    '<param name="pageId" value="' + AdapterJS.WebRTCPlugin.pageId + '" /> ' +
                    '<param name="onload" value="' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '" />' +
                    '<param name="tag" value="' + AdapterJS.WebRTCPlugin.TAGS.NONE + '" />' +
                        // uncomment to be able to use virtual cams
                    (AdapterJS.options.getAllCams ? '<param name="forceGetAllCams" value="True" />':'') +
                    
                    '</object>';
                while (AdapterJS.WebRTCPlugin.plugin.firstChild) {
                    frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);
                }
                document.body.appendChild(frag);
                
                // Need to re-fetch the plugin
                AdapterJS.WebRTCPlugin.plugin =
                    document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);
            } else {
                // Load Plugin
                AdapterJS.WebRTCPlugin.plugin = document.createElement('object');
                AdapterJS.WebRTCPlugin.plugin.id =
                    AdapterJS.WebRTCPlugin.pluginInfo.pluginId;
                // IE will only start the plugin if it's ACTUALLY visible
                if (isIE) {
                    AdapterJS.WebRTCPlugin.plugin.width = '1px';
                    AdapterJS.WebRTCPlugin.plugin.height = '1px';
                } else { // The size of the plugin on Safari should be 0x0px
                    // so that the autorisation prompt is at the top
                    AdapterJS.WebRTCPlugin.plugin.width = '0px';
                    AdapterJS.WebRTCPlugin.plugin.height = '0px';
                }
                AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type;
                AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name="onload" value="' +
                    AdapterJS.WebRTCPlugin.pluginInfo.onload + '">' +
                    '<param name="pluginId" value="' +
                    AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '">' +
                    '<param name="windowless" value="false" /> ' +
                    (AdapterJS.options.getAllCams ? '<param name="forceGetAllCams" value="True" />':'') +
                    '<param name="pageId" value="' + AdapterJS.WebRTCPlugin.pageId + '">' +
                    '<param name="tag" value="' + AdapterJS.WebRTCPlugin.TAGS.NONE + '" />';
                document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);
            }
            
            
            AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;
        };
        
        AdapterJS.WebRTCPlugin.isPluginInstalled =
            function (comName, plugName, installedCb, notInstalledCb) {
                if (!isIE) {
                    var pluginArray = navigator.plugins;
                    for (var i = 0; i < pluginArray.length; i++) {
                        if (pluginArray[i].name.indexOf(plugName) >= 0) {
                            installedCb();
                            return;
                        }
                    }
                    notInstalledCb();
                } else {
                    try {
                        var axo = new ActiveXObject(comName + '.' + plugName);
                    } catch (e) {
                        notInstalledCb();
                        return;
                    }
                    installedCb();
                }
            };
        
        AdapterJS.WebRTCPlugin.defineWebRTCInterface = function () {
            if (AdapterJS.WebRTCPlugin.pluginState ===
                AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {
                console.error("AdapterJS - WebRTC interface has already been defined");
                return;
            }
            
            AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING;
            
            AdapterJS.isDefined = function (variable) {
                return variable !== null && variable !== undefined;
            };
            
            createIceServer = function (url, username, password) {
                var iceServer = null;
                var url_parts = url.split(':');
                if (url_parts[0].indexOf('stun') === 0) {
                    iceServer = {
                        'url' : url,
                        'hasCredentials' : false
                    };
                } else if (url_parts[0].indexOf('turn') === 0) {
                    iceServer = {
                        'url' : url,
                        'hasCredentials' : true,
                        'credential' : password,
                        'username' : username
                    };
                }
                return iceServer;
            };
            
            createIceServers = function (urls, username, password) {
                var iceServers = [];
                for (var i = 0; i < urls.length; ++i) {
                    iceServers.push(createIceServer(urls[i], username, password));
                }
                return iceServers;
            };
            
            RTCSessionDescription = function (info) {
                AdapterJS.WebRTCPlugin.WaitForPluginReady();
                return AdapterJS.WebRTCPlugin.plugin.
                    ConstructSessionDescription(info.type, info.sdp);
            };
            
            RTCPeerConnection = function (servers, constraints) {
                var iceServers = null;
                if (servers) {
                    iceServers = servers.iceServers;
                    for (var i = 0; i < iceServers.length; i++) {
                        if (iceServers[i].urls && !iceServers[i].url) {
                            iceServers[i].url = iceServers[i].urls;
                        }
                        iceServers[i].hasCredentials = AdapterJS.
                                isDefined(iceServers[i].username) &&
                            AdapterJS.isDefined(iceServers[i].credential);
                    }
                }
                var mandatory = (constraints && constraints.mandatory) ?
                    constraints.mandatory : null;
                var optional = (constraints && constraints.optional) ?
                    constraints.optional : null;
                
                AdapterJS.WebRTCPlugin.WaitForPluginReady();
                return AdapterJS.WebRTCPlugin.plugin.
                    PeerConnection(AdapterJS.WebRTCPlugin.pageId,
                    iceServers, mandatory, optional);
            };
            
            MediaStreamTrack = {};
            MediaStreamTrack.getSources = function (callback) {
                AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {
                    AdapterJS.WebRTCPlugin.plugin.GetSources(callback);
                });
            };
            
            window.getUserMedia = function (constraints, successCallback, failureCallback) {
                constraints.audio = constraints.audio || false;
                constraints.video = constraints.video || false;
                
                AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {
                    AdapterJS.WebRTCPlugin.plugin.
                        getUserMedia(constraints, successCallback, failureCallback);
                });
            };
            window.navigator.getUserMedia = window.getUserMedia;
            
            attachMediaStream = function (element, stream) {
                if (!element || !element.parentNode) {
                    return;
                }
                
                var streamId;
                if (stream === null) {
                    streamId = '';
                } else {
                    if (typeof stream.enableSoundTracks !== 'undefined') {
                        stream.enableSoundTracks(true);
                    }
                    streamId = stream.id;
                }
                
                var elementId = element.id.length === 0 ? Math.random().toString(36).slice(2) : element.id;
                var nodeName = element.nodeName.toLowerCase();
                if (nodeName !== 'object') { // not a plugin <object> tag yet
                    var tag;
                    switch(nodeName) {
                        case 'audio':
                            tag = AdapterJS.WebRTCPlugin.TAGS.AUDIO;
                            break;
                        case 'video':
                            tag = AdapterJS.WebRTCPlugin.TAGS.VIDEO;
                            break;
                        default:
                            tag = AdapterJS.WebRTCPlugin.TAGS.NONE;
                    }
                    
                    var frag = document.createDocumentFragment();
                    var temp = document.createElement('div');
                    var classHTML = '';
                    if (element.className) {
                        classHTML = 'class="' + element.className + '" ';
                    } else if (element.attributes && element.attributes['class']) {
                        classHTML = 'class="' + element.attributes['class'].value + '" ';
                    }
                    
                    temp.innerHTML = '<object id="' + elementId + '" ' + classHTML +
                        'type="' + AdapterJS.WebRTCPlugin.pluginInfo.type + '">' +
                        '<param name="pluginId" value="' + elementId + '" /> ' +
                        '<param name="pageId" value="' + AdapterJS.WebRTCPlugin.pageId + '" /> ' +
                        '<param name="windowless" value="true" /> ' +
                        '<param name="streamId" value="' + streamId + '" /> ' +
                        '<param name="tag" value="' + tag + '" /> ' +
                        '</object>';
                    while (temp.firstChild) {
                        frag.appendChild(temp.firstChild);
                    }
                    
                    var height = '';
                    var width = '';
                    if (element.clientWidth || element.clientHeight) {
                        width = element.clientWidth;
                        height = element.clientHeight;
                    }
                    else if (element.width || element.height) {
                        width = element.width;
                        height = element.height;
                    }
                    
                    element.parentNode.insertBefore(frag, element);
                    frag = document.getElementById(elementId);
                    frag.width = width;
                    frag.height = height;
                    element.parentNode.removeChild(element);
                } else { // already an <object> tag, just change the stream id
                    var children = element.children;
                    for (var i = 0; i !== children.length; ++i) {
                        if (children[i].name === 'streamId') {
                            children[i].value = streamId;
                            break;
                        }
                    }
                    element.setStreamId(streamId);
                }
                var newElement = document.getElementById(elementId);
                AdapterJS.forwardEventHandlers(newElement, element, Object.getPrototypeOf(element));
                
                return newElement;
            };
            
            reattachMediaStream = function (to, from) {
                var stream = null;
                var children = from.children;
                for (var i = 0; i !== children.length; ++i) {
                    if (children[i].name === 'streamId') {
                        AdapterJS.WebRTCPlugin.WaitForPluginReady();
                        stream = AdapterJS.WebRTCPlugin.plugin
                            .getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);
                        break;
                    }
                }
                if (stream !== null) {
                    return attachMediaStream(to, stream);
                } else {
                    console.log('Could not find the stream associated with this element');
                }
            };
            
            AdapterJS.forwardEventHandlers = function (destElem, srcElem, prototype) {
                
                properties = Object.getOwnPropertyNames( prototype );
                
                for(prop in properties) {
                    propName = properties[prop];
                    
                    if (typeof(propName.slice) === 'function') {
                        if (propName.slice(0,2) == 'on' && srcElem[propName] != null) {
                            if (isIE) {
                                destElem.attachEvent(propName,srcElem[propName]);
                            } else {
                                destElem.addEventListener(propName.slice(2), srcElem[propName], false)
                            }
                        } else {
                            //TODO (http://jira.temasys.com.sg/browse/TWP-328) Forward non-event properties ?
                        }
                    }
                }
                
                var subPrototype = Object.getPrototypeOf(prototype)
                if(subPrototype != null) {
                    AdapterJS.forwardEventHandlers(destElem, srcElem, subPrototype);
                }
            }
            
            RTCIceCandidate = function (candidate) {
                if (!candidate.sdpMid) {
                    candidate.sdpMid = '';
                }
                
                AdapterJS.WebRTCPlugin.WaitForPluginReady();
                return AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(
                    candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate
                );
            };
            
            // inject plugin
            AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.injectPlugin);
            AdapterJS.WebRTCPlugin.injectPlugin();
        };
        
        // This function will be called if the plugin is needed (browser different
        // from Chrome or Firefox), but the plugin is not installed.
        AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb ||
            function() {
                AdapterJS.addEvent(document,
                    'readystatechange',
                    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv);
                AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();
            };
        
        AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function () {
            if (AdapterJS.options.hidePluginInstallPrompt) {
                return;
            }
            
            var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;
            if(downloadLink) { // if download link
                var popupString;
                if (AdapterJS.WebRTCPlugin.pluginInfo.portalLink) { // is portal link
                    popupString = 'This website requires you to install the ' +
                        ' <a href="' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink +
                        '" target="_blank">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName +
                        ' WebRTC Plugin</a>' +
                        ' to work on this browser.';
                } else { // no portal link, just print a generic explanation
                    popupString = AdapterJS.TEXT.PLUGIN.REQUIRE_INSTALLATION;
                }
                
                AdapterJS.renderNotificationBar(popupString, AdapterJS.TEXT.PLUGIN.BUTTON, downloadLink);
            } else { // no download link, just print a generic explanation
                AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED);
            }
        };
        
        // Try to detect the plugin and act accordingly
        AdapterJS.WebRTCPlugin.isPluginInstalled(
            AdapterJS.WebRTCPlugin.pluginInfo.prefix,
            AdapterJS.WebRTCPlugin.pluginInfo.plugName,
            AdapterJS.WebRTCPlugin.defineWebRTCInterface,
            AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);
    }
    
},{}],10:[function(require,module,exports){
    /* global Strophe, APP, $, config, interfaceConfig, toastr */
    /* jshint -W101 */
    var UI = {};
    
    var VideoLayout = require("./videolayout/VideoLayout.js");
    var AudioLevels = require("./audio_levels/AudioLevels.js");
    var Prezi = require("./prezi/Prezi.js");
    var Etherpad = require("./etherpad/Etherpad.js");
    var Chat = require("./side_pannels/chat/Chat.js");
    var Toolbar = require("./toolbars/Toolbar");
    var ToolbarToggler = require("./toolbars/ToolbarToggler");
    var BottomToolbar = require("./toolbars/BottomToolbar");
    var ContactList = require("./side_pannels/contactlist/ContactList");
    var Avatar = require("./avatar/Avatar");
    var EventEmitter = require("events");
    var SettingsMenu = require("./side_pannels/settings/SettingsMenu");
    var Settings = require("./../settings/Settings");
    var PanelToggler = require("./side_pannels/SidePanelToggler");
    var RoomNameGenerator = require("./welcome_page/RoomnameGenerator");
    UI.messageHandler = require("./util/MessageHandler");
    var messageHandler = UI.messageHandler;
    var Authentication  = require("./authentication/Authentication");
    var UIUtil = require("./util/UIUtil");
    var NicknameHandler = require("./util/NicknameHandler");
    var JitsiPopover = require("./util/JitsiPopover");
    var CQEvents = require("../../service/connectionquality/CQEvents");
    var DesktopSharingEventTypes
        = require("../../service/desktopsharing/DesktopSharingEventTypes");
    var RTCEvents = require("../../service/RTC/RTCEvents");
    var RTCBrowserType = require("../RTC/RTCBrowserType");
    var StreamEventTypes = require("../../service/RTC/StreamEventTypes");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var StatisticsEvents = require("../../service/statistics/Events");
    var UIEvents = require("../../service/UI/UIEvents");
    var MemberEvents = require("../../service/members/Events");
    
    var eventEmitter = new EventEmitter();
    var roomNode = null;
    var roomName = null;
    
    
    function promptDisplayName() {
        var message = '<h2 data-i18n="dialog.displayNameRequired">';
        message += APP.translation.translateString(
            "dialog.displayNameRequired");
        message += '</h2>' +
            '<input name="displayName" type="text" data-i18n=' +
            '"[placeholder]defaultNickname" placeholder="' +
            APP.translation.translateString(
                "defaultNickname", {name: "Jane Pink"}) +
            '" autofocus>';
        
        var buttonTxt
            = APP.translation.generateTranslationHTML("dialog.Ok");
        var buttons = [];
        buttons.push({title: buttonTxt, value: "ok"});
        
        messageHandler.openDialog(null, message,
            true,
            buttons,
            function (e, v, m, f) {
                if (v == "ok") {
                    var displayName = f.displayName;
                    if (displayName) {
                        VideoLayout.inputDisplayNameHandler(displayName);
                        return true;
                    }
                }
                e.preventDefault();
            },
            function () {
                var form  = $.prompt.getPrompt();
                var input = form.find("input[name='displayName']");
                input.focus();
                var button = form.find("button");
                button.attr("disabled", "disabled");
                input.keyup(function () {
                    if(!input.val())
                        button.attr("disabled", "disabled");
                    else
                        button.removeAttr("disabled");
                });
            }
        );
    }
    
    function notifyForInitialMute() {
        messageHandler.notify(null, "notify.mutedTitle", "connected",
            "notify.muted", null, {timeOut: 120000});
    }
    
    function setupPrezi() {
        $("#reloadPresentationLink").click(function() {
            Prezi.reloadPresentation();
        });
    }
    
    function setupChat() {
        Chat.init();
        $("#toggle_smileys").click(function() {
            Chat.toggleSmileys();
        });
    }
    
    function setupToolbars() {
        Toolbar.init(UI);
        Toolbar.setupButtonsFromConfig();
        BottomToolbar.init();
    }
    
    function streamHandler(stream, isMuted) {
        switch (stream.type) {
            case "audio":
                VideoLayout.changeLocalAudio(stream, isMuted);
                break;
            case "video":
                VideoLayout.changeLocalVideo(stream, isMuted);
                break;
            case "stream":
                VideoLayout.changeLocalStream(stream, isMuted);
                break;
        }
    }
    
    function onXmppConnectionFailed(stropheErrorMsg) {
        
        var title = APP.translation.generateTranslationHTML(
            "dialog.error");
        
        var message;
        if (stropheErrorMsg) {
            message = APP.translation.generateTranslationHTML(
                "dialog.connectErrorWithMsg", {msg: stropheErrorMsg});
        } else {
            message = APP.translation.generateTranslationHTML(
                "dialog.connectError");
        }
        
        messageHandler.openDialog(
            title, message, true, {}, function (e, v, m, f) { return false; });
    }
    
    function onDisposeConference(unload) {
        Toolbar.showAuthenticateButton(false);
    }
    
    function onDisplayNameChanged(jid, displayName) {
        ContactList.onDisplayNameChange(jid, displayName);
        SettingsMenu.onDisplayNameChange(jid, displayName);
        VideoLayout.onDisplayNameChanged(jid, displayName);
    }
    
    function registerListeners() {
        APP.RTC.addStreamListener(streamHandler,
            StreamEventTypes.EVENT_TYPE_LOCAL_CREATED);
        APP.RTC.addStreamListener(streamHandler,
            StreamEventTypes.EVENT_TYPE_LOCAL_CHANGED);
        APP.RTC.addStreamListener(function (stream) {
            VideoLayout.onRemoteStreamAdded(stream);
        }, StreamEventTypes.EVENT_TYPE_REMOTE_CREATED);
        APP.RTC.addListener(RTCEvents.LASTN_CHANGED, onLastNChanged);
        APP.RTC.addListener(RTCEvents.DOMINANTSPEAKER_CHANGED,
            function (resourceJid) {
                VideoLayout.onDominantSpeakerChanged(resourceJid);
            });
        APP.RTC.addListener(RTCEvents.LASTN_ENDPOINT_CHANGED,
            function (lastNEndpoints, endpointsEnteringLastN, stream) {
                VideoLayout.onLastNEndpointsChanged(lastNEndpoints,
                    endpointsEnteringLastN, stream);
            });
        APP.RTC.addListener(RTCEvents.AVAILABLE_DEVICES_CHANGED,
            function (devices) {
                VideoLayout.setDeviceAvailabilityIcons(null, devices);
            });
        APP.RTC.addListener(RTCEvents.VIDEO_MUTE, UI.setVideoMuteButtonsState);
        APP.RTC.addListener(RTCEvents.DATA_CHANNEL_OPEN, function () {
            // when the data channel becomes available, tell the bridge about video
            // selections so that it can do adaptive simulcast,
            // we want the notification to trigger even if userJid is undefined,
            // or null.
            var userResource = APP.UI.getLargeVideoResource();
            eventEmitter.emit(UIEvents.SELECTED_ENDPOINT, userResource);
        });
        APP.statistics.addListener(StatisticsEvents.AUDIO_LEVEL,
            function(jid, audioLevel) {
                var resourceJid;
                if(jid === APP.statistics.LOCAL_JID) {
                    resourceJid = AudioLevels.LOCAL_LEVEL;
                    if(APP.RTC.localAudio.isMuted()) {
                        audioLevel = 0;
                    }
                } else {
                    resourceJid = Strophe.getResourceFromJid(jid);
                }
                
                AudioLevels.updateAudioLevel(resourceJid, audioLevel,
                    UI.getLargeVideoResource());
            });
        APP.desktopsharing.addListener(
            DesktopSharingEventTypes.INIT,
            ToolbarToggler.showToolbar);
        APP.desktopsharing.addListener(
            DesktopSharingEventTypes.SWITCHING_DONE,
            Toolbar.changeDesktopSharingButtonState);
        APP.desktopsharing.addListener(
            DesktopSharingEventTypes.FIREFOX_EXTENSION_NEEDED,
            function (url) {
                APP.UI.messageHandler.openMessageDialog(
                    "dialog.extensionRequired",
                    null,
                    null,
                    APP.translation.generateTranslationHTML(
                        "dialog.firefoxExtensionPrompt", {url: url}));
            });
        APP.connectionquality.addListener(CQEvents.LOCALSTATS_UPDATED,
            VideoLayout.updateLocalConnectionStats);
        APP.connectionquality.addListener(CQEvents.REMOTESTATS_UPDATED,
            VideoLayout.updateConnectionStats);
        APP.connectionquality.addListener(CQEvents.STOP,
            VideoLayout.onStatsStop);
        APP.xmpp.addListener(XMPPEvents.CONNECTION_FAILED, onXmppConnectionFailed);
        APP.xmpp.addListener(XMPPEvents.DISPOSE_CONFERENCE, onDisposeConference);
        APP.xmpp.addListener(XMPPEvents.GRACEFUL_SHUTDOWN, function () {
            messageHandler.openMessageDialog(
                'dialog.serviceUnavailable',
                'dialog.gracefulShutdown'
            );
        });
        APP.xmpp.addListener(XMPPEvents.RESERVATION_ERROR, function (code, msg) {
            var title = APP.translation.generateTranslationHTML(
                "dialog.reservationError");
            var message = APP.translation.generateTranslationHTML(
                "dialog.reservationErrorMsg", {code: code, msg: msg});
            messageHandler.openDialog(
                title,
                message,
                true, {},
                function (event, value, message, formVals) {
                    return false;
                }
            );
        });
        APP.xmpp.addListener(XMPPEvents.KICKED, function () {
            messageHandler.openMessageDialog("dialog.sessTerminated",
                "dialog.kickMessage");
        });
        APP.xmpp.addListener(XMPPEvents.MUC_DESTROYED, function (reason) {
            //FIXME: use Session Terminated from translation, but
            // 'reason' text comes from XMPP packet and is not translated
            var title = APP.translation.generateTranslationHTML("dialog.sessTerminated");
            messageHandler.openDialog(
                title, reason, true, {},
                function (event, value, message, formVals) {
                    return false;
                }
            );
        });
        APP.xmpp.addListener(XMPPEvents.BRIDGE_DOWN, function () {
            messageHandler.showError("dialog.error",
                "dialog.bridgeUnavailable");
        });
        APP.xmpp.addListener(XMPPEvents.USER_ID_CHANGED, function (from, id) {
            Avatar.setUserAvatar(from, id);
        });
        APP.xmpp.addListener(XMPPEvents.DISPLAY_NAME_CHANGED, onDisplayNameChanged);
        APP.xmpp.addListener(XMPPEvents.MUC_JOINED, onMucJoined);
        APP.xmpp.addListener(XMPPEvents.LOCAL_ROLE_CHANGED, onLocalRoleChanged);
        APP.xmpp.addListener(XMPPEvents.MUC_MEMBER_JOINED, onMucMemberJoined);
        APP.xmpp.addListener(XMPPEvents.MUC_ROLE_CHANGED, onMucRoleChanged);
        APP.xmpp.addListener(XMPPEvents.PRESENCE_STATUS, onMucPresenceStatus);
        APP.xmpp.addListener(XMPPEvents.SUBJECT_CHANGED, chatSetSubject);
        APP.xmpp.addListener(XMPPEvents.MUC_MEMBER_LEFT, onMucMemberLeft);
        APP.xmpp.addListener(XMPPEvents.PASSWORD_REQUIRED, onPasswordRequired);
        APP.xmpp.addListener(XMPPEvents.ETHERPAD, initEtherpad);
        APP.xmpp.addListener(XMPPEvents.AUTHENTICATION_REQUIRED,
            onAuthenticationRequired);
        APP.xmpp.addListener(XMPPEvents.PARTICIPANT_VIDEO_TYPE_CHANGED,
            onPeerVideoTypeChanged);
        APP.xmpp.addListener(XMPPEvents.DEVICE_AVAILABLE,
            function (resource, devices) {
                VideoLayout.setDeviceAvailabilityIcons(resource, devices);
            });
        
        APP.xmpp.addListener(XMPPEvents.PARTICIPANT_AUDIO_MUTED,
            VideoLayout.onAudioMute);
        APP.xmpp.addListener(XMPPEvents.PARTICIPANT_VIDEO_MUTED,
            VideoLayout.onVideoMute);
        APP.xmpp.addListener(XMPPEvents.AUDIO_MUTED_BY_FOCUS, function (doMuteAudio) {
            UI.setAudioMuted(doMuteAudio);
        });
        APP.members.addListener(MemberEvents.DTMF_SUPPORT_CHANGED,
            onDtmfSupportChanged);
        APP.xmpp.addListener(XMPPEvents.START_MUTED_SETTING_CHANGED, function (audio, video) {
            SettingsMenu.setStartMuted(audio, video);
        });
        APP.xmpp.addListener(XMPPEvents.START_MUTED_FROM_FOCUS, function (audio, video) {
            UI.setInitialMuteFromFocus(audio, video);
        });
        
        APP.xmpp.addListener(XMPPEvents.JINGLE_FATAL_ERROR, function (session, error) {
            UI.messageHandler.showError("dialog.sorry",
                "dialog.internalError");
        });
        
        APP.xmpp.addListener(XMPPEvents.SET_LOCAL_DESCRIPTION_ERROR, function () {
            messageHandler.showError("dialog.error",
                "dialog.SLDFailure");
        });
        APP.xmpp.addListener(XMPPEvents.SET_REMOTE_DESCRIPTION_ERROR, function () {
            messageHandler.showError("dialog.error",
                "dialog.SRDFailure");
        });
        APP.xmpp.addListener(XMPPEvents.CREATE_ANSWER_ERROR, function () {
            messageHandler.showError();
        });
        APP.xmpp.addListener(XMPPEvents.PROMPT_FOR_LOGIN, function (callback) {
            // FIXME: re-use LoginDialog which supports retries
            if (config.token) {
                messageHandler.showError("dialog.error", "dialog.tokenAuthFailed");
            } else {
                UI.showLoginPopup(callback);
            }
        });
        
        APP.xmpp.addListener(XMPPEvents.FOCUS_DISCONNECTED, function (focusComponent, retrySec) {
            UI.messageHandler.notify(
                null, "notify.focus",
                'disconnected', "notify.focusFail",
                {component: focusComponent, ms: retrySec});
        });
        
        APP.xmpp.addListener(XMPPEvents.ROOM_JOIN_ERROR, function (pres) {
            UI.messageHandler.openReportDialog(null,
                "dialog.connectError", pres);
        });
        APP.xmpp.addListener(XMPPEvents.ROOM_CONNECT_ERROR, function (pres) {
            UI.messageHandler.openReportDialog(null,
                "dialog.connectError", pres);
        });
        
        APP.xmpp.addListener(XMPPEvents.READY_TO_JOIN, function () {
            var roomName = UI.generateRoomName();
            APP.xmpp.allocateConferenceFocus(roomName, UI.checkForNicknameAndJoin);
        });
        
        //NicknameHandler emits this event
        UI.addListener(UIEvents.NICKNAME_CHANGED, function (nickname) {
            APP.xmpp.addToPresence("displayName", nickname);
        });
        
        UI.addListener(UIEvents.LARGEVIDEO_INIT, function () {
            AudioLevels.init();
        });
        
        if (!interfaceConfig.filmStripOnly) {
            APP.xmpp.addListener(XMPPEvents.MESSAGE_RECEIVED, updateChatConversation);
            APP.xmpp.addListener(XMPPEvents.CHAT_ERROR_RECEIVED, chatAddError);
            // Listens for video interruption events.
            APP.xmpp.addListener(XMPPEvents.CONNECTION_INTERRUPTED, VideoLayout.onVideoInterrupted);
            // Listens for video restores events.
            APP.xmpp.addListener(XMPPEvents.CONNECTION_RESTORED, VideoLayout.onVideoRestored);
        }
    }
    
    
    /**
     * Mutes/unmutes the local video.
     *
     * @param mute <tt>true</tt> to mute the local video; otherwise, <tt>false</tt>
     * @param options an object which specifies optional arguments such as the
     * <tt>boolean</tt> key <tt>byUser</tt> with default value <tt>true</tt> which
     * specifies whether the method was initiated in response to a user command (in
     * contrast to an automatic decision taken by the application logic)
     */
    function setVideoMute(mute, options) {
        APP.RTC.setVideoMute(mute,
            UI.setVideoMuteButtonsState,
            options);
    }
    
    function onResize() {
        Chat.resizeChat();
        VideoLayout.resizeLargeVideoContainer();
    }
    
    function bindEvents() {
        /**
         * Resizes and repositions videos in full screen mode.
         */
        $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange',
            onResize);
        
        $(window).resize(onResize);
    }
    
    UI.start = function (init) {
        document.title = interfaceConfig.APP_NAME;
        var setupWelcomePage = null;
        if(config.enableWelcomePage && window.location.pathname == "/" &&
            (!window.localStorage.welcomePageDisabled ||
            window.localStorage.welcomePageDisabled == "false")) {
            $("#videoconference_page").hide();
            if (!setupWelcomePage)
                setupWelcomePage = require("./welcome_page/WelcomePage");
            setupWelcomePage();
            
            return;
        }
        
        $("#welcome_page").hide();
        
        // Set the defaults for prompt dialogs.
        $.prompt.setDefaults({persistent: false});
        
        
        registerListeners();
        
        VideoLayout.init(eventEmitter);
        NicknameHandler.init(eventEmitter);
        
        bindEvents();
        setupPrezi();
        if (!interfaceConfig.filmStripOnly) {
            $("#videospace").mousemove(function () {
                return ToolbarToggler.showToolbar();
            });
            setupToolbars();
            setupChat();
            // Display notice message at the top of the toolbar
            if (config.noticeMessage) {
                $('#noticeText').text(config.noticeMessage);
                $('#notice').css({display: 'block'});
            }
            $("#downloadlog").click(function (event) {
                dump(event.target);
            });
        }
        else
        {
            $("#header").css("display", "none");
            $("#bottomToolbar").css("display", "none");
            $("#downloadlog").css("display", "none");
            $("#remoteVideos").css("padding", "0px 0px 18px 0px");
            $("#remoteVideos").css("right", "0px");
            messageHandler.disableNotifications();
            $('body').popover("disable");
            //        $("[data-toggle=popover]").popover("disable");
            JitsiPopover.enabled = false;
        }
        
        document.title = interfaceConfig.APP_NAME;
        
        
        
        
        
        if(config.requireDisplayName) {
            var currentSettings = Settings.getSettings();
            if (!currentSettings.displayName) {
                promptDisplayName();
            }
        }
        
        init();
        
        if (!interfaceConfig.filmStripOnly) {
            toastr.options = {
                "closeButton": true,
                "debug": false,
                "positionClass": "notification-bottom-right",
                "onclick": null,
                "showDuration": "300",
                "hideDuration": "1000",
                "timeOut": "2000",
                "extendedTimeOut": "1000",
                "showEasing": "swing",
                "hideEasing": "linear",
                "showMethod": "fadeIn",
                "hideMethod": "fadeOut",
                "reposition": function () {
                    if (PanelToggler.isVisible()) {
                        $("#toast-container").addClass("notification-bottom-right-center");
                    } else {
                        $("#toast-container").removeClass("notification-bottom-right-center");
                    }
                },
                "newestOnTop": false
            };
            
            
            SettingsMenu.init();
        }
        
    };
    
    function chatAddError(errorMessage, originalText) {
        return Chat.chatAddError(errorMessage, originalText);
    }
    
    function chatSetSubject(text) {
        return Chat.chatSetSubject(text);
    }
    
    function updateChatConversation(from, displayName, message, myjid, stamp) {
        return Chat.updateChatConversation(from, displayName, message, myjid, stamp);
    }
    
    function onMucJoined(jid, info) {
        Toolbar.updateRoomUrl(window.location.href);
        var meHTML = APP.translation.generateTranslationHTML("me");
        $("#localNick").html(Strophe.getResourceFromJid(jid) + " (" + meHTML + ")");
        
        var settings = Settings.getSettings();
        
        // Make sure we configure our avatar id, before creating avatar for us
        Avatar.setUserAvatar(jid, settings.email || settings.uid);
        
        // Add myself to the contact list.
        ContactList.addContact(jid);
        
        // Once we've joined the muc show the toolbar
        ToolbarToggler.showToolbar();
        
        var displayName =
            config.displayJids ? Strophe.getResourceFromJid(jid) : info.displayName;
        
        if (displayName)
            onDisplayNameChanged('localVideoContainer', displayName);
        
        
        VideoLayout.mucJoined();
    }
    
    function initEtherpad(name) {
        Etherpad.init(name);
    }
    
    function onMucMemberLeft(jid) {
        console.log('left.muc', jid);
        var displayName = $('#participant_' + Strophe.getResourceFromJid(jid) +
            '>.displayname').html();
        messageHandler.notify(displayName,'notify.somebody',
            'disconnected',
            'notify.disconnected');
        if (!config.startAudioMuted ||
            config.startAudioMuted > APP.members.size()) {
            UIUtil.playSoundNotification('userLeft');
        }
        
        ContactList.removeContact(jid);
        
        VideoLayout.participantLeft(jid);
    }
    
    function onLocalRoleChanged(jid, info, pres, isModerator) {
        console.info("My role changed, new role: " + info.role);
        onModeratorStatusChanged(isModerator);
        VideoLayout.showModeratorIndicator();
        SettingsMenu.onRoleChanged();
        
        if (isModerator) {
            Authentication.closeAuthenticationWindow();
            messageHandler.notify(null, "notify.me",
                'connected', "notify.moderator");
            
            Toolbar.checkAutoRecord();
        }
    }
    
    function onModeratorStatusChanged(isModerator) {
        Toolbar.showSipCallButton(isModerator);
        Toolbar.showRecordingButton(
            isModerator); //&&
        // FIXME:
        // Recording visible if
        // there are at least 2(+ 1 focus) participants
        //Object.keys(connection.emuc.members).length >= 3);
    }
    
    function onPasswordRequired(callback) {
        // password is required
        Toolbar.lockLockButton();
        var message = '<h2 data-i18n="dialog.passwordRequired">';
        message += APP.translation.translateString(
            "dialog.passwordRequired");
        message += '</h2>' +
            '<input name="lockKey" type="text" data-i18n=' +
            '"[placeholder]dialog.password" placeholder="' +
            APP.translation.translateString("dialog.password") +
            '" autofocus>';
        
        messageHandler.openTwoButtonDialog(null, null, null, message,
            true,
            "dialog.Ok",
            function (e, v, m, f) {},
            null,
            function (e, v, m, f) {
                if (v) {
                    var lockKey = f.lockKey;
                    if (lockKey) {
                        Toolbar.setSharedKey(lockKey);
                        callback(lockKey);
                    }
                }
            },
            ':input:first'
        );
    }
    
    /**
     * The dialpad button is shown iff there is at least one member that supports
     * DTMF (e.g. jigasi).
     */
    function onDtmfSupportChanged(dtmfSupport) {
        //TODO: enable when the UI is ready
        //Toolbar.showDialPadButton(dtmfSupport);
    }
    
    function onMucMemberJoined(jid, id, displayName) {
        messageHandler.notify(displayName,'notify.somebody',
            'connected',
            'notify.connected');
        
        if (!config.startAudioMuted ||
            config.startAudioMuted > APP.members.size())
            UIUtil.playSoundNotification('userJoined');
        
        // Configure avatar
        Avatar.setUserAvatar(jid, id);
        
        // Add Peer's container
        VideoLayout.ensurePeerContainerExists(jid);
    }
    
    function onMucPresenceStatus(jid, info) {
        VideoLayout.setPresenceStatus(Strophe.getResourceFromJid(jid), info.status);
    }
    
    function onPeerVideoTypeChanged(resourceJid, newVideoType) {
        VideoLayout.onVideoTypeChanged(resourceJid, newVideoType);
    }
    
    function onMucRoleChanged(role, displayName) {
        VideoLayout.showModeratorIndicator();
        
        if (role === 'moderator') {
            var messageKey, messageOptions = {};
            if (!displayName) {
                messageKey = "notify.grantedToUnknown";
            }
            else {
                messageKey = "notify.grantedTo";
                messageOptions = {to: displayName};
            }
            messageHandler.notify(
                displayName,'notify.somebody',
                'connected', messageKey,
                messageOptions);
        }
    }
    
    function onAuthenticationRequired(intervalCallback) {
        Authentication.openAuthenticationDialog(
            roomName, intervalCallback, function () {
                Toolbar.authenticateClicked();
            });
    }
    
    
    function onLastNChanged(oldValue, newValue) {
        if (config.muteLocalVideoIfNotInLastN) {
            setVideoMute(!newValue, { 'byUser': false });
        }
    }
    
    
    UI.toggleSmileys = function () {
        Chat.toggleSmileys();
    };
    
    UI.getSettings = function () {
        return Settings.getSettings();
    };
    
    UI.toggleFilmStrip = function () {
        return BottomToolbar.toggleFilmStrip();
    };
    
    UI.toggleChat = function () {
        return BottomToolbar.toggleChat();
    };
    
    UI.toggleContactList = function () {
        return BottomToolbar.toggleContactList();
    };
    
    UI.inputDisplayNameHandler = function (value) {
        VideoLayout.inputDisplayNameHandler(value);
    };
    
    UI.getLargeVideoResource = function () {
        return VideoLayout.getLargeVideoResource();
    };
    
    UI.getRoomNode = function () {
        if (roomNode)
            return roomNode;
        var path = window.location.pathname;
        
        // determinde the room node from the url
        // TODO: just the roomnode or the whole bare jid?
        if (config.getroomnode && typeof config.getroomnode === 'function') {
            // custom function might be responsible for doing the pushstate
            roomNode = config.getroomnode(path);
        } else {
            /* fall back to default strategy
             * this is making assumptions about how the URL->room mapping happens.
             * It currently assumes deployment at root, with a rewrite like the
             * following one (for nginx):
             location ~ ^/([a-zA-Z0-9]+)$ {
             rewrite ^/(.*)$ / break;
             }
             */
            if (path.length > 1) {
                roomNode = path.substr(1).toLowerCase();
            } else {
                var word = RoomNameGenerator.generateRoomWithoutSeparator();
                roomNode = word.toLowerCase();
                window.history.pushState('VideoChat',
                    'Room: ' + word, window.location.pathname + word);
            }
        }
        return roomNode;
    };
    
    UI.generateRoomName = function () {
        if (roomName)
            return roomName;
        var roomNode = UI.getRoomNode();
        roomName = roomNode + '@' + config.hosts.muc;
        return roomName;
    };
    
    
    UI.connectionIndicatorShowMore = function(jid) {
        return VideoLayout.showMore(jid);
    };
    
    UI.showLoginPopup = function(callback) {
        console.log('password is required');
        var message = '<h2 data-i18n="dialog.passwordRequired">';
        message += APP.translation.translateString(
            "dialog.passwordRequired");
        message += '</h2>' +
            '<input name="username" type="text" ' +
            'placeholder="user@domain.net" autofocus>' +
            '<input name="password" ' +
            'type="password" data-i18n="[placeholder]dialog.userPassword"' +
            ' placeholder="user password">';
        UI.messageHandler.openTwoButtonDialog(null, null, null, message,
            true,
            "dialog.Ok",
            function (e, v, m, f) {
                if (v) {
                    if (f.username && f.password) {
                        callback(f.username, f.password);
                    }
                }
            },
            null, null, ':input:first'
        
        );
    };
    
    UI.checkForNicknameAndJoin = function () {
        
        Authentication.closeAuthenticationDialog();
        Authentication.stopInterval();
        
        var nick = null;
        if (config.useNicks) {
            nick = window.prompt('Your nickname (optional)');
        }
        APP.xmpp.joinRoom(roomName, config.useNicks, nick);
    };
    
    
    function dump(elem, filename) {
        elem = elem.parentNode;
        elem.download = filename || 'meetlog.json';
        elem.href = 'data:application/json;charset=utf-8,\n';
        var data = APP.xmpp.getJingleLog();
        var metadata = {};
        metadata.time = new Date();
        metadata.url = window.location.href;
        metadata.ua = navigator.userAgent;
        var log = APP.xmpp.getXmppLog();
        if (log) {
            metadata.xmpp = log;
        }
        data.metadata = metadata;
        elem.href += encodeURIComponent(JSON.stringify(data, null, '  '));
        return false;
    }
    
    UI.getRoomName = function () {
        return roomName;
    };
    
    UI.setInitialMuteFromFocus = function (muteAudio, muteVideo) {
        if (muteAudio || muteVideo)
            notifyForInitialMute();
        if (muteAudio)
            UI.setAudioMuted(true);
        if (muteVideo)
            UI.setVideoMute(true);
    };
    
    /**
     * Mutes/unmutes the local video.
     */
    UI.toggleVideo = function () {
        setVideoMute(!APP.RTC.localVideo.isMuted());
    };
    
    /**
     * Mutes / unmutes audio for the local participant.
     */
    UI.toggleAudio = function() {
        UI.setAudioMuted(!APP.RTC.localAudio.isMuted());
    };
    
    /**
     * Sets muted audio state for the local participant.
     */
    UI.setAudioMuted = function (mute, earlyMute) {
        var audioMute = null;
        if (earlyMute)
            audioMute = function (mute, cb) {
                return APP.xmpp.sendAudioInfoPresence(mute, cb);
            };
        else
            audioMute = function (mute, cb) {
                return APP.xmpp.setAudioMute(mute, cb);
            };
        if (!audioMute(mute, function () {
                VideoLayout.showLocalAudioIndicator(mute);
                
                UIUtil.buttonClick("#toolbar_button_mute", "icon-microphone icon-mic-disabled");
            })) {
            // We still click the button.
            UIUtil.buttonClick("#toolbar_button_mute", "icon-microphone icon-mic-disabled");
            return;
        }
    };
    
    UI.addListener = function (type, listener) {
        eventEmitter.on(type, listener);
    };
    
    UI.clickOnVideo = function (videoNumber) {
        var remoteVideos = $(".videocontainer:not(#mixedstream)");
        if (remoteVideos.length > videoNumber) {
            remoteVideos[videoNumber].click();
        }
    };
    
    //Used by torture
    UI.showToolbar = function () {
        return ToolbarToggler.showToolbar();
    };
    
    //Used by torture
    UI.dockToolbar = function (isDock) {
        return ToolbarToggler.dockToolbar(isDock);
    };
    
    UI.setVideoMuteButtonsState = function (mute) {
        var video = $('#toolbar_button_camera');
        var communicativeClass = "icon-camera";
        var muteClass = "icon-camera icon-camera-disabled";
        
        if (mute) {
            video.removeClass(communicativeClass);
            video.addClass(muteClass);
        } else {
            video.removeClass(muteClass);
            video.addClass(communicativeClass);
        }
    };
    
    UI.userAvatarChanged = function (resourceJid, thumbUrl, contactListUrl) {
        VideoLayout.userAvatarChanged(resourceJid, thumbUrl);
        ContactList.userAvatarChanged(resourceJid, contactListUrl);
        if(resourceJid === APP.xmpp.myResource())
            SettingsMenu.changeAvatar(thumbUrl);
    };
    
    UI.setVideoMute = setVideoMute;
    
    module.exports = UI;
    
    
},{"../../service/RTC/RTCEvents":178,"../../service/RTC/StreamEventTypes":180,"../../service/UI/UIEvents":181,"../../service/connectionquality/CQEvents":183,"../../service/desktopsharing/DesktopSharingEventTypes":184,"../../service/members/Events":185,"../../service/statistics/Events":186,"../../service/xmpp/XMPPEvents":188,"../RTC/RTCBrowserType":7,"./../settings/Settings":50,"./audio_levels/AudioLevels.js":11,"./authentication/Authentication":13,"./avatar/Avatar":15,"./etherpad/Etherpad.js":16,"./prezi/Prezi.js":17,"./side_pannels/SidePanelToggler":19,"./side_pannels/chat/Chat.js":20,"./side_pannels/contactlist/ContactList":24,"./side_pannels/settings/SettingsMenu":25,"./toolbars/BottomToolbar":26,"./toolbars/Toolbar":27,"./toolbars/ToolbarToggler":28,"./util/JitsiPopover":29,"./util/MessageHandler":30,"./util/NicknameHandler":31,"./util/UIUtil":32,"./videolayout/VideoLayout.js":38,"./welcome_page/RoomnameGenerator":39,"./welcome_page/WelcomePage":40,"events":79}],11:[function(require,module,exports){
    /* global APP, interfaceConfig, $, Strophe */
    /* jshint -W101 */
    var CanvasUtil = require("./CanvasUtils");
    
    var ASDrawContext = null;
    
    function initActiveSpeakerAudioLevels() {
        var ASRadius = interfaceConfig.ACTIVE_SPEAKER_AVATAR_SIZE / 2;
        var ASCenter = (interfaceConfig.ACTIVE_SPEAKER_AVATAR_SIZE + ASRadius) / 2;
        
        // Draw a circle.
        ASDrawContext.arc(ASCenter, ASCenter, ASRadius, 0, 2 * Math.PI);
        
        // Add a shadow around the circle
        ASDrawContext.shadowColor = interfaceConfig.SHADOW_COLOR;
        ASDrawContext.shadowOffsetX = 0;
        ASDrawContext.shadowOffsetY = 0;
    }
    
    /**
     * The audio Levels plugin.
     */
    var AudioLevels = (function(my) {
        var audioLevelCanvasCache = {};
        
        my.LOCAL_LEVEL = 'local';
        
        my.init = function () {
            ASDrawContext = $('#activeSpeakerAudioLevel')[0].getContext('2d');
            initActiveSpeakerAudioLevels();
        };
        
        /**
         * Updates the audio level canvas for the given peerJid. If the canvas
         * didn't exist we create it.
         */
        my.updateAudioLevelCanvas = function (peerJid, VideoLayout) {
            var resourceJid = null;
            var videoSpanId = null;
            if (!peerJid)
                videoSpanId = 'localVideoContainer';
            else {
                resourceJid = Strophe.getResourceFromJid(peerJid);
                
                videoSpanId = 'participant_' + resourceJid;
            }
            
            var videoSpan = document.getElementById(videoSpanId);
            
            if (!videoSpan) {
                if (resourceJid)
                    console.error("No video element for jid", resourceJid);
                else
                    console.error("No video element for local video.");
                
                return;
            }
            
            var audioLevelCanvas = $('#' + videoSpanId + '>canvas');
            
            var videoSpaceWidth = $('#remoteVideos').width();
            var thumbnailSize = VideoLayout.calculateThumbnailSize(videoSpaceWidth);
            var thumbnailWidth = thumbnailSize[0];
            var thumbnailHeight = thumbnailSize[1];
            
            if (!audioLevelCanvas || audioLevelCanvas.length === 0) {
                
                audioLevelCanvas = document.createElement('canvas');
                audioLevelCanvas.className = "audiolevel";
                audioLevelCanvas.style.bottom = "-" + interfaceConfig.CANVAS_EXTRA/2 + "px";
                audioLevelCanvas.style.left = "-" + interfaceConfig.CANVAS_EXTRA/2 + "px";
                resizeAudioLevelCanvas( audioLevelCanvas,
                    thumbnailWidth,
                    thumbnailHeight);
                
                videoSpan.appendChild(audioLevelCanvas);
            } else {
                audioLevelCanvas = audioLevelCanvas.get(0);
                
                resizeAudioLevelCanvas( audioLevelCanvas,
                    thumbnailWidth,
                    thumbnailHeight);
            }
        };
        
        /**
         * Updates the audio level UI for the given resourceJid.
         *
         * @param resourceJid the resource jid indicating the video element for
         * which we draw the audio level
         * @param audioLevel the newAudio level to render
         */
        my.updateAudioLevel = function (resourceJid, audioLevel, largeVideoResourceJid) {
            drawAudioLevelCanvas(resourceJid, audioLevel);
            
            var videoSpanId = getVideoSpanId(resourceJid);
            
            var audioLevelCanvas = $('#' + videoSpanId + '>canvas').get(0);
            
            if (!audioLevelCanvas)
                return;
            
            var drawContext = audioLevelCanvas.getContext('2d');
            
            var canvasCache = audioLevelCanvasCache[resourceJid];
            
            drawContext.clearRect (0, 0,
                audioLevelCanvas.width, audioLevelCanvas.height);
            drawContext.drawImage(canvasCache, 0, 0);
            
            if(resourceJid === AudioLevels.LOCAL_LEVEL) {
                if(!APP.xmpp.myJid()) {
                    return;
                }
                resourceJid = APP.xmpp.myResource();
            }
            
            if(resourceJid === largeVideoResourceJid) {
                window.requestAnimationFrame(function () {
                    AudioLevels.updateActiveSpeakerAudioLevel(audioLevel);
                });
            }
        };
        
        my.updateActiveSpeakerAudioLevel = function(audioLevel) {
            if($("#activeSpeaker").css("visibility") == "hidden" || ASDrawContext === null)
                return;
            
            ASDrawContext.clearRect(0, 0, 300, 300);
            if (!audioLevel)
                return;
            
            ASDrawContext.shadowBlur = getShadowLevel(audioLevel);
            
            
            // Fill the shape.
            ASDrawContext.fill();
        };
        
        /**
         * Resizes the given audio level canvas to match the given thumbnail size.
         */
        function resizeAudioLevelCanvas(audioLevelCanvas,
                                        thumbnailWidth,
                                        thumbnailHeight) {
            audioLevelCanvas.width = thumbnailWidth + interfaceConfig.CANVAS_EXTRA;
            audioLevelCanvas.height = thumbnailHeight + interfaceConfig.CANVAS_EXTRA;
        }
        
        /**
         * Draws the audio level canvas into the cached canvas object.
         *
         * @param resourceJid the resource jid indicating the video element for
         * which we draw the audio level
         * @param audioLevel the newAudio level to render
         */
        function drawAudioLevelCanvas(resourceJid, audioLevel) {
            if (!audioLevelCanvasCache[resourceJid]) {
                
                var videoSpanId = getVideoSpanId(resourceJid);
                
                var audioLevelCanvasOrig = $('#' + videoSpanId + '>canvas').get(0);
                
                /*
                 * FIXME Testing has shown that audioLevelCanvasOrig may not exist.
                 * In such a case, the method CanvasUtil.cloneCanvas may throw an
                 * error. Since audio levels are frequently updated, the errors have
                 * been observed to pile into the console, strain the CPU.
                 */
                if (audioLevelCanvasOrig) {
                    audioLevelCanvasCache[resourceJid] =
                        CanvasUtil.cloneCanvas(audioLevelCanvasOrig);
                }
            }
            
            var canvas = audioLevelCanvasCache[resourceJid];
            
            if (!canvas)
                return;
            
            var drawContext = canvas.getContext('2d');
            
            drawContext.clearRect(0, 0, canvas.width, canvas.height);
            
            var shadowLevel = getShadowLevel(audioLevel);
            
            if (shadowLevel > 0) {
                // drawContext, x, y, w, h, r, shadowColor, shadowLevel
                CanvasUtil.drawRoundRectGlow(drawContext,
                    interfaceConfig.CANVAS_EXTRA / 2, interfaceConfig.CANVAS_EXTRA / 2,
                    canvas.width - interfaceConfig.CANVAS_EXTRA,
                    canvas.height - interfaceConfig.CANVAS_EXTRA,
                    interfaceConfig.CANVAS_RADIUS,
                    interfaceConfig.SHADOW_COLOR,
                    shadowLevel);
            }
        }
        
        /**
         * Returns the shadow/glow level for the given audio level.
         *
         * @param audioLevel the audio level from which we determine the shadow
         * level
         */
        function getShadowLevel (audioLevel) {
            var shadowLevel = 0;
            
            if (audioLevel <= 0.3) {
                shadowLevel = Math.round(interfaceConfig.CANVAS_EXTRA/2*(audioLevel/0.3));
            }
            else if (audioLevel <= 0.6) {
                shadowLevel = Math.round(interfaceConfig.CANVAS_EXTRA/2*((audioLevel - 0.3) / 0.3));
            }
            else {
                shadowLevel = Math.round(interfaceConfig.CANVAS_EXTRA/2*((audioLevel - 0.6) / 0.4));
            }
            return shadowLevel;
        }
        
        /**
         * Returns the video span id corresponding to the given resourceJid or local
         * user.
         */
        function getVideoSpanId(resourceJid) {
            var videoSpanId = null;
            if (resourceJid === AudioLevels.LOCAL_LEVEL ||
                (APP.xmpp.myResource() && resourceJid === APP.xmpp.myResource()))
                videoSpanId = 'localVideoContainer';
            else
                videoSpanId = 'participant_' + resourceJid;
            
            return videoSpanId;
        }
        
        /**
         * Indicates that the remote video has been resized.
         */
        $(document).bind('remotevideo.resized', function (event, width, height) {
            var resized = false;
            $('#remoteVideos>span>canvas').each(function() {
                var canvas = $(this).get(0);
                if (canvas.width !== width + interfaceConfig.CANVAS_EXTRA) {
                    canvas.width = width + interfaceConfig.CANVAS_EXTRA;
                    resized = true;
                }
                
                if (canvas.height !== height + interfaceConfig.CANVAS_EXTRA) {
                    canvas.height = height + interfaceConfig.CANVAS_EXTRA;
                    resized = true;
                }
            });
            
            if (resized)
                Object.keys(audioLevelCanvasCache).forEach(function (resourceJid) {
                    audioLevelCanvasCache[resourceJid].width =
                        width + interfaceConfig.CANVAS_EXTRA;
                    audioLevelCanvasCache[resourceJid].height =
                        height + interfaceConfig.CANVAS_EXTRA;
                });
        });
        
        return my;
        
    })(AudioLevels || {});
    
    module.exports = AudioLevels;
},{"./CanvasUtils":12}],12:[function(require,module,exports){
    /**
     * Utility class for drawing canvas shapes.
     */
    var CanvasUtil = (function(my) {
        
        /**
         * Draws a round rectangle with a glow. The glowWidth indicates the depth
         * of the glow.
         *
         * @param drawContext the context of the canvas to draw to
         * @param x the x coordinate of the round rectangle
         * @param y the y coordinate of the round rectangle
         * @param w the width of the round rectangle
         * @param h the height of the round rectangle
         * @param glowColor the color of the glow
         * @param glowWidth the width of the glow
         */
        my.drawRoundRectGlow
            = function(drawContext, x, y, w, h, r, glowColor, glowWidth) {
            
            // Save the previous state of the context.
            drawContext.save();
            
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            
            // Draw a round rectangle.
            drawContext.beginPath();
            drawContext.moveTo(x+r, y);
            drawContext.arcTo(x+w, y,   x+w, y+h, r);
            drawContext.arcTo(x+w, y+h, x,   y+h, r);
            drawContext.arcTo(x,   y+h, x,   y,   r);
            drawContext.arcTo(x,   y,   x+w, y,   r);
            drawContext.closePath();
            
            // Add a shadow around the rectangle
            drawContext.shadowColor = glowColor;
            drawContext.shadowBlur = glowWidth;
            drawContext.shadowOffsetX = 0;
            drawContext.shadowOffsetY = 0;
            
            // Fill the shape.
            drawContext.fill();
            
            drawContext.save();
            
            drawContext.restore();
            
            //      1) Uncomment this line to use Composite Operation, which is doing the
            //      same as the clip function below and is also antialiasing the round
            //      border, but is said to be less fast performance wise.
            
            //      drawContext.globalCompositeOperation='destination-out';
            
            drawContext.beginPath();
            drawContext.moveTo(x+r, y);
            drawContext.arcTo(x+w, y,   x+w, y+h, r);
            drawContext.arcTo(x+w, y+h, x,   y+h, r);
            drawContext.arcTo(x,   y+h, x,   y,   r);
            drawContext.arcTo(x,   y,   x+w, y,   r);
            drawContext.closePath();
            
            //      2) Uncomment this line to use Composite Operation, which is doing the
            //      same as the clip function below and is also antialiasing the round
            //      border, but is said to be less fast performance wise.
            
            //      drawContext.fill();
            
            // Comment these two lines if choosing to do the same with composite
            // operation above 1 and 2.
            drawContext.clip();
            drawContext.clearRect(0, 0, 277, 200);
            
            // Restore the previous context state.
            drawContext.restore();
        };
        
        /**
         * Clones the given canvas.
         *
         * @return the new cloned canvas.
         */
        my.cloneCanvas = function (oldCanvas) {
            /*
             * FIXME Testing has shown that oldCanvas may not exist. In such a case,
             * the method CanvasUtil.cloneCanvas may throw an error. Since audio
             * levels are frequently updated, the errors have been observed to pile
             * into the console, strain the CPU.
             */
            if (!oldCanvas)
                return oldCanvas;
            
            //create a new canvas
            var newCanvas = document.createElement('canvas');
            var context = newCanvas.getContext('2d');
            
            //set dimensions
            newCanvas.width = oldCanvas.width;
            newCanvas.height = oldCanvas.height;
            
            //apply the old canvas to the new one
            context.drawImage(oldCanvas, 0, 0);
            
            //return the new canvas
            return newCanvas;
        };
        
        return my;
    })(CanvasUtil || {});
    
    module.exports = CanvasUtil;
},{}],13:[function(require,module,exports){
    /* global $, APP*/
    
    var LoginDialog = require('./LoginDialog');
    var Moderator = require('../../xmpp/moderator');
    
    /* Initial "authentication required" dialog */
    var authDialog = null;
    /* Loop retry ID that wits for other user to create the room */
    var authRetryId = null;
    var authenticationWindow = null;
    
    var Authentication = {
        openAuthenticationDialog: function (roomName, intervalCallback, callback) {
            // This is the loop that will wait for the room to be created by
            // someone else. 'auth_required.moderator' will bring us back here.
            authRetryId = window.setTimeout(intervalCallback, 5000);
            // Show prompt only if it's not open
            if (authDialog !== null) {
                return;
            }
            // extract room name from 'room@muc.server.net'
            var room = roomName.substr(0, roomName.indexOf('@'));
            
            var title
                = APP.translation.generateTranslationHTML("dialog.WaitingForHost");
            var msg
                = APP.translation.generateTranslationHTML(
                "dialog.WaitForHostMsg", {room: room});
            
            var buttonTxt
                = APP.translation.generateTranslationHTML("dialog.IamHost");
            var buttons = [];
            buttons.push({title: buttonTxt, value: "authNow"});
            
            authDialog = APP.UI.messageHandler.openDialog(
                title,
                msg,
                true,
                buttons,
                function (onSubmitEvent, submitValue) {
                    
                    // Do not close the dialog yet
                    onSubmitEvent.preventDefault();
                    
                    // Open login popup
                    if (submitValue === 'authNow') {
                        callback();
                    }
                }
            );
        },
        closeAuthenticationWindow: function () {
            if (authenticationWindow) {
                authenticationWindow.close();
                authenticationWindow = null;
            }
        },
        xmppAuthenticate: function () {
            
            var loginDialog = LoginDialog.show(
                function (connection, state) {
                    if (!state) {
                        // User cancelled
                        loginDialog.close();
                        return;
                    } else if (state == APP.xmpp.Status.CONNECTED) {
                        
                        loginDialog.close();
                        
                        Authentication.stopInterval();
                        Authentication.closeAuthenticationDialog();
                        
                        // Close the connection as anonymous one will be used
                        // to create the conference. Session-id will authorize
                        // the request.
                        connection.disconnect();
                        
                        var roomName = APP.UI.generateRoomName();
                        Moderator.allocateConferenceFocus(roomName, function () {
                            // If it's not "on the fly" authentication now join
                            // the conference room
                            if (!APP.xmpp.isMUCJoined()) {
                                APP.UI.checkForNicknameAndJoin();
                            }
                        });
                    }
                }, true);
        },
        focusAuthenticationWindow: function () {
            // If auth window exists just bring it to the front
            if (authenticationWindow) {
                authenticationWindow.focus();
                return;
            }
        },
        closeAuthenticationDialog: function () {
            // Close authentication dialog if opened
            if (authDialog) {
                authDialog.close();
                authDialog = null;
            }
        },
        createAuthenticationWindow: function (callback, url) {
            authenticationWindow = APP.UI.messageHandler.openCenteredPopup(
                url, 910, 660,
                // On closed
                function () {
                    // Close authentication dialog if opened
                    Authentication.closeAuthenticationDialog();
                    callback();
                    authenticationWindow = null;
                });
            return authenticationWindow;
        },
        stopInterval: function () {
            // Clear retry interval, so that we don't call 'doJoinAfterFocus' twice
            if (authRetryId) {
                window.clearTimeout(authRetryId);
                authRetryId = null;
            }
        }
    };
    
    module.exports = Authentication;
},{"../../xmpp/moderator":65,"./LoginDialog":14}],14:[function(require,module,exports){
    /* global $, APP, config*/
    
    var XMPP = require('../../xmpp/xmpp');
    var Moderator = require('../../xmpp/moderator');
    
    //FIXME: use LoginDialog to add retries to XMPP.connect method used when
    // anonymous domain is not enabled
    
    /**
     * Creates new <tt>Dialog</tt> instance.
     * @param callback <tt>function(Strophe.Connection, Strophe.Status)</tt> called
     *        when we either fail to connect or succeed(check Strophe.Status).
     * @param obtainSession <tt>true</tt> if we want to send ConferenceIQ to Jicofo
     *        in order to create session-id after the connection is established.
     * @constructor
     */
    function Dialog(callback, obtainSession) {
        
        var self = this;
        
        var stop = false;
        
        var connection = APP.xmpp.createConnection();
        
        var message = '<h2 data-i18n="dialog.passwordRequired">';
        message += APP.translation.translateString("dialog.passwordRequired");
        message += '</h2>' +
            '<input name="username" type="text" ';
        if (config.hosts.authdomain) {
            message += 'placeholder="user identity" autofocus>';
        } else {
            message += 'placeholder="user@domain.net" autofocus>';
        }
        message += '<input name="password" ' +
            'type="password" data-i18n="[placeholder]dialog.userPassword"' +
            ' placeholder="user password">';
        
        var okButton = APP.translation.generateTranslationHTML("dialog.Ok");
        
        var cancelButton = APP.translation.generateTranslationHTML("dialog.Cancel");
        
        var states = {
            login: {
                html: message,
                buttons: [
                    { title: okButton, value: true},
                    { title: cancelButton, value: false}
                ],
                focus: ':input:first',
                submit: function (e, v, m, f) {
                    e.preventDefault();
                    if (v) {
                        var jid = f.username;
                        var password = f.password;
                        if (jid && password) {
                            stop = false;
                            if (jid.indexOf("@") < 0) {
                                jid = jid.concat('@');
                                if (config.hosts.authdomain) {
                                    jid += config.hosts.authdomain;
                                } else {
                                    jid += config.hosts.domain;
                                }
                            }
                            connection.reset();
                            connDialog.goToState('connecting');
                            connection.connect(jid, password, stateHandler);
                        }
                    } else {
                        // User cancelled
                        stop = true;
                        callback();
                    }
                }
            },
            connecting: {
                title: APP.translation.translateString('dialog.connecting'),
                html:   '<div id="connectionStatus"></div>',
                buttons: [],
                defaultButton: 0
            },
            finished: {
                title: APP.translation.translateString('dialog.error'),
                html:   '<div id="errorMessage"></div>',
                buttons: [
                    {
                        title: APP.translation.translateString('dialog.retry'),
                        value: 'retry'
                    },
                    {
                        title: APP.translation.translateString('dialog.Cancel'),
                        value: 'cancel'
                    },
                ],
                defaultButton: 0,
                submit: function (e, v, m, f) {
                    e.preventDefault();
                    if (v === 'retry')
                        connDialog.goToState('login');
                    else
                        callback();
                }
            }
        };
        
        var connDialog
            = APP.UI.messageHandler.openDialogWithStates(states,
            { persistent: true, closeText: '' }, null);
        
        var stateHandler = function (status, message) {
            if (stop) {
                return;
            }
            
            var translateKey = "connection." + XMPP.getStatusString(status);
            var statusStr = APP.translation.translateString(translateKey);
            
            // Display current state
            var connectionStatus =
                connDialog.getState('connecting').find('#connectionStatus');
            
            connectionStatus.text(statusStr);
            
            switch (status) {
                case XMPP.Status.CONNECTED:
                    
                    stop = true;
                    if (!obtainSession) {
                        callback(connection, status);
                        return;
                    }
                    // Obtaining session-id status
                    connectionStatus.text(
                        APP.translation.translateString(
                            'connection.FETCH_SESSION_ID'));
                    
                    // Authenticate with Jicofo and obtain session-id
                    var roomName = APP.UI.generateRoomName();
                    
                    // Jicofo will return new session-id when connected
                    // from authenticated domain
                    connection.sendIQ(
                        Moderator.createConferenceIq(roomName),
                        function (result) {
                            
                            connectionStatus.text(
                                APP.translation.translateString(
                                    'connection.GOT_SESSION_ID'));
                            
                            stop = true;
                            
                            // Parse session-id
                            Moderator.parseSessionId(result);
                            
                            callback(connection, status);
                        },
                        function (error) {
                            console.error("Auth on the fly failed", error);
                            
                            stop = true;
                            
                            var errorMsg =
                                APP.translation.translateString(
                                    'connection.GET_SESSION_ID_ERROR') +
                                $(error).find('>error').attr('code');
                            
                            self.displayError(errorMsg);
                            
                            connection.disconnect();
                        });
                    
                    break;
                case XMPP.Status.AUTHFAIL:
                case XMPP.Status.CONNFAIL:
                case XMPP.Status.DISCONNECTED:
                    
                    stop = true;
                    
                    callback(connection, status);
                    
                    var errorMessage = statusStr;
                    
                    if (message)
                    {
                        errorMessage += ': ' + message;
                    }
                    self.displayError(errorMessage);
                    
                    break;
                default:
                    break;
            }
        };
        
        /**
         * Displays error message in 'finished' state which allows either to cancel
         * or retry.
         * @param message the final message to be displayed.
         */
        this.displayError = function (message) {
            
            var finishedState = connDialog.getState('finished');
            
            var errorMessageElem = finishedState.find('#errorMessage');
            errorMessageElem.text(message);
            
            connDialog.goToState('finished');
        };
        
        /**
         * Closes LoginDialog.
         */
        this.close = function () {
            stop = true;
            connDialog.close();
        };
    }
    
    var LoginDialog = {
        
        /**
         * Displays login prompt used to establish new XMPP connection. Given
         * <tt>callback(Strophe.Connection, Strophe.Status)</tt> function will be
         * called when we connect successfully(status === CONNECTED) or when we fail
         * to do so. On connection failure program can call Dialog.close() method in
         * order to cancel or do nothing to let the user retry.
         * @param callback <tt>function(Strophe.Connection, Strophe.Status)</tt>
         *        called when we either fail to connect or succeed(check
         *        Strophe.Status).
         * @param obtainSession <tt>true</tt> if we want to send ConferenceIQ to
         *        Jicofo in order to create session-id after the connection is
         *        established.
         * @returns {Dialog}
         */
        show: function (callback, obtainSession) {
            return new Dialog(callback, obtainSession);
        }
    };
    
    module.exports = LoginDialog;
    
},{"../../xmpp/moderator":65,"../../xmpp/xmpp":74}],15:[function(require,module,exports){
    /* global Strophe, APP, MD5 */
    var Settings = require("../../settings/Settings");
    
    var users = {};
    
    var Avatar = {
        
        /**
         * Sets the user's avatar in the settings menu(if local user), contact list
         * and thumbnail
         * @param jid jid of the user
         * @param id email or userID to be used as a hash
         */
        setUserAvatar: function (jid, id) {
            if (id) {
                if (users[jid] === id) {
                    return;
                }
                users[jid] = id;
            }
            var thumbUrl = this.getThumbUrl(jid);
            var contactListUrl = this.getContactListUrl(jid);
            var resourceJid = Strophe.getResourceFromJid(jid);
            
            APP.UI.userAvatarChanged(resourceJid, thumbUrl, contactListUrl);
        },
        /**
         * Returns image URL for the avatar to be displayed on large video area
         * where current active speaker is presented.
         * @param jid full MUC jid of the user for whom we want to obtain avatar URL
         */
        getActiveSpeakerUrl: function (jid) {
            return this.getGravatarUrl(jid, 100);
        },
        /**
         * Returns image URL for the avatar to be displayed on small video thumbnail
         * @param jid full MUC jid of the user for whom we want to obtain avatar URL
         */
        getThumbUrl: function (jid) {
            return this.getGravatarUrl(jid, 100);
        },
        /**
         * Returns the URL for the avatar to be displayed as contactlist item
         * @param jid full MUC jid of the user for whom we want to obtain avatar URL
         */
        getContactListUrl: function (jid) {
            return this.getGravatarUrl(jid, 30);
        },
        getGravatarUrl: function (jid, size) {
            if (!jid) {
                console.error("Get gravatar - jid is undefined");
                return null;
            }
            var id = users[jid];
            if (!id) {
                console.warn(
                    "No avatar stored yet for " + jid + " - using JID as ID");
                id = jid;
            }
            return 'https://www.gravatar.com/avatar/' +
                MD5.hexdigest(id.trim().toLowerCase()) +
                "?d=wavatar&size=" + (size || "30");
        }
        
    };
    
    
    module.exports = Avatar;
},{"../../settings/Settings":50}],16:[function(require,module,exports){
    /* global $, config,
     setLargeVideoVisible, Util */
    
    var VideoLayout = require("../videolayout/VideoLayout");
    var Prezi = require("../prezi/Prezi");
    var UIUtil = require("../util/UIUtil");
    
    var etherpadName = null;
    var etherpadIFrame = null;
    var domain = null;
    var options = "?showControls=true&showChat=false&showLineNumbers=true" +
        "&useMonospaceFont=false";
    
    
    /**
     * Resizes the etherpad.
     */
    function resize() {
        if ($('#etherpad>iframe').length) {
            var remoteVideos = $('#remoteVideos');
            var availableHeight
                = window.innerHeight - remoteVideos.outerHeight();
            var availableWidth = UIUtil.getAvailableVideoWidth();
            
            $('#etherpad>iframe').width(availableWidth);
            $('#etherpad>iframe').height(availableHeight);
        }
    }
    
    /**
     * Creates the Etherpad button and adds it to the toolbar.
     */
    function enableEtherpadButton() {
        if (!$('#toolbar_button_etherpad').is(":visible"))
            $('#toolbar_button_etherpad').css({display: 'inline-block'});
    }
    
    /**
     * Creates the IFrame for the etherpad.
     */
    function createIFrame() {
        etherpadIFrame = VideoLayout.createEtherpadIframe(
            domain + etherpadName + options, function() {
                
                document.domain = document.domain;
                bubbleIframeMouseMove(etherpadIFrame);
                setTimeout(function() {
                    // the iframes inside of the etherpad are
                    // not yet loaded when the etherpad iframe is loaded
                    var outer = etherpadIFrame.
                        contentDocument.getElementsByName("ace_outer")[0];
                    bubbleIframeMouseMove(outer);
                    var inner = outer.
                        contentDocument.getElementsByName("ace_inner")[0];
                    bubbleIframeMouseMove(inner);
                }, 2000);
            });
    }
    
    function bubbleIframeMouseMove(iframe){
        var existingOnMouseMove = iframe.contentWindow.onmousemove;
        iframe.contentWindow.onmousemove = function(e){
            if(existingOnMouseMove) existingOnMouseMove(e);
            var evt = document.createEvent("MouseEvents");
            var boundingClientRect = iframe.getBoundingClientRect();
            evt.initMouseEvent(
                "mousemove",
                true, // bubbles
                false, // not cancelable
                window,
                e.detail,
                e.screenX,
                e.screenY,
                e.clientX + boundingClientRect.left,
                e.clientY + boundingClientRect.top,
                e.ctrlKey,
                e.altKey,
                e.shiftKey,
                e.metaKey,
                e.button,
                null // no related element
            );
            iframe.dispatchEvent(evt);
        };
    }
    
    
    var Etherpad = {
        /**
         * Initializes the etherpad.
         */
        init: function (name) {
            
            if (config.etherpad_base && !etherpadName && name) {
                
                domain = config.etherpad_base;
                
                etherpadName = name;
                
                enableEtherpadButton();
                
                /**
                 * Resizes the etherpad, when the window is resized.
                 */
                $(window).resize(function () {
                    resize();
                });
            }
        },
        
        /**
         * Opens/hides the Etherpad.
         */
        toggleEtherpad: function (isPresentation) {
            if (!etherpadIFrame)
                createIFrame();
            
            
            if(VideoLayout.getLargeVideoState() === "etherpad")
            {
                VideoLayout.setLargeVideoState("video");
            }
            else
            {
                VideoLayout.setLargeVideoState("etherpad");
            }
            resize();
        }
    };
    
    module.exports = Etherpad;
    
},{"../prezi/Prezi":17,"../util/UIUtil":32,"../videolayout/VideoLayout":38}],17:[function(require,module,exports){
    var ToolbarToggler = require("../toolbars/ToolbarToggler");
    var UIUtil = require("../util/UIUtil");
    var VideoLayout = require("../videolayout/VideoLayout");
    var messageHandler = require("../util/MessageHandler");
    var PreziPlayer = require("./PreziPlayer");
    
    var preziPlayer = null;
    
    
    /**
     * Shows/hides a presentation.
     */
    function setPresentationVisible(visible) {
        
        if (visible) {
            VideoLayout.setLargeVideoState("prezi");
        }
        else {
            VideoLayout.setLargeVideoState("video");
        }
    }
    
    var Prezi = {
        
        
        /**
         * Reloads the current presentation.
         */
        reloadPresentation: function() {
            var iframe = document.getElementById(preziPlayer.options.preziId);
            iframe.src = iframe.src;
        },
        
        /**
         * Returns <tt>true</tt> if the presentation is visible, <tt>false</tt> -
         * otherwise.
         */
        isPresentationVisible: function () {
            return ($('#presentation>iframe') != null
            && $('#presentation>iframe').css('opacity') == 1);
        },
        
        /**
         * Opens the Prezi dialog, from which the user could choose a presentation
         * to load.
         */
        openPreziDialog: function() {
            var myprezi = APP.xmpp.getPrezi();
            if (myprezi) {
                messageHandler.openTwoButtonDialog("dialog.removePreziTitle",
                    null,
                    "dialog.removePreziMsg",
                    null,
                    false,
                    "dialog.Remove",
                    function(e,v,m,f) {
                        if(v) {
                            APP.xmpp.removePreziFromPresence();
                        }
                    }
                );
            }
            else if (preziPlayer != null) {
                messageHandler.openTwoButtonDialog("dialog.sharePreziTitle",
                    null, "dialog.sharePreziMsg",
                    null,
                    false,
                    "dialog.Ok",
                    function(e,v,m,f) {
                        $.prompt.close();
                    }
                );
            }
            else {
                var html = APP.translation.generateTranslationHTML(
                    "dialog.sharePreziTitle");
                var cancelButton = APP.translation.generateTranslationHTML(
                    "dialog.Cancel");
                var shareButton = APP.translation.generateTranslationHTML(
                    "dialog.Share");
                var backButton = APP.translation.generateTranslationHTML(
                    "dialog.Back");
                var buttons = [];
                var buttons1 = [];
                // Cancel button to both states
                buttons.push({title: cancelButton, value: false});
                buttons1.push({title: cancelButton, value: false});
                // Share button
                buttons.push({title: shareButton, value: true});
                // Back button
                buttons1.push({title: backButton, value: true});
                var linkError = APP.translation.generateTranslationHTML(
                    "dialog.preziLinkError");
                var defaultUrl = APP.translation.translateString("defaultPreziLink",
                    {url: "http://prezi.com/wz7vhjycl7e6/my-prezi"});
                var openPreziState = {
                    state0: {
                        html:   '<h2>' + html + '</h2>' +
                        '<input name="preziUrl" type="text" ' +
                        'data-i18n="[placeholder]defaultPreziLink" data-i18n-options=\'' +
                        JSON.stringify({"url": "http://prezi.com/wz7vhjycl7e6/my-prezi"}) +
                        '\' placeholder="' + defaultUrl + '" autofocus>',
                        persistent: false,
                        buttons: buttons,
                        focus: ':input:first',
                        defaultButton: 0,
                        submit: function (e, v, m, f) {
                            e.preventDefault();
                            if(v)
                            {
                                var preziUrl = f.preziUrl;
                                
                                if (preziUrl)
                                {
                                    var urlValue
                                        = encodeURI(UIUtil.escapeHtml(preziUrl));
                                    
                                    if (urlValue.indexOf('http://prezi.com/') != 0
                                        && urlValue.indexOf('https://prezi.com/') != 0)
                                    {
                                        $.prompt.goToState('state1');
                                        return false;
                                    }
                                    else {
                                        var presIdTmp = urlValue.substring(
                                            urlValue.indexOf("prezi.com/") + 10);
                                        if (!isAlphanumeric(presIdTmp)
                                            || presIdTmp.indexOf('/') < 2) {
                                            $.prompt.goToState('state1');
                                            return false;
                                        }
                                        else {
                                            APP.xmpp.addToPresence("prezi", urlValue);
                                            $.prompt.close();
                                        }
                                    }
                                }
                            }
                            else
                                $.prompt.close();
                        }
                    },
                    state1: {
                        html:   '<h2>' + html + '</h2>' +
                        linkError,
                        persistent: false,
                        buttons: buttons1,
                        focus: ':input:first',
                        defaultButton: 1,
                        submit: function (e, v, m, f) {
                            e.preventDefault();
                            if (v === 0)
                                $.prompt.close();
                            else
                                $.prompt.goToState('state0');
                        }
                    }
                };
                messageHandler.openDialogWithStates(openPreziState);
            }
        }
        
    };
    
    /**
     * A new presentation has been added.
     *
     * @param event the event indicating the add of a presentation
     * @param jid the jid from which the presentation was added
     * @param presUrl url of the presentation
     * @param currentSlide the current slide to which we should move
     */
    function presentationAdded(event, jid, presUrl, currentSlide) {
        console.log("presentation added", presUrl);
        
        var presId = getPresentationId(presUrl);
        
        var elementId = 'participant_'
            + Strophe.getResourceFromJid(jid)
            + '_' + presId;
        
        VideoLayout.addPreziContainer(elementId);
        
        var controlsEnabled = false;
        if (jid === APP.xmpp.myJid())
            controlsEnabled = true;
        
        setPresentationVisible(true);
        VideoLayout.setLargeVideoHover(
            function (event) {
                if (Prezi.isPresentationVisible()) {
                    var reloadButtonRight = window.innerWidth
                        - $('#presentation>iframe').offset().left
                        - $('#presentation>iframe').width();
                    
                    $('#reloadPresentation').css({  right: reloadButtonRight,
                        display:'inline-block'});
                }
            },
            function (event) {
                if (!Prezi.isPresentationVisible())
                    $('#reloadPresentation').css({display:'none'});
                else {
                    var e = event.toElement || event.relatedTarget;
                    
                    if (e && e.id != 'reloadPresentation' && e.id != 'header')
                        $('#reloadPresentation').css({display:'none'});
                }
            });
        
        preziPlayer = new PreziPlayer(
            'presentation',
            {preziId: presId,
                width: getPresentationWidth(),
                height: getPresentationHeihgt(),
                controls: controlsEnabled,
                debug: true
            });
        
        $('#presentation>iframe').attr('id', preziPlayer.options.preziId);
        
        preziPlayer.on(PreziPlayer.EVENT_STATUS, function(event) {
            console.log("prezi status", event.value);
            if (event.value == PreziPlayer.STATUS_CONTENT_READY) {
                if (jid != APP.xmpp.myJid())
                    preziPlayer.flyToStep(currentSlide);
            }
        });
        
        preziPlayer.on(PreziPlayer.EVENT_CURRENT_STEP, function(event) {
            console.log("event value", event.value);
            APP.xmpp.addToPresence("preziSlide", event.value);
        });
        
        $("#" + elementId).css( 'background-image',
            'url(../images/avatarprezi.png)');
        $("#" + elementId).click(
            function () {
                setPresentationVisible(true);
            }
        );
    };
    
    /**
     * A presentation has been removed.
     *
     * @param event the event indicating the remove of a presentation
     * @param jid the jid for which the presentation was removed
     * @param the url of the presentation
     */
    function presentationRemoved(event, jid, presUrl) {
        console.log('presentation removed', presUrl);
        var presId = getPresentationId(presUrl);
        setPresentationVisible(false);
        $('#participant_'
            + Strophe.getResourceFromJid(jid)
            + '_' + presId).remove();
        $('#presentation>iframe').remove();
        if (preziPlayer != null) {
            preziPlayer.destroy();
            preziPlayer = null;
        }
    };
    
    /**
     * Indicates if the given string is an alphanumeric string.
     * Note that some special characters are also allowed (-, _ , /, &, ?, =, ;) for the
     * purpose of checking URIs.
     */
    function isAlphanumeric(unsafeText) {
        var regex = /^[a-z0-9-_\/&\?=;]+$/i;
        return regex.test(unsafeText);
    }
    
    /**
     * Returns the presentation id from the given url.
     */
    function getPresentationId (presUrl) {
        var presIdTmp = presUrl.substring(presUrl.indexOf("prezi.com/") + 10);
        return presIdTmp.substring(0, presIdTmp.indexOf('/'));
    }
    
    /**
     * Returns the presentation width.
     */
    function getPresentationWidth() {
        var availableWidth = UIUtil.getAvailableVideoWidth();
        var availableHeight = getPresentationHeihgt();
        
        var aspectRatio = 16.0 / 9.0;
        if (availableHeight < availableWidth / aspectRatio) {
            availableWidth = Math.floor(availableHeight * aspectRatio);
        }
        return availableWidth;
    }
    
    /**
     * Returns the presentation height.
     */
    function getPresentationHeihgt() {
        var remoteVideos = $('#remoteVideos');
        return window.innerHeight - remoteVideos.outerHeight();
    }
    
    /**
     * Resizes the presentation iframe.
     */
    function resize() {
        if ($('#presentation>iframe')) {
            $('#presentation>iframe').width(getPresentationWidth());
            $('#presentation>iframe').height(getPresentationHeihgt());
        }
    }
    
    /**
     * Presentation has been removed.
     */
    $(document).bind('presentationremoved.muc', presentationRemoved);
    
    /**
     * Presentation has been added.
     */
    $(document).bind('presentationadded.muc', presentationAdded);
    
    /*
     * Indicates presentation slide change.
     */
    $(document).bind('gotoslide.muc', function (event, jid, presUrl, current) {
        if (preziPlayer && preziPlayer.getCurrentStep() != current) {
            preziPlayer.flyToStep(current);
            
            var animationStepsArray = preziPlayer.getAnimationCountOnSteps();
            for (var i = 0; i < parseInt(animationStepsArray[current]); i++) {
                preziPlayer.flyToStep(current, i);
            }
        }
    });
    
    $(window).resize(function () {
        resize();
    });
    
    module.exports = Prezi;
    
},{"../toolbars/ToolbarToggler":28,"../util/MessageHandler":30,"../util/UIUtil":32,"../videolayout/VideoLayout":38,"./PreziPlayer":18}],18:[function(require,module,exports){
    /* global PreziPlayer */
    /* jshint -W101 */
    (function() {
        "use strict";
        var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
        
        window.PreziPlayer = (function() {
            
            PreziPlayer.API_VERSION = 1;
            PreziPlayer.CURRENT_STEP = 'currentStep';
            PreziPlayer.CURRENT_ANIMATION_STEP = 'currentAnimationStep';
            PreziPlayer.CURRENT_OBJECT = 'currentObject';
            PreziPlayer.STATUS_LOADING = 'loading';
            PreziPlayer.STATUS_READY = 'ready';
            PreziPlayer.STATUS_CONTENT_READY = 'contentready';
            PreziPlayer.EVENT_CURRENT_STEP = "currentStepChange";
            PreziPlayer.EVENT_CURRENT_ANIMATION_STEP = "currentAnimationStepChange";
            PreziPlayer.EVENT_CURRENT_OBJECT = "currentObjectChange";
            PreziPlayer.EVENT_STATUS = "statusChange";
            PreziPlayer.EVENT_PLAYING = "isAutoPlayingChange";
            PreziPlayer.EVENT_IS_MOVING = "isMovingChange";
            PreziPlayer.domain = "https://prezi.com";
            PreziPlayer.path = "/player/";
            PreziPlayer.players = {};
            PreziPlayer.binded_methods = ['changesHandler'];
            
            PreziPlayer.createMultiplePlayers = function(optionArray){
                for(var i=0; i<optionArray.length; i++) {
                    var optionSet = optionArray[i];
                    new PreziPlayer(optionSet.id, optionSet);
                }
            };
            
            PreziPlayer.messageReceived = function(event){
                var message, item, player;
                try {
                    message = JSON.parse(event.data);
                    if (message.id && (player = PreziPlayer.players[message.id])) {
                        if (player.options.debug === true) {
                            if (console && console.log)
                                console.log('received', message);
                        }
                        if (message.type === "changes") {
                            player.changesHandler(message);
                        }
                        for (var i = 0; i < player.callbacks.length; i++) {
                            item = player.callbacks[i];
                            if (item && message.type === item.event) {
                                item.callback(message);
                            }
                        }
                    }
                } catch (e) { }
            };
            
            /*jshint -W004 */
            function PreziPlayer(id, options) {
                /*jshint +W004 */
                var params, paramString = "", _this = this;
                if (PreziPlayer.players[id]){
                    PreziPlayer.players[id].destroy();
                }
                for(var i=0; i<PreziPlayer.binded_methods.length; i++) {
                    var method_name = PreziPlayer.binded_methods[i];
                    _this[method_name] = __bind(_this[method_name], _this);
                }
                options = options || {};
                this.options = options;
                this.values = {'status': PreziPlayer.STATUS_LOADING};
                this.values[PreziPlayer.CURRENT_STEP] = 0;
                this.values[PreziPlayer.CURRENT_ANIMATION_STEP] = 0;
                this.values[PreziPlayer.CURRENT_OBJECT] = null;
                this.callbacks = [];
                this.id = id;
                this.embedTo = document.getElementById(id);
                if (!this.embedTo) {
                    throw "The element id is not available.";
                }
                this.iframe = document.createElement('iframe');
                params = [
                    { name: 'oid', value: options.preziId },
                    { name: 'explorable', value: options.explorable ? 1 : 0 },
                    { name: 'controls', value: options.controls ? 1 : 0 }
                ];
                for (i=0; i<params.length; i++) {
                    var param = params[i];
                    paramString += (i===0 ? "?" : "&") + param.name + "=" + param.value;
                }
                this.iframe.src = PreziPlayer.domain + PreziPlayer.path + paramString;
                this.iframe.frameBorder = 0;
                this.iframe.scrolling = "no";
                this.iframe.width = options.width || 640;
                this.iframe.height = options.height || 480;
                this.embedTo.innerHTML = '';
                // JITSI: IN CASE SOMETHING GOES WRONG.
                try {
                    this.embedTo.appendChild(this.iframe);
                }
                catch (err) {
                    console.log("CATCH ERROR");
                }
                
                // JITSI: Increase interval from 200 to 500, which fixes prezi
                // crashes for us.
                this.initPollInterval = setInterval(function(){
                    _this.sendMessage({'action': 'init'});
                }, 500);
                PreziPlayer.players[id] = this;
            }
            
            PreziPlayer.prototype.changesHandler = function(message) {
                var key, value, j, item;
                if (this.initPollInterval) {
                    clearInterval(this.initPollInterval);
                    this.initPollInterval = false;
                }
                for (key in message.data) {
                    if (message.data.hasOwnProperty(key)){
                        value = message.data[key];
                        this.values[key] = value;
                        for (j=0; j<this.callbacks.length; j++) {
                            item = this.callbacks[j];
                            if (item && item.event === key + "Change"){
                                item.callback({type: item.event, value: value});
                            }
                        }
                    }
                }
            };
            
            PreziPlayer.prototype.destroy = function() {
                if (this.initPollInterval) {
                    clearInterval(this.initPollInterval);
                    this.initPollInterval = false;
                }
                this.embedTo.innerHTML = '';
            };
            
            PreziPlayer.prototype.sendMessage = function(message) {
                if (this.options.debug === true) {
                    if (console && console.log) console.log('sent', message);
                }
                message.version = PreziPlayer.API_VERSION;
                message.id = this.id;
                return this.iframe.contentWindow.postMessage(JSON.stringify(message), '*');
            };
            
            PreziPlayer.prototype.nextStep = /* nextStep is DEPRECATED */
                PreziPlayer.prototype.flyToNextStep = function() {
                    return this.sendMessage({
                        'action': 'present',
                        'data': ['moveToNextStep']
                    });
                };
            
            PreziPlayer.prototype.previousStep = /* previousStep is DEPRECATED */
                PreziPlayer.prototype.flyToPreviousStep = function() {
                    return this.sendMessage({
                        'action': 'present',
                        'data': ['moveToPrevStep']
                    });
                };
            
            PreziPlayer.prototype.toStep = /* toStep is DEPRECATED */
                PreziPlayer.prototype.flyToStep = function(step, animation_step) {
                    var obj = this;
                    // check animation_step
                    if (animation_step > 0 &&
                        obj.values.animationCountOnSteps &&
                        obj.values.animationCountOnSteps[step] <= animation_step) {
                        animation_step = obj.values.animationCountOnSteps[step];
                    }
                    // jump to animation steps by calling flyToNextStep()
                    function doAnimationSteps() {
                        if (obj.values.isMoving) {
                            setTimeout(doAnimationSteps, 100); // wait until the flight ends
                            return;
                        }
                        while (animation_step-- > 0) {
                            obj.flyToNextStep(); // do the animation steps
                        }
                    }
                    setTimeout(doAnimationSteps, 200); // 200ms is the internal "reporting" time
                    // jump to the step
                    return this.sendMessage({
                        'action': 'present',
                        'data': ['moveToStep', step]
                    });
                };
            
            PreziPlayer.prototype.toObject = /* toObject is DEPRECATED */
                PreziPlayer.prototype.flyToObject = function(objectId) {
                    return this.sendMessage({
                        'action': 'present',
                        'data': ['moveToObject', objectId]
                    });
                };
            
            PreziPlayer.prototype.play = function(defaultDelay) {
                return this.sendMessage({
                    'action': 'present',
                    'data': ['startAutoPlay', defaultDelay]
                });
            };
            
            PreziPlayer.prototype.stop = function() {
                return this.sendMessage({
                    'action': 'present',
                    'data': ['stopAutoPlay']
                });
            };
            
            PreziPlayer.prototype.pause = function(defaultDelay) {
                return this.sendMessage({
                    'action': 'present',
                    'data': ['pauseAutoPlay', defaultDelay]
                });
            };
            
            PreziPlayer.prototype.getCurrentStep = function() {
                return this.values.currentStep;
            };
            
            PreziPlayer.prototype.getCurrentAnimationStep = function() {
                return this.values.currentAnimationStep;
            };
            
            PreziPlayer.prototype.getCurrentObject = function() {
                return this.values.currentObject;
            };
            
            PreziPlayer.prototype.getStatus = function() {
                return this.values.status;
            };
            
            PreziPlayer.prototype.isPlaying = function() {
                return this.values.isAutoPlaying;
            };
            
            PreziPlayer.prototype.getStepCount = function() {
                return this.values.stepCount;
            };
            
            PreziPlayer.prototype.getAnimationCountOnSteps = function() {
                return this.values.animationCountOnSteps;
            };
            
            PreziPlayer.prototype.getTitle = function() {
                return this.values.title;
            };
            
            PreziPlayer.prototype.setDimensions = function(dims) {
                for (var parameter in dims) {
                    this.iframe[parameter] = dims[parameter];
                }
            };
            
            PreziPlayer.prototype.getDimensions = function() {
                return {
                    width: parseInt(this.iframe.width, 10),
                    height: parseInt(this.iframe.height, 10)
                };
            };
            
            PreziPlayer.prototype.on = function(event, callback) {
                this.callbacks.push({
                    event: event,
                    callback: callback
                });
            };
            
            PreziPlayer.prototype.off = function(event, callback) {
                var j, item;
                if (event === undefined) {
                    this.callbacks = [];
                }
                j = this.callbacks.length;
                while (j--) {
                    item = this.callbacks[j];
                    if (item && item.event === event && (callback === undefined || item.callback === callback)){
                        this.callbacks.splice(j, 1);
                    }
                }
            };
            
            if (window.addEventListener) {
                window.addEventListener('message', PreziPlayer.messageReceived, false);
            } else {
                window.attachEvent('onmessage', PreziPlayer.messageReceived);
            }
            
            return PreziPlayer;
            
        })();
        
    })();
    
    module.exports = PreziPlayer;
    
},{}],19:[function(require,module,exports){
    /* global require, $ */
    var Chat = require("./chat/Chat");
    var ContactList = require("./contactlist/ContactList");
    var Settings = require("./../../settings/Settings");
    var SettingsMenu = require("./settings/SettingsMenu");
    var VideoLayout = require("../videolayout/VideoLayout");
    var ToolbarToggler = require("../toolbars/ToolbarToggler");
    var UIUtil = require("../util/UIUtil");
    var LargeVideo = require("../videolayout/LargeVideo");
    
    /**
     * Toggler for the chat, contact list, settings menu, etc..
     */
    var PanelToggler = (function(my) {
        
        var currentlyOpen = null;
        var buttons = {
            '#chatspace': '#chatBottomButton',
            '#contactlist': '#contactListButton',
            '#settingsmenu': '#toolbar_button_settings'
        };
        
        /**
         * Toggles the windows in the side panel
         * @param object the window that should be shown
         * @param selector the selector for the element containing the panel
         * @param onOpenComplete function to be called when the panel is opened
         * @param onOpen function to be called if the window is going to be opened
         * @param onClose function to be called if the window is going to be closed
         */
        var toggle = function(object, selector, onOpenComplete, onOpen, onClose) {
            UIUtil.buttonClick(buttons[selector], "active");
            
            if (object.isVisible()) {
                $("#toast-container").animate({
                        right: '5px'
                    },
                    {
                        queue: false,
                        duration: 500
                    });
                $(selector).hide("slide", {
                    direction: "right",
                    queue: false,
                    duration: 500
                });
                if(typeof onClose === "function") {
                    onClose();
                }
                
                currentlyOpen = null;
            }
            else {
                // Undock the toolbar when the chat is shown and if we're in a
                // video mode.
                if (LargeVideo.isLargeVideoVisible()) {
                    ToolbarToggler.dockToolbar(false);
                }
                
                if(currentlyOpen) {
                    var current = $(currentlyOpen);
                    UIUtil.buttonClick(buttons[currentlyOpen], "active");
                    current.css('z-index', 4);
                    setTimeout(function () {
                        current.css('display', 'none');
                        current.css('z-index', 5);
                    }, 500);
                }
                
                $("#toast-container").animate({
                        right: (PanelToggler.getPanelSize()[0] + 5) + 'px'
                    },
                    {
                        queue: false,
                        duration: 500
                    });
                $(selector).show("slide", {
                    direction: "right",
                    queue: false,
                    duration: 500,
                    complete: onOpenComplete
                });
                if(typeof onOpen === "function") {
                    onOpen();
                }
                
                currentlyOpen = selector;
            }
        };
        
        /**
         * Opens / closes the chat area.
         */
        my.toggleChat = function() {
            var chatCompleteFunction = Chat.isVisible() ?
                function() {} : function () {
                Chat.scrollChatToBottom();
                $('#chatspace').trigger('shown');
            };
            
            VideoLayout.resizeVideoArea(!Chat.isVisible(), chatCompleteFunction);
            
            toggle(Chat,
                '#chatspace',
                function () {
                    // Request the focus in the nickname field or the chat input
                    // field.
                    if ($('#nickname').css('visibility') === 'visible') {
                        $('#nickinput').focus();
                    } else {
                        $('#usermsg').focus();
                    }
                },
                null,
                Chat.resizeChat,
                null);
        };
        
        /**
         * Opens / closes the contact list area.
         */
        my.toggleContactList = function () {
            var completeFunction = ContactList.isVisible() ?
                function() {} : function () { $('#contactlist').trigger('shown');};
            VideoLayout.resizeVideoArea(!ContactList.isVisible(), completeFunction);
            
            toggle(ContactList,
                '#contactlist',
                null,
                function() {
                    ContactList.setVisualNotification(false);
                },
                null);
        };
        
        /**
         * Opens / closes the settings menu
         */
        my.toggleSettingsMenu = function() {
            VideoLayout.resizeVideoArea(!SettingsMenu.isVisible(), function (){});
            toggle(SettingsMenu,
                '#settingsmenu',
                null,
                function() {
                    var settings = Settings.getSettings();
                    $('#setDisplayName').get(0).value = settings.displayName;
                    $('#setEmail').get(0).value = settings.email;
                },
                null);
        };
        
        /**
         * Returns the size of the side panel.
         */
        my.getPanelSize = function () {
            var availableHeight = window.innerHeight;
            var availableWidth = window.innerWidth;
            
            var panelWidth = 200;
            if (availableWidth * 0.2 < 200) {
                panelWidth = availableWidth * 0.2;
            }
            
            return [panelWidth, availableHeight];
        };
        
        my.isVisible = function() {
            return (Chat.isVisible() ||
            ContactList.isVisible() ||
            SettingsMenu.isVisible());
        };
        
        return my;
        
    }(PanelToggler || {}));
    
    module.exports = PanelToggler;
},{"../toolbars/ToolbarToggler":28,"../util/UIUtil":32,"../videolayout/LargeVideo":34,"../videolayout/VideoLayout":38,"./../../settings/Settings":50,"./chat/Chat":20,"./contactlist/ContactList":24,"./settings/SettingsMenu":25}],20:[function(require,module,exports){
    /* global APP, $, Util, nickname:true */
    var Replacement = require("./Replacement");
    var CommandsProcessor = require("./Commands");
    var ToolbarToggler = require("../../toolbars/ToolbarToggler");
    var smileys = require("./smileys.json").smileys;
    var NicknameHandler = require("../../util/NicknameHandler");
    var UIUtil = require("../../util/UIUtil");
    var UIEvents = require("../../../../service/UI/UIEvents");
    
    var notificationInterval = false;
    var unreadMessages = 0;
    
    
    /**
     * Shows/hides a visual notification, indicating that a message has arrived.
     */
    function setVisualNotification(show) {
        var unreadMsgElement = document.getElementById('unreadMessages');
        var unreadMsgBottomElement
            = document.getElementById('bottomUnreadMessages');
        
        var glower = $('#toolbar_button_chat');
        var bottomGlower = $('#chatBottomButton');
        
        if (unreadMessages) {
            unreadMsgElement.innerHTML = unreadMessages.toString();
            unreadMsgBottomElement.innerHTML = unreadMessages.toString();
            
            ToolbarToggler.dockToolbar(true);
            
            var chatButtonElement
                = document.getElementById('toolbar_button_chat');
            var leftIndent = (UIUtil.getTextWidth(chatButtonElement) -
                UIUtil.getTextWidth(unreadMsgElement)) / 2;
            var topIndent = (UIUtil.getTextHeight(chatButtonElement) -
                UIUtil.getTextHeight(unreadMsgElement)) / 2 - 3;
            
            unreadMsgElement.setAttribute(
                'style',
                'top:' + topIndent +
                '; left:' + leftIndent + ';');
            
            var chatBottomButtonElement
                = document.getElementById('chatBottomButton').parentNode;
            var bottomLeftIndent = (UIUtil.getTextWidth(chatBottomButtonElement) -
                UIUtil.getTextWidth(unreadMsgBottomElement)) / 2;
            var bottomTopIndent = (UIUtil.getTextHeight(chatBottomButtonElement) -
                UIUtil.getTextHeight(unreadMsgBottomElement)) / 2 - 2;
            
            unreadMsgBottomElement.setAttribute(
                'style',
                'top:' + bottomTopIndent +
                '; left:' + bottomLeftIndent + ';');
            
            
            if (!glower.hasClass('icon-chat-simple')) {
                glower.removeClass('icon-chat');
                glower.addClass('icon-chat-simple');
            }
        }
        else {
            unreadMsgElement.innerHTML = '';
            unreadMsgBottomElement.innerHTML = '';
            glower.removeClass('icon-chat-simple');
            glower.addClass('icon-chat');
        }
        
        if (show && !notificationInterval) {
            notificationInterval = window.setInterval(function () {
                glower.toggleClass('active');
                bottomGlower.toggleClass('active glowing');
            }, 800);
        }
        else if (!show && notificationInterval) {
            window.clearInterval(notificationInterval);
            notificationInterval = false;
            glower.removeClass('active');
            bottomGlower.removeClass('glowing');
            bottomGlower.addClass('active');
        }
    }
    
    
    /**
     * Returns the current time in the format it is shown to the user
     * @returns {string}
     */
    function getCurrentTime(stamp) {
        var now     = (stamp? new Date(stamp): new Date());
        var hour    = now.getHours();
        var minute  = now.getMinutes();
        var second  = now.getSeconds();
        if(hour.toString().length === 1) {
            hour = '0'+hour;
        }
        if(minute.toString().length === 1) {
            minute = '0'+minute;
        }
        if(second.toString().length === 1) {
            second = '0'+second;
        }
        return hour+':'+minute+':'+second;
    }
    
    function toggleSmileys() {
        var smileys = $('#smileysContainer');
        if(!smileys.is(':visible')) {
            smileys.show("slide", { direction: "down", duration: 300});
        } else {
            smileys.hide("slide", { direction: "down", duration: 300});
        }
        $('#usermsg').focus();
    }
    
    function addClickFunction(smiley, number) {
        smiley.onclick = function addSmileyToMessage() {
            var usermsg = $('#usermsg');
            var message = usermsg.val();
            message += smileys['smiley' + number];
            usermsg.val(message);
            usermsg.get(0).setSelectionRange(message.length, message.length);
            toggleSmileys();
            usermsg.focus();
        };
    }
    
    /**
     * Adds the smileys container to the chat
     */
    function addSmileys() {
        var smileysContainer = document.createElement('div');
        smileysContainer.id = 'smileysContainer';
        for(var i = 1; i <= 21; i++) {
            var smileyContainer = document.createElement('div');
            smileyContainer.id = 'smiley' + i;
            smileyContainer.className = 'smileyContainer';
            var smiley = document.createElement('img');
            smiley.src = 'images/smileys/smiley' + i + '.svg';
            smiley.className =  'smiley';
            addClickFunction(smiley, i);
            smileyContainer.appendChild(smiley);
            smileysContainer.appendChild(smileyContainer);
        }
        
        $("#chatspace").append(smileysContainer);
    }
    
    /**
     * Resizes the chat conversation.
     */
    function resizeChatConversation() {
        var msgareaHeight = $('#usermsg').outerHeight();
        var chatspace = $('#chatspace');
        var width = chatspace.width();
        var chat = $('#chatconversation');
        var smileys = $('#smileysarea');
        
        smileys.height(msgareaHeight);
        $("#smileys").css('bottom', (msgareaHeight - 26) / 2);
        $('#smileysContainer').css('bottom', msgareaHeight);
        chat.width(width - 10);
        chat.height(window.innerHeight - 15 - msgareaHeight);
    }
    
    /**
     * Chat related user interface.
     */
    var Chat = (function (my) {
        /**
         * Initializes chat related interface.
         */
        my.init = function () {
            if(NicknameHandler.getNickname())
                Chat.setChatConversationMode(true);
            NicknameHandler.addListener(UIEvents.NICKNAME_CHANGED,
                function (nickname) {
                    Chat.setChatConversationMode(true);
                });
            
            $('#nickinput').keydown(function (event) {
                if (event.keyCode === 13) {
                    event.preventDefault();
                    var val = UIUtil.escapeHtml(this.value);
                    this.value = '';
                    if (!NicknameHandler.getNickname()) {
                        NicknameHandler.setNickname(val);
                        
                        return;
                    }
                }
            });
            
            var usermsg = $('#usermsg');
            usermsg.keydown(function (event) {
                if (event.keyCode === 13) {
                    event.preventDefault();
                    var value = this.value;
                    usermsg.val('').trigger('autosize.resize');
                    this.focus();
                    var command = new CommandsProcessor(value);
                    if(command.isCommand()) {
                        command.processCommand();
                    }
                    else {
                        var message = UIUtil.escapeHtml(value);
                        APP.xmpp.sendChatMessage(message,
                            NicknameHandler.getNickname());
                    }
                }
            });
            
            var onTextAreaResize = function () {
                resizeChatConversation();
                Chat.scrollChatToBottom();
            };
            usermsg.autosize({callback: onTextAreaResize});
            
            $("#chatspace").bind("shown",
                function () {
                    unreadMessages = 0;
                    setVisualNotification(false);
                });
            
            addSmileys();
        };
        
        /**
         * Appends the given message to the chat conversation.
         */
        my.updateChatConversation =
            function (from, displayName, message, myjid, stamp) {
                var divClassName = '';
                
                if (APP.xmpp.myJid() === from) {
                    divClassName = "localuser";
                }
                else {
                    divClassName = "remoteuser";
                    
                    if (!Chat.isVisible()) {
                        unreadMessages++;
                        UIUtil.playSoundNotification('chatNotification');
                        setVisualNotification(true);
                    }
                }
                
                // replace links and smileys
                // Strophe already escapes special symbols on sending,
                // so we escape here only tags to avoid double &amp;
                var escMessage = message.replace(/</g, '&lt;').
                    replace(/>/g, '&gt;').replace(/\n/g, '<br/>');
                var escDisplayName = UIUtil.escapeHtml(displayName);
                message = Replacement.processReplacements(escMessage);
                
                var messageContainer =
                    '<div class="chatmessage">'+
                    '<img src="../images/chatArrow.svg" class="chatArrow">' +
                    '<div class="username ' + divClassName +'">' + escDisplayName +
                    '</div>' + '<div class="timestamp">' + getCurrentTime(stamp) +
                    '</div>' + '<div class="usermessage">' + message + '</div>' +
                    '</div>';
                
                $('#chatconversation').append(messageContainer);
                $('#chatconversation').animate(
                    { scrollTop: $('#chatconversation')[0].scrollHeight}, 1000);
            };
        
        /**
         * Appends error message to the conversation
         * @param errorMessage the received error message.
         * @param originalText the original message.
         */
        my.chatAddError = function(errorMessage, originalText) {
            errorMessage = UIUtil.escapeHtml(errorMessage);
            originalText = UIUtil.escapeHtml(originalText);
            
            $('#chatconversation').append(
                '<div class="errorMessage"><b>Error: </b>' + 'Your message' +
                (originalText? (' \"'+ originalText + '\"') : "") +
                ' was not sent.' +
                (errorMessage? (' Reason: ' + errorMessage) : '') +  '</div>');
            $('#chatconversation').animate(
                { scrollTop: $('#chatconversation')[0].scrollHeight}, 1000);
        };
        
        /**
         * Sets the subject to the UI
         * @param subject the subject
         */
        my.chatSetSubject = function(subject) {
            if (subject)
                subject = subject.trim();
            $('#subject').html(Replacement.linkify(UIUtil.escapeHtml(subject)));
            if(subject === "") {
                $("#subject").css({display: "none"});
            }
            else {
                $("#subject").css({display: "block"});
            }
        };
        
        /**
         * Sets the chat conversation mode.
         */
        my.setChatConversationMode = function (isConversationMode) {
            if (isConversationMode) {
                $('#nickname').css({visibility: 'hidden'});
                $('#chatconversation').css({visibility: 'visible'});
                $('#usermsg').css({visibility: 'visible'});
                $('#smileysarea').css({visibility: 'visible'});
                $('#usermsg').focus();
            }
        };
        
        /**
         * Resizes the chat area.
         */
        my.resizeChat = function () {
            var chatSize = require("../SidePanelToggler").getPanelSize();
            
            $('#chatspace').width(chatSize[0]);
            $('#chatspace').height(chatSize[1]);
            
            resizeChatConversation();
        };
        
        /**
         * Indicates if the chat is currently visible.
         */
        my.isVisible = function () {
            return $('#chatspace').is(":visible");
        };
        /**
         * Shows and hides the window with the smileys
         */
        my.toggleSmileys = toggleSmileys;
        
        /**
         * Scrolls chat to the bottom.
         */
        my.scrollChatToBottom = function() {
            setTimeout(function () {
                $('#chatconversation').scrollTop(
                    $('#chatconversation')[0].scrollHeight);
            }, 5);
        };
        
        
        return my;
    }(Chat || {}));
    module.exports = Chat;
},{"../../../../service/UI/UIEvents":181,"../../toolbars/ToolbarToggler":28,"../../util/NicknameHandler":31,"../../util/UIUtil":32,"../SidePanelToggler":19,"./Commands":21,"./Replacement":22,"./smileys.json":23}],21:[function(require,module,exports){
    /* global APP, require */
    var UIUtil = require("../../util/UIUtil");
    
    /**
     * List with supported commands. The keys are the names of the commands and
     * the value is the function that processes the message.
     * @type {{String: function}}
     */
    var commands = {
        "topic" : processTopic
    };
    
    /**
     * Extracts the command from the message.
     * @param message the received message
     * @returns {string} the command
     */
    function getCommand(message) {
        if(message) {
            for(var command in commands) {
                if(message.indexOf("/" + command) === 0)
                    return command;
            }
        }
        return "";
    }
    
    /**
     * Processes the data for topic command.
     * @param commandArguments the arguments of the topic command.
     */
    function processTopic(commandArguments) {
        var topic = UIUtil.escapeHtml(commandArguments);
        APP.xmpp.setSubject(topic);
    }
    
    /**
     * Constructs a new CommandProccessor instance from a message that
     * handles commands received via chat messages.
     * @param message the message
     * @constructor
     */
    function CommandsProcessor(message) {
        var command = getCommand(message);
        
        /**
         * Returns the name of the command.
         * @returns {String} the command
         */
        this.getCommand = function() {
            return command;
        };
        
        
        var messageArgument = message.substr(command.length + 2);
        
        /**
         * Returns the arguments of the command.
         * @returns {string}
         */
        this.getArgument = function() {
            return messageArgument;
        };
    }
    
    /**
     * Checks whether this instance is valid command or not.
     * @returns {boolean}
     */
    CommandsProcessor.prototype.isCommand = function() {
        if (this.getCommand())
            return true;
        return false;
    };
    
    /**
     * Processes the command.
     */
    CommandsProcessor.prototype.processCommand = function() {
        if(!this.isCommand())
            return;
        
        commands[this.getCommand()](this.getArgument());
    };
    
    module.exports = CommandsProcessor;
},{"../../util/UIUtil":32}],22:[function(require,module,exports){
    /* jshint -W101 */
    var Smileys = require("./smileys.json");
    /**
     * Processes links and smileys in "body"
     */
    function processReplacements(body)
    {
        //make links clickable
        body = linkify(body);
        
        //add smileys
        body = smilify(body);
        
        return body;
    }
    
    /**
     * Finds and replaces all links in the links in "body"
     * with their <a href=""></a>
     */
    function linkify(inputText)
    {
        var replacedText, replacePattern1, replacePattern2, replacePattern3;
        
        //URLs starting with http://, https://, or ftp://
        replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
        replacedText = inputText.replace(replacePattern1, '<a href="$1" target="_blank">$1</a>');
        
        //URLs starting with "www." (without // before it, or it'd re-link the ones done above).
        replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
        replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" target="_blank">$2</a>');
        
        //Change email addresses to mailto:: links.
        replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z\_]+?(\.[a-zA-Z]{2,6})+)/gim;
        replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>');
        
        return replacedText;
    }
    
    /**
     * Replaces common smiley strings with images
     */
    function smilify(body)
    {
        if(!body) {
            return body;
        }
        
        var regexs = Smileys.regexs;
        for(var smiley in regexs) {
            if(regexs.hasOwnProperty(smiley)) {
                body = body.replace(regexs[smiley],
                    '<img class="smiley" src="images/smileys/' + smiley + '.svg">');
            }
        }
        
        return body;
    }
    
    module.exports = {
        processReplacements: processReplacements,
        linkify: linkify
    };
    
},{"./smileys.json":23}],23:[function(require,module,exports){
    module.exports={
        "smileys": {
            "smiley1": ":)",
            "smiley2": ":(",
            "smiley3": ":D",
            "smiley4": "(y)",
            "smiley5": " :P",
            "smiley6": "(wave)",
            "smiley7": "(blush)",
            "smiley8": "(chuckle)",
            "smiley9": "(shocked)",
            "smiley10": ":*",
            "smiley11": "(n)",
            "smiley12": "(search)",
            "smiley13": " <3",
            "smiley14": "(oops)",
            "smiley15": "(angry)",
            "smiley16": "(angel)",
            "smiley17": "(sick)",
            "smiley18": ";(",
            "smiley19": "(bomb)",
            "smiley20": "(clap)",
            "smiley21": " ;)"
        },
        "regexs": {
            "smiley2": /(:-\(\(|:-\(|:\(\(|:\(|\(sad\))/gi,
            "smiley3": /(:-\)\)|:\)\)|\(lol\)|:-D|:D)/gi,
            "smiley1": /(:-\)|:\))/gi,
            "smiley4": /(\(y\)|\(Y\)|\(ok\))/gi,
            "smiley5": /(:-P|:P|:-p|:p)/gi,
            "smiley6": /(\(wave\))/gi,
            "smiley7": /(\(blush\))/gi,
            "smiley8": /(\(chuckle\))/gi,
            "smiley9": /(:-0|\(shocked\))/gi,
            "smiley10": /(:-\*|:\*|\(kiss\))/gi,
            "smiley11": /(\(n\))/gi,
            "smiley12": /(\(search\))/g,
            "smiley13": /(<3|&lt;3|&amp;lt;3|\(L\)|\(l\)|\(H\)|\(h\))/gi,
            "smiley14": /(\(oops\))/gi,
            "smiley15": /(\(angry\))/gi,
            "smiley16": /(\(angel\))/gi,
            "smiley17": /(\(sick\))/gi,
            "smiley18": /(;-\(\(|;\(\(|;-\(|;\(|:"\(|:"-\(|:~-\(|:~\(|\(upset\))/gi,
            "smiley19": /(\(bomb\))/gi,
            "smiley20": /(\(clap\))/gi,
            "smiley21": /(;-\)|;\)|;-\)\)|;\)\)|;-D|;D|\(wink\))/gi
        }
    }
    
},{}],24:[function(require,module,exports){
    /* global $, APP, Strophe */
    var Avatar = require('../../avatar/Avatar');
    
    var numberOfContacts = 0;
    var notificationInterval;
    
    /**
     * Updates the number of participants in the contact list button and sets
     * the glow
     * @param delta indicates whether a new user has joined (1) or someone has
     * left(-1)
     */
    function updateNumberOfParticipants(delta) {
        numberOfContacts += delta;
        if (numberOfContacts === 1) {
            // when the user is alone we don't show the number of participants
            $("#numberOfParticipants").text('');
            ContactList.setVisualNotification(false);
        } else if (numberOfContacts > 1) {
            ContactList.setVisualNotification(!ContactList.isVisible());
            $("#numberOfParticipants").text(numberOfContacts);
        } else {
            console.error("Invalid number of participants: " + numberOfContacts);
        }
    }
    
    /**
     * Creates the avatar element.
     *
     * @return {object} the newly created avatar element
     */
    function createAvatar(jid) {
        var avatar = document.createElement('img');
        avatar.className = "icon-avatar avatar";
        avatar.src = Avatar.getContactListUrl(jid);
        
        return avatar;
    }
    
    /**
     * Creates the display name paragraph.
     *
     * @param displayName the display name to set
     */
    function createDisplayNameParagraph(key, displayName) {
        var p = document.createElement('p');
        if(displayName)
            p.innerText = displayName;
        else if(key) {
            p.setAttribute("data-i18n",key);
            p.innerText = APP.translation.translateString(key);
        }
        
        return p;
    }
    
    
    function stopGlowing(glower) {
        window.clearInterval(notificationInterval);
        notificationInterval = false;
        glower.removeClass('glowing');
        if (!ContactList.isVisible()) {
            glower.removeClass('active');
        }
    }
    
    /**
     * Contact list.
     */
    var ContactList = {
        /**
         * Indicates if the chat is currently visible.
         *
         * @return <tt>true</tt> if the chat is currently visible, <tt>false</tt> -
         * otherwise
         */
        isVisible: function () {
            return $('#contactlist').is(":visible");
        },
        
        /**
         * Adds a contact for the given peerJid if such doesn't yet exist.
         *
         * @param peerJid the peerJid corresponding to the contact
         */
        ensureAddContact: function (peerJid) {
            var resourceJid = Strophe.getResourceFromJid(peerJid);
            
            var contact = $('#contacts>li[id="' + resourceJid + '"]');
            
            if (!contact || contact.length <= 0)
                ContactList.addContact(peerJid);
        },
        
        /**
         * Adds a contact for the given peer jid.
         *
         * @param peerJid the jid of the contact to add
         */
        addContact: function (peerJid) {
            var resourceJid = Strophe.getResourceFromJid(peerJid);
            
            var contactlist = $('#contacts');
            
            var newContact = document.createElement('li');
            newContact.id = resourceJid;
            newContact.className = "clickable";
            newContact.onclick = function (event) {
                if (event.currentTarget.className === "clickable") {
                    $(ContactList).trigger('contactclicked', [peerJid]);
                }
            };
            
            newContact.appendChild(createAvatar(peerJid));
            newContact.appendChild(createDisplayNameParagraph("participant"));
            
            if (resourceJid === APP.xmpp.myResource()) {
                contactlist.prepend(newContact);
            }
            else {
                contactlist.append(newContact);
            }
            updateNumberOfParticipants(1);
        },
        
        /**
         * Removes a contact for the given peer jid.
         *
         * @param peerJid the peerJid corresponding to the contact to remove
         */
        removeContact: function (peerJid) {
            var resourceJid = Strophe.getResourceFromJid(peerJid);
            
            var contact = $('#contacts>li[id="' + resourceJid + '"]');
            
            if (contact && contact.length > 0) {
                var contactlist = $('#contactlist>ul');
                
                contactlist.get(0).removeChild(contact.get(0));
                
                updateNumberOfParticipants(-1);
            }
        },
        
        setVisualNotification: function (show, stopGlowingIn) {
            var glower = $('#contactListButton');
            
            if (show && !notificationInterval) {
                notificationInterval = window.setInterval(function () {
                    glower.toggleClass('active glowing');
                }, 800);
            }
            else if (!show && notificationInterval) {
                stopGlowing(glower);
            }
            if (stopGlowingIn) {
                setTimeout(function () {
                    stopGlowing(glower);
                }, stopGlowingIn);
            }
        },
        
        setClickable: function (resourceJid, isClickable) {
            var contact = $('#contacts>li[id="' + resourceJid + '"]');
            if (isClickable) {
                contact.addClass('clickable');
            } else {
                contact.removeClass('clickable');
            }
        },
        
        onDisplayNameChange: function (peerJid, displayName) {
            if (peerJid === 'localVideoContainer')
                peerJid = APP.xmpp.myJid();
            
            var resourceJid = Strophe.getResourceFromJid(peerJid);
            
            var contactName = $('#contacts #' + resourceJid + '>p');
            
            if (contactName && displayName && displayName.length > 0)
                contactName.html(displayName);
        },
        
        userAvatarChanged: function (resourceJid, contactListUrl) {
            // set the avatar in the contact list
            var contact = $('#' + resourceJid + '>img');
            if (contact && contact.length > 0) {
                contact.get(0).src = contactListUrl;
            }
            
        }
    };
    
    module.exports = ContactList;
},{"../../avatar/Avatar":15}],25:[function(require,module,exports){
    /* global APP, $ */
    var Avatar = require("../../avatar/Avatar");
    var Settings = require("./../../../settings/Settings");
    var UIUtil = require("../../util/UIUtil");
    var languages = require("../../../../service/translation/languages");
    
    function generateLanguagesSelectBox() {
        var currentLang = APP.translation.getCurrentLanguage();
        var html = "<select id=\"languages_selectbox\">";
        var langArray = languages.getLanguages();
        for(var i = 0; i < langArray.length; i++) {
            var lang = langArray[i];
            html += "<option ";
            if(lang === currentLang)
                html += "selected ";
            html += "value=\"" + lang + "\" data-i18n='languages:" + lang + "'>";
            html += "</option>";
            
        }
        
        return html + "</select>";
    }
    
    
    var SettingsMenu = {
        
        init: function () {
            var startMutedSelector = $("#startMutedOptions");
            startMutedSelector.before(generateLanguagesSelectBox());
            APP.translation.translateElement($("#languages_selectbox"));
            $('#settingsmenu>input').keyup(function(event){
                if(event.keyCode === 13) {//enter
                    SettingsMenu.update();
                }
            });
            
            if (APP.xmpp.isModerator()) {
                startMutedSelector.css("display", "block");
            }
            else {
                startMutedSelector.css("display", "none");
            }
            
            $("#updateSettings").click(function () {
                SettingsMenu.update();
            });
        },
        
        onRoleChanged: function () {
            if(APP.xmpp.isModerator()) {
                $("#startMutedOptions").css("display", "block");
            }
            else {
                $("#startMutedOptions").css("display", "none");
            }
        },
        
        setStartMuted: function (audio, video) {
            $("#startAudioMuted").attr("checked", audio);
            $("#startVideoMuted").attr("checked", video);
        },
        
        update: function() {
            var newDisplayName =
                UIUtil.escapeHtml($('#setDisplayName').get(0).value);
            var newEmail = UIUtil.escapeHtml($('#setEmail').get(0).value);
            
            if(newDisplayName) {
                var displayName = Settings.setDisplayName(newDisplayName);
                APP.xmpp.addToPresence("displayName", displayName, true);
            }
            
            var language = $("#languages_selectbox").val();
            APP.translation.setLanguage(language);
            Settings.setLanguage(language);
            
            APP.xmpp.addToPresence("email", newEmail);
            var email = Settings.setEmail(newEmail);
            
            var startAudioMuted = ($("#startAudioMuted").is(":checked"));
            var startVideoMuted = ($("#startVideoMuted").is(":checked"));
            APP.xmpp.addToPresence("startMuted",
                [startAudioMuted, startVideoMuted]);
            
            Avatar.setUserAvatar(APP.xmpp.myJid(), email);
        },
        
        isVisible: function() {
            return $('#settingsmenu').is(':visible');
        },
        
        setDisplayName: function(newDisplayName) {
            var displayName = Settings.setDisplayName(newDisplayName);
            $('#setDisplayName').get(0).value = displayName;
        },
        
        onDisplayNameChange: function(peerJid, newDisplayName) {
            if(peerJid === 'localVideoContainer' ||
                peerJid === APP.xmpp.myJid()) {
                this.setDisplayName(newDisplayName);
            }
        },
        changeAvatar: function (thumbUrl) {
            $('#avatar').get(0).src = thumbUrl;
        }
    };
    
    
    module.exports = SettingsMenu;
},{"../../../../service/translation/languages":187,"../../avatar/Avatar":15,"../../util/UIUtil":32,"./../../../settings/Settings":50}],26:[function(require,module,exports){
    /* global $ */
    var PanelToggler = require("../side_pannels/SidePanelToggler");
    var UIUtil = require("../util/UIUtil");
    var AnalyticsAdapter = require("../../statistics/AnalyticsAdapter");
    
    var buttonHandlers = {
        "bottom_toolbar_contact_list": function () {
            AnalyticsAdapter.sendEvent('bottomtoolbar.contacts.toggled');
            BottomToolbar.toggleContactList();
        },
        "bottom_toolbar_film_strip": function () {
            AnalyticsAdapter.sendEvent('bottomtoolbar.filmstrip.toggled');
            BottomToolbar.toggleFilmStrip();
        },
        "bottom_toolbar_chat": function () {
            AnalyticsAdapter.sendEvent('bottomtoolbar.chat.toggled');
            BottomToolbar.toggleChat();
        }
    };
    
    
    var defaultBottomToolbarButtons = {
        'chat': '#bottom_toolbar_chat',
        'contacts': '#bottom_toolbar_contact_list',
        'filmstrip': '#bottom_toolbar_film_strip'
    };
    
    
    var BottomToolbar = (function (my) {
        my.init = function () {
            UIUtil.hideDisabledButtons(defaultBottomToolbarButtons);
            
            for(var k in buttonHandlers)
                $("#" + k).click(buttonHandlers[k]);
        };
        
        my.toggleChat = function() {
            PanelToggler.toggleChat();
        };
        
        my.toggleContactList = function() {
            PanelToggler.toggleContactList();
        };
        
        my.toggleFilmStrip = function() {
            var filmstrip = $("#remoteVideos");
            filmstrip.toggleClass("hidden");
        };
        
        $(document).bind("remotevideo.resized", function (event, width, height) {
            var bottom = (height - $('#bottomToolbar').outerHeight())/2 + 18;
            
            $('#bottomToolbar').css({bottom: bottom + 'px'});
        });
        
        return my;
    }(BottomToolbar || {}));
    
    module.exports = BottomToolbar;
    
},{"../../statistics/AnalyticsAdapter":51,"../side_pannels/SidePanelToggler":19,"../util/UIUtil":32}],27:[function(require,module,exports){
    /* global APP, $, buttonClick, config, lockRoom, interfaceConfig, setSharedKey,
     Util */
    /* jshint -W101 */
    var messageHandler = require("../util/MessageHandler");
    var BottomToolbar = require("./BottomToolbar");
    var Prezi = require("../prezi/Prezi");
    var Etherpad = require("../etherpad/Etherpad");
    var PanelToggler = require("../side_pannels/SidePanelToggler");
    var Authentication = require("../authentication/Authentication");
    var UIUtil = require("../util/UIUtil");
    var AuthenticationEvents
        = require("../../../service/authentication/AuthenticationEvents");
    var AnalyticsAdapter = require("../../statistics/AnalyticsAdapter");
    
    var roomUrl = null;
    var sharedKey = '';
    var UI = null;
    var recordingToaster = null;
    
    var buttonHandlers = {
        "toolbar_button_mute": function () {
            if (APP.RTC.localAudio.isMuted()) {
                AnalyticsAdapter.sendEvent('toolbar.audio.unmuted');
            } else {
                AnalyticsAdapter.sendEvent('toolbar.audio.muted');
            }
            return APP.UI.toggleAudio();
        },
        "toolbar_button_camera": function () {
            if (APP.RTC.localVideo.isMuted()) {
                AnalyticsAdapter.sendEvent('toolbar.video.enabled');
            } else {
                AnalyticsAdapter.sendEvent('toolbar.video.disabled');
            }
            return APP.UI.toggleVideo();
        },
        /*"toolbar_button_authentication": function () {
         return Toolbar.authenticateClicked();
         },*/
        "toolbar_button_record": function () {
            AnalyticsAdapter.sendEvent('toolbar.recording.toggled');
            return toggleRecording();
        },
        "toolbar_button_security": function () {
            if (sharedKey) {
                AnalyticsAdapter.sendEvent('toolbar.lock.disabled');
            } else {
                AnalyticsAdapter.sendEvent('toolbar.lock.enabled');
            }
            return Toolbar.openLockDialog();
        },
        "toolbar_button_link": function () {
            AnalyticsAdapter.sendEvent('toolbar.invite.clicked');
            return Toolbar.openLinkDialog();
        },
        "toolbar_button_chat": function () {
            AnalyticsAdapter.sendEvent('toolbar.chat.toggled');
            return BottomToolbar.toggleChat();
        },
        "toolbar_button_prezi": function () {
            AnalyticsAdapter.sendEvent('toolbar.prezi.clicked');
            return Prezi.openPreziDialog();
        },
        "toolbar_button_etherpad": function () {
            AnalyticsAdapter.sendEvent('toolbar.etherpad.clicked');
            return Etherpad.toggleEtherpad(0);
        },
        "toolbar_button_desktopsharing": function () {
            if (APP.desktopsharing.isUsingScreenStream) {
                AnalyticsAdapter.sendEvent('toolbar.screen.disabled');
            } else {
                AnalyticsAdapter.sendEvent('toolbar.screen.enabled');
            }
            return APP.desktopsharing.toggleScreenSharing();
        },
        "toolbar_button_fullScreen": function() {
            AnalyticsAdapter.sendEvent('toolbar.fullscreen.enabled');
            UIUtil.buttonClick("#toolbar_button_fullScreen", "icon-full-screen icon-exit-full-screen");
            return Toolbar.toggleFullScreen();
        },
        "toolbar_button_sip": function () {
            AnalyticsAdapter.sendEvent('toolbar.sip.clicked');
            return callSipButtonClicked();
        },
        "toolbar_button_dialpad": function () {
            AnalyticsAdapter.sendEvent('toolbar.sip.dialpad.clicked');
            return dialpadButtonClicked();
        },
        "toolbar_button_settings": function () {
            AnalyticsAdapter.sendEvent('toolbar.settings.toggled');
            PanelToggler.toggleSettingsMenu();
        },
        "toolbar_button_hangup": function () {
            AnalyticsAdapter.sendEvent('toolbar.hangup');
            return hangup();
        },
        "toolbar_button_login": function () {
            AnalyticsAdapter.sendEvent('toolbar.authenticate.login.clicked');
            Toolbar.authenticateClicked();
        },
        "toolbar_button_logout": function () {
            AnalyticsAdapter.sendEvent('toolbar.authenticate.logout.clicked');
            // Ask for confirmation
            messageHandler.openTwoButtonDialog(
                "dialog.logoutTitle",
                null,
                "dialog.logoutQuestion",
                null,
                false,
                "dialog.Yes",
                function (evt, yes) {
                    if (yes) {
                        APP.xmpp.logout(function (url) {
                            if (url) {
                                window.location.href = url;
                            } else {
                                hangup();
                            }
                        });
                    }
                });
        }
    };
    var defaultToolbarButtons = {
        'microphone': '#toolbar_button_mute',
        'camera': '#toolbar_button_camera',
        'desktop': '#toolbar_button_desktopsharing',
        'security': '#toolbar_button_security',
        'invite': '#toolbar_button_link',
        'chat': '#toolbar_button_chat',
        'prezi': '#toolbar_button_prezi',
        'etherpad': '#toolbar_button_etherpad',
        'fullscreen': '#toolbar_button_fullScreen',
        'settings': '#toolbar_button_settings',
        'hangup': '#toolbar_button_hangup'
    };
    
    function hangup() {
        APP.xmpp.disposeConference();
        if(config.enableWelcomePage) {
            setTimeout(function() {
                window.localStorage.welcomePageDisabled = false;
                window.location.pathname = "/";
            }, 10000);
            
        }
        
        var title = APP.translation.generateTranslationHTML(
            "dialog.sessTerminated");
        var msg = APP.translation.generateTranslationHTML(
            "dialog.hungUp");
        var button = APP.translation.generateTranslationHTML(
            "dialog.joinAgain");
        var buttons = [];
        buttons.push({title: button, value: true});
        
        UI.messageHandler.openDialog(
            title,
            msg,
            true,
            buttons,
            function(event, value, message, formVals) {
                window.location.reload();
                return false;
            }
        );
    }
    
    /**
     * Starts or stops the recording for the conference.
     */
    
    function toggleRecording(predefinedToken) {
        APP.xmpp.toggleRecording(function (callback) {
            if (predefinedToken) {
                callback(UIUtil.escapeHtml(predefinedToken));
                return;
            }
            
            var msg = APP.translation.generateTranslationHTML(
                "dialog.recordingToken");
            var token = APP.translation.translateString("dialog.token");
            APP.UI.messageHandler.openTwoButtonDialog(null, null, null,
                '<h2>' + msg + '</h2>' +
                '<input name="recordingToken" type="text" ' +
                ' data-i18n="[placeholder]dialog.token" ' +
                'placeholder="' + token + '" autofocus>',
                false,
                "dialog.Save",
                function (e, v, m, f) {
                    if (v) {
                        var token = f.recordingToken;
                        
                        if (token) {
                            callback(UIUtil.escapeHtml(token));
                        }
                    }
                },
                null,
                function () { },
                ':input:first'
            );
        }, Toolbar.setRecordingButtonState);
    }
    
    /**
     * Locks / unlocks the room.
     */
    function lockRoom(lock) {
        var currentSharedKey = '';
        if (lock)
            currentSharedKey = sharedKey;
        
        APP.xmpp.lockRoom(currentSharedKey, function (res) {
            // password is required
            if (sharedKey) {
                console.log('set room password');
                Toolbar.lockLockButton();
            }
            else {
                console.log('removed room password');
                Toolbar.unlockLockButton();
            }
        }, function (err) {
            console.warn('setting password failed', err);
            messageHandler.showError("dialog.lockTitle",
                "dialog.lockMessage");
            Toolbar.setSharedKey('');
        }, function () {
            console.warn('room passwords not supported');
            messageHandler.showError("dialog.warning",
                "dialog.passwordNotSupported");
            Toolbar.setSharedKey('');
        });
    }
    
    /**
     * Invite participants to conference.
     */
    function inviteParticipants() {
        if (roomUrl === null)
            return;
        
        var sharedKeyText = "";
        if (sharedKey && sharedKey.length > 0) {
            sharedKeyText =
                APP.translation.translateString("email.sharedKey",
                    {sharedKey: sharedKey});
            sharedKeyText = sharedKeyText.replace(/\n/g, "%0D%0A");
        }
        
        var supportedBrowsers = "Chromium, Google Chrome " +
            APP.translation.translateString("email.and") + " Opera";
        var conferenceName = roomUrl.substring(roomUrl.lastIndexOf('/') + 1);
        var subject = APP.translation.translateString("email.subject",
            {appName:interfaceConfig.APP_NAME, conferenceName: conferenceName});
        var body = APP.translation.translateString("email.body",
            {appName:interfaceConfig.APP_NAME, sharedKeyText: sharedKeyText,
                roomUrl: roomUrl, supportedBrowsers: supportedBrowsers});
        body = body.replace(/\n/g, "%0D%0A");
        
        if (window.localStorage.displayname) {
            body += "%0D%0A%0D%0A" + window.localStorage.displayname;
        }
        
        if (interfaceConfig.INVITATION_POWERED_BY) {
            body += "%0D%0A%0D%0A--%0D%0Apowered by jitsi.org";
        }
        
        window.open("mailto:?subject=" + subject + "&body=" + body, '_blank');
    }
    
    function dialpadButtonClicked() {
        //TODO show the dialpad box
    }
    
    function callSipButtonClicked() {
        var defaultNumber
            = config.defaultSipNumber ? config.defaultSipNumber : '';
        
        var sipMsg = APP.translation.generateTranslationHTML(
            "dialog.sipMsg");
        messageHandler.openTwoButtonDialog(null, null, null,
            '<h2>' + sipMsg + '</h2>' +
            '<input name="sipNumber" type="text"' +
            ' value="' + defaultNumber + '" autofocus>',
            false,
            "dialog.Dial",
            function (e, v, m, f) {
                if (v) {
                    var numberInput = f.sipNumber;
                    if (numberInput) {
                        APP.xmpp.dial(
                            numberInput, 'fromnumber', UI.getRoomName(), sharedKey);
                    }
                }
            },
            null, null, ':input:first'
        );
    }
    
    var Toolbar = (function (my) {
        
        my.init = function (ui) {
            UIUtil.hideDisabledButtons(defaultToolbarButtons);
            
            for(var k in buttonHandlers)
                $("#" + k).click(buttonHandlers[k]);
            UI = ui;
            // Update login info
            APP.xmpp.addListener(
                AuthenticationEvents.IDENTITY_UPDATED,
                function (authenticationEnabled, userIdentity) {
                    
                    var loggedIn = false;
                    if (userIdentity) {
                        loggedIn = true;
                    }
                    
                    Toolbar.showAuthenticateButton(authenticationEnabled);
                    
                    if (authenticationEnabled) {
                        Toolbar.setAuthenticatedIdentity(userIdentity);
                        
                        Toolbar.showLoginButton(!loggedIn);
                        Toolbar.showLogoutButton(loggedIn);
                    }
                }
            );
        };
        
        /**
         * Sets shared key
         * @param sKey the shared key
         */
        my.setSharedKey = function (sKey) {
            sharedKey = sKey;
        };
        
        my.authenticateClicked = function () {
            Authentication.focusAuthenticationWindow();
            if (!APP.xmpp.isExternalAuthEnabled()) {
                Authentication.xmppAuthenticate();
                return;
            }
            // Get authentication URL
            if (!APP.xmpp.isMUCJoined()) {
                APP.xmpp.getLoginUrl(UI.getRoomName(), function (url) {
                    // If conference has not been started yet - redirect to login page
                    window.location.href = url;
                });
            } else {
                APP.xmpp.getPopupLoginUrl(UI.getRoomName(), function (url) {
                    // Otherwise - open popup with authentication URL
                    var authenticationWindow = Authentication.createAuthenticationWindow(
                        function () {
                            // On popup closed - retry room allocation
                            APP.xmpp.allocateConferenceFocus(
                                APP.UI.getRoomName(),
                                function () { console.info("AUTH DONE"); }
                            );
                        }, url);
                    if (!authenticationWindow) {
                        messageHandler.openMessageDialog(
                            null, "dialog.popupError");
                    }
                });
            }
        };
        
        /**
         * Updates the room invite url.
         */
        my.updateRoomUrl = function (newRoomUrl) {
            roomUrl = newRoomUrl;
            
            // If the invite dialog has been already opened we update the information.
            var inviteLink = document.getElementById('inviteLinkRef');
            if (inviteLink) {
                inviteLink.value = roomUrl;
                inviteLink.select();
                $('#inviteLinkRef').parent()
                    .find('button[value=true]').prop('disabled', false);
            }
        };
        
        /**
         * Disables and enables some of the buttons.
         */
        my.setupButtonsFromConfig = function () {
            if (UIUtil.isButtonEnabled('prezi')) {
                $("#toolbar_button_prezi").css({display: "none"});
            }
        };
        
        /**
         * Opens the lock room dialog.
         */
        my.openLockDialog = function () {
            // Only the focus is able to set a shared key.
            if (!APP.xmpp.isModerator()) {
                if (sharedKey) {
                    messageHandler.openMessageDialog(null,
                        "dialog.passwordError");
                } else {
                    messageHandler.openMessageDialog(null, "dialog.passwordError2");
                }
            } else {
                if (sharedKey) {
                    messageHandler.openTwoButtonDialog(null, null,
                        "dialog.passwordCheck",
                        null,
                        false,
                        "dialog.Remove",
                        function (e, v) {
                            if (v) {
                                Toolbar.setSharedKey('');
                                lockRoom(false);
                            }
                        });
                } else {
                    var msg = APP.translation.generateTranslationHTML(
                        "dialog.passwordMsg");
                    var yourPassword = APP.translation.translateString(
                        "dialog.yourPassword");
                    messageHandler.openTwoButtonDialog(null, null, null,
                        '<h2>' + msg + '</h2>' +
                        '<input name="lockKey" type="text"' +
                        ' data-i18n="[placeholder]dialog.yourPassword" ' +
                        'placeholder="' + yourPassword + '" autofocus>',
                        false,
                        "dialog.Save",
                        function (e, v, m, f) {
                            if (v) {
                                var lockKey = f.lockKey;
                                
                                if (lockKey) {
                                    Toolbar.setSharedKey(
                                        UIUtil.escapeHtml(lockKey));
                                    lockRoom(true);
                                }
                            }
                        },
                        null, null, 'input:first'
                    );
                }
            }
        };
        
        /**
         * Opens the invite link dialog.
         */
        my.openLinkDialog = function () {
            var inviteAttributes;
            
            if (roomUrl === null) {
                inviteAttributes = 'data-i18n="[value]roomUrlDefaultMsg" value="' +
                    APP.translation.translateString("roomUrlDefaultMsg") + '"';
            } else {
                inviteAttributes = "value=\"" + encodeURI(roomUrl) + "\"";
            }
            messageHandler.openTwoButtonDialog("dialog.shareLink",
                null, null,
                '<input id="inviteLinkRef" type="text" ' +
                inviteAttributes + ' onclick="this.select();" readonly>',
                false,
                "dialog.Invite",
                function (e, v) {
                    if (v) {
                        if (roomUrl) {
                            inviteParticipants();
                        }
                    }
                },
                function (event) {
                    if (roomUrl) {
                        document.getElementById('inviteLinkRef').select();
                    } else {
                        if (event && event.target)
                            $(event.target)
                                .find('button[value=true]').prop('disabled', true);
                    }
                }
            );
        };
        
        /**
         * Opens the settings dialog.
         * FIXME: not used ?
         */
        my.openSettingsDialog = function () {
            var settings1 = APP.translation.generateTranslationHTML(
                "dialog.settings1");
            var settings2 = APP.translation.generateTranslationHTML(
                "dialog.settings2");
            var settings3 = APP.translation.generateTranslationHTML(
                "dialog.settings3");
            
            var yourPassword = APP.translation.translateString(
                "dialog.yourPassword");
            
            messageHandler.openTwoButtonDialog(null,
                '<h2>' + settings1 + '</h2>' +
                '<input type="checkbox" id="initMuted">' +
                settings2 + '<br/>' +
                '<input type="checkbox" id="requireNicknames">' +
                settings3 +
                '<input id="lockKey" type="text" placeholder="' + yourPassword +
                '" data-i18n="[placeholder]dialog.yourPassword" autofocus>',
                null,
                null,
                false,
                "dialog.Save",
                function () {
                    document.getElementById('lockKey').focus();
                },
                function (e, v) {
                    if (v) {
                        if ($('#initMuted').is(":checked")) {
                            // it is checked
                        }
                        
                        if ($('#requireNicknames').is(":checked")) {
                            // it is checked
                        }
                        /*
                         var lockKey = document.getElementById('lockKey');
                        
                         if (lockKey.value) {
                         setSharedKey(lockKey.value);
                         lockRoom(true);
                         }
                         */
                    }
                }
            );
        };
        
        /**
         * Toggles the application in and out of full screen mode
         * (a.k.a. presentation mode in Chrome).
         */
        my.toggleFullScreen = function () {
            var fsElement = document.documentElement;
            
            if (!document.mozFullScreen && !document.webkitIsFullScreen) {
                //Enter Full Screen
                if (fsElement.mozRequestFullScreen) {
                    fsElement.mozRequestFullScreen();
                }
                else {
                    fsElement.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                //Exit Full Screen
                if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else {
                    document.webkitCancelFullScreen();
                }
            }
        };
        /**
         * Unlocks the lock button state.
         */
        my.unlockLockButton = function () {
            if ($("#toolbar_button_security").hasClass("icon-security-locked"))
                UIUtil.buttonClick("#toolbar_button_security", "icon-security icon-security-locked");
        };
        /**
         * Updates the lock button state to locked.
         */
        my.lockLockButton = function () {
            if ($("#toolbar_button_security").hasClass("icon-security"))
                UIUtil.buttonClick("#toolbar_button_security", "icon-security icon-security-locked");
        };
        
        /**
         * Shows or hides authentication button
         * @param show <tt>true</tt> to show or <tt>false</tt> to hide
         */
        my.showAuthenticateButton = function (show) {
            if (UIUtil.isButtonEnabled('authentication') && show) {
                $('#authentication').css({display: "inline"});
            }
            else {
                $('#authentication').css({display: "none"});
            }
        };
        
        // Shows or hides the 'recording' button.
        my.showRecordingButton = function (show) {
            if (UIUtil.isButtonEnabled('recording') && show) {
                $('#toolbar_button_record').css({display: "inline-block"});
            }
            else {
                $('#toolbar_button_record').css({display: "none"});
            }
        };
        
        // Sets the state of the recording button
        my.setRecordingButtonState = function (recordingState) {
            var selector = $('#toolbar_button_record');
            
            if (recordingState === 'on') {
                selector.removeClass("icon-recEnable");
                selector.addClass("icon-recEnable active");
                
                $("#largeVideo").toggleClass("videoMessageFilter", true);
                var recordOnKey = "recording.on";
                $('#videoConnectionMessage').attr("data-i18n", recordOnKey);
                $('#videoConnectionMessage').text(APP.translation.translateString(recordOnKey));
                
                setTimeout(function(){
                    $("#largeVideo").toggleClass("videoMessageFilter", false);
                    $('#videoConnectionMessage').css({display: "none"});
                }, 1500);
                
                recordingToaster = messageHandler.notify(null, "recording.toaster", null,
                    null, null, {timeOut: 0, closeButton: null, tapToDismiss: false});
            } else if (recordingState === 'off') {
                selector.removeClass("icon-recEnable active");
                selector.addClass("icon-recEnable");
                
                $("#largeVideo").toggleClass("videoMessageFilter", false);
                $('#videoConnectionMessage').css({display: "none"});
                
                if (recordingToaster)
                    messageHandler.remove(recordingToaster);
                
            } else if (recordingState === 'pending') {
                selector.removeClass("icon-recEnable active");
                selector.addClass("icon-recEnable");
                
                $("#largeVideo").toggleClass("videoMessageFilter", true);
                var recordPendingKey = "recording.pending";
                $('#videoConnectionMessage').attr("data-i18n", recordPendingKey);
                $('#videoConnectionMessage').text(APP.translation.translateString(recordPendingKey));
                $('#videoConnectionMessage').css({display: "block"});
            }
        };
        
        // checks whether recording is enabled and whether we have params to start automatically recording
        my.checkAutoRecord = function () {
            if (UIUtil.isButtonEnabled('recording') && config.autoRecord) {
                toggleRecording(config.autoRecordToken);
            }
        };
        
        // Shows or hides SIP calls button
        my.showSipCallButton = function (show) {
            if (APP.xmpp.isSipGatewayEnabled() && UIUtil.isButtonEnabled('sip') && show) {
                $('#toolbar_button_sip').css({display: "inline-block"});
            } else {
                $('#toolbar_button_sip').css({display: "none"});
            }
        };
        
        // Shows or hides the dialpad button
        my.showDialPadButton = function (show) {
            if (UIUtil.isButtonEnabled('dialpad') && show) {
                $('#toolbar_button_dialpad').css({display: "inline-block"});
            } else {
                $('#toolbar_button_dialpad').css({display: "none"});
            }
        };
        
        /**
         * Displays user authenticated identity name(login).
         * @param authIdentity identity name to be displayed.
         */
        my.setAuthenticatedIdentity = function (authIdentity) {
            if (authIdentity) {
                var selector = $('#toolbar_auth_identity');
                selector.css({display: "list-item"});
                selector.text(authIdentity);
            } else {
                $('#toolbar_auth_identity').css({display: "none"});
            }
        };
        
        /**
         * Shows/hides login button.
         * @param show <tt>true</tt> to show
         */
        my.showLoginButton = function (show) {
            if (UIUtil.isButtonEnabled('authentication') && show) {
                $('#toolbar_button_login').css({display: "list-item"});
            } else {
                $('#toolbar_button_login').css({display: "none"});
            }
        };
        
        /**
         * Shows/hides logout button.
         * @param show <tt>true</tt> to show
         */
        my.showLogoutButton = function (show) {
            if (UIUtil.isButtonEnabled('authentication') && show) {
                $('#toolbar_button_logout').css({display: "list-item"});
            } else {
                $('#toolbar_button_logout').css({display: "none"});
            }
        };
        
        /**
         * Sets the state of the button. The button has blue glow if desktop
         * streaming is active.
         * @param active the state of the desktop streaming.
         */
        my.changeDesktopSharingButtonState = function (active) {
            var button = $("#toolbar_button_desktopsharing");
            if (active) {
                button.addClass("glow");
            } else {
                button.removeClass("glow");
            }
        };
        
        return my;
    }(Toolbar || {}));
    
    module.exports = Toolbar;
    
},{"../../../service/authentication/AuthenticationEvents":182,"../../statistics/AnalyticsAdapter":51,"../authentication/Authentication":13,"../etherpad/Etherpad":16,"../prezi/Prezi":17,"../side_pannels/SidePanelToggler":19,"../util/MessageHandler":30,"../util/UIUtil":32,"./BottomToolbar":26}],28:[function(require,module,exports){
    /* global APP, config, $, interfaceConfig, Moderator,
     DesktopStreaming.showDesktopSharingButton */
    
    var toolbarTimeoutObject,
        toolbarTimeout = interfaceConfig.INITIAL_TOOLBAR_TIMEOUT,
        UIUtil = require("../util/UIUtil");
    
    function showDesktopSharingButton() {
        if (APP.desktopsharing.isDesktopSharingEnabled() &&
            UIUtil.isButtonEnabled('desktop')) {
            $('#toolbar_button_desktopsharing').css({display: "inline-block"});
        } else {
            $('#toolbar_button_desktopsharing').css({display: "none"});
        }
    }
    
    /**
     * Hides the toolbar.
     */
    function hideToolbar() {
        if(config.alwaysVisibleToolbar)
            return;
        
        var header = $("#header"),
            bottomToolbar = $("#bottomToolbar");
        var isToolbarHover = false;
        header.find('*').each(function () {
            var id = $(this).attr('id');
            if ($("#" + id + ":hover").length > 0) {
                isToolbarHover = true;
            }
        });
        if ($("#bottomToolbar:hover").length > 0) {
            isToolbarHover = true;
        }
        
        clearTimeout(toolbarTimeoutObject);
        toolbarTimeoutObject = null;
        
        if (!isToolbarHover) {
            header.hide("slide", { direction: "up", duration: 300});
            $('#subject').animate({top: "-=40"}, 300);
            if ($("#remoteVideos").hasClass("hidden")) {
                bottomToolbar.hide(
                    "slide", {direction: "right", duration: 300});
            }
        }
        else {
            toolbarTimeoutObject = setTimeout(hideToolbar, toolbarTimeout);
        }
    }
    
    var ToolbarToggler = {
        /**
         * Shows the main toolbar.
         */
        showToolbar: function () {
            if (interfaceConfig.filmStripOnly)
                return;
            var header = $("#header"),
                bottomToolbar = $("#bottomToolbar");
            if (!header.is(':visible') || !bottomToolbar.is(":visible")) {
                header.show("slide", { direction: "up", duration: 300});
                $('#subject').animate({top: "+=40"}, 300);
                if (!bottomToolbar.is(":visible")) {
                    bottomToolbar.show(
                        "slide", {direction: "right", duration: 300});
                }
                
                if (toolbarTimeoutObject) {
                    clearTimeout(toolbarTimeoutObject);
                    toolbarTimeoutObject = null;
                }
                toolbarTimeoutObject = setTimeout(hideToolbar, toolbarTimeout);
                toolbarTimeout = interfaceConfig.TOOLBAR_TIMEOUT;
            }
            
            if (APP.xmpp.isModerator())
            {
                //            TODO: Enable settings functionality.
                //                  Need to uncomment the settings button in index.html.
                //            $('#settingsButton').css({visibility:"visible"});
            }
            
            // Show/hide desktop sharing button
            showDesktopSharingButton();
        },
        
        /**
         * Docks/undocks the toolbar.
         *
         * @param isDock indicates what operation to perform
         */
        dockToolbar: function (isDock) {
            if (interfaceConfig.filmStripOnly)
                return;
            
            if (isDock) {
                // First make sure the toolbar is shown.
                if (!$('#header').is(':visible')) {
                    this.showToolbar();
                }
                
                // Then clear the time out, to dock the toolbar.
                if (toolbarTimeoutObject) {
                    clearTimeout(toolbarTimeoutObject);
                    toolbarTimeoutObject = null;
                }
            }
            else {
                if (!$('#header').is(':visible')) {
                    this.showToolbar();
                }
                else {
                    toolbarTimeoutObject = setTimeout(hideToolbar, toolbarTimeout);
                }
            }
        },
        
        showDesktopSharingButton: showDesktopSharingButton
    };
    
    module.exports = ToolbarToggler;
},{"../util/UIUtil":32}],29:[function(require,module,exports){
    /* global $ */
    var JitsiPopover = (function () {
        /**
         * Constructs new JitsiPopover and attaches it to the element
         * @param element jquery selector
         * @param options the options for the popover.
         * @constructor
         */
        function JitsiPopover(element, options)
        {
            this.options = {
                skin: "white",
                content: ""
            };
            if(options)
            {
                if(options.skin)
                    this.options.skin = options.skin;
                
                if(options.content)
                    this.options.content = options.content;
            }
            
            this.elementIsHovered = false;
            this.popoverIsHovered = false;
            this.popoverShown = false;
            
            element.data("jitsi_popover", this);
            this.element = element;
            this.template = ' <div class="jitsipopover ' + this.options.skin +
                '"><div class="arrow"></div>' +
                '<div class="jitsipopover-content"></div>' +
                '<div class="jitsiPopupmenuPadding"></div></div>';
            var self = this;
            this.element.on("mouseenter", function () {
                self.elementIsHovered = true;
                self.show();
            }).on("mouseleave", function () {
                self.elementIsHovered = false;
                setTimeout(function () {
                    self.hide();
                }, 10);
            });
        }
        
        /**
         * Shows the popover
         */
        JitsiPopover.prototype.show = function () {
            if(!JitsiPopover.enabled)
                return;
            this.createPopover();
            this.popoverShown = true;
        };
        
        /**
         * Hides the popover
         */
        JitsiPopover.prototype.hide = function () {
            if(!this.elementIsHovered && !this.popoverIsHovered &&
                this.popoverShown) {
                this.forceHide();
            }
        };
        
        /**
         * Hides the popover.
         */
        JitsiPopover.prototype.forceHide = function () {
            $(".jitsipopover").remove();
            this.popoverShown = false;
        };
        
        /**
         * Creates the popover html.
         */
        JitsiPopover.prototype.createPopover = function () {
            $("body").append(this.template);
            $(".jitsipopover > .jitsipopover-content").html(this.options.content);
            var self = this;
            $(".jitsipopover").on("mouseenter", function () {
                self.popoverIsHovered = true;
            }).on("mouseleave", function () {
                self.popoverIsHovered = false;
                self.hide();
            });
            
            this.refreshPosition();
        };
        
        /**
         * Refreshes the position of the popover.
         */
        JitsiPopover.prototype.refreshPosition = function () {
            $(".jitsipopover").position({
                my: "bottom",
                at: "top",
                collision: "fit",
                of: this.element,
                using: function (position, elements) {
                    var calcLeft = elements.target.left - elements.element.left +
                        elements.target.width/2;
                    $(".jitsipopover").css(
                        {top: position.top, left: position.left, display: "table"});
                    $(".jitsipopover > .arrow").css({left: calcLeft});
                    $(".jitsipopover > .jitsiPopupmenuPadding").css(
                        {left: calcLeft - 50});
                }
            });
        };
        
        /**
         * Updates the content of popover.
         * @param content new content
         */
        JitsiPopover.prototype.updateContent = function (content) {
            this.options.content = content;
            if(!this.popoverShown)
                return;
            $(".jitsipopover").remove();
            this.createPopover();
        };
        
        JitsiPopover.enabled = true;
        
        return JitsiPopover;
    })();
    
    module.exports = JitsiPopover;
},{}],30:[function(require,module,exports){
    /* global $, APP, jQuery, toastr, Impromptu */
    /* jshint -W101 */
    
    /**
     * Flag for enable/disable of the notifications.
     * @type {boolean}
     */
    var notificationsEnabled = true;
    
    var messageHandler = (function(my) {
        
        /**
         * Shows a message to the user.
         *
         * @param titleKey the key used to find the translation of the title of the
         * message, if a message title is not provided.
         * @param messageKey the key used to find the translation of the message,
         * if a message is not provided.
         * @param title the title of the message. If a falsy value is provided,
         * titleKey will be used to get a title via the translation API.
         * @param message the message to show. If a falsy value is provided,
         * messageKey will be used to get a message via the translation API.
         */
        my.openMessageDialog = function(titleKey, messageKey, title, message) {
            if (!title) {
                title = APP.translation.generateTranslationHTML(titleKey);
            }
            if (!message) {
                message = APP.translation.generateTranslationHTML(messageKey);
            }
            
            $.prompt(message,
                {title: title, persistent: false}
            );
        };
        
        /**
         * Shows a message to the user with two buttons: first is given as a
         * parameter and the second is Cancel.
         *
         * @param titleString the title of the message
         * @param msgString the text of the message
         * @param persistent boolean value which determines whether the message is
         *        persistent or not
         * @param leftButton the fist button's text
         * @param submitFunction function to be called on submit
         * @param loadedFunction function to be called after the prompt is fully
         *        loaded
         * @param closeFunction function to be called after the prompt is closed
         * @param focus optional focus selector or button index to be focused after
         *        the dialog is opened
         * @param defaultButton index of default button which will be activated when
         *        the user press 'enter'. Indexed from 0.
         */
        my.openTwoButtonDialog = function(titleKey, titleString, msgKey, msgString,
                                          persistent, leftButtonKey, submitFunction, loadedFunction,
                                          closeFunction, focus, defaultButton) {
            var buttons = [];
            
            var leftButton = APP.translation.generateTranslationHTML(leftButtonKey);
            buttons.push({ title: leftButton, value: true});
            
            var cancelButton
                = APP.translation.generateTranslationHTML("dialog.Cancel");
            buttons.push({title: cancelButton, value: false});
            
            var message = msgString, title = titleString;
            if (titleKey) {
                title = APP.translation.generateTranslationHTML(titleKey);
            }
            if (msgKey) {
                message = APP.translation.generateTranslationHTML(msgKey);
            }
            $.prompt(message, {
                title: title,
                persistent: false,
                buttons: buttons,
                defaultButton: defaultButton,
                focus: focus,
                loaded: loadedFunction,
                submit: submitFunction,
                close: closeFunction
            });
        };
        
        /**
         * Shows a message to the user with two buttons: first is given as a parameter and the second is Cancel.
         *
         * @param titleString the title of the message
         * @param msgString the text of the message
         * @param persistent boolean value which determines whether the message is
         *        persistent or not
         * @param buttons object with the buttons. The keys must be the name of the
         *        button and value is the value that will be passed to
         *        submitFunction
         * @param submitFunction function to be called on submit
         * @param loadedFunction function to be called after the prompt is fully
         *        loaded
         */
        my.openDialog = function (titleString, msgString, persistent, buttons,
                                  submitFunction, loadedFunction) {
            var args = {
                title: titleString,
                persistent: persistent,
                buttons: buttons,
                defaultButton: 1,
                loaded: loadedFunction,
                submit: submitFunction
            };
            if (persistent) {
                args.closeText = '';
            }
            return new Impromptu(msgString, args);
        };
        
        /**
         * Closes currently opened dialog.
         */
        my.closeDialog = function () {
            $.prompt.close();
        };
        
        /**
         * Shows a dialog with different states to the user.
         *
         * @param statesObject object containing all the states of the dialog.
         */
        my.openDialogWithStates = function (statesObject, options) {
            return new Impromptu(statesObject, options);
        };
        
        /**
         * Opens new popup window for given <tt>url</tt> centered over current
         * window.
         *
         * @param url the URL to be displayed in the popup window
         * @param w the width of the popup window
         * @param h the height of the popup window
         * @param onPopupClosed optional callback function called when popup window
         *        has been closed.
         *
         * @returns {object} popup window object if opened successfully or undefined
         *          in case we failed to open it(popup blocked)
         */
        my.openCenteredPopup = function (url, w, h, onPopupClosed) {
            var l = window.screenX + (window.innerWidth / 2) - (w / 2);
            var t = window.screenY + (window.innerHeight / 2) - (h / 2);
            var popup = window.open(
                url, '_blank',
                'top=' + t + ', left=' + l + ', width=' + w + ', height=' + h + '');
            if (popup && onPopupClosed) {
                var pollTimer = window.setInterval(function () {
                    if (popup.closed !== false) {
                        window.clearInterval(pollTimer);
                        onPopupClosed();
                    }
                }, 200);
            }
            return popup;
        };
        
        /**
         * Shows a dialog prompting the user to send an error report.
         *
         * @param titleKey the title of the message
         * @param msgKey the text of the message
         * @param error the error that is being reported
         */
        my.openReportDialog = function(titleKey, msgKey, error) {
            my.openMessageDialog(titleKey, msgKey);
            console.log(error);
            //FIXME send the error to the server
        };
        
        /**
         *  Shows an error dialog to the user.
         * @param titleKey the title of the message.
         * @param msgKey the text of the message.
         */
        my.showError = function(titleKey, msgKey) {
            
            if (!titleKey) {
                titleKey = "dialog.oops";
            }
            if (!msgKey) {
                msgKey = "dialog.defaultError";
            }
            messageHandler.openMessageDialog(titleKey, msgKey);
        };
        
        /**
         * Displayes notification.
         * @param displayName display name of the participant that is associated with the notification.
         * @param displayNameKey the key from the language file for the display name.
         * @param cls css class for the notification
         * @param messageKey the key from the language file for the text of the message.
         * @param messageArguments object with the arguments for the message.
         * @param options object with language options.
         */
        my.notify = function(displayName, displayNameKey,
                             cls, messageKey, messageArguments, options) {
            if(!notificationsEnabled)
                return;
            var displayNameSpan = '<span class="nickname" ';
            if (displayName) {
                displayNameSpan += ">" + displayName;
            } else {
                displayNameSpan += "data-i18n='" + displayNameKey +
                    "'>" + APP.translation.translateString(displayNameKey);
            }
            displayNameSpan += "</span>";
            return toastr.info(
                displayNameSpan + '<br>' +
                '<span class=' + cls + ' data-i18n="' + messageKey + '"' +
                (messageArguments?
                " data-i18n-options='" + JSON.stringify(messageArguments) + "'"
                    : "") + ">" +
                APP.translation.translateString(messageKey,
                    messageArguments) +
                '</span>', null, options);
        };
        
        /**
         * Removes the toaster.
         * @param toasterElement
         */
        my.remove = function(toasterElement) {
            toasterElement.remove();
        };
        
        /**
         * Disables notifications.
         */
        my.disableNotifications = function () {
            notificationsEnabled = false;
        };
        
        /**
         * Enables notifications.
         */
        my.enableNotifications = function () {
            notificationsEnabled = true;
        };
        
        return my;
    }(messageHandler || {}));
    
    module.exports = messageHandler;
    
    
    
},{}],31:[function(require,module,exports){
    var UIEvents = require("../../../service/UI/UIEvents");
    
    var nickname = null;
    var eventEmitter = null;
    
    var NicknameHandler = {
        init: function (emitter) {
            eventEmitter = emitter;
            var storedDisplayName = window.localStorage.displayname;
            if (storedDisplayName) {
                nickname = storedDisplayName;
            }
        },
        setNickname: function (newNickname) {
            if (!newNickname || nickname === newNickname)
                return;
            
            nickname = newNickname;
            window.localStorage.displayname = nickname;
            eventEmitter.emit(UIEvents.NICKNAME_CHANGED, newNickname);
        },
        getNickname: function () {
            return nickname;
        },
        addListener: function (type, listener) {
            eventEmitter.on(type, listener);
        }
    };
    
    module.exports = NicknameHandler;
},{"../../../service/UI/UIEvents":181}],32:[function(require,module,exports){
    /* global $, config, interfaceConfig */
    /**
     * Created by hristo on 12/22/14.
     */
    var UIUtil = module.exports = {
        /**
         * Returns the available video width.
         */
        getAvailableVideoWidth: function (isVisible) {
            var PanelToggler = require("../side_pannels/SidePanelToggler");
            if(typeof isVisible === "undefined" || isVisible === null)
                isVisible = PanelToggler.isVisible();
            var rightPanelWidth
                = isVisible ? PanelToggler.getPanelSize()[0] : 0;
            
            return window.innerWidth - rightPanelWidth;
        },
        /**
         * Changes the style class of the element given by id.
         */
        buttonClick: function(id, classname) {
            $(id).toggleClass(classname); // add the class to the clicked element
        },
        /**
         * Returns the text width for the given element.
         *
         * @param el the element
         */
        getTextWidth: function (el) {
            return (el.clientWidth + 1);
        },
        
        /**
         * Returns the text height for the given element.
         *
         * @param el the element
         */
        getTextHeight: function (el) {
            return (el.clientHeight + 1);
        },
        
        /**
         * Plays the sound given by id.
         *
         * @param id the identifier of the audio element.
         */
        playSoundNotification: function (id) {
            document.getElementById(id).play();
        },
        
        /**
         * Escapes the given text.
         */
        escapeHtml: function (unsafeText) {
            return $('<div/>').text(unsafeText).html();
        },
        
        imageToGrayScale: function (canvas) {
            var context = canvas.getContext('2d');
            var imgData = context.getImageData(0, 0, canvas.width, canvas.height);
            var pixels  = imgData.data;
            
            for (var i = 0, n = pixels.length; i < n; i += 4) {
                var grayscale
                    = pixels[i] * 0.3 + pixels[i+1] * 0.59 + pixels[i+2] * 0.11;
                pixels[i  ] = grayscale;        // red
                pixels[i+1] = grayscale;        // green
                pixels[i+2] = grayscale;        // blue
                // pixels[i+3]              is alpha
            }
            // redraw the image in black & white
            context.putImageData(imgData, 0, 0);
        },
        
        setTooltip: function (element, key, position) {
            element.setAttribute("data-i18n", "[data-content]" + key);
            element.setAttribute("data-toggle", "popover");
            element.setAttribute("data-placement", position);
            element.setAttribute("data-html", true);
            element.setAttribute("data-container", "body");
        },
        
        /**
         * Inserts given child element as the first one into the container.
         * @param container the container to which new child element will be added
         * @param newChild the new element that will be inserted into the container
         */
        prependChild: function (container, newChild) {
            var firstChild = container.childNodes[0];
            if (firstChild) {
                container.insertBefore(newChild, firstChild);
            } else {
                container.appendChild(newChild);
            }
        },
        
        isButtonEnabled: function (name) {
            var isEnabled = interfaceConfig.TOOLBAR_BUTTONS.indexOf(name) !== -1;
            if (name === 'prezi') {
                return isEnabled && !config.disablePrezi;
            } else if (name === 'recording') {
                return isEnabled && config.enableRecording;
            }
            return isEnabled;
        },
        
        hideDisabledButtons: function (mappings) {
            var selector = Object.keys(mappings)
                .map(function (buttonName) {
                    return UIUtil.isButtonEnabled(buttonName)
                        ? null : mappings[buttonName]; })
                .filter(function (item) { return item; })
                .join(',');
            $(selector).hide();
        }
    };
},{"../side_pannels/SidePanelToggler":19}],33:[function(require,module,exports){
    /* global APP, $ */
    /* jshint -W101 */
    var JitsiPopover = require("../util/JitsiPopover");
    
    /**
     * Constructs new connection indicator.
     * @param videoContainer the video container associated with the indicator.
     * @constructor
     */
    function ConnectionIndicator(videoContainer, jid) {
        this.videoContainer = videoContainer;
        this.bandwidth = null;
        this.packetLoss = null;
        this.bitrate = null;
        this.showMoreValue = false;
        this.resolution = null;
        this.transport = [];
        this.popover = null;
        this.jid = jid;
        this.create();
    }
    
    /**
     * Values for the connection quality
     * @type {{98: string,
 *         81: string,
 *         64: string,
 *         47: string,
 *         30: string,
 *         0: string}}
     */
    ConnectionIndicator.connectionQualityValues = {
        98: "18px", //full
        81: "15px",//4 bars
        64: "11px",//3 bars
        47: "7px",//2 bars
        30: "3px",//1 bar
        0: "0px"//empty
    };
    
    ConnectionIndicator.getIP = function(value) {
        return value.substring(0, value.lastIndexOf(":"));
    };
    
    ConnectionIndicator.getPort = function(value) {
        return value.substring(value.lastIndexOf(":") + 1, value.length);
    };
    
    ConnectionIndicator.getStringFromArray = function (array) {
        var res = "";
        for(var i = 0; i < array.length; i++) {
            res += (i === 0? "" : ", ") + array[i];
        }
        return res;
    };
    
    /**
     * Generates the html content.
     * @returns {string} the html content.
     */
    ConnectionIndicator.prototype.generateText = function () {
        var downloadBitrate, uploadBitrate, packetLoss, resolution, i;
        
        var translate = APP.translation.translateString;
        
        if(this.bitrate === null) {
            downloadBitrate = "N/A";
            uploadBitrate = "N/A";
        }
        else {
            downloadBitrate =
                this.bitrate.download? this.bitrate.download + " Kbps" : "N/A";
            uploadBitrate =
                this.bitrate.upload? this.bitrate.upload + " Kbps" : "N/A";
        }
        
        if(this.packetLoss === null) {
            packetLoss = "N/A";
        } else {
            
            packetLoss = "<span class='jitsipopover_green'>&darr;</span>" +
                (this.packetLoss.download !== null ?
                    this.packetLoss.download : "N/A") +
                "% <span class='jitsipopover_orange'>&uarr;</span>" +
                (this.packetLoss.upload !== null? this.packetLoss.upload : "N/A") +
                "%";
        }
        
        var resolutionValue = null;
        if(this.resolution && this.jid) {
            var keys = Object.keys(this.resolution);
            for(var ssrc in this.resolution) {
                resolutionValue = this.resolution[ssrc];
            }
        }
        
        if(this.jid === null) {
            resolution = "";
            if(this.resolution === null || !Object.keys(this.resolution) ||
                Object.keys(this.resolution).length === 0) {
                resolution = "N/A";
            } else {
                for (i in this.resolution) {
                    resolutionValue = this.resolution[i];
                    if (resolutionValue) {
                        if (resolutionValue.height &&
                            resolutionValue.width) {
                            resolution += (resolution === "" ? "" : ", ") +
                                resolutionValue.width + "x" +
                                resolutionValue.height;
                        }
                    }
                }
            }
        } else if(!resolutionValue ||
            !resolutionValue.height ||
            !resolutionValue.width) {
            resolution = "N/A";
        } else {
            resolution = resolutionValue.width + "x" + resolutionValue.height;
        }
        
        var result = "<table style='width:100%'>" +
            "<tr>" +
            "<td><span class='jitsipopover_blue' data-i18n='connectionindicator.bitrate'>" +
            translate("connectionindicator.bitrate") + "</span></td>" +
            "<td><span class='jitsipopover_green'>&darr;</span>" +
            downloadBitrate + " <span class='jitsipopover_orange'>&uarr;</span>" +
            uploadBitrate + "</td>" +
            "</tr><tr>" +
            "<td><span class='jitsipopover_blue' data-i18n='connectionindicator.packetloss'>" +
            translate("connectionindicator.packetloss") + "</span></td>" +
            "<td>" + packetLoss  + "</td>" +
            "</tr><tr>" +
            "<td><span class='jitsipopover_blue' data-i18n='connectionindicator.resolution'>" +
            translate("connectionindicator.resolution") + "</span></td>" +
            "<td>" + resolution + "</td></tr></table>";
        
        if(this.videoContainer.videoSpanId == "localVideoContainer") {
            result += "<div class=\"jitsipopover_showmore\" " +
                "onclick = \"APP.UI.connectionIndicatorShowMore('" +
                    // FIXME: we do not know local jid when this text is generated
                    //this.jid + "')\"  data-i18n='connectionindicator." +
                "local')\"  data-i18n='connectionindicator." +
                (this.showMoreValue ? "less" : "more") + "'>" +
                translate("connectionindicator." + (this.showMoreValue ? "less" : "more")) +
                "</div><br />";
        }
        
        if (this.showMoreValue) {
            var downloadBandwidth, uploadBandwidth, transport;
            if (this.bandwidth === null) {
                downloadBandwidth = "N/A";
                uploadBandwidth = "N/A";
            } else {
                downloadBandwidth = this.bandwidth.download?
                this.bandwidth.download + " Kbps" :
                    "N/A";
                uploadBandwidth = this.bandwidth.upload?
                this.bandwidth.upload + " Kbps" :
                    "N/A";
            }
            
            if (!this.transport || this.transport.length === 0) {
                transport = "<tr>" +
                    "<td><span class='jitsipopover_blue' " +
                    "data-i18n='connectionindicator.address'>" +
                    translate("connectionindicator.address") + "</span></td>" +
                    "<td> N/A</td></tr>";
            } else {
                var data = {remoteIP: [], localIP:[], remotePort:[], localPort:[]};
                for(i = 0; i < this.transport.length; i++) {
                    var ip =  ConnectionIndicator.getIP(this.transport[i].ip);
                    var port = ConnectionIndicator.getPort(this.transport[i].ip);
                    var localIP =
                        ConnectionIndicator.getIP(this.transport[i].localip);
                    var localPort =
                        ConnectionIndicator.getPort(this.transport[i].localip);
                    if(data.remoteIP.indexOf(ip) == -1) {
                        data.remoteIP.push(ip);
                    }
                    
                    if(data.remotePort.indexOf(port) == -1) {
                        data.remotePort.push(port);
                    }
                    
                    if(data.localIP.indexOf(localIP) == -1) {
                        data.localIP.push(localIP);
                    }
                    
                    if(data.localPort.indexOf(localPort) == -1) {
                        data.localPort.push(localPort);
                    }
                }
                
                var local_address_key = "connectionindicator.localaddress";
                var remote_address_key = "connectionindicator.remoteaddress";
                var localTransport =
                    "<tr><td><span class='jitsipopover_blue' data-i18n='" +
                    local_address_key +"' data-i18n-options='" +
                    JSON.stringify({count: data.localIP.length}) + "'>" +
                    translate(local_address_key, {count: data.localIP.length}) +
                    "</span></td><td> " +
                    ConnectionIndicator.getStringFromArray(data.localIP) +
                    "</td></tr>";
                transport =
                    "<tr><td><span class='jitsipopover_blue' data-i18n='" +
                    remote_address_key + "' data-i18n-options='" +
                    JSON.stringify({count: data.remoteIP.length}) + "'>" +
                    translate(remote_address_key,
                        {count: data.remoteIP.length}) +
                    "</span></td><td> " +
                    ConnectionIndicator.getStringFromArray(data.remoteIP) +
                    "</td></tr>";
                
                var key_remote = "connectionindicator.remoteport",
                    key_local = "connectionindicator.localport";
                
                transport += "<tr>" +
                    "<td>" +
                    "<span class='jitsipopover_blue' data-i18n='" + key_remote +
                    "' data-i18n-options='" +
                    JSON.stringify({count: this.transport.length}) + "'>" +
                    translate(key_remote, {count: this.transport.length}) +
                    "</span></td><td>";
                localTransport += "<tr>" +
                    "<td>" +
                    "<span class='jitsipopover_blue' data-i18n='" + key_local +
                    "' data-i18n-options='" +
                    JSON.stringify({count: this.transport.length}) + "'>" +
                    translate(key_local, {count: this.transport.length}) +
                    "</span></td><td>";
                
                transport +=
                    ConnectionIndicator.getStringFromArray(data.remotePort);
                localTransport +=
                    ConnectionIndicator.getStringFromArray(data.localPort);
                transport += "</td></tr>";
                transport += localTransport + "</td></tr>";
                transport +="<tr>" +
                    "<td><span class='jitsipopover_blue' data-i18n='connectionindicator.transport'>" +
                    translate("connectionindicator.transport") + "</span></td>" +
                    "<td>" + this.transport[0].type + "</td></tr>";
                
            }
            
            result += "<table  style='width:100%'>" +
                "<tr>" +
                "<td>" +
                "<span class='jitsipopover_blue' data-i18n='connectionindicator.bandwidth'>" +
                translate("connectionindicator.bandwidth") + "</span>" +
                "</td><td>" +
                "<span class='jitsipopover_green'>&darr;</span>" +
                downloadBandwidth +
                " <span class='jitsipopover_orange'>&uarr;</span>" +
                uploadBandwidth + "</td></tr>";
            
            result += transport + "</table>";
        }
        
        return result;
    };
    
    /**
     * Shows or hide the additional information.
     */
    ConnectionIndicator.prototype.showMore = function () {
        this.showMoreValue = !this.showMoreValue;
        this.updatePopoverData();
    };
    
    
    function createIcon(classes) {
        var icon = document.createElement("span");
        for(var i in classes) {
            icon.classList.add(classes[i]);
        }
        icon.appendChild(
            document.createElement("i")).classList.add("icon-connection");
        return icon;
    }
    
    /**
     * Creates the indicator
     */
    ConnectionIndicator.prototype.create = function () {
        this.connectionIndicatorContainer = document.createElement("div");
        this.connectionIndicatorContainer.className = "connectionindicator";
        this.connectionIndicatorContainer.style.display = "none";
        this.videoContainer.container.appendChild(
            this.connectionIndicatorContainer);
        this.popover = new JitsiPopover(
            $("#" + this.videoContainer.videoSpanId + " > .connectionindicator"),
            {content: "<div class=\"connection_info\" data-i18n='connectionindicator.na'>" +
            APP.translation.translateString("connectionindicator.na") + "</div>",
                skin: "black"});
        
        this.emptyIcon = this.connectionIndicatorContainer.appendChild(
            createIcon(["connection", "connection_empty"]));
        this.fullIcon = this.connectionIndicatorContainer.appendChild(
            createIcon(["connection", "connection_full"]));
    };
    
    /**
     * Removes the indicator
     */
    ConnectionIndicator.prototype.remove = function() {
        if (this.connectionIndicatorContainer.parentNode) {
            this.connectionIndicatorContainer.parentNode.removeChild(
                this.connectionIndicatorContainer);
        }
        this.popover.forceHide();
    };
    
    /**
     * Updates the data of the indicator
     * @param percent the percent of connection quality
     * @param object the statistics data.
     */
    ConnectionIndicator.prototype.updateConnectionQuality =
        function (percent, object) {
            
            if (percent === null) {
                this.connectionIndicatorContainer.style.display = "none";
                this.popover.forceHide();
                return;
            } else {
                if(this.connectionIndicatorContainer.style.display == "none") {
                    this.connectionIndicatorContainer.style.display = "block";
                    this.videoContainer.updateIconPositions();
                }
            }
            this.bandwidth = object.bandwidth;
            this.bitrate = object.bitrate;
            this.packetLoss = object.packetLoss;
            this.transport = object.transport;
            if (object.resolution) {
                this.resolution = object.resolution;
            }
            for (var quality in ConnectionIndicator.connectionQualityValues) {
                if (percent >= quality) {
                    this.fullIcon.style.width =
                        ConnectionIndicator.connectionQualityValues[quality];
                }
            }
            this.updatePopoverData();
        };
    
    /**
     * Updates the resolution
     * @param resolution the new resolution
     */
    ConnectionIndicator.prototype.updateResolution = function (resolution) {
        this.resolution = resolution;
        this.updatePopoverData();
    };
    
    /**
     * Updates the content of the popover
     */
    ConnectionIndicator.prototype.updatePopoverData = function () {
        this.popover.updateContent(
            "<div class=\"connection_info\">" + this.generateText() + "</div>");
        APP.translation.translateElement($(".connection_info"));
    };
    
    /**
     * Hides the popover
     */
    ConnectionIndicator.prototype.hide = function () {
        this.popover.forceHide();
    };
    
    /**
     * Hides the indicator
     */
    ConnectionIndicator.prototype.hideIndicator = function () {
        this.connectionIndicatorContainer.style.display = "none";
        if(this.popover)
            this.popover.forceHide();
    };
    
    module.exports = ConnectionIndicator;
},{"../util/JitsiPopover":29}],34:[function(require,module,exports){
    /* global $, APP, Strophe, interfaceConfig */
    /* jshint -W101 */
    var Avatar = require("../avatar/Avatar");
    var RTCBrowserType = require("../../RTC/RTCBrowserType");
    var UIUtil = require("../util/UIUtil");
    var UIEvents = require("../../../service/UI/UIEvents");
    var xmpp = require("../../xmpp/xmpp");
    var ToolbarToggler = require("../toolbars/ToolbarToggler");
    
    // FIXME: With Temasys we have to re-select everytime
    //var video = $('#largeVideo');
    
    var currentVideoWidth = null;
    var currentVideoHeight = null;
    // By default we use camera
    var getVideoSize = getCameraVideoSize;
    var getVideoPosition = getCameraVideoPosition;
    /**
     * The small video instance that is displayed in the large video
     * @type {SmallVideo}
     */
    var currentSmallVideo = null;
    /**
     * Indicates whether the large video is enabled.
     * @type {boolean}
     */
    var isEnabled = true;
    /**
     * Current large video state.
     * Possible values - video, prezi or etherpad.
     * @type {string}
     */
    var state = "video";
    
    /**
     * Returns the html element associated with the passed state of large video
     * @param state the state.
     * @returns {JQuery|*|jQuery|HTMLElement} the container.
     */
    function getContainerByState(state)
    {
        var selector = null;
        switch (state)
        {
            case "video":
                selector = "#largeVideoWrapper";
                break;
            case "etherpad":
                selector = "#etherpad>iframe";
                break;
            case "prezi":
                selector = "#presentation>iframe";
                break;
        }
        return (selector !== null)? $(selector) : null;
    }
    
    /**
     * Sets the size and position of the given video element.
     *
     * @param video the video element to position
     * @param width the desired video width
     * @param height the desired video height
     * @param horizontalIndent the left and right indent
     * @param verticalIndent the top and bottom indent
     */
    function positionVideo(video,
                           width,
                           height,
                           horizontalIndent,
                           verticalIndent,
                           animate) {
        if (animate) {
            video.animate({
                    width: width,
                    height: height,
                    top: verticalIndent,
                    bottom: verticalIndent,
                    left: horizontalIndent,
                    right: horizontalIndent
                },
                {
                    queue: false,
                    duration: 500
                });
        } else {
            video.width(width);
            video.height(height);
            video.css({  top: verticalIndent + 'px',
                bottom: verticalIndent + 'px',
                left: horizontalIndent + 'px',
                right: horizontalIndent + 'px'});
        }
        
    }
    
    /**
     * Returns an array of the video dimensions, so that it keeps it's aspect
     * ratio and fits available area with it's larger dimension. This method
     * ensures that whole video will be visible and can leave empty areas.
     *
     * @return an array with 2 elements, the video width and the video height
     */
    function getDesktopVideoSize(videoWidth,
                                 videoHeight,
                                 videoSpaceWidth,
                                 videoSpaceHeight) {
        if (!videoWidth)
            videoWidth = currentVideoWidth;
        if (!videoHeight)
            videoHeight = currentVideoHeight;
        
        var aspectRatio = videoWidth / videoHeight;
        
        var availableWidth = Math.max(videoWidth, videoSpaceWidth);
        var availableHeight = Math.max(videoHeight, videoSpaceHeight);
        
        videoSpaceHeight -= $('#remoteVideos').outerHeight();
        
        if (availableWidth / aspectRatio >= videoSpaceHeight)
        {
            availableHeight = videoSpaceHeight;
            availableWidth = availableHeight * aspectRatio;
        }
        
        if (availableHeight * aspectRatio >= videoSpaceWidth)
        {
            availableWidth = videoSpaceWidth;
            availableHeight = availableWidth / aspectRatio;
        }
        
        return [availableWidth, availableHeight];
    }
    
    
    /**
     * Returns an array of the video horizontal and vertical indents,
     * so that if fits its parent.
     *
     * @return an array with 2 elements, the horizontal indent and the vertical
     * indent
     */
    function getCameraVideoPosition(videoWidth,
                                    videoHeight,
                                    videoSpaceWidth,
                                    videoSpaceHeight) {
        // Parent height isn't completely calculated when we position the video in
        // full screen mode and this is why we use the screen height in this case.
        // Need to think it further at some point and implement it properly.
        var isFullScreen = document.fullScreen ||
            document.mozFullScreen ||
            document.webkitIsFullScreen;
        if (isFullScreen)
            videoSpaceHeight = window.innerHeight;
        
        var horizontalIndent = (videoSpaceWidth - videoWidth) / 2;
        var verticalIndent = (videoSpaceHeight - videoHeight) / 2;
        
        return [horizontalIndent, verticalIndent];
    }
    
    /**
     * Returns an array of the video horizontal and vertical indents.
     * Centers horizontally and top aligns vertically.
     *
     * @return an array with 2 elements, the horizontal indent and the vertical
     * indent
     */
    function getDesktopVideoPosition(videoWidth,
                                     videoHeight,
                                     videoSpaceWidth,
                                     videoSpaceHeight) {
        
        var horizontalIndent = (videoSpaceWidth - videoWidth) / 2;
        
        var verticalIndent = 0;// Top aligned
        
        return [horizontalIndent, verticalIndent];
    }
    
    
    /**
     * Returns an array of the video dimensions. It respects the
     * VIDEO_LAYOUT_FIT config, to fit the video to the screen, by hiding some parts
     * of it, or to fit it to the height or width.
     *
     * @param videoWidth the original video width
     * @param videoHeight the original video height
     * @param videoSpaceWidth the width of the video space
     * @param videoSpaceHeight the height of the video space
     * @return an array with 2 elements, the video width and the video height
     */
    function getCameraVideoSize(videoWidth,
                                videoHeight,
                                videoSpaceWidth,
                                videoSpaceHeight) {
        
        if (!videoWidth)
            videoWidth = currentVideoWidth;
        if (!videoHeight)
            videoHeight = currentVideoHeight;
        
        var aspectRatio = videoWidth / videoHeight;
        
        var availableWidth = videoWidth;
        var availableHeight = videoHeight;
        
        if (interfaceConfig.VIDEO_LAYOUT_FIT == 'height') {
            availableHeight = videoSpaceHeight;
            availableWidth = availableHeight*aspectRatio;
        }
        else if (interfaceConfig.VIDEO_LAYOUT_FIT == 'width') {
            availableWidth = videoSpaceWidth;
            availableHeight = availableWidth/aspectRatio;
        }
        else if (interfaceConfig.VIDEO_LAYOUT_FIT == 'both') {
            availableWidth = Math.max(videoWidth, videoSpaceWidth);
            availableHeight = Math.max(videoHeight, videoSpaceHeight);
            
            if (availableWidth / aspectRatio < videoSpaceHeight) {
                availableHeight = videoSpaceHeight;
                availableWidth = availableHeight * aspectRatio;
            }
            
            if (availableHeight * aspectRatio < videoSpaceWidth) {
                availableWidth = videoSpaceWidth;
                availableHeight = availableWidth / aspectRatio;
            }
        }
        
        
        return [availableWidth, availableHeight];
    }
    
    /**
     * Updates the src of the active speaker avatar
     * @param jid of the current active speaker
     */
    function updateActiveSpeakerAvatarSrc() {
        var avatar = $("#activeSpeakerAvatar")[0];
        var jid = currentSmallVideo.peerJid;
        var url = Avatar.getActiveSpeakerUrl(jid);
        if (avatar.src === url)
            return;
        if (jid) {
            avatar.src = url;
            currentSmallVideo.showAvatar();
        }
    }
    
    /**
     * Change the video source of the large video.
     * @param isVisible
     */
    function changeVideo(isVisible) {
        
        if (!currentSmallVideo) {
            console.error("Unable to change large video - no 'currentSmallVideo'");
            return;
        }
        
        updateActiveSpeakerAvatarSrc();
        var largeVideoElement = $('#largeVideo')[0];
        
        APP.RTC.setVideoSrc(largeVideoElement, currentSmallVideo.getSrc());
        
        var flipX = currentSmallVideo.flipX;
        
        largeVideoElement.style.transform = flipX ? "scaleX(-1)" : "none";
        
        var isDesktop = currentSmallVideo.getVideoType() === 'screen';
        // Change the way we'll be measuring and positioning large video
        
        getVideoSize = isDesktop ? getDesktopVideoSize : getCameraVideoSize;
        getVideoPosition = isDesktop ? getDesktopVideoPosition :
            getCameraVideoPosition;
        
        
        // Only if the large video is currently visible.
        if (isVisible) {
            LargeVideo.VideoLayout.largeVideoUpdated(currentSmallVideo);
            
            $('#largeVideoWrapper').fadeTo(300, 1);
        }
    }
    
    /**
     * Creates the html elements for the large video.
     */
    function createLargeVideoHTML()
    {
        var html = '<div id="largeVideoContainer" class="videocontainer">';
        html += '<div id="presentation"></div>' +
            '<div id="etherpad"></div>' +
            '<a target="_new"><div class="watermark leftwatermark"></div></a>' +
            '<a target="_new"><div class="watermark rightwatermark"></div></a>' +
            '<a class="poweredby" href="http://jitsi.org" target="_new" >' +
            '<span data-i18n="poweredby"></span> jitsi.org' +
            '</a>'+
            '<div id="activeSpeaker">' +
            '<img id="activeSpeakerAvatar" src=""/>' +
            '<canvas id="activeSpeakerAudioLevel"></canvas>' +
            '</div>' +
            '<div id="largeVideoWrapper">' +
            '<video id="largeVideo" autoplay oncontextmenu="return false;"></video>' +
            '</div id="largeVideoWrapper">' +
            '<span id="videoConnectionMessage"></span>';
        html += '</div>';
        $(html).prependTo("#videospace");
        
        if (interfaceConfig.SHOW_JITSI_WATERMARK) {
            var leftWatermarkDiv
                = $("#largeVideoContainer div[class='watermark leftwatermark']");
            
            leftWatermarkDiv.css({display: 'block'});
            leftWatermarkDiv.parent().get(0).href
                = interfaceConfig.JITSI_WATERMARK_LINK;
        }
        
        if (interfaceConfig.SHOW_BRAND_WATERMARK) {
            var rightWatermarkDiv
                = $("#largeVideoContainer div[class='watermark rightwatermark']");
            
            rightWatermarkDiv.css({display: 'block'});
            rightWatermarkDiv.parent().get(0).href
                = interfaceConfig.BRAND_WATERMARK_LINK;
            rightWatermarkDiv.get(0).style.backgroundImage
                = "url(images/rightwatermark.png)";
        }
        
        if (interfaceConfig.SHOW_POWERED_BY) {
            $("#largeVideoContainer>a[class='poweredby']").css({display: 'block'});
        }
        
        if (!RTCBrowserType.isIExplorer()) {
            $('#largeVideo').volume = 0;
        }
    }
    
    var LargeVideo = {
        
        init: function (VideoLayout, emitter) {
            if(!isEnabled)
                return;
            createLargeVideoHTML();
            
            this.VideoLayout = VideoLayout;
            this.eventEmitter = emitter;
            this.eventEmitter.emit(UIEvents.LARGEVIDEO_INIT);
            var self = this;
            // Listen for large video size updates
            var largeVideo = $('#largeVideo')[0];
            var onplaying = function (arg1, arg2, arg3) {
                // re-select
                if (RTCBrowserType.isTemasysPluginUsed())
                    largeVideo = $('#largeVideo')[0];
                currentVideoWidth = largeVideo.videoWidth;
                currentVideoHeight = largeVideo.videoHeight;
                self.position(currentVideoWidth, currentVideoHeight);
            };
            largeVideo.onplaying = onplaying;
        },
        /**
         * Indicates if the large video is currently visible.
         *
         * @return <tt>true</tt> if visible, <tt>false</tt> - otherwise
         */
        isLargeVideoVisible: function() {
            return $('#largeVideoWrapper').is(':visible');
        },
        /**
         * Returns <tt>true</tt> if the user is currently displayed on large video.
         */
        isCurrentlyOnLarge: function (resourceJid) {
            return currentSmallVideo && resourceJid &&
                currentSmallVideo.getResourceJid() === resourceJid;
        },
        /**
         * Updates the large video with the given new video source.
         */
        updateLargeVideo: function (resourceJid, forceUpdate) {
            if(!isEnabled)
                return;
            var newSmallVideo = this.VideoLayout.getSmallVideo(resourceJid);
            console.info('hover in ' + resourceJid + ', video: ', newSmallVideo);
            
            if (!newSmallVideo) {
                console.error("Small video not found for: " + resourceJid);
                return;
            }
            
            if (!LargeVideo.isCurrentlyOnLarge(resourceJid) || forceUpdate) {
                $('#activeSpeaker').css('visibility', 'hidden');
                
                var oldSmallVideo = null;
                if (currentSmallVideo) {
                    oldSmallVideo = currentSmallVideo;
                }
                currentSmallVideo = newSmallVideo;
                
                var oldJid = null;
                if (oldSmallVideo)
                    oldJid = oldSmallVideo.peerJid;
                if (oldJid !== resourceJid) {
                    // we want the notification to trigger even if userJid is undefined,
                    // or null.
                    this.eventEmitter.emit(UIEvents.SELECTED_ENDPOINT, resourceJid);
                }
                // We are doing fadeOut/fadeIn animations on parent div which wraps
                // largeVideo, because when Temasys plugin is in use it replaces
                // <video> elements with plugin <object> tag. In Safari jQuery is
                // unable to store values on this plugin object which breaks all
                // animation effects performed on it directly.
                //
                // If for any reason large video was hidden before calling fadeOut
                // changeVideo will never be called, so we call show() in chain just
                // to be sure
                $('#largeVideoWrapper').show().fadeTo(300, 0,
                    changeVideo.bind($('#largeVideo'), this.isLargeVideoVisible()));
            } else {
                if (currentSmallVideo) {
                    currentSmallVideo.showAvatar();
                }
            }
            
        },
        
        /**
         * Shows/hides the large video.
         */
        setLargeVideoVisible: function(isVisible) {
            if(!isEnabled)
                return;
            if (isVisible) {
                $('#largeVideoWrapper').css({visibility: 'visible'});
                $('.watermark').css({visibility: 'visible'});
                if(currentSmallVideo)
                    currentSmallVideo.enableDominantSpeaker(true);
            }
            else {
                $('#largeVideoWrapper').css({visibility: 'hidden'});
                $('#activeSpeaker').css('visibility', 'hidden');
                $('.watermark').css({visibility: 'hidden'});
                if(currentSmallVideo)
                    currentSmallVideo.enableDominantSpeaker(false);
            }
        },
        onVideoTypeChanged: function (resourceJid, newVideoType) {
            if (!isEnabled)
                return;
            if (LargeVideo.isCurrentlyOnLarge(resourceJid))
            {
                var isDesktop = newVideoType === 'screen';
                getVideoSize = isDesktop ? getDesktopVideoSize : getCameraVideoSize;
                getVideoPosition = isDesktop ? getDesktopVideoPosition
                    : getCameraVideoPosition;
                this.position(null, null, null, null, true);
            }
        },
        /**
         * Positions the large video.
         *
         * @param videoWidth the stream video width
         * @param videoHeight the stream video height
         */
        position: function (videoWidth, videoHeight,
                            videoSpaceWidth, videoSpaceHeight, animate) {
            if(!isEnabled)
                return;
            if(!videoSpaceWidth)
                videoSpaceWidth = $('#videospace').width();
            if(!videoSpaceHeight)
                videoSpaceHeight = window.innerHeight;
            
            var videoSize = getVideoSize(videoWidth,
                videoHeight,
                videoSpaceWidth,
                videoSpaceHeight);
            
            var largeVideoWidth = videoSize[0];
            var largeVideoHeight = videoSize[1];
            
            var videoPosition = getVideoPosition(largeVideoWidth,
                largeVideoHeight,
                videoSpaceWidth,
                videoSpaceHeight);
            
            var horizontalIndent = videoPosition[0];
            var verticalIndent = videoPosition[1];
            
            positionVideo($('#largeVideoWrapper'),
                largeVideoWidth,
                largeVideoHeight,
                horizontalIndent, verticalIndent, animate);
        },
        /**
         * Resizes the large html elements.
         * @param animate boolean property that indicates whether the resize should be animated or not.
         * @param isChatVisible boolean property that indicates whether the chat area is displayed or not.
         * If that parameter is null the method will check the chat pannel visibility.
         * @param completeFunction a function to be called when the video space is resized
         * @returns {*[]} array with the current width and height values of the largeVideo html element.
         */
        resize: function (animate, isVisible, completeFunction) {
            if(!isEnabled)
                return;
            var availableHeight = window.innerHeight;
            var availableWidth = UIUtil.getAvailableVideoWidth(isVisible);
            
            if (availableWidth < 0 || availableHeight < 0) return;
            
            var avatarSize = interfaceConfig.ACTIVE_SPEAKER_AVATAR_SIZE;
            var top = availableHeight / 2 - avatarSize / 4 * 3;
            $('#activeSpeaker').css('top', top);
            
            this.VideoLayout.resizeVideoSpace(animate, isVisible, completeFunction);
            if(animate) {
                $('#largeVideoContainer').animate({
                        width: availableWidth,
                        height: availableHeight
                    },
                    {
                        queue: false,
                        duration: 500
                    });
            } else {
                $('#largeVideoContainer').width(availableWidth);
                $('#largeVideoContainer').height(availableHeight);
            }
            return [availableWidth, availableHeight];
        },
        resizeVideoAreaAnimated: function (isVisible, completeFunction) {
            if(!isEnabled)
                return;
            var size = this.resize(true, isVisible, completeFunction);
            this.position(null, null, size[0], size[1], true);
        },
        getResourceJid: function () {
            return currentSmallVideo ? currentSmallVideo.getResourceJid() : null;
        },
        updateAvatar: function (resourceJid) {
            if(!isEnabled)
                return;
            if (resourceJid === this.getResourceJid()) {
                updateActiveSpeakerAvatarSrc();
            }
        },
        showAvatar: function (resourceJid, show) {
            if (!isEnabled)
                return;
            if (this.getResourceJid() === resourceJid && state === "video") {
                $("#largeVideoWrapper")
                    .css("visibility", show ? "hidden" : "visible");
                $('#activeSpeaker').css("visibility", show ? "visible" : "hidden");
                return true;
            }
            return false;
        },
        /**
         * Disables the large video
         */
        disable: function () {
            isEnabled = false;
        },
        /**
         * Enables the large video
         */
        enable: function () {
            isEnabled = true;
        },
        /**
         * Returns true if the video is enabled.
         */
        isEnabled: function () {
            return isEnabled;
        },
        /**
         * Creates the iframe used by the etherpad
         * @param src the value for src attribute
         * @param onloadHandler handler executed when the iframe loads it content
         * @returns {HTMLElement} the iframe
         */
        createEtherpadIframe: function (src, onloadHandler) {
            if(!isEnabled)
                return;
            
            var etherpadIFrame = document.createElement('iframe');
            etherpadIFrame.src = src;
            etherpadIFrame.frameBorder = 0;
            etherpadIFrame.scrolling = "no";
            etherpadIFrame.width = $('#largeVideoContainer').width() || 640;
            etherpadIFrame.height = $('#largeVideoContainer').height() || 480;
            etherpadIFrame.setAttribute('style', 'visibility: hidden;');
            
            document.getElementById('etherpad').appendChild(etherpadIFrame);
            
            etherpadIFrame.onload = onloadHandler;
            
            return etherpadIFrame;
        },
        /**
         * Changes the state of the large video.
         * Possible values - video, prezi, etherpad.
         * @param newState - the new state
         */
        setState: function (newState) {
            if(state === newState)
                return;
            var currentContainer = getContainerByState(state);
            if(!currentContainer)
                return;
            
            var self = this;
            var oldState = state;
            
            switch (newState)
            {
                case "etherpad":
                    $('#activeSpeaker').css('visibility', 'hidden');
                    currentContainer.fadeOut(300, function () {
                        if (oldState === "prezi") {
                            currentContainer.css({opacity: '0'});
                            $('#reloadPresentation').css({display: 'none'});
                        }
                        else {
                            self.setLargeVideoVisible(false);
                        }
                    });
                    
                    $('#etherpad>iframe').fadeIn(300, function () {
                        document.body.style.background = '#eeeeee';
                        $('#etherpad>iframe').css({visibility: 'visible'});
                        $('#etherpad').css({zIndex: 2});
                    });
                    break;
                case "prezi":
                    var prezi = $('#presentation>iframe');
                    currentContainer.fadeOut(300, function() {
                        document.body.style.background = 'black';
                    });
                    prezi.fadeIn(300, function() {
                        prezi.css({opacity:'1'});
                        ToolbarToggler.dockToolbar(true);//fix that
                        self.setLargeVideoVisible(false);
                        $('#etherpad>iframe').css({visibility: 'hidden'});
                        $('#etherpad').css({zIndex: 0});
                    });
                    $('#activeSpeaker').css('visibility', 'hidden');
                    break;
                
                case "video":
                    currentContainer.fadeOut(300, function () {
                        $('#presentation>iframe').css({opacity:'0'});
                        $('#reloadPresentation').css({display:'none'});
                        $('#etherpad>iframe').css({visibility: 'hidden'});
                        $('#etherpad').css({zIndex: 0});
                        document.body.style.background = 'black';
                        ToolbarToggler.dockToolbar(false);//fix that
                    });
                    $('#largeVideoWrapper').fadeIn(300, function () {
                        self.setLargeVideoVisible(true);
                    });
                    break;
            }
            
            state = newState;
            
        },
        /**
         * Returns the current state of the large video.
         * @returns {string} the current state - video, prezi or etherpad.
         */
        getState: function () {
            return state;
        },
        /**
         * Sets hover handlers for the large video container div.
         *
         * @param inHandler
         * @param outHandler
         */
        setHover: function(inHandler, outHandler)
        {
            $('#largeVideoContainer').hover(inHandler, outHandler);
        },
        
        /**
         * Enables/disables the filter indicating a video problem to the user.
         *
         * @param enable <tt>true</tt> to enable, <tt>false</tt> to disable
         */
        enableVideoProblemFilter: function (enable) {
            $("#largeVideo").toggleClass("videoProblemFilter", enable);
        }
    };
    
    module.exports = LargeVideo;
},{"../../../service/UI/UIEvents":181,"../../RTC/RTCBrowserType":7,"../../xmpp/xmpp":74,"../avatar/Avatar":15,"../toolbars/ToolbarToggler":28,"../util/UIUtil":32}],35:[function(require,module,exports){
    /* global $, interfaceConfig, APP */
    var SmallVideo = require("./SmallVideo");
    var ConnectionIndicator = require("./ConnectionIndicator");
    var NicknameHandler = require("../util/NicknameHandler");
    var UIUtil = require("../util/UIUtil");
    var LargeVideo = require("./LargeVideo");
    var RTCBrowserType = require("../../RTC/RTCBrowserType");
    
    function LocalVideo(VideoLayout) {
        this.videoSpanId = "localVideoContainer";
        this.container = $("#localVideoContainer").get(0);
        this.bindHoverHandler();
        this.VideoLayout = VideoLayout;
        this.flipX = true;
        this.isLocal = true;
        this.peerJid = null;
    }
    
    LocalVideo.prototype = Object.create(SmallVideo.prototype);
    LocalVideo.prototype.constructor = LocalVideo;
    
    /**
     * Creates the edit display name button.
     *
     * @returns {object} the edit button
     */
    function createEditDisplayNameButton() {
        var editButton = document.createElement('a');
        editButton.className = 'displayname';
        UIUtil.setTooltip(editButton,
            "videothumbnail.editnickname",
            "top");
        editButton.innerHTML = '<i class="fa fa-pencil"></i>';
        
        return editButton;
    }
    
    /**
     * Sets the display name for the given video span id.
     */
    LocalVideo.prototype.setDisplayName = function(displayName, key) {
        if (!this.container) {
            console.warn(
                "Unable to set displayName - " + this.videoSpanId +
                " does not exist");
            return;
        }
        
        var nameSpan = $('#' + this.videoSpanId + '>span.displayname');
        var defaultLocalDisplayName = APP.translation.generateTranslationHTML(
            interfaceConfig.DEFAULT_LOCAL_DISPLAY_NAME);
        
        var meHTML;
        // If we already have a display name for this video.
        if (nameSpan.length > 0) {
            if (nameSpan.text() !== displayName) {
                if (displayName && displayName.length > 0) {
                    meHTML = APP.translation.generateTranslationHTML("me");
                    $('#localDisplayName').html(displayName + ' (' + meHTML + ')');
                } else {
                    $('#localDisplayName').html(defaultLocalDisplayName);
                }
            }
        } else {
            var editButton = createEditDisplayNameButton();
            
            nameSpan = document.createElement('span');
            nameSpan.className = 'displayname';
            $('#' + this.videoSpanId)[0].appendChild(nameSpan);
            
            
            if (displayName && displayName.length > 0) {
                meHTML = APP.translation.generateTranslationHTML("me");
                nameSpan.innerHTML = displayName + meHTML;
            }
            else {
                nameSpan.innerHTML = defaultLocalDisplayName;
            }
            
            
            nameSpan.id = 'localDisplayName';
            this.container.appendChild(editButton);
            //translates popover of edit button
            APP.translation.translateElement($("a.displayname"));
            
            var editableText = document.createElement('input');
            editableText.className = 'displayname';
            editableText.type = 'text';
            editableText.id = 'editDisplayName';
            
            if (displayName && displayName.length) {
                editableText.value = displayName;
            }
            
            var defaultNickname = APP.translation.translateString(
                "defaultNickname", {name: "Jane Pink"});
            editableText.setAttribute('style', 'display:none;');
            editableText.setAttribute('data-18n',
                '[placeholder]defaultNickname');
            editableText.setAttribute("data-i18n-options",
                JSON.stringify({name: "Jane Pink"}));
            editableText.setAttribute("placeholder", defaultNickname);
            
            this.container.appendChild(editableText);
            
            var self = this;
            $('#localVideoContainer .displayname')
                .bind("click", function (e) {
                    
                    var editDisplayName = $('#editDisplayName');
                    e.preventDefault();
                    e.stopPropagation();
                    $('#localDisplayName').hide();
                    editDisplayName.show();
                    editDisplayName.focus();
                    editDisplayName.select();
                    
                    editDisplayName.one("focusout", function (e) {
                        self.VideoLayout.inputDisplayNameHandler(this.value);
                    });
                    
                    editDisplayName.on('keydown', function (e) {
                        if (e.keyCode === 13) {
                            e.preventDefault();
                            self.VideoLayout.inputDisplayNameHandler(this.value);
                        }
                    });
                });
        }
    };
    
    LocalVideo.prototype.inputDisplayNameHandler = function (name) {
        NicknameHandler.setNickname(name);
        
        var localDisplayName = $('#localDisplayName');
        if (!localDisplayName.is(":visible")) {
            if (NicknameHandler.getNickname()) {
                var meHTML = APP.translation.generateTranslationHTML("me");
                localDisplayName.html(NicknameHandler.getNickname() + " (" +
                    meHTML + ")");
            } else {
                var defaultHTML = APP.translation.generateTranslationHTML(
                    interfaceConfig.DEFAULT_LOCAL_DISPLAY_NAME);
                localDisplayName .html(defaultHTML);
            }
            localDisplayName.show();
        }
        
        $('#editDisplayName').hide();
    };
    
    LocalVideo.prototype.createConnectionIndicator = function() {
        if(this.connectionIndicator)
            return;
        
        this.connectionIndicator = new ConnectionIndicator(this, null);
    };
    
    LocalVideo.prototype.changeVideo = function (stream, isMuted) {
        var self = this;
        
        function localVideoClick(event) {
            // FIXME: with Temasys plugin event arg is not an event, but
            // the clicked object itself, so we have to skip this call
            if (event.stopPropagation) {
                event.stopPropagation();
            }
            self.VideoLayout.handleVideoThumbClicked(
                true,
                APP.xmpp.myResource());
        }
        
        var localVideoContainerSelector = $('#localVideoContainer');
        localVideoContainerSelector.off('click');
        localVideoContainerSelector.on('click', localVideoClick);
        
        if(isMuted) {
            APP.UI.setVideoMute(true);
            return;
        }
        this.flipX = stream.videoType != "screen";
        var localVideo = document.createElement('video');
        localVideo.id = 'localVideo_' +
            APP.RTC.getStreamID(stream.getOriginalStream());
        if (!RTCBrowserType.isIExplorer()) {
            localVideo.autoplay = true;
            localVideo.volume = 0; // is it required if audio is separated ?
        }
        localVideo.oncontextmenu = function () { return false; };
        
        var localVideoContainer = document.getElementById('localVideoWrapper');
        // Put the new video always in front
        UIUtil.prependChild(localVideoContainer, localVideo);
        
        var localVideoSelector = $('#' + localVideo.id);
        
        // Add click handler to both video and video wrapper elements in case
        // there's no video.
        
        // onclick has to be used with Temasys plugin
        localVideo.onclick = localVideoClick;
        
        if (this.flipX) {
            localVideoSelector.addClass("flipVideoX");
        }
        
        // Attach WebRTC stream
        APP.RTC.attachMediaStream(localVideoSelector, stream.getOriginalStream());
        
        // Add stream ended handler
        APP.RTC.addMediaStreamInactiveHandler(
            stream.getOriginalStream(), function () {
                // We have to re-select after attach when Temasys plugin is used,
                // because <video> element is replaced with <object>
                localVideo = $('#' + localVideo.id)[0];
                localVideoContainer.removeChild(localVideo);
                self.VideoLayout.updateRemovedVideo(APP.xmpp.myResource());
            });
    };
    
    LocalVideo.prototype.joined = function (jid) {
        this.peerJid = jid;
    };
    
    LocalVideo.prototype.getResourceJid = function () {
        var myResource = APP.xmpp.myResource();
        if (!myResource) {
            console.error("Requested local resource before we're in the MUC");
        }
        return myResource;
    };
    
    module.exports = LocalVideo;
},{"../../RTC/RTCBrowserType":7,"../util/NicknameHandler":31,"../util/UIUtil":32,"./ConnectionIndicator":33,"./LargeVideo":34,"./SmallVideo":37}],36:[function(require,module,exports){
    /* global $, APP, require, Strophe, interfaceConfig */
    var ConnectionIndicator = require("./ConnectionIndicator");
    var SmallVideo = require("./SmallVideo");
    var AudioLevels = require("../audio_levels/AudioLevels");
    var RTCBrowserType = require("../../RTC/RTCBrowserType");
    var UIUtils = require("../util/UIUtil");
    var XMPPEvents = require("../../../service/xmpp/XMPPEvents");
    
    function RemoteVideo(peerJid, VideoLayout) {
        this.peerJid = peerJid;
        this.resourceJid = Strophe.getResourceFromJid(peerJid);
        this.videoSpanId = 'participant_' + this.resourceJid;
        this.VideoLayout = VideoLayout;
        this.addRemoteVideoContainer();
        this.connectionIndicator = new ConnectionIndicator(
            this, this.peerJid);
        this.setDisplayName();
        var nickfield = document.createElement('span');
        nickfield.className = "nick";
        nickfield.appendChild(document.createTextNode(this.resourceJid));
        this.container.appendChild(nickfield);
        this.bindHoverHandler();
        this.flipX = false;
        this.isLocal = false;
    }
    
    RemoteVideo.prototype = Object.create(SmallVideo.prototype);
    RemoteVideo.prototype.constructor = RemoteVideo;
    
    RemoteVideo.prototype.addRemoteVideoContainer = function() {
        this.container = RemoteVideo.createContainer(this.videoSpanId);
        if (APP.xmpp.isModerator())
            this.addRemoteVideoMenu();
        AudioLevels.updateAudioLevelCanvas(this.peerJid, this.VideoLayout);
        
        return this.container;
    };
    
    /**
     * Adds the remote video menu element for the given <tt>jid</tt> in the
     * given <tt>parentElement</tt>.
     *
     * @param jid the jid indicating the video for which we're adding a menu.
     * @param parentElement the parent element where this menu will be added
     */
    
    if (!interfaceConfig.filmStripOnly) {
        RemoteVideo.prototype.addRemoteVideoMenu = function () {
            var spanElement = document.createElement('span');
            spanElement.className = 'remotevideomenu';
            
            this.container.appendChild(spanElement);
            
            var menuElement = document.createElement('i');
            menuElement.className = 'fa fa-angle-down';
            menuElement.title = 'Remote user controls';
            spanElement.appendChild(menuElement);
            
            
            var popupmenuElement = document.createElement('ul');
            popupmenuElement.className = 'popupmenu';
            popupmenuElement.id = 'remote_popupmenu_' + this.getResourceJid();
            spanElement.appendChild(popupmenuElement);
            
            var muteMenuItem = document.createElement('li');
            var muteLinkItem = document.createElement('a');
            
            var mutedIndicator = "<i style='float:left;' " +
                "class='icon-mic-disabled'></i>";
            
            if (!this.isMuted) {
                muteLinkItem.innerHTML = mutedIndicator +
                    " <div style='width: 90px;margin-left: 20px;' " +
                    "data-i18n='videothumbnail.domute'></div>";
                muteLinkItem.className = 'mutelink';
            }
            else {
                muteLinkItem.innerHTML = mutedIndicator +
                    " <div style='width: 90px;margin-left: 20px;' " +
                    "data-i18n='videothumbnail.muted'></div>";
                muteLinkItem.className = 'mutelink disabled';
            }
            
            var self = this;
            muteLinkItem.onclick = function(){
                if ($(this).attr('disabled')) {
                    event.preventDefault();
                }
                var isMute = !!self.isMuted;
                APP.xmpp.setMute(self.peerJid, !isMute);
                
                popupmenuElement.setAttribute('style', 'display:none;');
                
                if (isMute) {
                    this.innerHTML = mutedIndicator +
                        " <div style='width: 90px;margin-left: 20px;' " +
                        "data-i18n='videothumbnail.muted'></div>";
                    this.className = 'mutelink disabled';
                }
                else {
                    this.innerHTML = mutedIndicator +
                        " <div style='width: 90px;margin-left: 20px;' " +
                        "data-i18n='videothumbnail.domute'></div>";
                    this.className = 'mutelink';
                }
            };
            
            muteMenuItem.appendChild(muteLinkItem);
            popupmenuElement.appendChild(muteMenuItem);
            
            var ejectIndicator = "<i style='float:left;' class='fa fa-eject'></i>";
            
            var ejectMenuItem = document.createElement('li');
            var ejectLinkItem = document.createElement('a');
            var ejectText = "<div style='width: 90px;margin-left: 20px;' " +
                "data-i18n='videothumbnail.kick'>&nbsp;</div>";
            ejectLinkItem.innerHTML = ejectIndicator + ' ' + ejectText;
            ejectLinkItem.onclick = function(){
                APP.xmpp.eject(self.peerJid);
                popupmenuElement.setAttribute('style', 'display:none;');
            };
            
            ejectMenuItem.appendChild(ejectLinkItem);
            popupmenuElement.appendChild(ejectMenuItem);
            
            var paddingSpan = document.createElement('span');
            paddingSpan.className = 'popupmenuPadding';
            popupmenuElement.appendChild(paddingSpan);
            APP.translation.translateElement(
                $("#" + popupmenuElement.id + " > li > a > div"));
        };
        
    } else {
        RemoteVideo.prototype.addRemoteVideoMenu = function() {};
    }
    
    /**
     * Removes the remote stream element corresponding to the given stream and
     * parent container.
     *
     * @param stream the stream
     * @param isVideo <tt>true</tt> if given <tt>stream</tt> is a video one.
     */
    RemoteVideo.prototype.removeRemoteStreamElement =
        function (stream, isVideo, id) {
            if (!this.container)
                return false;
            
            var select = null;
            if (isVideo) {
                select = $('#' + id);
            }
            else
                select = $('#' + this.videoSpanId + '>audio');
            
            select.remove();
            
            console.info((isVideo ? "Video" : "Audio") +
                " removed " + this.getResourceJid(), select);
            
            if (isVideo)
                this.VideoLayout.updateRemovedVideo(this.getResourceJid());
        };
    
    /**
     * Removes RemoteVideo from the page.
     */
    RemoteVideo.prototype.remove = function () {
        console.log("Remove thumbnail", this.peerJid);
        this.removeConnectionIndicator();
        // Make sure that the large video is updated if are removing its
        // corresponding small video.
        this.VideoLayout.updateRemovedVideo(this.getResourceJid());
        // Remove whole container
        if (this.container.parentNode)
            this.container.parentNode.removeChild(this.container);
    };
    
    RemoteVideo.prototype.waitForPlayback = function (sel, stream) {
        
        var isVideo = stream.getVideoTracks().length > 0;
        if (!isVideo || stream.id === 'mixedmslabel') {
            return;
        }
        
        var self = this;
        var resourceJid = this.getResourceJid();
        
        // Register 'onplaying' listener to trigger 'videoactive' on VideoLayout
        // when video playback starts
        var onPlayingHandler = function () {
            // FIXME: why do i have to do this for FF?
            if (RTCBrowserType.isFirefox()) {
                APP.RTC.attachMediaStream(sel, stream);
            }
            if (RTCBrowserType.isTemasysPluginUsed()) {
                sel = self.selectVideoElement();
            }
            self.VideoLayout.videoactive(sel, resourceJid);
            sel[0].onplaying = null;
            if (RTCBrowserType.isTemasysPluginUsed()) {
                // 'currentTime' is used to check if the video has started
                // and the value is not set by the plugin, so we do it
                sel[0].currentTime = 1;
            }
        };
        sel[0].onplaying = onPlayingHandler;
    };
    
    RemoteVideo.prototype.addRemoteStreamElement = function (stream) {
        if (!this.container)
            return;
        
        var self = this;
        var isVideo = stream.getVideoTracks().length > 0;
        var streamElement = SmallVideo.createStreamElement(stream);
        var newElementId = streamElement.id;
        
        // Put new stream element always in front
        UIUtils.prependChild(this.container, streamElement);
        
        var sel = $('#' + newElementId);
        sel.hide();
        
        // If the container is currently visible we attach the stream.
        if (!isVideo || (this.container.offsetParent !== null && isVideo)) {
            this.waitForPlayback(sel, stream);
            
            APP.RTC.attachMediaStream(sel, stream);
        }
        
        APP.RTC.addMediaStreamInactiveHandler(
            stream, function () {
                console.log('stream ended', this);
                
                self.removeRemoteStreamElement(stream, isVideo, newElementId);
            });
        
        // Add click handler.
        var onClickHandler = function (event) {
            
            self.VideoLayout.handleVideoThumbClicked(false, self.getResourceJid());
            
            // On IE we need to populate this handler on video <object>
            // and it does not give event instance as an argument,
            // so we check here for methods.
            if (event.stopPropagation && event.preventDefault) {
                event.stopPropagation();
                event.preventDefault();
            }
            return false;
        };
        this.container.onclick = onClickHandler;
        // reselect
        if (RTCBrowserType.isTemasysPluginUsed())
            sel = $('#' + newElementId);
        sel[0].onclick = onClickHandler;
    },
    
    /**
     * Show/hide peer container for the given resourceJid.
     */
        RemoteVideo.prototype.showPeerContainer = function (state) {
            if (!this.container)
                return;
            
            var isHide = state === 'hide';
            var resizeThumbnails = false;
            
            if (!isHide) {
                if (!$(this.container).is(':visible')) {
                    resizeThumbnails = true;
                    $(this.container).show();
                }
                // Call showAvatar with undefined, so that we'll figure out if avatar
                // should be displayed based on video muted status and whether or not
                // it's in the lastN set
                this.showAvatar(undefined);
            }
            else if ($(this.container).is(':visible') && isHide)
            {
                resizeThumbnails = true;
                $(this.container).hide();
                if(this.connectionIndicator)
                    this.connectionIndicator.hide();
            }
            
            if (resizeThumbnails) {
                this.VideoLayout.resizeThumbnails();
            }
            
            // We want to be able to pin a participant from the contact list, even
            // if he's not in the lastN set!
            // ContactList.setClickable(resourceJid, !isHide);
            
        };
    
    RemoteVideo.prototype.removeConnectionIndicator = function () {
        if (this.connectionIndicator)
            this.connectionIndicator.remove();
    };
    
    RemoteVideo.prototype.hideConnectionIndicator = function () {
        if (this.connectionIndicator)
            this.connectionIndicator.hide();
    };
    
    /**
     * Updates the remote video menu.
     *
     * @param jid the jid indicating the video for which we're adding a menu.
     * @param isMuted indicates the current mute state
     */
    RemoteVideo.prototype.updateRemoteVideoMenu = function (isMuted) {
        var muteMenuItem
            = $('#remote_popupmenu_' + this.getResourceJid() + '>li>a.mutelink');
        
        var mutedIndicator = "<i class='icon-mic-disabled'></i>";
        
        if (muteMenuItem.length) {
            var muteLink = muteMenuItem.get(0);
            
            if (isMuted) {
                muteLink.innerHTML = mutedIndicator + ' Muted';
                muteLink.className = 'mutelink disabled';
            }
            else {
                muteLink.innerHTML = mutedIndicator + ' Mute';
                muteLink.className = 'mutelink';
            }
        }
    };
    
    /**
     * Sets the display name for the given video span id.
     */
    RemoteVideo.prototype.setDisplayName = function(displayName, key) {
        
        if (!this.container) {
            console.warn( "Unable to set displayName - " + this.videoSpanId +
                " does not exist");
            return;
        }
        
        var nameSpan = $('#' + this.videoSpanId + '>span.displayname');
        
        // If we already have a display name for this video.
        if (nameSpan.length > 0) {
            if (displayName && displayName.length > 0) {
                $('#' + this.videoSpanId + '_name').html(displayName);
            }
            else if (key && key.length > 0) {
                var nameHtml = APP.translation.generateTranslationHTML(key);
                $('#' + this.videoSpanId + '_name').html(nameHtml);
            }
            else
                $('#' + this.videoSpanId + '_name').text(
                    interfaceConfig.DEFAULT_REMOTE_DISPLAY_NAME);
        } else {
            nameSpan = document.createElement('span');
            nameSpan.className = 'displayname';
            $('#' + this.videoSpanId)[0].appendChild(nameSpan);
            
            
            if (displayName && displayName.length > 0) {
                nameSpan.innerText = displayName;
            }
            else
                nameSpan.innerText = interfaceConfig.DEFAULT_REMOTE_DISPLAY_NAME;
            
            nameSpan.id = this.videoSpanId + '_name';
        }
    };
    
    /**
     * Removes remote video menu element from video element identified by
     * given <tt>videoElementId</tt>.
     *
     * @param videoElementId the id of local or remote video element.
     */
    RemoteVideo.prototype.removeRemoteVideoMenu = function() {
        var menuSpan = $('#' + this.videoSpanId + '>span.remotevideomenu');
        if (menuSpan.length) {
            menuSpan.remove();
        }
    };
    
    RemoteVideo.prototype.getResourceJid = function () {
        if (!this.resourceJid) {
            console.error("Undefined resource jid");
        }
        return this.resourceJid;
    };
    
    RemoteVideo.createContainer = function (spanId) {
        var container = document.createElement('span');
        container.id = spanId;
        container.className = 'videocontainer';
        var remotes = document.getElementById('remoteVideos');
        return remotes.appendChild(container);
    };
    
    
    module.exports = RemoteVideo;
},{"../../../service/xmpp/XMPPEvents":188,"../../RTC/RTCBrowserType":7,"../audio_levels/AudioLevels":11,"../util/UIUtil":32,"./ConnectionIndicator":33,"./SmallVideo":37}],37:[function(require,module,exports){
    /* global $, APP, require */
    /* jshint -W101 */
    var Avatar = require("../avatar/Avatar");
    var UIUtil = require("../util/UIUtil");
    var LargeVideo = require("./LargeVideo");
    var RTCBrowserType = require("../../RTC/RTCBrowserType");
    
    function SmallVideo() {
        this.isMuted = false;
        this.hasAvatar = false;
    }
    
    function setVisibility(selector, show) {
        if (selector && selector.length > 0) {
            selector.css("visibility", show ? "visible" : "hidden");
        }
    }
    
    SmallVideo.prototype.showDisplayName = function(isShow) {
        var nameSpan = $('#' + this.videoSpanId + '>span.displayname').get(0);
        if (isShow) {
            if (nameSpan && nameSpan.innerHTML && nameSpan.innerHTML.length)
                nameSpan.setAttribute("style", "display:inline-block;");
        }
        else {
            if (nameSpan)
                nameSpan.setAttribute("style", "display:none;");
        }
    };
    
    SmallVideo.prototype.setDeviceAvailabilityIcons = function (devices) {
        if(!this.container)
            return;
        
        var noMic = $("#" + this.videoSpanId + " > .noMic");
        var noVideo =  $("#" + this.videoSpanId + " > .noVideo");
        
        noMic.remove();
        noVideo.remove();
        if (!devices.audio) {
            this.container.appendChild(
                document.createElement("div")).setAttribute("class", "noMic");
        }
        
        if (!devices.video) {
            this.container.appendChild(
                document.createElement("div")).setAttribute("class", "noVideo");
        }
        
        if (!devices.audio && !devices.video) {
            noMic.css("background-position", "75%");
            noVideo.css("background-position", "25%");
            noVideo.css("background-color", "transparent");
        }
    };
    
    /**
     * Sets the type of the video displayed by this instance.
     * @param videoType 'camera' or 'screen'
     */
    SmallVideo.prototype.setVideoType = function (videoType) {
        this.videoType = videoType;
    };
    
    /**
     * Returns the type of the video displayed by this instance.
     * @returns {String} 'camera', 'screen' or undefined.
     */
    SmallVideo.prototype.getVideoType = function () {
        return this.videoType;
    };
    
    /**
     * Shows the presence status message for the given video.
     */
    SmallVideo.prototype.setPresenceStatus = function (statusMsg) {
        if (!this.container) {
            // No container
            return;
        }
        
        var statusSpan = $('#' + this.videoSpanId + '>span.status');
        if (!statusSpan.length) {
            //Add status span
            statusSpan = document.createElement('span');
            statusSpan.className = 'status';
            statusSpan.id = this.videoSpanId + '_status';
            $('#' + this.videoSpanId)[0].appendChild(statusSpan);
            
            statusSpan = $('#' + this.videoSpanId + '>span.status');
        }
        
        // Display status
        if (statusMsg && statusMsg.length) {
            $('#' + this.videoSpanId + '_status').text(statusMsg);
            statusSpan.get(0).setAttribute("style", "display:inline-block;");
        }
        else {
            // Hide
            statusSpan.get(0).setAttribute("style", "display:none;");
        }
    };
    
    /**
     * Creates an audio or video element for a particular MediaStream.
     */
    SmallVideo.createStreamElement = function (stream) {
        var isVideo = stream.getVideoTracks().length > 0;
        
        var element = isVideo ? document.createElement('video')
            : document.createElement('audio');
        
        if (!RTCBrowserType.isIExplorer()) {
            element.autoplay = true;
        }
        
        element.id = (isVideo ? 'remoteVideo_' : 'remoteAudio_') +
            APP.RTC.getStreamID(stream);
        
        element.onplay = function() {
            console.log("(TIME) Render " + (isVideo ? 'video' : 'audio') + ":\t",
                window.performance.now());
        };
        
        element.oncontextmenu = function () { return false; };
        
        return element;
    };
    
    /**
     * Configures hoverIn/hoverOut handlers.
     */
    SmallVideo.prototype.bindHoverHandler = function () {
        // Add hover handler
        var self = this;
        $(this.container).hover(
            function () {
                self.showDisplayName(true);
            },
            function () {
                // If the video has been "pinned" by the user we want to
                // keep the display name on place.
                if (!LargeVideo.isLargeVideoVisible() ||
                    !LargeVideo.isCurrentlyOnLarge(self.getResourceJid()))
                    self.showDisplayName(false);
            }
        );
    };
    
    /**
     * Updates the data for the indicator
     * @param id the id of the indicator
     * @param percent the percent for connection quality
     * @param object the data
     */
    SmallVideo.prototype.updateStatsIndicator = function (percent, object) {
        if(this.connectionIndicator)
            this.connectionIndicator.updateConnectionQuality(percent, object);
    };
    
    SmallVideo.prototype.hideIndicator = function () {
        if(this.connectionIndicator)
            this.connectionIndicator.hideIndicator();
    };
    
    
    /**
     * Shows audio muted indicator over small videos.
     * @param {string} isMuted
     */
    SmallVideo.prototype.showAudioIndicator = function(isMuted) {
        var audioMutedSpan = $('#' + this.videoSpanId + '>span.audioMuted');
        
        if (!isMuted) {
            if (audioMutedSpan.length > 0) {
                audioMutedSpan.popover('hide');
                audioMutedSpan.remove();
            }
        }
        else {
            if (!audioMutedSpan.length) {
                audioMutedSpan = document.createElement('span');
                audioMutedSpan.className = 'audioMuted';
                UIUtil.setTooltip(audioMutedSpan,
                    "videothumbnail.mute",
                    "top");
                
                this.container.appendChild(audioMutedSpan);
                APP.translation.translateElement($('#' + this.videoSpanId + " > span"));
                var mutedIndicator = document.createElement('i');
                mutedIndicator.className = 'icon-mic-disabled';
                audioMutedSpan.appendChild(mutedIndicator);
                
            }
            this.updateIconPositions();
        }
        this.isMuted = isMuted;
    };
    
    /**
     * Shows video muted indicator over small videos.
     */
    SmallVideo.prototype.showVideoIndicator = function(isMuted) {
        this.showAvatar(isMuted);
        
        var videoMutedSpan = $('#' + this.videoSpanId + '>span.videoMuted');
        
        if (isMuted === false) {
            if (videoMutedSpan.length > 0) {
                videoMutedSpan.remove();
            }
        }
        else {
            if (!videoMutedSpan.length) {
                videoMutedSpan = document.createElement('span');
                videoMutedSpan.className = 'videoMuted';
                
                this.container.appendChild(videoMutedSpan);
                
                var mutedIndicator = document.createElement('i');
                mutedIndicator.className = 'icon-camera-disabled';
                UIUtil.setTooltip(mutedIndicator,
                    "videothumbnail.videomute",
                    "top");
                videoMutedSpan.appendChild(mutedIndicator);
                //translate texts for muted indicator
                APP.translation.translateElement($('#' + this.videoSpanId  + " > span > i"));
            }
            
            this.updateIconPositions();
            
        }
    };
    
    SmallVideo.prototype.enableDominantSpeaker = function (isEnable) {
        var resourceJid = this.getResourceJid();
        var displayName = resourceJid;
        var nameSpan = $('#' + this.videoSpanId + '>span.displayname');
        if (nameSpan.length > 0)
            displayName = nameSpan.html();
        
        console.log("UI enable dominant speaker",
            displayName,
            resourceJid,
            isEnable);
        
        
        if (!this.container) {
            return;
        }
        
        if (isEnable) {
            this.showDisplayName(LargeVideo.getState() === "video");
            
            if (!this.container.classList.contains("dominantspeaker"))
                this.container.classList.add("dominantspeaker");
        }
        else {
            this.showDisplayName(false);
            
            if (this.container.classList.contains("dominantspeaker"))
                this.container.classList.remove("dominantspeaker");
        }
        
        this.showAvatar();
    };
    
    SmallVideo.prototype.updateIconPositions = function () {
        var audioMutedSpan = $('#' + this.videoSpanId + '>span.audioMuted');
        var connectionIndicator = $('#' + this.videoSpanId + '>div.connectionindicator');
        var videoMutedSpan = $('#' + this.videoSpanId + '>span.videoMuted');
        if(connectionIndicator.length > 0 &&
            connectionIndicator[0].style.display != "none") {
            audioMutedSpan.css({right: "23px"});
            videoMutedSpan.css({right: ((audioMutedSpan.length > 0? 23 : 0) + 30) + "px"});
        } else {
            audioMutedSpan.css({right: "0px"});
            videoMutedSpan.css({right: (audioMutedSpan.length > 0? 30 : 0) + "px"});
        }
    };
    
    /**
     * Creates the element indicating the moderator(owner) of the conference.
     *
     * @param parentElement the parent element where the owner indicator will
     * be added
     */
    SmallVideo.prototype.createModeratorIndicatorElement = function () {
        // Show moderator indicator
        var indicatorSpan = $('#' + this.videoSpanId + ' .focusindicator');
        
        if (!indicatorSpan || indicatorSpan.length === 0) {
            indicatorSpan = document.createElement('span');
            indicatorSpan.className = 'focusindicator';
            
            this.container.appendChild(indicatorSpan);
            indicatorSpan = $('#' + this.videoSpanId + ' .focusindicator');
        }
        
        if (indicatorSpan.children().length !== 0)
            return;
        var moderatorIndicator = document.createElement('i');
        moderatorIndicator.className = 'fa fa-star';
        indicatorSpan[0].appendChild(moderatorIndicator);
        
        UIUtil.setTooltip(indicatorSpan[0],
            "videothumbnail.moderator",
            "top");
        
        //translates text in focus indicators
        APP.translation.translateElement($('#' + this.videoSpanId + ' .focusindicator'));
    };
    
    SmallVideo.prototype.selectVideoElement = function () {
        var videoElem = APP.RTC.getVideoElementName();
        if (!RTCBrowserType.isTemasysPluginUsed()) {
            return $('#' + this.videoSpanId).find(videoElem);
        } else {
            return $('#' + this.videoSpanId +
                (this.isLocal ? '>>' : '>') +
                videoElem + '>param[value="video"]').parent();
        }
    };
    
    SmallVideo.prototype.getSrc = function () {
        var videoElement = this.selectVideoElement().get(0);
        return APP.RTC.getVideoSrc(videoElement);
    };
    
    SmallVideo.prototype.focus = function(isFocused) {
        if(!isFocused) {
            this.container.classList.remove("videoContainerFocused");
        } else {
            this.container.classList.add("videoContainerFocused");
        }
    };
    
    SmallVideo.prototype.hasVideo = function () {
        return this.selectVideoElement().length !== 0;
    };
    
    /**
     * Hides or shows the user's avatar
     * @param show whether we should show the avatar or not
     * video because there is no dominant speaker and no focused speaker
     */
    SmallVideo.prototype.showAvatar = function (show) {
        if (!this.hasAvatar) {
            if (this.peerJid) {
                // Init avatar
                this.avatarChanged(Avatar.getThumbUrl(this.peerJid));
            } else {
                console.error("Unable to init avatar - no peerjid", this);
                return;
            }
        }
        
        var resourceJid = this.getResourceJid();
        var video = this.selectVideoElement();
        
        var avatar = $('#avatar_' + resourceJid);
        
        if (show === undefined || show === null) {
            if (!this.isLocal &&
                !this.VideoLayout.isInLastN(resourceJid)) {
                show = true;
            } else {
                // We want to show the avatar when the video is muted or not exists
                // that is when 'true' or 'null' is returned
                show = APP.RTC.isVideoMuted(this.peerJid) !== false;
            }
        }
        
        if (LargeVideo.showAvatar(resourceJid, show)) {
            setVisibility(avatar, false);
            setVisibility(video, false);
        } else {
            if (video && video.length > 0) {
                setVisibility(video, !show);
            }
            setVisibility(avatar, show);
        }
    };
    
    SmallVideo.prototype.avatarChanged = function (thumbUrl) {
        var thumbnail = $('#' + this.videoSpanId);
        var resourceJid = this.getResourceJid();
        var avatar = $('#avatar_' + resourceJid);
        this.hasAvatar = true;
        
        // set the avatar in the thumbnail
        if (avatar && avatar.length > 0) {
            avatar[0].src = thumbUrl;
        } else {
            if (thumbnail && thumbnail.length > 0) {
                avatar = document.createElement('img');
                avatar.id = 'avatar_' + resourceJid;
                avatar.className = 'userAvatar';
                avatar.src = thumbUrl;
                thumbnail.append(avatar);
            }
        }
    };
    
    module.exports = SmallVideo;
},{"../../RTC/RTCBrowserType":7,"../avatar/Avatar":15,"../util/UIUtil":32,"./LargeVideo":34}],38:[function(require,module,exports){
    /* global config, APP, $, Strophe, require, interfaceConfig */
    /* jshint -W101 */
    var AudioLevels = require("../audio_levels/AudioLevels");
    var ContactList = require("../side_pannels/contactlist/ContactList");
    var MediaStreamType = require("../../../service/RTC/MediaStreamTypes");
    var UIEvents = require("../../../service/UI/UIEvents");
    var UIUtil = require("../util/UIUtil");
    
    var RTC = require("../../RTC/RTC");
    var RTCBrowserType = require('../../RTC/RTCBrowserType');
    
    var RemoteVideo = require("./RemoteVideo");
    var LargeVideo = require("./LargeVideo");
    var LocalVideo = require("./LocalVideo");
    
    
    var remoteVideos = {};
    var remoteVideoTypes = {};
    var localVideoThumbnail = null;
    
    var currentDominantSpeaker = null;
    var lastNCount = config.channelLastN;
    var localLastNCount = config.channelLastN;
    var localLastNSet = [];
    var lastNEndpointsCache = [];
    var lastNPickupJid = null;
    
    var eventEmitter = null;
    
    /**
     * Currently focused video jid
     * @type {String}
     */
    var focusedVideoResourceJid = null;
    
    var VideoLayout = (function (my) {
        my.init = function (emitter) {
            eventEmitter = emitter;
            localVideoThumbnail = new LocalVideo(VideoLayout);
            if (interfaceConfig.filmStripOnly) {
                LargeVideo.disable();
            } else {
                LargeVideo.init(VideoLayout, emitter);
            }
            
            VideoLayout.resizeLargeVideoContainer();
            
        };
        
        my.isInLastN = function(resource) {
            return lastNCount < 0 || // lastN is disabled
                    // lastNEndpoints cache not built yet
                (lastNCount > 0 && !lastNEndpointsCache.length) ||
                (lastNEndpointsCache &&
                lastNEndpointsCache.indexOf(resource) !== -1);
        };
        
        my.changeLocalStream = function (stream, isMuted) {
            VideoLayout.changeLocalVideo(stream, isMuted);
        };
        
        my.changeLocalAudio = function(stream, isMuted) {
            if (isMuted)
                APP.UI.setAudioMuted(true, true);
            APP.RTC.attachMediaStream($('#localAudio'), stream.getOriginalStream());
            var localAudio = document.getElementById('localAudio');
            // Writing volume not allowed in IE
            if (!RTCBrowserType.isIExplorer()) {
                localAudio.autoplay = true;
                localAudio.volume = 0;
            }
            // Now when Temasys plugin is converting also <audio> elements to
            // plugin's <object>s, in current layout it will capture click events
            // before it reaches the local video object. We hide it here in order
            // to prevent that.
            if (RTCBrowserType.isIExplorer()) {
                // The issue is not present on Safari. Also if we hide it in Safari
                // then the local audio track will have 'enabled' flag set to false
                // which will result in audio mute issues
                $('#localAudio').hide();
            }
        };
        
        my.changeLocalVideo = function(stream, isMuted) {
            // Set default display name.
            localVideoThumbnail.setDisplayName();
            localVideoThumbnail.createConnectionIndicator();
            
            this.onVideoTypeChanged(APP.xmpp.myResource(), stream.videoType);
            
            AudioLevels.updateAudioLevelCanvas(null, VideoLayout);
            
            localVideoThumbnail.changeVideo(stream, isMuted);
            
            /* force update if we're currently being displayed */
            if (LargeVideo.isCurrentlyOnLarge(APP.xmpp.myResource())) {
                LargeVideo.updateLargeVideo(APP.xmpp.myResource(), true);
            }
        };
        
        my.mucJoined = function () {
            var myResourceJid = APP.xmpp.myResource();
            localVideoThumbnail.joined(APP.xmpp.myJid());
            
            if (!LargeVideo.getResourceJid())
                LargeVideo.updateLargeVideo(myResourceJid, true);
        };
        
        /**
         * Adds or removes icons for not available camera and microphone.
         * @param resourceJid the jid of user
         * @param devices available devices
         */
        my.setDeviceAvailabilityIcons = function (resourceJid, devices) {
            if(!devices)
                return;
            
            if(!resourceJid) {
                localVideoThumbnail.setDeviceAvailabilityIcons(devices);
            } else {
                if(remoteVideos[resourceJid])
                    remoteVideos[resourceJid].setDeviceAvailabilityIcons(devices);
            }
        };
        
        /**
         * Checks if removed video is currently displayed and tries to display
         * another one instead.
         */
        my.updateRemovedVideo = function(resourceJid) {
            var newResourceJid;
            
            if (resourceJid === LargeVideo.getResourceJid()) {
                // We'll show user's avatar if he is the dominant speaker or if
                // his video thumbnail is pinned
                if (remoteVideos[resourceJid] &&
                    resourceJid === focusedVideoResourceJid ||
                    resourceJid === currentDominantSpeaker) {
                    newResourceJid = resourceJid;
                } else {
                    // Otherwise select last visible video
                    newResourceJid = this.electLastVisibleVideo();
                }
                LargeVideo.updateLargeVideo(newResourceJid);
            }
        };
        
        my.electLastVisibleVideo = function () {
            // pick the last visible video in the row
            // if nobody else is left, this picks the local video
            var jid;
            var pick = $('#remoteVideos>span[id!="mixedstream"]:visible:last');
            if (pick.length) {
                jid = VideoLayout.getPeerContainerResourceJid(pick[0]);
                if (!remoteVideos[jid]) {
                    // The RemoteVideo was removed (but the DOM elements may still
                    // exist).
                    jid = null;
                }
            }
            
            if (!jid) {
                console.info("Last visible video no longer exists");
                pick = $('#remoteVideos>span[id!="mixedstream"]');
                if (pick.length) {
                    jid = VideoLayout.getPeerContainerResourceJid(pick[0]);
                    if (!remoteVideos[jid]) {
                        // The RemoteVideo was removed (but the DOM elements may
                        // still exist).
                        jid = null;
                    }
                }
            }
            
            if (!jid) {
                // Go with local video
                console.info("Fallback to local video...");
                jid = APP.xmpp.myResource();
            }
            
            console.info("electLastVisibleVideo: " + jid);
            return jid;
        };
        
        my.onRemoteStreamAdded = function (stream) {
            if (stream.peerjid) {
                VideoLayout.ensurePeerContainerExists(stream.peerjid);
                
                var resourceJid = Strophe.getResourceFromJid(stream.peerjid);
                remoteVideos[resourceJid].addRemoteStreamElement(
                    stream.getOriginalStream());
            }
        };
        
        my.getLargeVideoResource = function () {
            return LargeVideo.getResourceJid();
        };
        
        /**
         * Called when large video update is finished
         * @param currentSmallVideo small video currently displayed on large video
         */
        my.largeVideoUpdated = function (currentSmallVideo) {
            // Makes sure that dominant speaker UI
            // is enabled only on current small video
            localVideoThumbnail.enableDominantSpeaker(
                localVideoThumbnail === currentSmallVideo);
            Object.keys(remoteVideos).forEach(
                function (resourceJid) {
                    var remoteVideo = remoteVideos[resourceJid];
                    if (remoteVideo) {
                        remoteVideo.enableDominantSpeaker(
                            remoteVideo === currentSmallVideo);
                    }
                }
            );
        };
        
        my.handleVideoThumbClicked = function(noPinnedEndpointChangedEvent,
                                              resourceJid) {
            if(focusedVideoResourceJid) {
                var oldSmallVideo = VideoLayout.getSmallVideo(focusedVideoResourceJid);
                if (oldSmallVideo && !interfaceConfig.filmStripOnly)
                    oldSmallVideo.focus(false);
            }
            
            var smallVideo = VideoLayout.getSmallVideo(resourceJid);
            // Unlock current focused.
            if (focusedVideoResourceJid === resourceJid)
            {
                focusedVideoResourceJid = null;
                // Enable the currently set dominant speaker.
                if (currentDominantSpeaker) {
                    if(smallVideo && smallVideo.hasVideo()) {
                        LargeVideo.updateLargeVideo(currentDominantSpeaker);
                    }
                }
                
                if (!noPinnedEndpointChangedEvent) {
                    eventEmitter.emit(UIEvents.PINNED_ENDPOINT);
                }
                return;
            }
            
            // Lock new video
            focusedVideoResourceJid = resourceJid;
            
            // Update focused/pinned interface.
            if (resourceJid) {
                if (smallVideo && !interfaceConfig.filmStripOnly)
                    smallVideo.focus(true);
                
                if (!noPinnedEndpointChangedEvent) {
                    eventEmitter.emit(UIEvents.PINNED_ENDPOINT, resourceJid);
                }
            }
            
            LargeVideo.setState("video");
            
            LargeVideo.updateLargeVideo(resourceJid);
            
            // Writing volume not allowed in IE
            if (!RTCBrowserType.isIExplorer()) {
                $('audio').each(function (idx, el) {
                    el.volume = 0;
                    el.volume = 1;
                });
            }
        };
        
        
        /**
         * Checks if container for participant identified by given peerJid exists
         * in the document and creates it eventually.
         *
         * @param peerJid peer Jid to check.
         *
         * @return Returns <tt>true</tt> if the peer container exists,
         * <tt>false</tt> - otherwise
         */
        my.ensurePeerContainerExists = function(peerJid) {
            ContactList.ensureAddContact(peerJid);
            
            var resourceJid = Strophe.getResourceFromJid(peerJid);
            
            if (!remoteVideos[resourceJid]) {
                
                var remoteVideo = new RemoteVideo(peerJid, VideoLayout);
                remoteVideos[resourceJid] = remoteVideo;
                
                var videoType = remoteVideoTypes[resourceJid];
                if (videoType) {
                    remoteVideo.setVideoType(videoType);
                }
                
                // In case this is not currently in the last n we don't show it.
                if (localLastNCount &&
                    localLastNCount > 0 &&
                    $('#remoteVideos>span').length >= localLastNCount + 2) {
                    remoteVideo.showPeerContainer('hide');
                }
                else
                    VideoLayout.resizeThumbnails();
            }
        };
        
        
        my.inputDisplayNameHandler = function (name) {
            localVideoThumbnail.inputDisplayNameHandler(name);
        };
        
        my.videoactive = function (videoelem, resourceJid) {
            
            console.info(resourceJid + " video is now active");
            
            videoelem.show();
            VideoLayout.resizeThumbnails();
            
            // Update the large video to the last added video only if there's no
            // current dominant, focused speaker or prezi playing or update it to
            // the current dominant speaker.
            if ((!focusedVideoResourceJid &&
                !currentDominantSpeaker &&
                !require("../prezi/Prezi").isPresentationVisible()) ||
                focusedVideoResourceJid === resourceJid ||
                (resourceJid &&
                currentDominantSpeaker === resourceJid)) {
                LargeVideo.updateLargeVideo(resourceJid, true);
            }
        };
        
        /**
         * Shows the presence status message for the given video.
         */
        my.setPresenceStatus = function (resourceJid, statusMsg) {
            remoteVideos[resourceJid].setPresenceStatus(statusMsg);
        };
        
        /**
         * Shows a visual indicator for the moderator of the conference.
         */
        my.showModeratorIndicator = function () {
            
            var isModerator = APP.xmpp.isModerator();
            if (isModerator) {
                localVideoThumbnail.createModeratorIndicatorElement();
            }
            
            var members = APP.xmpp.getMembers();
            
            Object.keys(members).forEach(function (jid) {
                
                if (Strophe.getResourceFromJid(jid) === 'focus') {
                    // Skip server side focus
                    return;
                }
                
                var resourceJid = Strophe.getResourceFromJid(jid);
                var member = members[jid];
                
                if (member.role === 'moderator') {
                    remoteVideos[resourceJid].removeRemoteVideoMenu();
                    remoteVideos[resourceJid].createModeratorIndicatorElement();
                } else if (isModerator) {
                    // We are moderator, but user is not - add menu
                    if ($('#remote_popupmenu_' + resourceJid).length <= 0) {
                        remoteVideos[resourceJid].addRemoteVideoMenu();
                    }
                }
            });
        };
        
        /*
         * Shows or hides the audio muted indicator over the local thumbnail video.
         * @param {boolean} isMuted
         */
        my.showLocalAudioIndicator = function(isMuted) {
            localVideoThumbnail.showAudioIndicator(isMuted);
        };
        
        /**
         * Resizes the large video container.
         */
        my.resizeLargeVideoContainer = function () {
            if(LargeVideo.isEnabled()) {
                LargeVideo.resize();
            } else {
                VideoLayout.resizeVideoSpace();
            }
            VideoLayout.resizeThumbnails();
            LargeVideo.position();
        };
        
        /**
         * Resizes thumbnails.
         */
        my.resizeThumbnails = function(animate) {
            var videoSpaceWidth = $('#remoteVideos').width();
            
            var thumbnailSize = VideoLayout.calculateThumbnailSize(videoSpaceWidth);
            var width = thumbnailSize[0];
            var height = thumbnailSize[1];
            
            $('.userAvatar').css('left', (width - height) / 2);
            
            if(animate) {
                $('#remoteVideos').animate({
                        height: height + 2 // adds 2 px because of small video 1px border
                    },
                    {
                        queue: false,
                        duration: 500
                    });
                
                $('#remoteVideos>span').animate({
                        height: height,
                        width: width
                    },
                    {
                        queue: false,
                        duration: 500,
                        complete: function () {
                            $(document).trigger(
                                "remotevideo.resized",
                                [width,
                                    height]);
                        }
                    });
                
            } else {
                // size videos so that while keeping AR and max height, we have a
                // nice fit
                $('#remoteVideos').height(height + 2);// adds 2 px because of small video 1px border
                $('#remoteVideos>span').width(width);
                $('#remoteVideos>span').height(height);
                
                $(document).trigger("remotevideo.resized", [width, height]);
            }
        };
        
        /**
         * Calculates the thumbnail size.
         *
         * @param videoSpaceWidth the width of the video space
         */
        my.calculateThumbnailSize = function (videoSpaceWidth) {
            // Calculate the available height, which is the inner window height minus
            // 39px for the header minus 2px for the delimiter lines on the top and
            // bottom of the large video, minus the 36px space inside the remoteVideos
            // container used for highlighting shadow.
            var availableHeight = 100;
            
            var numvids = $('#remoteVideos>span:visible').length;
            if (localLastNCount && localLastNCount > 0) {
                numvids = Math.min(localLastNCount + 1, numvids);
            }
            
            // Remove the 3px borders arround videos and border around the remote
            // videos area and the 4 pixels between the local video and the others
            //TODO: Find out where the 4 pixels come from and remove them
            var availableWinWidth = videoSpaceWidth - 2 * 3 * numvids - 70 - 4;
            
            var availableWidth = availableWinWidth / numvids;
            var aspectRatio = 16.0 / 9.0;
            var maxHeight = Math.min(160, availableHeight);
            availableHeight = Math.min(maxHeight, availableWidth / aspectRatio, window.innerHeight - 18);
            if (availableHeight < availableWidth / aspectRatio) {
                availableWidth = Math.floor(availableHeight * aspectRatio);
            }
            
            return [availableWidth, availableHeight];
        };
        
        /**
         * Returns the corresponding resource jid to the given peer container
         * DOM element.
         *
         * @return the corresponding resource jid to the given peer container
         * DOM element
         */
        my.getPeerContainerResourceJid = function (containerElement) {
            if (localVideoThumbnail.container === containerElement) {
                return localVideoThumbnail.getResourceJid();
            }
            
            var i = containerElement.id.indexOf('participant_');
            
            if (i >= 0)
                return containerElement.id.substring(i + 12);
        };
        
        /**
         * On contact list item clicked.
         */
        $(ContactList).bind('contactclicked', function(event, jid) {
            if (!jid) {
                return;
            }
            
            if (jid === APP.xmpp.myJid()) {
                $("#localVideoContainer").click();
                return;
            }
            
            var resource = Strophe.getResourceFromJid(jid);
            var remoteVideo = remoteVideos[resource];
            if (remoteVideo && remoteVideo.selectVideoElement().length) {
                var videoThumb = remoteVideo.selectVideoElement()[0];
                // It is not always the case that a videoThumb exists (if there is
                // no actual video).
                if (RTC.getVideoSrc(videoThumb)) {
                    
                    // We have a video src, great! Let's update the large video
                    // now.
                    VideoLayout.handleVideoThumbClicked(
                        false,
                        Strophe.getResourceFromJid(jid));
                } else {
                    
                    // If we don't have a video src for jid, there's absolutely
                    // no point in calling handleVideoThumbClicked; Quite
                    // simply, it won't work because it needs an src to attach
                    // to the large video.
                    //
                    // Instead, we trigger the pinned endpoint changed event to
                    // let the bridge adjust its lastN set for myjid and store
                    // the pinned user in the lastNPickupJid variable to be
                    // picked up later by the lastN changed event handler.
                    
                    lastNPickupJid = jid;
                    eventEmitter.emit(UIEvents.PINNED_ENDPOINT,
                        Strophe.getResourceFromJid(jid));
                }
            }
        });
        
        /**
         * On audio muted event.
         */
        my.onAudioMute = function (jid, isMuted) {
            var resourceJid = Strophe.getResourceFromJid(jid);
            if (resourceJid === APP.xmpp.myResource()) {
                localVideoThumbnail.showAudioIndicator(isMuted);
            } else {
                VideoLayout.ensurePeerContainerExists(jid);
                remoteVideos[resourceJid].showAudioIndicator(isMuted);
                if (APP.xmpp.isModerator()) {
                    remoteVideos[resourceJid].updateRemoteVideoMenu(isMuted);
                }
            }
        };
        
        /**
         * On video muted event.
         */
        my.onVideoMute = function (jid, value) {
            if (jid !== APP.xmpp.myJid() &&
                !APP.RTC.muteRemoteVideoStream(jid, value))
                return;
            
            if (jid === APP.xmpp.myJid()) {
                localVideoThumbnail.showVideoIndicator(value);
            } else {
                var resource = Strophe.getResourceFromJid(jid);
                
                VideoLayout.ensurePeerContainerExists(jid);
                var remoteVideo = remoteVideos[resource];
                remoteVideo.showVideoIndicator(value);
                
                var el = remoteVideo.selectVideoElement();
                if (!value)
                    el.show();
                else
                    el.hide();
            }
        };
        
        /**
         * Display name changed.
         */
        my.onDisplayNameChanged =
            function (jid, displayName, status) {
                if (jid === 'localVideoContainer' ||
                    jid === APP.xmpp.myJid()) {
                    localVideoThumbnail.setDisplayName(displayName);
                } else {
                    VideoLayout.ensurePeerContainerExists(jid);
                    remoteVideos[Strophe.getResourceFromJid(jid)].setDisplayName(
                        displayName,
                        status);
                }
            };
        
        /**
         * On dominant speaker changed event.
         */
        my.onDominantSpeakerChanged = function (resourceJid) {
            // We ignore local user events.
            if (resourceJid === APP.xmpp.myResource())
                return;
            
            var remoteVideo = remoteVideos[resourceJid];
            var members = APP.xmpp.getMembers();
            // Update the current dominant speaker.
            if (resourceJid !== currentDominantSpeaker) {
                var currentJID = APP.xmpp.findJidFromResource(currentDominantSpeaker);
                var newJID = APP.xmpp.findJidFromResource(resourceJid);
                if (currentDominantSpeaker && (!members || !members[currentJID] ||
                    !members[currentJID].displayName) && remoteVideo) {
                    remoteVideo.setDisplayName(null);
                }
                if (resourceJid && (!members || !members[newJID] ||
                    !members[newJID].displayName) && remoteVideo) {
                    remoteVideo.setDisplayName(null,
                        interfaceConfig.DEFAULT_DOMINANT_SPEAKER_DISPLAY_NAME);
                }
                currentDominantSpeaker = resourceJid;
            } else {
                return;
            }
            
            if (!remoteVideo)
                return;
            
            // Obtain container for new dominant speaker.
            var videoSel  = remoteVideo.selectVideoElement();
            
            // Local video will not have container found, but that's ok
            // since we don't want to switch to local video.
            if (!focusedVideoResourceJid && videoSel.length) {
                // Update the large video if the video source is already available,
                // otherwise wait for the "videoactive.jingle" event.
                if (videoSel[0].currentTime > 0) {
                    LargeVideo.updateLargeVideo(resourceJid);
                }
            }
        };
        
        /**
         * On last N change event.
         *
         * @param lastNEndpoints the list of last N endpoints
         * @param endpointsEnteringLastN the list currently entering last N
         * endpoints
         */
        my.onLastNEndpointsChanged = function (lastNEndpoints,
                                               endpointsEnteringLastN,
                                               stream) {
            if (lastNCount !== lastNEndpoints.length)
                lastNCount = lastNEndpoints.length;
            
            lastNEndpointsCache = lastNEndpoints;
            
            // Say A, B, C, D, E, and F are in a conference and LastN = 3.
            //
            // If LastN drops to, say, 2, because of adaptivity, then E should see
            // thumbnails for A, B and C. A and B are in E's server side LastN set,
            // so E sees them. C is only in E's local LastN set.
            //
            // If F starts talking and LastN = 3, then E should see thumbnails for
            // F, A, B. B gets "ejected" from E's server side LastN set, but it
            // enters E's local LastN ejecting C.
            
            // Increase the local LastN set size, if necessary.
            if (lastNCount > localLastNCount) {
                localLastNCount = lastNCount;
            }
            
            // Update the local LastN set preserving the order in which the
            // endpoints appeared in the LastN/local LastN set.
            
            var nextLocalLastNSet = lastNEndpoints.slice(0);
            for (var i = 0; i < localLastNSet.length; i++) {
                if (nextLocalLastNSet.length >= localLastNCount) {
                    break;
                }
                
                var resourceJid = localLastNSet[i];
                if (nextLocalLastNSet.indexOf(resourceJid) === -1) {
                    nextLocalLastNSet.push(resourceJid);
                }
            }
            
            localLastNSet = nextLocalLastNSet;
            var updateLargeVideo = false;
            
            // Handle LastN/local LastN changes.
            $('#remoteVideos>span').each(function( index, element ) {
                var resourceJid = VideoLayout.getPeerContainerResourceJid(element);
                
                var isReceived = true;
                if (resourceJid &&
                    lastNEndpoints.indexOf(resourceJid) < 0 &&
                    localLastNSet.indexOf(resourceJid) < 0) {
                    console.log("Remove from last N", resourceJid);
                    if (remoteVideos[resourceJid])
                        remoteVideos[resourceJid].showPeerContainer('hide');
                    else if (APP.xmpp.myResource() !== resourceJid)
                        console.error("No remote video for: " + resourceJid);
                    isReceived = false;
                } else if (resourceJid &&
                    $('#participant_' + resourceJid).is(':visible') &&
                    lastNEndpoints.indexOf(resourceJid) < 0 &&
                    localLastNSet.indexOf(resourceJid) >= 0) {
                    if (remoteVideos[resourceJid])
                        remoteVideos[resourceJid].showPeerContainer('avatar');
                    else if (APP.xmpp.myResource() !== resourceJid)
                        console.error("No remote video for: " + resourceJid);
                    isReceived = false;
                }
                
                if (!isReceived) {
                    // resourceJid has dropped out of the server side lastN set, so
                    // it is no longer being received. If resourceJid was being
                    // displayed in the large video we have to switch to another
                    // user.
                    if (!updateLargeVideo &&
                        resourceJid === LargeVideo.getResourceJid()) {
                        updateLargeVideo = true;
                    }
                }
            });
            
            if (!endpointsEnteringLastN || endpointsEnteringLastN.length < 0)
                endpointsEnteringLastN = lastNEndpoints;
            
            if (endpointsEnteringLastN && endpointsEnteringLastN.length > 0) {
                endpointsEnteringLastN.forEach(function (resourceJid) {
                    
                    var isVisible = $('#participant_' + resourceJid).is(':visible');
                    var remoteVideo = remoteVideos[resourceJid];
                    remoteVideo.showPeerContainer('show');
                    if (!isVisible) {
                        console.log("Add to last N", resourceJid);
                        
                        var jid = APP.xmpp.findJidFromResource(resourceJid);
                        var mediaStream =
                            APP.RTC.remoteStreams[jid][MediaStreamType.VIDEO_TYPE];
                        var sel = remoteVideo.selectVideoElement();
                        
                        APP.RTC.attachMediaStream(sel, mediaStream.stream);
                        if (lastNPickupJid == mediaStream.peerjid) {
                            // Clean up the lastN pickup jid.
                            lastNPickupJid = null;
                            
                            // Don't fire the events again, they've already
                            // been fired in the contact list click handler.
                            VideoLayout.handleVideoThumbClicked(
                                false,
                                Strophe.getResourceFromJid(mediaStream.peerjid));
                            
                            updateLargeVideo = false;
                        }
                        remoteVideos[resourceJid].
                            waitForPlayback(sel, mediaStream.stream);
                    }
                });
            }
            
            // The endpoint that was being shown in the large video has dropped out
            // of the lastN set and there was no lastN pickup jid. We need to update
            // the large video now.
            
            if (updateLargeVideo) {
                var resource;
                var myResource
                    = APP.xmpp.myResource();
                
                // Find out which endpoint to show in the large video.
                for (i = 0; i < lastNEndpoints.length; i++) {
                    resource = lastNEndpoints[i];
                    if (!resource || resource === myResource)
                        continue;
                    
                    // videoSrcToSsrc needs to be update for this call to succeed.
                    LargeVideo.updateLargeVideo(resource);
                    break;
                }
            }
        };
        
        /**
         * Updates local stats
         * @param percent
         * @param object
         */
        my.updateLocalConnectionStats = function (percent, object) {
            var resolution = null;
            if (object.resolution !== null) {
                resolution = object.resolution;
                object.resolution = resolution[APP.xmpp.myJid()];
                delete resolution[APP.xmpp.myJid()];
            }
            localVideoThumbnail.updateStatsIndicator(percent, object);
            for (var jid in resolution) {
                if (resolution[jid] === null)
                    continue;
                var resourceJid = Strophe.getResourceFromJid(jid);
                if (remoteVideos[resourceJid] &&
                    remoteVideos[resourceJid].connectionIndicator) {
                    remoteVideos[resourceJid].connectionIndicator.
                        updateResolution(resolution[jid]);
                }
            }
        };
        
        /**
         * Updates remote stats.
         * @param jid the jid associated with the stats
         * @param percent the connection quality percent
         * @param object the stats data
         */
        my.updateConnectionStats = function (jid, percent, object) {
            var resourceJid = Strophe.getResourceFromJid(jid);
            
            if (remoteVideos[resourceJid])
                remoteVideos[resourceJid].updateStatsIndicator(percent, object);
        };
        
        /**
         * Hides the connection indicator
         * @param jid
         */
        my.hideConnectionIndicator = function (jid) {
            remoteVideos[Strophe.getResourceFromJid(jid)].hideConnectionIndicator();
        };
        
        /**
         * Hides all the indicators
         */
        my.onStatsStop = function () {
            for(var video in remoteVideos) {
                remoteVideos[video].hideIndicator();
            }
            localVideoThumbnail.hideIndicator();
        };
        
        my.participantLeft = function (jid) {
            // Unlock large video
            var resourceJid = Strophe.getResourceFromJid(jid);
            if (focusedVideoResourceJid === resourceJid) {
                console.info("Focused video owner has left the conference");
                focusedVideoResourceJid = null;
            }
            
            if (currentDominantSpeaker === resourceJid) {
                console.info("Dominant speaker has left the conference");
                currentDominantSpeaker = null;
            }
            
            var remoteVideo = remoteVideos[resourceJid];
            if (remoteVideo) {
                // Remove remote video
                console.info("Removing remote video: " + resourceJid);
                delete remoteVideos[resourceJid];
                remoteVideo.remove();
            } else {
                console.warn("No remote video for " + resourceJid);
            }
            
            VideoLayout.resizeThumbnails();
        };
        
        my.onVideoTypeChanged = function (resourceJid, newVideoType) {
            if (remoteVideoTypes[resourceJid] === newVideoType) {
                return;
            }
            
            console.info("Peer video type changed: ", resourceJid, newVideoType);
            remoteVideoTypes[resourceJid] = newVideoType;
            
            var smallVideo;
            if (resourceJid === APP.xmpp.myResource()) {
                if (!localVideoThumbnail) {
                    console.warn("Local video not ready yet");
                    return;
                }
                smallVideo = localVideoThumbnail;
            } else if (remoteVideos[resourceJid]) {
                smallVideo = remoteVideos[resourceJid];
            } else {
                return;
            }
            
            smallVideo.setVideoType(newVideoType);
            LargeVideo.onVideoTypeChanged(resourceJid, newVideoType);
            
        };
        
        my.showMore = function (jid) {
            if (jid === 'local') {
                localVideoThumbnail.connectionIndicator.showMore();
            } else {
                var remoteVideo = remoteVideos[Strophe.getResourceFromJid(jid)];
                if (remoteVideo) {
                    remoteVideo.connectionIndicator.showMore();
                } else {
                    console.info("Error - no remote video for jid: " + jid);
                }
            }
        };
        
        my.addPreziContainer = function (id) {
            var container = RemoteVideo.createContainer(id);
            VideoLayout.resizeThumbnails();
            return container;
        };
        
        my.setLargeVideoVisible = function (isVisible) {
            LargeVideo.setLargeVideoVisible(isVisible);
            if(!isVisible && focusedVideoResourceJid) {
                var smallVideo = VideoLayout.getSmallVideo(focusedVideoResourceJid);
                if(smallVideo) {
                    smallVideo.focus(false);
                    smallVideo.showAvatar();
                }
                focusedVideoResourceJid = null;
            }
        };
        
        /**
         * Resizes the video area
         * @param callback a function to be called when the video space is
         * resized.
         */
        my.resizeVideoArea = function(isVisible, callback) {
            LargeVideo.resizeVideoAreaAnimated(isVisible, callback);
            VideoLayout.resizeThumbnails(true);
        };
        
        /**
         * Resizes the #videospace html element
         * @param animate boolean property that indicates whether the resize should be animated or not.
         * @param isChatVisible boolean property that indicates whether the chat area is displayed or not.
         * If that parameter is null the method will check the chat pannel visibility.
         * @param completeFunction a function to be called when the video space is resized
         */
        my.resizeVideoSpace = function (animate, isChatVisible, completeFunction) {
            var availableHeight = window.innerHeight;
            var availableWidth = UIUtil.getAvailableVideoWidth(isChatVisible);
            
            if (availableWidth < 0 || availableHeight < 0) return;
            
            if(animate) {
                $('#videospace').animate({
                        right: window.innerWidth - availableWidth,
                        width: availableWidth,
                        height: availableHeight
                    },
                    {
                        queue: false,
                        duration: 500,
                        complete: completeFunction
                    });
            } else {
                $('#videospace').width(availableWidth);
                $('#videospace').height(availableHeight);
            }
            
        };
        
        my.getSmallVideo = function (resourceJid) {
            if(resourceJid == APP.xmpp.myResource()) {
                return localVideoThumbnail;
            } else {
                if(!remoteVideos[resourceJid])
                    return null;
                return remoteVideos[resourceJid];
            }
        };
        
        my.userAvatarChanged = function(resourceJid, thumbUrl) {
            var smallVideo = VideoLayout.getSmallVideo(resourceJid);
            if(smallVideo)
                smallVideo.avatarChanged(thumbUrl);
            else
                console.warn(
                    "Missed avatar update - no small video yet for " + resourceJid);
            LargeVideo.updateAvatar(resourceJid, thumbUrl);
        };
        
        my.createEtherpadIframe = function(src, onloadHandler)
        {
            return LargeVideo.createEtherpadIframe(src, onloadHandler);
        };
        
        my.setLargeVideoState = function (state) {
            LargeVideo.setState(state);
        };
        
        my.getLargeVideoState = function () {
            return LargeVideo.getState();
        };
        
        my.setLargeVideoHover = function (inHandler, outHandler) {
            LargeVideo.setHover(inHandler, outHandler);
        };
        
        /**
         * Indicates that the video has been interrupted.
         */
        my.onVideoInterrupted = function () {
            LargeVideo.enableVideoProblemFilter(true);
            var reconnectingKey = "connection.RECONNECTING";
            $('#videoConnectionMessage').attr("data-i18n", reconnectingKey);
            $('#videoConnectionMessage').text(APP.translation.translateString(reconnectingKey));
            $('#videoConnectionMessage').css({display: "block"});
        };
        
        /**
         * Indicates that the video has been restored.
         */
        my.onVideoRestored = function () {
            LargeVideo.enableVideoProblemFilter(false);
            $('#videoConnectionMessage').css({display: "none"});
        };
        
        return my;
    }(VideoLayout || {}));
    
    module.exports = VideoLayout;
},{"../../../service/RTC/MediaStreamTypes":177,"../../../service/UI/UIEvents":181,"../../RTC/RTC":6,"../../RTC/RTCBrowserType":7,"../audio_levels/AudioLevels":11,"../prezi/Prezi":17,"../side_pannels/contactlist/ContactList":24,"../util/UIUtil":32,"./LargeVideo":34,"./LocalVideo":35,"./RemoteVideo":36}],39:[function(require,module,exports){
    /* jshint -W101 */
    //var nouns = [
    //];
    var pluralNouns = [
        "Aliens", "Animals", "Antelopes", "Ants", "Apes", "Apples", "Baboons", "Bacteria", "Badgers", "Bananas", "Bats",
        "Bears", "Birds", "Bonobos", "Brides", "Bugs", "Bulls", "Butterflies", "Cheetahs",
        "Cherries", "Chicken", "Children", "Chimps", "Clowns", "Cows", "Creatures", "Dinosaurs", "Dogs", "Dolphins",
        "Donkeys", "Dragons", "Ducks", "Dwarfs", "Eagles", "Elephants", "Elves", "Fathers",
        "Fish", "Flowers", "Frogs", "Fruit", "Fungi", "Galaxies", "Geese", "Goats",
        "Gorillas", "Hedgehogs", "Hippos", "Horses", "Hunters", "Insects", "Kids", "Knights",
        "Lemons", "Lemurs", "Leopards", "LifeForms", "Lions", "Lizards", "Mice", "Monkeys", "Monsters",
        "Mushrooms", "Octopodes", "Oranges", "Orangutans", "Organisms", "Pants", "Parrots", "Penguins",
        "People", "Pigeons", "Pigs", "Pineapples", "Plants", "Potatoes", "Priests", "Rats", "Reptiles", "Reptilians",
        "Rhinos", "Seagulls", "Sheep", "Siblings", "Snakes", "Spaghetti", "Spiders", "Squid", "Squirrels",
        "Stars", "Students", "Teachers", "Tigers", "Tomatoes", "Trees", "Vampires", "Vegetables", "Viruses", "Vulcans",
        "Warewolves", "Weasels", "Whales", "Witches", "Wizards", "Wolves", "Workers", "Worms", "Zebras"
    ];
    //var places = [
    //"Pub", "University", "Airport", "Library", "Mall", "Theater", "Stadium", "Office", "Show", "Gallows", "Beach",
    // "Cemetery", "Hospital", "Reception", "Restaurant", "Bar", "Church", "House", "School", "Square", "Village",
    // "Cinema", "Movies", "Party", "Restroom", "End", "Jail", "PostOffice", "Station", "Circus", "Gates", "Entrance",
    // "Bridge"
    //];
    var verbs = [
        "Abandon", "Adapt", "Advertise", "Answer", "Anticipate", "Appreciate",
        "Approach", "Argue", "Ask", "Bite", "Blossom", "Blush", "Breathe", "Breed", "Bribe", "Burn", "Calculate",
        "Clean", "Code", "Communicate", "Compute", "Confess", "Confiscate", "Conjugate", "Conjure", "Consume",
        "Contemplate", "Crawl", "Dance", "Delegate", "Devour", "Develop", "Differ", "Discuss",
        "Dissolve", "Drink", "Eat", "Elaborate", "Emancipate", "Estimate", "Expire", "Extinguish",
        "Extract", "Facilitate", "Fall", "Feed", "Finish", "Floss", "Fly", "Follow", "Fragment", "Freeze",
        "Gather", "Glow", "Grow", "Hex", "Hide", "Hug", "Hurry", "Improve", "Intersect", "Investigate", "Jinx",
        "Joke", "Jubilate", "Kiss", "Laugh", "Manage", "Meet", "Merge", "Move", "Object", "Observe", "Offer",
        "Paint", "Participate", "Party", "Perform", "Plan", "Pursue", "Pierce", "Play", "Postpone", "Pray", "Proclaim",
        "Question", "Read", "Reckon", "Rejoice", "Represent", "Resize", "Rhyme", "Scream", "Search", "Select", "Share", "Shoot",
        "Shout", "Signal", "Sing", "Skate", "Sleep", "Smile", "Smoke", "Solve", "Spell", "Steer", "Stink",
        "Substitute", "Swim", "Taste", "Teach", "Terminate", "Think", "Type", "Unite", "Vanish", "Worship"
    ];
    var adverbs = [
        "Absently", "Accurately", "Accusingly", "Adorably", "AllTheTime", "Alone", "Always", "Amazingly", "Angrily",
        "Anxiously", "Anywhere", "Appallingly", "Apparently", "Articulately", "Astonishingly", "Badly", "Barely",
        "Beautifully", "Blindly", "Bravely", "Brightly", "Briskly", "Brutally", "Calmly", "Carefully", "Casually",
        "Cautiously", "Cleverly", "Constantly", "Correctly", "Crazily", "Curiously", "Cynically", "Daily",
        "Dangerously", "Deliberately", "Delicately", "Desperately", "Discreetly", "Eagerly", "Easily", "Euphoricly",
        "Evenly", "Everywhere", "Exactly", "Expectantly", "Extensively", "Ferociously", "Fiercely", "Finely",
        "Flatly", "Frequently", "Frighteningly", "Gently", "Gloriously", "Grimly", "Guiltily", "Happily",
        "Hard", "Hastily", "Heroically", "High", "Highly", "Hourly", "Humbly", "Hysterically", "Immensely",
        "Impartially", "Impolitely", "Indifferently", "Intensely", "Jealously", "Jovially", "Kindly", "Lazily",
        "Lightly", "Loudly", "Lovingly", "Loyally", "Magnificently", "Malevolently", "Merrily", "Mightily", "Miserably",
        "Mysteriously", "NOT", "Nervously", "Nicely", "Nowhere", "Objectively", "Obnoxiously", "Obsessively",
        "Obviously", "Often", "Painfully", "Patiently", "Playfully", "Politely", "Poorly", "Precisely", "Promptly",
        "Quickly", "Quietly", "Randomly", "Rapidly", "Rarely", "Recklessly", "Regularly", "Remorsefully", "Responsibly",
        "Rudely", "Ruthlessly", "Sadly", "Scornfully", "Seamlessly", "Seldom", "Selfishly", "Seriously", "Shakily",
        "Sharply", "Sideways", "Silently", "Sleepily", "Slightly", "Slowly", "Slyly", "Smoothly", "Softly", "Solemnly",
        "Steadily", "Sternly", "Strangely", "Strongly", "Stunningly", "Surely", "Tenderly", "Thoughtfully",
        "Tightly", "Uneasily", "Vanishingly", "Violently", "Warmly", "Weakly", "Wearily", "Weekly", "Weirdly", "Well",
        "Well", "Wickedly", "Wildly", "Wisely", "Wonderfully", "Yearly"
    ];
    var adjectives = [
        "Abominable", "Accurate", "Adorable", "All", "Alleged", "Ancient", "Angry", "Angry", "Anxious", "Appalling",
        "Apparent", "Astonishing", "Attractive", "Awesome", "Baby", "Bad", "Beautiful", "Benign", "Big", "Bitter",
        "Blind", "Blue", "Bold", "Brave", "Bright", "Brisk", "Calm", "Camouflaged", "Casual", "Cautious",
        "Choppy", "Chosen", "Clever", "Cold", "Cool", "Crawly", "Crazy", "Creepy", "Cruel", "Curious", "Cynical",
        "Dangerous", "Dark", "Delicate", "Desperate", "Difficult", "Discreet", "Disguised", "Dizzy",
        "Dumb", "Eager", "Easy", "Edgy", "Electric", "Elegant", "Emancipated", "Enormous", "Euphoric", "Evil",
        "Fast", "Ferocious", "Fierce", "Fine", "Flawed", "Flying", "Foolish", "Foxy",
        "Freezing", "Funny", "Furious", "Gentle", "Glorious", "Golden", "Good", "Green", "Green", "Guilty",
        "Hairy", "Happy", "Hard", "Hasty", "Hazy", "Heroic", "Hostile", "Hot", "Humble", "Humongous",
        "Humorous", "Hysterical", "Idealistic", "Ignorant", "Immense", "Impartial", "Impolite", "Indifferent",
        "Infuriated", "Insightful", "Intense", "Interesting", "Intimidated", "Intriguing", "Jealous", "Jolly", "Jovial",
        "Jumpy", "Kind", "Laughing", "Lazy", "Liquid", "Lonely", "Longing", "Loud", "Loving", "Loyal", "Macabre", "Mad",
        "Magical", "Magnificent", "Malevolent", "Medieval", "Memorable", "Mere", "Merry", "Mighty",
        "Mischievous", "Miserable", "Modified", "Moody", "Most", "Mysterious", "Mystical", "Needy",
        "Nervous", "Nice", "Objective", "Obnoxious", "Obsessive", "Obvious", "Opinionated", "Orange",
        "Painful", "Passionate", "Perfect", "Pink", "Playful", "Poisonous", "Polite", "Poor", "Popular", "Powerful",
        "Precise", "Preserved", "Pretty", "Purple", "Quick", "Quiet", "Random", "Rapid", "Rare", "Real",
        "Reassuring", "Reckless", "Red", "Regular", "Remorseful", "Responsible", "Rich", "Rude", "Ruthless",
        "Sad", "Scared", "Scary", "Scornful", "Screaming", "Selfish", "Serious", "Shady", "Shaky", "Sharp",
        "Shiny", "Shy", "Simple", "Sleepy", "Slow", "Sly", "Small", "Smart", "Smelly", "Smiling", "Smooth",
        "Smug", "Sober", "Soft", "Solemn", "Square", "Square", "Steady", "Strange", "Strong",
        "Stunning", "Subjective", "Successful", "Surly", "Sweet", "Tactful", "Tense",
        "Thoughtful", "Tight", "Tiny", "Tolerant", "Uneasy", "Unique", "Unseen", "Warm", "Weak",
        "Weird", "WellCooked", "Wild", "Wise", "Witty", "Wonderful", "Worried", "Yellow", "Young",
        "Zealous"
    ];
    //var pronouns = [
    //];
    //var conjunctions = [
    //"And", "Or", "For", "Above", "Before", "Against", "Between"
    //];
    
    /*
     * Maps a string (category name) to the array of words from that category.
     */
    var CATEGORIES =
    {
        //"_NOUN_": nouns,
        "_PLURALNOUN_": pluralNouns,
        //"_PLACE_": places,
        "_VERB_": verbs,
        "_ADVERB_": adverbs,
        "_ADJECTIVE_": adjectives
        //"_PRONOUN_": pronouns,
        //"_CONJUNCTION_": conjunctions,
    };
    
    var PATTERNS = [
        "_ADJECTIVE__PLURALNOUN__VERB__ADVERB_"
        
        // BeautifulFungiOrSpaghetti
        //"_ADJECTIVE__PLURALNOUN__CONJUNCTION__PLURALNOUN_",
        
        // AmazinglyScaryToy
        //"_ADVERB__ADJECTIVE__NOUN_",
        
        // NeitherTrashNorRifle
        //"Neither_NOUN_Nor_NOUN_",
        //"Either_NOUN_Or_NOUN_",
        
        // EitherCopulateOrInvestigate
        //"Either_VERB_Or_VERB_",
        //"Neither_VERB_Nor_VERB_",
        
        //"The_ADJECTIVE__ADJECTIVE__NOUN_",
        //"The_ADVERB__ADJECTIVE__NOUN_",
        //"The_ADVERB__ADJECTIVE__NOUN_s",
        //"The_ADVERB__ADJECTIVE__PLURALNOUN__VERB_",
        
        // WolvesComputeBadly
        //"_PLURALNOUN__VERB__ADVERB_",
        
        // UniteFacilitateAndMerge
        //"_VERB__VERB_And_VERB_",
        
        //NastyWitchesAtThePub
        //"_ADJECTIVE__PLURALNOUN_AtThe_PLACE_",
    ];
    
    
    /*
     * Returns a random element from the array 'arr'
     */
    function randomElement(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
    
    /*
     * Returns true if the string 's' contains one of the
     * template strings.
     */
    function hasTemplate(s) {
        for (var template in CATEGORIES){
            if (s.indexOf(template) >= 0){
                return true;
            }
        }
    }
    
    /**
     * Generates new room name.
     */
    var RoomNameGenerator = {
        generateRoomWithoutSeparator: function() {
            // Note that if more than one pattern is available, the choice of
            // 'name' won't have a uniform distribution amongst all patterns (names
            // from patterns with fewer options will have higher probability of
            // being chosen that names from patterns with more options).
            var name = randomElement(PATTERNS);
            var word;
            while (hasTemplate(name)) {
                for (var template in CATEGORIES) {
                    word = randomElement(CATEGORIES[template]);
                    name = name.replace(template, word);
                }
            }
            
            return name;
        }
    };
    
    module.exports = RoomNameGenerator;
    
},{}],40:[function(require,module,exports){
    /* global $, interfaceConfig */
    var animateTimeout, updateTimeout;
    
    var RoomNameGenerator = require("./RoomnameGenerator");
    
    function enter_room() {
        var val = $("#enter_room_field").val();
        if(!val) {
            val = $("#enter_room_field").attr("room_name");
        }
        if (val) {
            window.location.pathname = "/" + val;
        }
    }
    
    function animate(word) {
        var currentVal = $("#enter_room_field").attr("placeholder");
        $("#enter_room_field").attr("placeholder", currentVal + word.substr(0, 1));
        animateTimeout = setTimeout(function() {
            animate(word.substring(1, word.length));
        }, 70);
    }
    
    function update_roomname() {
        var word = RoomNameGenerator.generateRoomWithoutSeparator();
        $("#enter_room_field").attr("room_name", word);
        $("#enter_room_field").attr("placeholder", "");
        clearTimeout(animateTimeout);
        animate(word);
        updateTimeout = setTimeout(update_roomname, 10000);
    }
    
    function setupWelcomePage() {
        $("#videoconference_page").hide();
        $("#domain_name").text(
            window.location.protocol + "//" + window.location.host + "/");
        if (interfaceConfig.SHOW_JITSI_WATERMARK) {
            var leftWatermarkDiv =
                $("#welcome_page_header div[class='watermark leftwatermark']");
            if(leftWatermarkDiv && leftWatermarkDiv.length > 0) {
                leftWatermarkDiv.css({display: 'block'});
                leftWatermarkDiv.parent().get(0).href =
                    interfaceConfig.JITSI_WATERMARK_LINK;
            }
            
        }
        
        if (interfaceConfig.SHOW_BRAND_WATERMARK) {
            var rightWatermarkDiv =
                $("#welcome_page_header div[class='watermark rightwatermark']");
            if(rightWatermarkDiv && rightWatermarkDiv.length > 0) {
                rightWatermarkDiv.css({display: 'block'});
                rightWatermarkDiv.parent().get(0).href =
                    interfaceConfig.BRAND_WATERMARK_LINK;
                rightWatermarkDiv.get(0).style.backgroundImage =
                    "url(images/rightwatermark.png)";
            }
        }
        
        if (interfaceConfig.SHOW_POWERED_BY) {
            $("#welcome_page_header>a[class='poweredby']")
                .css({display: 'block'});
        }
        
        $("#enter_room_button").click(function() {
            enter_room();
        });
        
        $("#enter_room_field").keydown(function (event) {
            if (event.keyCode === 13 /* enter */) {
                enter_room();
            }
        });
        
        if (interfaceConfig.GENERATE_ROOMNAMES_ON_WELCOME_PAGE !== false) {
            var updateTimeout;
            var animateTimeout;
            var selector = $("#reload_roomname");
            selector.click(function () {
                clearTimeout(updateTimeout);
                clearTimeout(animateTimeout);
                update_roomname();
            });
            selector.show();
            
            update_roomname();
        }
        
        $("#disable_welcome").click(function () {
            window.localStorage.welcomePageDisabled =
                $("#disable_welcome").is(":checked");
        });
        
    }
    
    module.exports = setupWelcomePage;
},{"./RoomnameGenerator":39}],41:[function(require,module,exports){
    var jssha = require('jssha');
    
    module.exports = {
        /**
         * Looks for a list of possible BOSH addresses in 'config.boshList' and
         * sets the value of 'config.bosh' based on that list and 'roomName'.
         * @param config the configuration object.
         * @param roomName the name of the room/conference.
         */
        chooseAddress: function(config, roomName) {
            if (!roomName || !config.boshList || !Array.isArray(config.boshList) ||
                !config.boshList.length) {
                return;
            }
            
            // This implements the actual choice of an entry in the list based on
            // roomName. Please consider the implications for existing deployments
            // before introducing changes.
            var hash = (new jssha(roomName, 'TEXT')).getHash('SHA-1', 'HEX');
            var n = parseInt("0x"+hash.substr(-6));
            var idx = n % config.boshList.length;
            var attemptFirstAddress;
            
            config.bosh = config.boshList[idx];
            console.log('Setting config.bosh to ' + config.bosh +
                ' (idx=' + idx + ')');
            
            if (config.boshAttemptFirstList &&
                Array.isArray(config.boshAttemptFirstList) &&
                config.boshAttemptFirstList.length > 0) {
                
                idx = n % config.boshAttemptFirstList.length;
                attemptFirstAddress = config.boshAttemptFirstList[idx];
                
                if (attemptFirstAddress != config.bosh) {
                    config.boshAttemptFirst = attemptFirstAddress;
                    console.log('Setting config.boshAttemptFirst=' +
                        attemptFirstAddress + ' (idx=' + idx + ')');
                } else {
                    console.log('Not setting boshAttemptFirst, address matches.');
                }
            }
        }
    };
    
},{"jssha":85}],42:[function(require,module,exports){
    /* global $, config, interfaceConfig */
    
    var configUtil = require('./Util');
    
    var HttpConfig = {
        /**
         * Sends HTTP POST request to specified <tt>endpoint</tt>. In request
         * the name of the room is included in JSON format:
         * {
     *   "rooomName": "someroom12345"
     * }
         * @param endpoint the name of HTTP endpoint to which HTTP POST request will
         *                 be sent.
         * @param roomName the name of the conference room for which config will be
         *                 requested.
         * @param complete
         */
        obtainConfig: function (endpoint, roomName, complete) {
            console.info(
                "Send config request to " + endpoint + " for room: " + roomName);
            
            
            $.ajax(
                endpoint,
                {
                    method: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({"roomName": roomName}),
                    dataType: 'json',
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error("Get config error: ", jqXHR, errorThrown);
                        var error = "Get config response status: " + textStatus;
                        complete(false, error);
                    },
                    success: function(data, textStatus, jqXHR) {
                        try {
                            configUtil.overrideConfigJSON(
                                config, interfaceConfig, data);
                            complete(true);
                            return;
                        } catch (exception) {
                            console.error("Parse config error: ", exception);
                            complete(false, exception);
                        }
                    }
                }
            );
        }
    };
    
    module.exports = HttpConfig;
},{"./Util":44}],43:[function(require,module,exports){
    /* global $, $iq, config, interfaceConfig */
    var configUtils = require('./Util');
    var params = {};
    function getConfigParamsFromUrl() {
        if (!location.hash)
            return {};
        var hash = location.hash.substr(1);
        var result = {};
        hash.split("&").forEach(function (part) {
            var item = part.split("=");
            result[item[0]] = JSON.parse(
                decodeURIComponent(item[1]).replace(/\\&/, "&"));
        });
        return result;
    }
    
    params = getConfigParamsFromUrl();
    
    var URLProcessor = {
        setConfigParametersFromUrl: function () {
            // Convert 'params' to JSON object
            // We have:
            // {
            //   "config.disableAudioLevels": false,
            //   "config.channelLastN": -1,
            //   "interfaceConfig.APP_NAME": "Jitsi Meet"
            // }
            // We want to have:
            // {
            //   "config": {
            //     "disableAudioLevels": false,
            //     "channelLastN": -1
            //   },
            //   interfaceConfig: {
            //     APP_NAME: "Jitsi Meet"
            //   }
            // }
            var configJSON = {
                config: {},
                interfaceConfig: {}
            };
            for (var key in params) {
                if (typeof key !== "string") {
                    console.warn("Invalid config key: ", key);
                    continue;
                }
                var confObj = null, confKey;
                if (key.indexOf("config.") === 0) {
                    confObj = configJSON.config;
                    confKey = key.substr("config.".length);
                } else if (key.indexOf("interfaceConfig.") === 0) {
                    confObj = configJSON.interfaceConfig;
                    confKey = key.substr("interfaceConfig.".length);
                }
                
                if (!confObj)
                    continue;
                
                confObj[confKey] = params[key];
            }
            configUtils.overrideConfigJSON(config, interfaceConfig, configJSON);
        }
    };
    
    module.exports = URLProcessor;
},{"./Util":44}],44:[function(require,module,exports){
    /* global $ */
    var ConfigUtil = {
        /**
         * Method overrides JSON properties in <tt>config</tt> and
         * <tt>interfaceConfig</tt> Objects with the values from <tt>newConfig</tt>
         * @param config the config object for which we'll be overriding properties
         * @param interfaceConfig the interfaceConfig object for which we'll be
         *                        overriding properties.
         * @param newConfig object containing configuration properties. Destination
         *        object is selected based on root property name:
         *        {
     *          config: {
     *             // config.js properties to be
     *          },
     *          interfaceConfig: {
     *             // interfaceConfig.js properties here
     *          }
     *        }
         */
        overrideConfigJSON: function (config, interfaceConfig, newConfig) {
            var configRoot, key, value, confObj;
            for (configRoot in newConfig) {
                confObj = null;
                if (configRoot == "config") {
                    confObj = config;
                } else if (configRoot == "interfaceConfig") {
                    confObj = interfaceConfig;
                } else {
                    continue;
                }
                
                for (key in newConfig[configRoot]) {
                    value = newConfig[configRoot][key];
                    if (confObj[key] && typeof confObj[key] !== typeof value) {
                        console.log("Overriding a " + configRoot +
                            " property with a property of different type.");
                    }
                    console.info("Overriding " + key + " with: " + value);
                    confObj[key] = value;
                }
            }
        }
    };
    
    module.exports = ConfigUtil;
},{}],45:[function(require,module,exports){
    /* global APP, require */
    /* jshint -W101 */
    var EventEmitter = require("events");
    var eventEmitter = new EventEmitter();
    var CQEvents = require("../../service/connectionquality/CQEvents");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var StatisticsEvents = require("../../service/statistics/Events");
    
    /**
     * local stats
     * @type {{}}
     */
    var stats = {};
    
    /**
     * remote stats
     * @type {{}}
     */
    var remoteStats = {};
    
    /**
     * Interval for sending statistics to other participants
     * @type {null}
     */
    var sendIntervalId = null;
    
    
    /**
     * Start statistics sending.
     */
    function startSendingStats() {
        sendStats();
        sendIntervalId = setInterval(sendStats, 10000);
    }
    
    /**
     * Sends statistics to other participants
     */
    function sendStats() {
        APP.xmpp.addToPresence("connectionQuality", convertToMUCStats(stats));
    }
    
    /**
     * Converts statistics to format for sending through XMPP
     * @param stats the statistics
     * @returns {{bitrate_donwload: *, bitrate_uplpoad: *, packetLoss_total: *, packetLoss_download: *, packetLoss_upload: *}}
     */
    function convertToMUCStats(stats) {
        return {
            "bitrate_download": stats.bitrate.download,
            "bitrate_upload": stats.bitrate.upload,
            "packetLoss_total": stats.packetLoss.total,
            "packetLoss_download": stats.packetLoss.download,
            "packetLoss_upload": stats.packetLoss.upload
        };
    }
    
    /**
     * Converts statistics to format used by VideoLayout
     * @param stats
     * @returns {{bitrate: {download: *, upload: *}, packetLoss: {total: *, download: *, upload: *}}}
     */
    function parseMUCStats(stats) {
        return {
            bitrate: {
                download: stats.bitrate_download,
                upload: stats.bitrate_upload
            },
            packetLoss: {
                total: stats.packetLoss_total,
                download: stats.packetLoss_download,
                upload: stats.packetLoss_upload
            }
        };
    }
    
    var ConnectionQuality = {
        init: function () {
            APP.xmpp.addListener(XMPPEvents.REMOTE_STATS, this.updateRemoteStats);
            APP.statistics.addListener(StatisticsEvents.CONNECTION_STATS,
                this.updateLocalStats);
            APP.statistics.addListener(StatisticsEvents.STOP,
                this.stopSendingStats);
        },
        
        /**
         * Updates the local statistics
         * @param data new statistics
         */
        updateLocalStats: function (data) {
            stats = data;
            eventEmitter.emit(CQEvents.LOCALSTATS_UPDATED, 100 - stats.packetLoss.total, stats);
            if (!sendIntervalId) {
                startSendingStats();
            }
        },
        
        /**
         * Updates remote statistics
         * @param jid the jid associated with the statistics
         * @param data the statistics
         */
        updateRemoteStats: function (jid, data) {
            if (!data || !data.packetLoss_total) {
                eventEmitter.emit(CQEvents.REMOTESTATS_UPDATED, jid, null, null);
                return;
            }
            remoteStats[jid] = parseMUCStats(data);
            
            eventEmitter.emit(CQEvents.REMOTESTATS_UPDATED,
                jid, 100 - data.packetLoss_total, remoteStats[jid]);
        },
        
        /**
         * Stops statistics sending.
         */
        stopSendingStats: function () {
            clearInterval(sendIntervalId);
            sendIntervalId = null;
            //notify UI about stopping statistics gathering
            eventEmitter.emit(CQEvents.STOP);
        },
        
        /**
         * Returns the local statistics.
         */
        getStats: function () {
            return stats;
        },
        
        addListener: function (type, listener) {
            eventEmitter.on(type, listener);
        }
        
    };
    
    module.exports = ConnectionQuality;
},{"../../service/connectionquality/CQEvents":183,"../../service/statistics/Events":186,"../../service/xmpp/XMPPEvents":188,"events":79}],46:[function(require,module,exports){
    /* global config, APP, chrome, $, alert */
    /* jshint -W003 */
    var RTCBrowserType = require("../RTC/RTCBrowserType");
    var AdapterJS = require("../RTC/adapter.screenshare");
    var DesktopSharingEventTypes
        = require("../../service/desktopsharing/DesktopSharingEventTypes");
    
    /**
     * Indicates whether the Chrome desktop sharing extension is installed.
     * @type {boolean}
     */
    var chromeExtInstalled = false;
    
    /**
     * Indicates whether an update of the Chrome desktop sharing extension is
     * required.
     * @type {boolean}
     */
    var chromeExtUpdateRequired = false;
    
    /**
     * Whether the jidesha extension for firefox is installed for the domain on
     * which we are running. Null designates an unknown value.
     * @type {null}
     */
    var firefoxExtInstalled = null;
    
    /**
     * If set to true, detection of an installed firefox extension will be started
     * again the next time obtainScreenOnFirefox is called (e.g. next time the
     * user tries to enable screen sharing).
     */
    var reDetectFirefoxExtension = false;
    
    /**
     * Handles obtaining a stream from a screen capture on different browsers.
     */
    function ScreenObtainer(){
    }
    
    /**
     * The EventEmitter to use to emit events.
     * @type {null}
     */
    ScreenObtainer.prototype.eventEmitter = null;
    
    /**
     * Initializes the function used to obtain a screen capture (this.obtainStream).
     *
     * If the browser is Chrome, it uses the value of
     * 'config.desktopSharingChromeMethod' (or 'config.desktopSharing') to * decide
     * whether to use the a Chrome extension (if the value is 'ext'), use the
     * "screen" media source (if the value is 'webrtc'), or disable screen capture
     * (if the value is other).
     * Note that for the "screen" media source to work the
     * 'chrome://flags/#enable-usermedia-screen-capture' flag must be set.
     */
    ScreenObtainer.prototype.init = function(eventEmitter) {
        this.eventEmitter = eventEmitter;
        var obtainDesktopStream = null;
        
        if (RTCBrowserType.isFirefox())
            initFirefoxExtensionDetection();
        
        // TODO remove this, config.desktopSharing is deprecated.
        var chromeMethod =
            (config.desktopSharingChromeMethod || config.desktopSharing);
        
        if (RTCBrowserType.isTemasysPluginUsed()) {
            if (!AdapterJS.WebRTCPlugin.plugin.HasScreensharingFeature) {
                console.info("Screensharing not supported by this plugin version");
            } else if (!AdapterJS.WebRTCPlugin.plugin.isScreensharingAvailable) {
                console.info(
                    "Screensharing not available with Temasys plugin on this site");
            } else {
                obtainDesktopStream = obtainWebRTCScreen;
                console.info("Using Temasys plugin for desktop sharing");
            }
        } else if (RTCBrowserType.isChrome()) {
            if (chromeMethod == "ext") {
                if (RTCBrowserType.getChromeVersion() >= 34) {
                    obtainDesktopStream = obtainScreenFromExtension;
                    console.info("Using Chrome extension for desktop sharing");
                    initChromeExtension();
                } else {
                    console.info("Chrome extension not supported until ver 34");
                }
            } else if (chromeMethod == "webrtc") {
                obtainDesktopStream = obtainWebRTCScreen;
                console.info("Using Chrome WebRTC for desktop sharing");
            }
        } else if (RTCBrowserType.isFirefox()) {
            if (config.desktopSharingFirefoxDisabled) {
                obtainDesktopStream = null;
            } else if (window.location.protocol === "http:"){
                console.log("Screen sharing is not supported over HTTP. Use of " +
                    "HTTPS is required.");
                obtainDesktopStream = null;
            } else {
                obtainDesktopStream = this.obtainScreenOnFirefox;
            }
            
        }
        
        if (!obtainDesktopStream) {
            console.info("Desktop sharing disabled");
        }
        
        ScreenObtainer.prototype.obtainStream = obtainDesktopStream;
    };
    
    ScreenObtainer.prototype.obtainStream = null;
    
    /**
     * Checks whether obtaining a screen capture is supported in the current
     * environment.
     * @returns {boolean}
     */
    ScreenObtainer.prototype.isSupported = function() {
        return !!this.obtainStream;
    };
    
    /**
     * Obtains a desktop stream using getUserMedia.
     * For this to work on Chrome, the
     * 'chrome://flags/#enable-usermedia-screen-capture' flag must be enabled.
     *
     * On firefox, the document's domain must be white-listed in the
     * 'media.getusermedia.screensharing.allowed_domains' preference in
     * 'about:config'.
     */
    function obtainWebRTCScreen(streamCallback, failCallback) {
        APP.RTC.getUserMediaWithConstraints(
            ['screen'],
            streamCallback,
            failCallback
        );
    }
    
    /**
     * Constructs inline install URL for Chrome desktop streaming extension.
     * The 'chromeExtensionId' must be defined in config.js.
     * @returns {string}
     */
    function getWebStoreInstallUrl()
    {
        //TODO remove chromeExtensionId (deprecated)
        return "https://chrome.google.com/webstore/detail/" +
            (config.desktopSharingChromeExtId || config.chromeExtensionId);
    }
    
    /**
     * Checks whether an update of the Chrome extension is required.
     * @param minVersion minimal required version
     * @param extVersion current extension version
     * @returns {boolean}
     */
    function isUpdateRequired(minVersion, extVersion) {
        try {
            var s1 = minVersion.split('.');
            var s2 = extVersion.split('.');
            
            var len = Math.max(s1.length, s2.length);
            for (var i = 0; i < len; i++) {
                var n1 = 0,
                    n2 = 0;
                
                if (i < s1.length)
                    n1 = parseInt(s1[i]);
                if (i < s2.length)
                    n2 = parseInt(s2[i]);
                
                if (isNaN(n1) || isNaN(n2)) {
                    return true;
                } else if (n1 !== n2) {
                    return n1 > n2;
                }
            }
            
            // will happen if both versions have identical numbers in
            // their components (even if one of them is longer, has more components)
            return false;
        }
        catch (e) {
            console.error("Failed to parse extension version", e);
            APP.UI.messageHandler.showError("dialog.error",
                "dialog.detectext");
            return true;
        }
    }
    
    function checkChromeExtInstalled(callback) {
        if (!chrome || !chrome.runtime) {
            // No API, so no extension for sure
            callback(false, false);
            return;
        }
        chrome.runtime.sendMessage(
            //TODO: remove chromeExtensionId (deprecated)
            (config.desktopSharingChromeExtId || config.chromeExtensionId),
            { getVersion: true },
            function (response) {
                if (!response || !response.version) {
                    // Communication failure - assume that no endpoint exists
                    console.warn(
                        "Extension not installed?: ", chrome.runtime.lastError);
                    callback(false, false);
                    return;
                }
                // Check installed extension version
                var extVersion = response.version;
                console.log('Extension version is: ' + extVersion);
                //TODO: remove minChromeExtVersion (deprecated)
                var updateRequired
                    = isUpdateRequired(
                    (config.desktopSharingChromeMinExtVersion ||
                    config.minChromeExtVersion),
                    extVersion);
                callback(!updateRequired, updateRequired);
            }
        );
    }
    
    function doGetStreamFromExtension(streamCallback, failCallback) {
        // Sends 'getStream' msg to the extension.
        // Extension id must be defined in the config.
        chrome.runtime.sendMessage(
            //TODO: remove chromeExtensionId (deprecated)
            (config.desktopSharingChromeExtId || config.chromeExtensionId),
            {
                getStream: true,
                //TODO: remove desktopSharingSources (deprecated).
                sources: (config.desktopSharingChromeSources ||
                config.desktopSharingSources)
            },
            function (response) {
                if (!response) {
                    failCallback(chrome.runtime.lastError);
                    return;
                }
                console.log("Response from extension: " + response);
                if (response.streamId) {
                    APP.RTC.getUserMediaWithConstraints(
                        ['desktop'],
                        function (stream) {
                            streamCallback(stream);
                        },
                        failCallback,
                        null, null, null,
                        response.streamId);
                } else {
                    failCallback("Extension failed to get the stream");
                }
            }
        );
    }
    
    /**
     * Asks Chrome extension to call chooseDesktopMedia and gets chrome 'desktop'
     * stream for returned stream token.
     */
    function obtainScreenFromExtension(streamCallback, failCallback) {
        if (chromeExtInstalled) {
            doGetStreamFromExtension(streamCallback, failCallback);
        } else {
            if (chromeExtUpdateRequired) {
                alert(
                    'Jitsi Desktop Streamer requires update. ' +
                    'Changes will take effect after next Chrome restart.');
            }
            
            chrome.webstore.install(
                getWebStoreInstallUrl(),
                function (arg) {
                    console.log("Extension installed successfully", arg);
                    chromeExtInstalled = true;
                    // We need to give a moment for the endpoint to become available
                    window.setTimeout(function () {
                        doGetStreamFromExtension(streamCallback, failCallback);
                    }, 500);
                },
                function (arg) {
                    console.log("Failed to install the extension", arg);
                    failCallback(arg);
                    APP.UI.messageHandler.showError("dialog.error",
                        "dialog.failtoinstall");
                }
            );
        }
    }
    
    /**
     * Initializes <link rel=chrome-webstore-item /> with extension id set in
     * config.js to support inline installs. Host site must be selected as main
     * website of published extension.
     */
    function initInlineInstalls()
    {
        $("link[rel=chrome-webstore-item]").attr("href", getWebStoreInstallUrl());
    }
    
    function initChromeExtension() {
        // Initialize Chrome extension inline installs
        initInlineInstalls();
        // Check if extension is installed
        checkChromeExtInstalled(function (installed, updateRequired) {
            chromeExtInstalled = installed;
            chromeExtUpdateRequired = updateRequired;
            console.info(
                "Chrome extension installed: " + chromeExtInstalled +
                " updateRequired: " + chromeExtUpdateRequired);
        });
    }
    
    /**
     * Obtains a screen capture stream on Firefox.
     * @param callback
     * @param errorCallback
     */
    ScreenObtainer.prototype.obtainScreenOnFirefox =
        function (callback, errorCallback) {
            var self = this;
            var extensionRequired = false;
            if (config.desktopSharingFirefoxMaxVersionExtRequired === -1 ||
                (config.desktopSharingFirefoxMaxVersionExtRequired >= 0 &&
                RTCBrowserType.getFirefoxVersion() <=
                config.desktopSharingFirefoxMaxVersionExtRequired)) {
                extensionRequired = true;
                console.log("Jidesha extension required on firefox version " +
                    RTCBrowserType.getFirefoxVersion());
            }
            
            if (!extensionRequired || firefoxExtInstalled === true) {
                obtainWebRTCScreen(callback, errorCallback);
                return;
            }
            
            if (reDetectFirefoxExtension) {
                reDetectFirefoxExtension = false;
                initFirefoxExtensionDetection();
            }
            
            // Give it some (more) time to initialize, and assume lack of extension if
            // it hasn't.
            if (firefoxExtInstalled === null) {
                window.setTimeout(
                    function() {
                        if (firefoxExtInstalled === null)
                            firefoxExtInstalled = false;
                        self.obtainScreenOnFirefox(callback, errorCallback);
                    },
                    300
                );
                console.log("Waiting for detection of jidesha on firefox to finish.");
                return;
            }
            
            // We need an extension and it isn't installed.
            
            // Make sure we check for the extension when the user clicks again.
            firefoxExtInstalled = null;
            reDetectFirefoxExtension = true;
            
            // Prompt the user to install the extension
            this.eventEmitter.emit(DesktopSharingEventTypes.FIREFOX_EXTENSION_NEEDED,
                config.desktopSharingFirefoxExtensionURL);
            
            // Make sure desktopsharing knows that we failed, so that it doesn't get
            // stuck in 'switching' mode.
            errorCallback('Firefox extension required.');
        };
    
    /**
     * Starts the detection of an installed jidesha extension for firefox.
     */
    function initFirefoxExtensionDetection() {
        if (config.desktopSharingFirefoxDisabled) {
            return;
        }
        if (firefoxExtInstalled === false || firefoxExtInstalled === true)
            return;
        if (!config.desktopSharingFirefoxExtId) {
            firefoxExtInstalled = false;
            return;
        }
        
        var img = document.createElement('img');
        img.onload = function(){
            console.log("Detected firefox screen sharing extension.");
            firefoxExtInstalled = true;
        };
        img.onerror = function(){
            console.log("Detected lack of firefox screen sharing extension.");
            firefoxExtInstalled = false;
        };
        
        // The jidesha extension exposes an empty image file under the url:
        // "chrome://EXT_ID/content/DOMAIN.png"
        // Where EXT_ID is the ID of the extension with "@" replaced by ".", and
        // DOMAIN is a domain whitelisted by the extension.
        var src = "chrome://" +
            (config.desktopSharingFirefoxExtId.replace('@', '.')) +
            "/content/" + document.location.hostname + ".png";
        img.setAttribute('src', src);
    }
    
    module.exports = ScreenObtainer;
    
},{"../../service/desktopsharing/DesktopSharingEventTypes":184,"../RTC/RTCBrowserType":7,"../RTC/adapter.screenshare":9}],47:[function(require,module,exports){
    /* global APP, config */
    var EventEmitter = require("events");
    var DesktopSharingEventTypes
        = require("../../service/desktopsharing/DesktopSharingEventTypes");
    var RTCBrowserType = require("../RTC/RTCBrowserType");
    var RTCEvents = require("../../service/RTC/RTCEvents");
    var ScreenObtainer = require("./ScreenObtainer");
    
    /**
     * Indicates that desktop stream is currently in use (for toggle purpose).
     * @type {boolean}
     */
    var isUsingScreenStream = false;
    
    /**
     * Indicates that switch stream operation is in progress and prevent from
     * triggering new events.
     * @type {boolean}
     */
    var switchInProgress = false;
    
    /**
     * Used to obtain the screen sharing stream from the browser.
     */
    var screenObtainer = new ScreenObtainer();
    
    var eventEmitter = new EventEmitter();
    
    function streamSwitchDone() {
        switchInProgress = false;
        eventEmitter.emit(
            DesktopSharingEventTypes.SWITCHING_DONE,
            isUsingScreenStream);
    }
    
    function newStreamCreated(stream) {
        eventEmitter.emit(DesktopSharingEventTypes.NEW_STREAM_CREATED,
            stream, isUsingScreenStream, streamSwitchDone);
    }
    
    function getVideoStreamFailed(error) {
        console.error("Failed to obtain the stream to switch to", error);
        switchInProgress = false;
        isUsingScreenStream = false;
        newStreamCreated(null);
    }
    
    function getDesktopStreamFailed(error) {
        console.error("Failed to obtain the stream to switch to", error);
        switchInProgress = false;
    }
    
    function onEndedHandler(stream) {
        if (!switchInProgress && isUsingScreenStream) {
            APP.desktopsharing.toggleScreenSharing();
        }
        
        APP.RTC.removeMediaStreamInactiveHandler(stream, onEndedHandler);
    }
    
    module.exports = {
        isUsingScreenStream: function () {
            return isUsingScreenStream;
        },
        
        /**
         * @returns {boolean} <tt>true</tt> if desktop sharing feature is available
         *          and enabled.
         */
        isDesktopSharingEnabled: function () {
            return screenObtainer.isSupported();
        },
        
        init: function () {
            // Called when RTC finishes initialization
            APP.RTC.addListener(RTCEvents.RTC_READY,
                function() {
                    screenObtainer.init(eventEmitter);
                    eventEmitter.emit(DesktopSharingEventTypes.INIT);
                });
        },
        
        addListener: function (type, listener) {
            eventEmitter.on(type, listener);
        },
        
        removeListener: function (type, listener) {
            eventEmitter.removeListener(type, listener);
        },
        
        /*
         * Toggles screen sharing.
         */
        toggleScreenSharing: function () {
            if (switchInProgress) {
                console.warn("Switch in progress.");
                return;
            } else if (!screenObtainer.isSupported()) {
                console.warn("Cannot toggle screen sharing: not supported.");
                return;
            }
            switchInProgress = true;
            
            if (!isUsingScreenStream) {
                // Switch to desktop stream
                screenObtainer.obtainStream(
                    function (stream) {
                        // We now use screen stream
                        isUsingScreenStream = true;
                        // Hook 'ended' event to restore camera
                        // when screen stream stops
                        APP.RTC.addMediaStreamInactiveHandler(
                            stream, onEndedHandler);
                        newStreamCreated(stream);
                    },
                    getDesktopStreamFailed);
            } else {
                // Disable screen stream
                APP.RTC.getUserMediaWithConstraints(
                    ['video'],
                    function (stream) {
                        // We are now using camera stream
                        isUsingScreenStream = false;
                        newStreamCreated(stream);
                    },
                    getVideoStreamFailed,
                    config.resolution || '360'
                );
            }
        },
        /*
         * Exports the event emitter to allow use by ScreenObtainer. Not for outside
         * use.
         */
        eventEmitter: eventEmitter
    };
    
    
},{"../../service/RTC/RTCEvents":178,"../../service/desktopsharing/DesktopSharingEventTypes":184,"../RTC/RTCBrowserType":7,"./ScreenObtainer":46,"events":79}],48:[function(require,module,exports){
    /* global APP, $ */
    //maps keycode to character, id of popover for given function and function
    var shortcuts = {};
    function initShortcutHandlers() {
        shortcuts = {
            67: {
                character: "C",
                id: "toggleChatPopover",
                function: APP.UI.toggleChat
            },
            70: {
                character: "F",
                id: "filmstripPopover",
                function: APP.UI.toggleFilmStrip
            },
            77: {
                character: "M",
                id: "mutePopover",
                function: APP.UI.toggleAudio
            },
            84: {
                character: "T",
                function: function() {
                    if(!APP.RTC.localAudio.isMuted()) {
                        APP.UI.toggleAudio();
                    }
                }
            },
            86: {
                character: "V",
                id: "toggleVideoPopover",
                function: APP.UI.toggleVideo
            }
        };
    }
    
    
    var KeyboardShortcut = {
        init: function () {
            initShortcutHandlers();
            window.onkeyup = function(e) {
                var keycode = e.which;
                if(!($(":focus").is("input[type=text]") ||
                    $(":focus").is("input[type=password]") ||
                    $(":focus").is("textarea"))) {
                    if (typeof shortcuts[keycode] === "object") {
                        shortcuts[keycode].function();
                    }
                    else if (keycode >= "0".charCodeAt(0) &&
                        keycode <= "9".charCodeAt(0)) {
                        APP.UI.clickOnVideo(keycode - "0".charCodeAt(0) + 1);
                    }
                    //esc while the smileys are visible hides them
                } else if (keycode === 27 &&
                    $('#smileysContainer').is(':visible')) {
                    APP.UI.toggleSmileys();
                }
            };
            
            window.onkeydown = function(e) {
                if(!($(":focus").is("input[type=text]") ||
                    $(":focus").is("input[type=password]") ||
                    $(":focus").is("textarea"))) {
                    if(e.which === "T".charCodeAt(0)) {
                        if(APP.RTC.localAudio.isMuted()) {
                            APP.UI.toggleAudio();
                        }
                    }
                }
            };
            var self = this;
            $('body').popover({ selector: '[data-toggle=popover]',
                trigger: 'click hover',
                content: function() {
                    return this.getAttribute("content") +
                        self.getShortcut(this.getAttribute("shortcut"));
                }
            });
        },
        /**
         *
         * @param id indicates the popover associated with the shortcut
         * @returns {string} the keyboard shortcut used for the id given
         */
        getShortcut: function (id) {
            for (var keycode in shortcuts) {
                if (shortcuts.hasOwnProperty(keycode)) {
                    if (shortcuts[keycode].id === id) {
                        return " (" + shortcuts[keycode].character + ")";
                    }
                }
            }
            return "";
        }
    };
    
    module.exports = KeyboardShortcut;
    
},{}],49:[function(require,module,exports){
    /* global APP, require, $ */
    
    /**
     * This module is meant to (eventually) contain and manage all information
     * about members/participants of the conference, so that other modules don't
     * have to do it on their own, and so that other modules can access members'
     * information from a single place.
     *
     * Currently this module only manages information about the support of jingle
     * DTMF of the members. Other fields, as well as accessor methods are meant to
     * be added as needed.
     */
    
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var Events = require("../../service/members/Events");
    var EventEmitter = require("events");
    
    var eventEmitter = new EventEmitter();
    
    /**
     * The actual container.
     */
    var members = {};
    
    /**
     * There is at least one member that supports DTMF (i.e. is jigasi).
     */
    var atLeastOneDtmf = false;
    
    
    function registerListeners() {
        APP.xmpp.addListener(XMPPEvents.MUC_MEMBER_JOINED, onMucMemberJoined);
        APP.xmpp.addListener(XMPPEvents.MUC_MEMBER_LEFT, onMucMemberLeft);
    }
    
    /**
     * Handles a new member joining the MUC.
     */
    function onMucMemberJoined(jid, id, displayName) {
        var member = {
            displayName: displayName
        };
        
        APP.xmpp.getConnection().disco.info(
            jid, "" /* node */, function(iq) { onDiscoInfoReceived(jid, iq); });
        
        members[jid] = member;
    }
    
    /**
     * Handles a member leaving the MUC.
     */
    function onMucMemberLeft(jid) {
        delete members[jid];
        updateAtLeastOneDtmf();
    }
    
    /**
     * Handles the reception of a disco#info packet from a particular JID.
     * @param jid the JID sending the packet.
     * @param iq the packet.
     */
    function onDiscoInfoReceived(jid, iq) {
        if (!members[jid])
            return;
        
        var supportsDtmf
            = $(iq).find('>query>feature[var="urn:xmpp:jingle:dtmf:0"]').length > 0;
        updateDtmf(jid, supportsDtmf);
    }
    
    /**
     * Updates the 'supportsDtmf' field for a member.
     * @param jid the jid of the member.
     * @param newValue the new value for the 'supportsDtmf' field.
     */
    function updateDtmf(jid, newValue) {
        var oldValue = members[jid].supportsDtmf;
        members[jid].supportsDtmf = newValue;
        
        if (newValue != oldValue) {
            updateAtLeastOneDtmf();
        }
    }
    
    /**
     * Checks each member's 'supportsDtmf' field and updates
     * 'atLastOneSupportsDtmf'.
     */
    function updateAtLeastOneDtmf() {
        var newAtLeastOneDtmf = false;
        for (var key in members) {
            if (typeof members[key].supportsDtmf !== 'undefined'
                && members[key].supportsDtmf) {
                newAtLeastOneDtmf= true;
                break;
            }
        }
        
        if (atLeastOneDtmf != newAtLeastOneDtmf) {
            atLeastOneDtmf = newAtLeastOneDtmf;
            eventEmitter.emit(Events.DTMF_SUPPORT_CHANGED, atLeastOneDtmf);
        }
    }
    
    
    /**
     * Exported interface.
     */
    var Members = {
        start: function() {
            registerListeners();
        },
        addListener: function(type, listener) {
            eventEmitter.on(type, listener);
        },
        removeListener: function (type, listener) {
            eventEmitter.removeListener(type, listener);
        },
        size: function () {
            return Object.keys(members).length;
        },
        getMembers: function () {
            return members;
        }
    };
    
    module.exports = Members;
    
},{"../../service/members/Events":185,"../../service/xmpp/XMPPEvents":188,"events":79}],50:[function(require,module,exports){
    var email = '';
    var displayName = '';
    var userId;
    var language = null;
    
    
    function supportsLocalStorage() {
        try {
            return 'localStorage' in window && window.localStorage !== null;
        } catch (e) {
            console.log("localstorage is not supported");
            return false;
        }
    }
    
    
    function generateUniqueId() {
        function _p8() {
            return (Math.random().toString(16) + "000000000").substr(2, 8);
        }
        return _p8() + _p8() + _p8() + _p8();
    }
    
    if (supportsLocalStorage()) {
        if (!window.localStorage.jitsiMeetId) {
            window.localStorage.jitsiMeetId = generateUniqueId();
            console.log("generated id", window.localStorage.jitsiMeetId);
        }
        userId = window.localStorage.jitsiMeetId || '';
        email = window.localStorage.email || '';
        displayName = window.localStorage.displayname || '';
        language = window.localStorage.language;
    } else {
        console.log("local storage is not supported");
        userId = generateUniqueId();
    }
    
    var Settings = {
        
        /**
         * Sets the local user display name and saves it to local storage
         *
         * @param newDisplayName the new display name for the local user
         * @returns {string} the display name we just set
         */
        setDisplayName: function (newDisplayName) {
            displayName = newDisplayName;
            window.localStorage.displayname = displayName;
            return displayName;
        },
        
        /**
         * Returns the currently used by the user
         * @returns {string} currently valid user display name.
         */
        getDisplayName: function () {
            return displayName;
        },
        
        setEmail: function (newEmail) {
            email = newEmail;
            window.localStorage.email = newEmail;
            return email;
        },
        
        getSettings: function () {
            return {
                email: email,
                displayName: displayName,
                uid: userId,
                language: language
            };
        },
        setLanguage: function (lang) {
            language = lang;
            window.localStorage.language = lang;
        }
    };
    
    module.exports = Settings;
    
},{}],51:[function(require,module,exports){
    function NoopAnalytics() {}
    NoopAnalytics.prototype.sendEvent = function () {};
    
    function AnalyticsAdapter() {
        var AnalyticsImpl = window.Analytics || NoopAnalytics;
        this.analytics = new AnalyticsImpl();
    }
    
    AnalyticsAdapter.prototype.sendEvent = function (action, data) {
        try {
            this.analytics.sendEvent.apply(this.analytics, arguments);
        } catch (ignored) {}
    };
    
    module.exports = new AnalyticsAdapter();
},{}],52:[function(require,module,exports){
    /* global config, $, APP, Strophe, callstats */
    
    var Settings = require('../settings/Settings');
    var jsSHA = require('jssha');
    var io = require('socket.io-client');
    var callStats = null;
    
    function initCallback (err, msg) {
        console.log("Initializing Status: err="+err+" msg="+msg);
    }
    
    var CallStats = {
        init: function (jingleSession) {
            
            if(!config.callStatsID || !config.callStatsSecret || callStats !== null)
                return;
            
            callStats = new callstats($, io, jsSHA);
            
            this.session = jingleSession;
            this.peerconnection = jingleSession.peerconnection.peerconnection;
            
            this.userID =  APP.xmpp.myResource();
            
            //use whatever the user said to facilitate debugging
            if(Settings.getDisplayName())
                this.userID = Settings.getDisplayName();
            
            var location = window.location;
            this.confID = location.hostname + location.pathname;
            
            //userID is generated or given by the origin server
            callStats.initialize(config.callStatsID,
                config.callStatsSecret,
                this.userID,
                initCallback);
            
            var usage = callStats.fabricUsage.multiplex;
            
            callStats.addNewFabric(this.peerconnection,
                Strophe.getResourceFromJid(jingleSession.peerjid),
                usage,
                this.confID,
                this.pcCallback.bind(this));
        },
        pcCallback: function (err, msg) {
            if (!callStats)
                return;
            console.log("Monitoring status: "+ err + " msg: " + msg);
            callStats.sendFabricEvent(this.peerconnection,
                callStats.fabricEvent.fabricSetup, this.confID);
        },
        sendMuteEvent: function (mute, type) {
            if (!callStats)
                return;
            var event = null;
            if (type === "video") {
                event = (mute? callStats.fabricEvent.videoPause :
                    callStats.fabricEvent.videoResume);
            }
            else {
                event = (mute? callStats.fabricEvent.audioMute :
                    callStats.fabricEvent.audioUnmute);
            }
            callStats.sendFabricEvent(this.peerconnection, event, this.confID);
        },
        sendTerminateEvent: function () {
            if(!callStats) {
                return;
            }
            callStats.sendFabricEvent(this.peerconnection,
                callStats.fabricEvent.fabricTerminated, this.confID);
        },
        sendSetupFailedEvent: function () {
            if(!callStats) {
                return;
            }
            callStats.sendFabricEvent(this.peerconnection,
                callStats.fabricEvent.fabricSetupFailed, this.confID);
        }
        
    };
    module.exports = CallStats;
},{"../settings/Settings":50,"jssha":85,"socket.io-client":123}],53:[function(require,module,exports){
    /* global config, AudioContext */
    /**
     * Provides statistics for the local stream.
     */
    
    var RTCBrowserType = require('../RTC/RTCBrowserType');
    var StatisticsEvents = require('../../service/statistics/Events');
    
    /**
     * Size of the webaudio analyzer buffer.
     * @type {number}
     */
    var WEBAUDIO_ANALYZER_FFT_SIZE = 2048;
    
    /**
     * Value of the webaudio analyzer smoothing time parameter.
     * @type {number}
     */
    var WEBAUDIO_ANALYZER_SMOOTING_TIME = 0.8;
    
    /**
     * Converts time domain data array to audio level.
     * @param samples the time domain data array.
     * @returns {number} the audio level
     */
    function timeDomainDataToAudioLevel(samples) {
        
        var maxVolume = 0;
        
        var length = samples.length;
        
        for (var i = 0; i < length; i++) {
            if (maxVolume < samples[i])
                maxVolume = samples[i];
        }
        
        return parseFloat(((maxVolume - 127) / 128).toFixed(3));
    }
    
    /**
     * Animates audio level change
     * @param newLevel the new audio level
     * @param lastLevel the last audio level
     * @returns {Number} the audio level to be set
     */
    function animateLevel(newLevel, lastLevel) {
        var value = 0;
        var diff = lastLevel - newLevel;
        if(diff > 0.2) {
            value = lastLevel - 0.2;
        }
        else if(diff < -0.4) {
            value = lastLevel + 0.4;
        }
        else {
            value = newLevel;
        }
        
        return parseFloat(value.toFixed(3));
    }
    
    
    /**
     * <tt>LocalStatsCollector</tt> calculates statistics for the local stream.
     *
     * @param stream the local stream
     * @param interval stats refresh interval given in ms.
     * @constructor
     */
    function LocalStatsCollector(stream, interval,
                                 statisticsService, eventEmitter) {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.stream = stream;
        this.intervalId = null;
        this.intervalMilis = interval;
        this.eventEmitter = eventEmitter;
        this.audioLevel = 0;
        this.statisticsService = statisticsService;
    }
    
    /**
     * Starts the collecting the statistics.
     */
    LocalStatsCollector.prototype.start = function () {
        if (config.disableAudioLevels || !window.AudioContext ||
            RTCBrowserType.isTemasysPluginUsed())
            return;
        
        var context = new AudioContext();
        var analyser = context.createAnalyser();
        analyser.smoothingTimeConstant = WEBAUDIO_ANALYZER_SMOOTING_TIME;
        analyser.fftSize = WEBAUDIO_ANALYZER_FFT_SIZE;
        
        
        var source = context.createMediaStreamSource(this.stream);
        source.connect(analyser);
        
        
        var self = this;
        
        this.intervalId = setInterval(
            function () {
                var array = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteTimeDomainData(array);
                var audioLevel = timeDomainDataToAudioLevel(array);
                if (audioLevel != self.audioLevel) {
                    self.audioLevel = animateLevel(audioLevel, self.audioLevel);
                    self.eventEmitter.emit(
                        StatisticsEvents.AUDIO_LEVEL,
                        self.statisticsService.LOCAL_JID,
                        self.audioLevel);
                }
            },
            this.intervalMilis
        );
    };
    
    /**
     * Stops collecting the statistics.
     */
    LocalStatsCollector.prototype.stop = function () {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    };
    
    module.exports = LocalStatsCollector;
},{"../../service/statistics/Events":186,"../RTC/RTCBrowserType":7}],54:[function(require,module,exports){
    /* global require, ssrc2jid */
    /* jshint -W117 */
    /* jshint -W101 */
    var RTCBrowserType = require("../RTC/RTCBrowserType");
    var StatisticsEvents = require("../../service/statistics/Events");
    
    /* Whether we support the browser we are running into for logging statistics */
    var browserSupported = RTCBrowserType.isChrome() ||
        RTCBrowserType.isOpera() || RTCBrowserType.isFirefox();
    /**
     * Calculates packet lost percent using the number of lost packets and the
     * number of all packet.
     * @param lostPackets the number of lost packets
     * @param totalPackets the number of all packets.
     * @returns {number} packet loss percent
     */
    function calculatePacketLoss(lostPackets, totalPackets) {
        if(!totalPackets || totalPackets <= 0 || !lostPackets || lostPackets <= 0)
            return 0;
        return Math.round((lostPackets/totalPackets)*100);
    }
    
    function getStatValue(item, name) {
        var browserType = RTCBrowserType.getBrowserType();
        if (!keyMap[browserType][name])
            throw "The property isn't supported!";
        var key = keyMap[browserType][name];
        return (RTCBrowserType.isChrome() || RTCBrowserType.isOpera()) ?
            item.stat(key) : item[key];
    }
    
    /**
     * Peer statistics data holder.
     * @constructor
     */
    function PeerStats()
    {
        this.ssrc2Loss = {};
        this.ssrc2AudioLevel = {};
        this.ssrc2bitrate = {};
        this.ssrc2resolution = {};
    }
    
    /**
     * The bandwidth
     * @type {{}}
     */
    PeerStats.bandwidth = {};
    
    /**
     * The bit rate
     * @type {{}}
     */
    PeerStats.bitrate = {};
    
    /**
     * The packet loss rate
     * @type {{}}
     */
    PeerStats.packetLoss = null;
    
    /**
     * Sets packets loss rate for given <tt>ssrc</tt> that blong to the peer
     * represented by this instance.
     * @param ssrc audio or video RTP stream SSRC.
     * @param lossRate new packet loss rate value to be set.
     */
    PeerStats.prototype.setSsrcLoss = function (ssrc, lossRate)
    {
        this.ssrc2Loss[ssrc] = lossRate;
    };
    
    /**
     * Sets resolution for given <tt>ssrc</tt> that belong to the peer
     * represented by this instance.
     * @param ssrc audio or video RTP stream SSRC.
     * @param resolution new resolution value to be set.
     */
    PeerStats.prototype.setSsrcResolution = function (ssrc, resolution)
    {
        if(resolution === null && this.ssrc2resolution[ssrc])
        {
            delete this.ssrc2resolution[ssrc];
        }
        else if(resolution !== null)
            this.ssrc2resolution[ssrc] = resolution;
    };
    
    /**
     * Sets the bit rate for given <tt>ssrc</tt> that blong to the peer
     * represented by this instance.
     * @param ssrc audio or video RTP stream SSRC.
     * @param bitrate new bitrate value to be set.
     */
    PeerStats.prototype.setSsrcBitrate = function (ssrc, bitrate)
    {
        if(this.ssrc2bitrate[ssrc])
        {
            this.ssrc2bitrate[ssrc].download += bitrate.download;
            this.ssrc2bitrate[ssrc].upload += bitrate.upload;
        }
        else {
            this.ssrc2bitrate[ssrc] = bitrate;
        }
    };
    
    /**
     * Sets new audio level(input or output) for given <tt>ssrc</tt> that identifies
     * the stream which belongs to the peer represented by this instance.
     * @param ssrc RTP stream SSRC for which current audio level value will be
     *        updated.
     * @param audioLevel the new audio level value to be set. Value is truncated to
     *        fit the range from 0 to 1.
     */
    PeerStats.prototype.setSsrcAudioLevel = function (ssrc, audioLevel)
    {
        // Range limit 0 - 1
        this.ssrc2AudioLevel[ssrc] = formatAudioLevel(audioLevel);
    };
    
    function formatAudioLevel(audioLevel) {
        return Math.min(Math.max(audioLevel, 0), 1);
    }
    
    /**
     * Array with the transport information.
     * @type {Array}
     */
    PeerStats.transport = [];
    
    
    /**
     * <tt>StatsCollector</tt> registers for stats updates of given
     * <tt>peerconnection</tt> in given <tt>interval</tt>. On each update particular
     * stats are extracted and put in {@link PeerStats} objects. Once the processing
     * is done <tt>audioLevelsUpdateCallback</tt> is called with <tt>this</tt>
     * instance as an event source.
     *
     * @param peerconnection webRTC peer connection object.
     * @param interval stats refresh interval given in ms.
     * @param {function(StatsCollector)} audioLevelsUpdateCallback the callback
     * called on stats update.
     * @constructor
     */
    function StatsCollector(peerconnection, audioLevelsInterval, statsInterval, eventEmitter)
    {
        this.peerconnection = peerconnection;
        this.baselineAudioLevelsReport = null;
        this.currentAudioLevelsReport = null;
        this.currentStatsReport = null;
        this.baselineStatsReport = null;
        this.audioLevelsIntervalId = null;
        this.eventEmitter = eventEmitter;
        
        /**
         * Gather PeerConnection stats once every this many milliseconds.
         */
        this.GATHER_INTERVAL = 15000;
        
        /**
         * Log stats via the focus once every this many milliseconds.
         */
        this.LOG_INTERVAL = 60000;
        
        /**
         * Gather stats and store them in this.statsToBeLogged.
         */
        this.gatherStatsIntervalId = null;
        
        /**
         * Send the stats already saved in this.statsToBeLogged to be logged via
         * the focus.
         */
        this.logStatsIntervalId = null;
        
        /**
         * Stores the statistics which will be send to the focus to be logged.
         */
        this.statsToBeLogged =
        {
            timestamps: [],
            stats: {}
        };
        
        // Updates stats interval
        this.audioLevelsIntervalMilis = audioLevelsInterval;
        
        this.statsIntervalId = null;
        this.statsIntervalMilis = statsInterval;
        // Map of jids to PeerStats
        this.jid2stats = {};
    }
    
    module.exports = StatsCollector;
    
    /**
     * Stops stats updates.
     */
    StatsCollector.prototype.stop = function () {
        if (this.audioLevelsIntervalId) {
            clearInterval(this.audioLevelsIntervalId);
            this.audioLevelsIntervalId = null;
        }
        
        if (this.statsIntervalId)
        {
            clearInterval(this.statsIntervalId);
            this.statsIntervalId = null;
        }
        
        if(this.logStatsIntervalId)
        {
            clearInterval(this.logStatsIntervalId);
            this.logStatsIntervalId = null;
        }
        
        if(this.gatherStatsIntervalId)
        {
            clearInterval(this.gatherStatsIntervalId);
            this.gatherStatsIntervalId = null;
        }
    };
    
    /**
     * Callback passed to <tt>getStats</tt> method.
     * @param error an error that occurred on <tt>getStats</tt> call.
     */
    StatsCollector.prototype.errorCallback = function (error)
    {
        console.error("Get stats error", error);
        this.stop();
    };
    
    /**
     * Starts stats updates.
     */
    StatsCollector.prototype.start = function ()
    {
        var self = this;
        if (!config.disableAudioLevels) {
            this.audioLevelsIntervalId = setInterval(
                function () {
                    // Interval updates
                    self.peerconnection.getStats(
                        function (report) {
                            var results = null;
                            if (!report || !report.result ||
                                typeof report.result != 'function') {
                                results = report;
                            }
                            else {
                                results = report.result();
                            }
                            //console.error("Got interval report", results);
                            self.currentAudioLevelsReport = results;
                            self.processAudioLevelReport();
                            self.baselineAudioLevelsReport =
                                self.currentAudioLevelsReport;
                        },
                        self.errorCallback
                    );
                },
                self.audioLevelsIntervalMilis
            );
        }
        
        if (!config.disableStats && browserSupported) {
            this.statsIntervalId = setInterval(
                function () {
                    // Interval updates
                    self.peerconnection.getStats(
                        function (report) {
                            var results = null;
                            if (!report || !report.result ||
                                typeof report.result != 'function') {
                                //firefox
                                results = report;
                            }
                            else {
                                //chrome
                                results = report.result();
                            }
                            //console.error("Got interval report", results);
                            self.currentStatsReport = results;
                            try {
                                self.processStatsReport();
                            }
                            catch (e) {
                                console.error("Unsupported key:" + e, e);
                            }
                            
                            self.baselineStatsReport = self.currentStatsReport;
                        },
                        self.errorCallback
                    );
                },
                self.statsIntervalMilis
            );
        }
        
        // Logging statistics does not support firefox
        if (config.logStats && (browserSupported && !RTCBrowserType.isFirefox())) {
            this.gatherStatsIntervalId = setInterval(
                function () {
                    self.peerconnection.getStats(
                        function (report) {
                            self.addStatsToBeLogged(report.result());
                        },
                        function () {
                        }
                    );
                },
                this.GATHER_INTERVAL
            );
            
            this.logStatsIntervalId = setInterval(
                function() { self.logStats(); },
                this.LOG_INTERVAL);
        }
    };
    
    /**
     * Checks whether a certain record should be included in the logged statistics.
     */
    function acceptStat(reportId, reportType, statName) {
        if (reportType == "googCandidatePair" && statName == "googChannelId")
            return false;
        
        if (reportType == "ssrc") {
            if (statName == "googTrackId" ||
                statName == "transportId" ||
                statName == "ssrc")
                return false;
        }
        
        return true;
    }
    
    /**
     * Checks whether a certain record should be included in the logged statistics.
     */
    function acceptReport(id, type) {
        if (id.substring(0, 15) == "googCertificate" ||
            id.substring(0, 9) == "googTrack" ||
            id.substring(0, 20) == "googLibjingleSession")
            return false;
        
        if (type == "googComponent")
            return false;
        
        return true;
    }
    
    /**
     * Converts the stats to the format used for logging, and saves the data in
     * this.statsToBeLogged.
     * @param reports Reports as given by webkitRTCPerConnection.getStats.
     */
    StatsCollector.prototype.addStatsToBeLogged = function (reports) {
        var self = this;
        var num_records = this.statsToBeLogged.timestamps.length;
        this.statsToBeLogged.timestamps.push(new Date().getTime());
        reports.map(function (report) {
            if (!acceptReport(report.id, report.type))
                return;
            var stat = self.statsToBeLogged.stats[report.id];
            if (!stat) {
                stat = self.statsToBeLogged.stats[report.id] = {};
            }
            stat.type = report.type;
            report.names().map(function (name) {
                if (!acceptStat(report.id, report.type, name))
                    return;
                var values = stat[name];
                if (!values) {
                    values = stat[name] = [];
                }
                while (values.length < num_records) {
                    values.push(null);
                }
                values.push(report.stat(name));
            });
        });
    };
    
    StatsCollector.prototype.logStats = function () {
        
        if(!APP.xmpp.sendLogs(this.statsToBeLogged))
            return;
        // Reset the stats
        this.statsToBeLogged.stats = {};
        this.statsToBeLogged.timestamps = [];
    };
    var keyMap = {};
    keyMap[RTCBrowserType.RTC_BROWSER_FIREFOX] = {
        "ssrc": "ssrc",
        "packetsReceived": "packetsReceived",
        "packetsLost": "packetsLost",
        "packetsSent": "packetsSent",
        "bytesReceived": "bytesReceived",
        "bytesSent": "bytesSent"
    };
    keyMap[RTCBrowserType.RTC_BROWSER_CHROME] = {
        "receiveBandwidth": "googAvailableReceiveBandwidth",
        "sendBandwidth": "googAvailableSendBandwidth",
        "remoteAddress": "googRemoteAddress",
        "transportType": "googTransportType",
        "localAddress": "googLocalAddress",
        "activeConnection": "googActiveConnection",
        "ssrc": "ssrc",
        "packetsReceived": "packetsReceived",
        "packetsSent": "packetsSent",
        "packetsLost": "packetsLost",
        "bytesReceived": "bytesReceived",
        "bytesSent": "bytesSent",
        "googFrameHeightReceived": "googFrameHeightReceived",
        "googFrameWidthReceived": "googFrameWidthReceived",
        "googFrameHeightSent": "googFrameHeightSent",
        "googFrameWidthSent": "googFrameWidthSent",
        "audioInputLevel": "audioInputLevel",
        "audioOutputLevel": "audioOutputLevel"
    };
    keyMap[RTCBrowserType.RTC_BROWSER_OPERA] =
        keyMap[RTCBrowserType.RTC_BROWSER_CHROME];
    
    
    /**
     * Stats processing logic.
     */
    StatsCollector.prototype.processStatsReport = function () {
        if (!this.baselineStatsReport) {
            return;
        }
        
        for (var idx in this.currentStatsReport) {
            var now = this.currentStatsReport[idx];
            try {
                if (getStatValue(now, 'receiveBandwidth') ||
                    getStatValue(now, 'sendBandwidth')) {
                    PeerStats.bandwidth = {
                        "download": Math.round(
                            (getStatValue(now, 'receiveBandwidth')) / 1000),
                        "upload": Math.round(
                            (getStatValue(now, 'sendBandwidth')) / 1000)
                    };
                }
            }
            catch(e){/*not supported*/}
            
            if(now.type == 'googCandidatePair')
            {
                var ip, type, localIP, active;
                try {
                    ip = getStatValue(now, 'remoteAddress');
                    type = getStatValue(now, "transportType");
                    localIP = getStatValue(now, "localAddress");
                    active = getStatValue(now, "activeConnection");
                }
                catch(e){/*not supported*/}
                if(!ip || !type || !localIP || active != "true")
                    continue;
                var addressSaved = false;
                for(var i = 0; i < PeerStats.transport.length; i++)
                {
                    if(PeerStats.transport[i].ip == ip &&
                        PeerStats.transport[i].type == type &&
                        PeerStats.transport[i].localip == localIP)
                    {
                        addressSaved = true;
                    }
                }
                if(addressSaved)
                    continue;
                PeerStats.transport.push({localip: localIP, ip: ip, type: type});
                continue;
            }
            
            if(now.type == "candidatepair")
            {
                if(now.state == "succeeded")
                    continue;
                
                var local = this.currentStatsReport[now.localCandidateId];
                var remote = this.currentStatsReport[now.remoteCandidateId];
                PeerStats.transport.push({localip: local.ipAddress + ":" + local.portNumber,
                    ip: remote.ipAddress + ":" + remote.portNumber, type: local.transport});
                
            }
            
            if (now.type != 'ssrc' && now.type != "outboundrtp" &&
                now.type != "inboundrtp") {
                continue;
            }
            
            var before = this.baselineStatsReport[idx];
            if (!before) {
                console.warn(getStatValue(now, 'ssrc') + ' not enough data');
                continue;
            }
            
            var ssrc = getStatValue(now, 'ssrc');
            if(!ssrc)
                continue;
            var jid = APP.xmpp.getJidFromSSRC(ssrc);
            if (!jid && (Date.now() - now.timestamp) < 3000) {
                console.warn("No jid for ssrc: " + ssrc);
                continue;
            }
            
            var jidStats = this.jid2stats[jid];
            if (!jidStats) {
                jidStats = new PeerStats();
                this.jid2stats[jid] = jidStats;
            }
            
            
            var isDownloadStream = true;
            var key = 'packetsReceived';
            var packetsNow = getStatValue(now, key);
            if (typeof packetsNow === 'undefined' || packetsNow === null) {
                isDownloadStream = false;
                key = 'packetsSent';
                packetsNow = getStatValue(now, key);
                if (typeof packetsNow === 'undefined' || packetsNow === null) {
                    console.warn("No packetsReceived nor packetsSent stat found");
                    continue;
                }
            }
            if (!packetsNow || packetsNow < 0)
                packetsNow = 0;
            
            var packetsBefore = getStatValue(before, key);
            if (!packetsBefore || packetsBefore < 0)
                packetsBefore = 0;
            var packetRate = packetsNow - packetsBefore;
            if (!packetRate || packetRate < 0)
                packetRate = 0;
            var currentLoss = getStatValue(now, 'packetsLost');
            if (!currentLoss || currentLoss < 0)
                currentLoss = 0;
            var previousLoss = getStatValue(before, 'packetsLost');
            if (!previousLoss || previousLoss < 0)
                previousLoss = 0;
            var lossRate = currentLoss - previousLoss;
            if (!lossRate || lossRate < 0)
                lossRate = 0;
            var packetsTotal = (packetRate + lossRate);
            
            jidStats.setSsrcLoss(ssrc,
                {"packetsTotal": packetsTotal,
                    "packetsLost": lossRate,
                    "isDownloadStream": isDownloadStream});
            
            
            var bytesReceived = 0, bytesSent = 0;
            if(getStatValue(now, "bytesReceived")) {
                bytesReceived = getStatValue(now, "bytesReceived") -
                    getStatValue(before, "bytesReceived");
            }
            
            if(getStatValue(now, "bytesSent")) {
                bytesSent = getStatValue(now, "bytesSent") -
                    getStatValue(before, "bytesSent");
            }
            
            var time = Math.round((now.timestamp - before.timestamp) / 1000);
            if(bytesReceived <= 0 || time <= 0) {
                bytesReceived = 0;
            } else {
                bytesReceived = Math.round(((bytesReceived * 8) / time) / 1000);
            }
            
            if(bytesSent <= 0 || time <= 0) {
                bytesSent = 0;
            } else {
                bytesSent = Math.round(((bytesSent * 8) / time) / 1000);
            }
            
            jidStats.setSsrcBitrate(ssrc, {
                "download": bytesReceived,
                "upload": bytesSent});
            
            var resolution = {height: null, width: null};
            try {
                if (getStatValue(now, "googFrameHeightReceived") &&
                    getStatValue(now, "googFrameWidthReceived")) {
                    resolution.height = getStatValue(now, "googFrameHeightReceived");
                    resolution.width = getStatValue(now, "googFrameWidthReceived");
                }
                else if (getStatValue(now, "googFrameHeightSent") &&
                    getStatValue(now, "googFrameWidthSent")) {
                    resolution.height = getStatValue(now, "googFrameHeightSent");
                    resolution.width = getStatValue(now, "googFrameWidthSent");
                }
            }
            catch(e){/*not supported*/}
            
            if(resolution.height && resolution.width) {
                jidStats.setSsrcResolution(ssrc, resolution);
            } else {
                jidStats.setSsrcResolution(ssrc, null);
            }
        }
        
        var self = this;
        // Jid stats
        var totalPackets = {download: 0, upload: 0};
        var lostPackets = {download: 0, upload: 0};
        var bitrateDownload = 0;
        var bitrateUpload = 0;
        var resolutions = {};
        Object.keys(this.jid2stats).forEach(
            function (jid) {
                Object.keys(self.jid2stats[jid].ssrc2Loss).forEach(
                    function (ssrc) {
                        var type = "upload";
                        if(self.jid2stats[jid].ssrc2Loss[ssrc].isDownloadStream)
                            type = "download";
                        totalPackets[type] +=
                            self.jid2stats[jid].ssrc2Loss[ssrc].packetsTotal;
                        lostPackets[type] +=
                            self.jid2stats[jid].ssrc2Loss[ssrc].packetsLost;
                    }
                );
                Object.keys(self.jid2stats[jid].ssrc2bitrate).forEach(
                    function (ssrc) {
                        bitrateDownload +=
                            self.jid2stats[jid].ssrc2bitrate[ssrc].download;
                        bitrateUpload +=
                            self.jid2stats[jid].ssrc2bitrate[ssrc].upload;
                        
                        delete self.jid2stats[jid].ssrc2bitrate[ssrc];
                    }
                );
                resolutions[jid] = self.jid2stats[jid].ssrc2resolution;
            }
        );
        
        PeerStats.bitrate = {"upload": bitrateUpload, "download": bitrateDownload};
        
        PeerStats.packetLoss = {
            total:
                calculatePacketLoss(lostPackets.download + lostPackets.upload,
                    totalPackets.download + totalPackets.upload),
            download:
                calculatePacketLoss(lostPackets.download, totalPackets.download),
            upload:
                calculatePacketLoss(lostPackets.upload, totalPackets.upload)
        };
        this.eventEmitter.emit(StatisticsEvents.CONNECTION_STATS,
            {
                "bitrate": PeerStats.bitrate,
                "packetLoss": PeerStats.packetLoss,
                "bandwidth": PeerStats.bandwidth,
                "resolution": resolutions,
                "transport": PeerStats.transport
            });
        PeerStats.transport = [];
        
    };
    
    /**
     * Stats processing logic.
     */
    StatsCollector.prototype.processAudioLevelReport = function () {
        if (!this.baselineAudioLevelsReport) {
            return;
        }
        
        for (var idx in this.currentAudioLevelsReport) {
            var now = this.currentAudioLevelsReport[idx];
            
            if (now.type != 'ssrc') {
                continue;
            }
            
            var before = this.baselineAudioLevelsReport[idx];
            if (!before) {
                console.warn(getStatValue(now, 'ssrc') + ' not enough data');
                continue;
            }
            
            var ssrc = getStatValue(now, 'ssrc');
            var jid = APP.xmpp.getJidFromSSRC(ssrc);
            if (!jid) {
                if((Date.now() - now.timestamp) < 3000)
                    console.warn("No jid for ssrc: " + ssrc);
                continue;
            }
            
            var jidStats = this.jid2stats[jid];
            if (!jidStats) {
                jidStats = new PeerStats();
                this.jid2stats[jid] = jidStats;
            }
            
            // Audio level
            var audioLevel = null;
            
            try {
                audioLevel = getStatValue(now, 'audioInputLevel');
                if (!audioLevel)
                    audioLevel = getStatValue(now, 'audioOutputLevel');
            }
            catch(e) {/*not supported*/
                console.warn("Audio Levels are not available in the statistics.");
                clearInterval(this.audioLevelsIntervalId);
                return;
            }
            
            if (audioLevel) {
                // TODO: can't find specs about what this value really is,
                // but it seems to vary between 0 and around 32k.
                audioLevel = audioLevel / 32767;
                jidStats.setSsrcAudioLevel(ssrc, audioLevel);
                if (jid != APP.xmpp.myJid()) {
                    this.eventEmitter.emit(
                        StatisticsEvents.AUDIO_LEVEL, jid, audioLevel);
                }
            }
        }
    };
    
},{"../../service/statistics/Events":186,"../RTC/RTCBrowserType":7}],55:[function(require,module,exports){
    /* global require, APP */
    /**
     * Created by hristo on 8/4/14.
     */
    var LocalStats = require("./LocalStatsCollector.js");
    var RTPStats = require("./RTPStatsCollector.js");
    var EventEmitter = require("events");
    var StreamEventTypes = require("../../service/RTC/StreamEventTypes.js");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var CallStats = require("./CallStats");
    var RTCEvents = require("../../service/RTC/RTCEvents");
    var StatisticsEvents = require("../../service/statistics/Events");
    
    var eventEmitter = new EventEmitter();
    
    var localStats = null;
    
    var rtpStats = null;
    
    function stopLocal() {
        if (localStats) {
            localStats.stop();
            localStats = null;
        }
    }
    
    function stopRemote() {
        if (rtpStats) {
            rtpStats.stop();
            eventEmitter.emit(StatisticsEvents.STOP);
            rtpStats = null;
        }
    }
    
    function startRemoteStats (peerconnection) {
        if (rtpStats) {
            rtpStats.stop();
        }
        
        rtpStats = new RTPStats(peerconnection, 200, 2000, eventEmitter);
        rtpStats.start();
    }
    
    function onStreamCreated(stream) {
        if(stream.getOriginalStream().getAudioTracks().length === 0) {
            return;
        }
        
        localStats = new LocalStats(stream.getOriginalStream(), 200, statistics,
            eventEmitter);
        localStats.start();
    }
    
    function onDisposeConference(onUnload) {
        CallStats.sendTerminateEvent();
        stopRemote();
        if(onUnload) {
            stopLocal();
            eventEmitter.removeAllListeners();
        }
    }
    
    var statistics = {
        /**
         * Indicates that this audio level is for local jid.
         * @type {string}
         */
        LOCAL_JID: 'local',
        
        addListener: function(type, listener) {
            eventEmitter.on(type, listener);
        },
        removeListener: function (type, listener) {
            eventEmitter.removeListener(type, listener);
        },
        stop: function () {
            stopLocal();
            stopRemote();
            if(eventEmitter)
            {
                eventEmitter.removeAllListeners();
            }
        },
        stopRemoteStatistics: function()
        {
            stopRemote();
        },
        start: function () {
            APP.RTC.addStreamListener(onStreamCreated,
                StreamEventTypes.EVENT_TYPE_LOCAL_CREATED);
            APP.xmpp.addListener(XMPPEvents.DISPOSE_CONFERENCE,
                onDisposeConference);
            //FIXME: we may want to change CALL INCOMING event to
            // onnegotiationneeded
            APP.xmpp.addListener(XMPPEvents.CALL_INCOMING, function (event) {
                startRemoteStats(event.peerconnection);
                //            CallStats.init(event);
            });
            APP.xmpp.addListener(XMPPEvents.PEERCONNECTION_READY,
                function (session) {
                    CallStats.init(session);
                });
            APP.RTC.addListener(RTCEvents.AUDIO_MUTE, function (mute) {
                CallStats.sendMuteEvent(mute, "audio");
            });
            APP.xmpp.addListener(XMPPEvents.CONFERENCE_SETUP_FAILED, function () {
                CallStats.sendSetupFailedEvent();
            });
            APP.RTC.addListener(RTCEvents.VIDEO_MUTE, function (mute) {
                CallStats.sendMuteEvent(mute, "video");
            });
        }
    };
    
    
    
    
    module.exports = statistics;
},{"../../service/RTC/RTCEvents":178,"../../service/RTC/StreamEventTypes.js":180,"../../service/statistics/Events":186,"../../service/xmpp/XMPPEvents":188,"./CallStats":52,"./LocalStatsCollector.js":53,"./RTPStatsCollector.js":54,"events":79}],56:[function(require,module,exports){
    /* global $, require, config, interfaceConfig */
    var i18n = require("i18next-client");
    var languages = require("../../service/translation/languages");
    var Settings = require("../settings/Settings");
    var DEFAULT_LANG = languages.EN;
    
    i18n.addPostProcessor("resolveAppName", function(value, key, options) {
        return value.replace("__app__", interfaceConfig.APP_NAME);
    });
    
    
    
    var defaultOptions = {
        detectLngQS: "lang",
        useCookie: false,
        fallbackLng: DEFAULT_LANG,
        load: "unspecific",
        resGetPath: 'lang/__ns__-__lng__.json',
        ns: {
            namespaces: ['main', 'languages'],
            defaultNs: 'main'
        },
        lngWhitelist : languages.getLanguages(),
        fallbackOnNull: true,
        fallbackOnEmpty: true,
        useDataAttrOptions: true,
        app: interfaceConfig.APP_NAME,
        getAsync: false,
        defaultValueFromContent: false,
        customLoad: function(lng, ns, options, done) {
            var resPath = "lang/__ns__-__lng__.json";
            if(lng === languages.EN)
                resPath = "lang/__ns__.json";
            var url = i18n.functions.applyReplacement(resPath,
                { lng: lng, ns: ns });
            i18n.functions.ajax({
                url: url,
                success: function(data, status, xhr) {
                    i18n.functions.log('loaded: ' + url);
                    done(null, data);
                },
                error : function(xhr, status, error) {
                    if ((status && status == 200) ||
                        (xhr && xhr.status && xhr.status == 200)) {
                        // file loaded but invalid json, stop waste time !
                        i18n.functions.error('There is a typo in: ' + url);
                    } else if ((status && status == 404) ||
                        (xhr && xhr.status && xhr.status == 404)) {
                        i18n.functions.log('Does not exist: ' + url);
                    } else {
                        var theStatus = status ? status :
                            ((xhr && xhr.status) ? xhr.status : null);
                        i18n.functions.log(theStatus + ' when loading ' + url);
                    }
                    
                    done(error, {});
                },
                dataType: "json",
                async : options.getAsync
            });
        }
        //              options for caching
        //                useLocalStorage: true,
        //                localStorageExpirationTime: 86400000 // in ms, default 1 week
    };
    
    function initCompleted(t) {
        $("[data-i18n]").i18n();
    }
    
    function checkForParameter() {
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i=0;i<vars.length;i++) {
            var pair = vars[i].split("=");
            if(pair[0] == "lang")
            {
                return pair[1];
            }
        }
        return null;
    }
    
    module.exports = {
        init: function (lang) {
            var options = defaultOptions;
            
            
            if(!lang)
            {
                lang = checkForParameter();
                if(!lang)
                {
                    var settings = Settings.getSettings();
                    if(settings)
                        lang = settings.language;
                    
                    if(!lang && config.defaultLanguage)
                    {
                        lang = config.defaultLanguage;
                    }
                }
            }
            
            if(lang) {
                options.lng = lang;
            }
            
            i18n.init(options, initCompleted);
        },
        translateString: function (key, options) {
            return i18n.t(key, options);
        },
        setLanguage: function (lang) {
            if(!lang)
                lang = DEFAULT_LANG;
            i18n.setLng(lang, defaultOptions, initCompleted);
        },
        getCurrentLanguage: function () {
            return i18n.lng();
        },
        translateElement: function (selector) {
            selector.i18n();
        },
        generateTranslationHTML: function (key, options) {
            var str = "<span data-i18n=\"" + key + "\"";
            if(options)
            {
                str += " data-i18n-options=\"" + JSON.stringify(options) + "\"";
            }
            str += ">";
            str += this.translateString(key, options);
            str += "</span>";
            return str;
            
        }
    };
    
},{"../../service/translation/languages":187,"../settings/Settings":50,"i18next-client":81}],57:[function(require,module,exports){
    
    /**
     * Generates random hex number within the range [min, max]
     * @param max the maximum value for the generated number
     * @param min the minimum value for the generated number
     * @returns random hex number
     */
    function rangeRandomHex(min, max)
    {
        return Math.floor(Math.random() * (max - min) + min).toString(16);
    }
    
    /**
     * Exported interface.
     */
    var RandomUtil = {
        /**
         * Generates hex number with length 4
         */
        random4digitsHex: function() {
            return rangeRandomHex(4096, 65535);
        },
        /**
         * Generates hex number with length 8
         */
        random8digitsHex: function() {
            return rangeRandomHex(268435456, 4294967295);
        },
        /**
         * Generates hex number with length 12
         */
        random12digitsHex: function() {
            return rangeRandomHex(17592186044416, 281474976710655);
        }
    };
    
    module.exports = RandomUtil;
    
},{}],58:[function(require,module,exports){
    /*
     * JingleSession provides an API to manage a single Jingle session. We will
     * have different implementations depending on the underlying interface used
     * (i.e. WebRTC and ORTC) and here we hold the code common to all of them.
     */
    function JingleSession(me, sid, connection, service, eventEmitter) {
        /**
         * Our JID.
         */
        this.me = me;
        
        /**
         * The Jingle session identifier.
         */
        this.sid = sid;
        
        /**
         * The XMPP connection.
         */
        this.connection = connection;
        
        /**
         * The XMPP service.
         */
        this.service = service;
        
        /**
         * The event emitter.
         */
        this.eventEmitter = eventEmitter;
        
        /**
         * Whether to use dripping or not. Dripping is sending trickle candidates
         * not one-by-one.
         * Note: currently we do not support 'false'.
         */
        this.usedrip = true;
        
        /**
         *  When dripping is used, stores ICE candidates which are to be sent.
         */
        this.drip_container = [];
        
        // Media constraints. Is this WebRTC only?
        this.media_constraints = null;
        
        // ICE servers config (RTCConfiguration?).
        this.ice_config = {};
    }
    
    /**
     * Prepares this object to initiate a session.
     * @param peerjid the JID of the remote peer.
     * @param isInitiator whether we will be the Jingle initiator.
     * @param media_constraints
     * @param ice_config
     */
    JingleSession.prototype.initialize = function(peerjid, isInitiator,
                                                  media_constraints, ice_config) {
        this.media_constraints = media_constraints;
        this.ice_config = ice_config;
        
        if (this.state !== null) {
            console.error('attempt to initiate on session ' + this.sid +
                'in state ' + this.state);
            return;
        }
        this.state = 'pending';
        this.initiator = isInitiator ? this.me : peerjid;
        this.responder = !isInitiator ? this.me : peerjid;
        this.peerjid = peerjid;
        
        this.doInitialize();
    };
    
    /**
     * Finishes initialization.
     */
    JingleSession.prototype.doInitialize = function() {};
    
    /**
     * Adds the ICE candidates found in the 'contents' array as remote candidates?
     * Note: currently only used on transport-info
     */
    JingleSession.prototype.addIceCandidates = function(contents) {};
    
    /**
     * Handles an 'add-source' event.
     *
     * @param contents an array of Jingle 'content' elements.
     */
    JingleSession.prototype.addSources = function(contents) {};
    
    /**
     * Handles a 'remove-source' event.
     *
     * @param contents an array of Jingle 'content' elements.
     */
    JingleSession.prototype.removeSources = function(contents) {};
    
    /**
     * Terminates this Jingle session (stops sending media and closes the streams?)
     */
    JingleSession.prototype.terminate = function() {};
    
    /**
     * Sends a Jingle session-terminate message to the peer and terminates the
     * session.
     * @param reason
     * @param text
     */
    JingleSession.prototype.sendTerminate = function(reason, text) {};
    
    /**
     * Handles an offer from the remote peer (prepares to accept a session).
     * @param jingle the 'jingle' XML element.
     */
    JingleSession.prototype.setOffer = function(jingle) {};
    
    /**
     * Handles an answer from the remote peer (prepares to accept a session).
     * @param jingle the 'jingle' XML element.
     */
    JingleSession.prototype.setAnswer = function(jingle) {};
    
    
    module.exports = JingleSession;
    
},{}],59:[function(require,module,exports){
    /* jshint -W117 */
    /* jshint -W101 */
    var JingleSession = require("./JingleSession");
    var TraceablePeerConnection = require("./TraceablePeerConnection");
    var SDPDiffer = require("./SDPDiffer");
    var SDPUtil = require("./SDPUtil");
    var SDP = require("./SDP");
    var async = require("async");
    var transform = require("sdp-transform");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var RTCBrowserType = require("../RTC/RTCBrowserType");
    var SSRCReplacement = require("./LocalSSRCReplacement");
    
    // Jingle stuff
    function JingleSessionPC(me, sid, connection, service, eventEmitter) {
        JingleSession.call(this, me, sid, connection, service, eventEmitter);
        this.initiator = null;
        this.responder = null;
        this.peerjid = null;
        this.state = null;
        this.localSDP = null;
        this.remoteSDP = null;
        this.pc_constraints = null;
        
        this.usetrickle = true;
        this.usepranswer = false; // early transport warmup -- mind you, this might fail. depends on webrtc issue 1718
        
        this.hadstuncandidate = false;
        this.hadturncandidate = false;
        this.lasticecandidate = false;
        
        this.statsinterval = null;
        
        this.reason = null;
        
        this.addssrc = [];
        this.removessrc = [];
        this.pendingop = null;
        this.switchstreams = false;
        
        this.wait = true;
        this.localStreamsSSRC = null;
        this.ssrcOwners = {};
        this.ssrcVideoTypes = {};
        this.eventEmitter = eventEmitter;
        
        /**
         * The indicator which determines whether the (local) video has been muted
         * in response to a user command in contrast to an automatic decision made
         * by the application logic.
         */
        this.videoMuteByUser = false;
        this.modifySourcesQueue = async.queue(this._modifySources.bind(this), 1);
        // We start with the queue paused. We resume it when the signaling state is
        // stable and the ice connection state is connected.
        this.modifySourcesQueue.pause();
    }
    //XXX this is badly broken...
    JingleSessionPC.prototype = JingleSession.prototype;
    JingleSessionPC.prototype.constructor = JingleSessionPC;
    
    
    JingleSessionPC.prototype.setOffer = function(offer) {
        this.setRemoteDescription(offer, 'offer');
    };
    
    JingleSessionPC.prototype.setAnswer = function(answer) {
        this.setRemoteDescription(answer, 'answer');
    };
    
    JingleSessionPC.prototype.updateModifySourcesQueue = function() {
        var signalingState = this.peerconnection.signalingState;
        var iceConnectionState = this.peerconnection.iceConnectionState;
        if (signalingState === 'stable' && iceConnectionState === 'connected') {
            this.modifySourcesQueue.resume();
        } else {
            this.modifySourcesQueue.pause();
        }
    };
    
    JingleSessionPC.prototype.doInitialize = function () {
        var self = this;
        
        this.hadstuncandidate = false;
        this.hadturncandidate = false;
        this.lasticecandidate = false;
        // True if reconnect is in progress
        this.isreconnect = false;
        // Set to true if the connection was ever stable
        this.wasstable = false;
        
        this.peerconnection = new TraceablePeerConnection(
            this.connection.jingle.ice_config,
            this.connection.jingle.pc_constraints,
            this);
        
        this.peerconnection.onicecandidate = function (event) {
            var protocol;
            if (event && event.candidate) {
                protocol = (typeof event.candidate.protocol === 'string')
                    ? event.candidate.protocol.toLowerCase() : '';
                if ((config.webrtcIceTcpDisable && protocol == 'tcp') ||
                    (config.webrtcIceUdpDisable && protocol == 'udp')) {
                    return;
                }
            }
            self.sendIceCandidate(event.candidate);
        };
        this.peerconnection.onaddstream = function (event) {
            if (event.stream.id === 'default') {
                // This is a recvonly stream. Clients that implement Unified Plan,
                // such as Firefox use recvonly "streams/channels/tracks" for
                // receiving remote stream/tracks, as opposed to Plan B where there
                // are only 3 channels: audio, video and data.
                console.log("RECVONLY REMOTE STREAM IGNORED: " + event.stream +
                    " - " + event.stream.id);
                return;
            }
            
            console.log("REMOTE STREAM ADDED: ", event.stream, event.stream.id);
            self.remoteStreamAdded(event);
        };
        this.peerconnection.onremovestream = function (event) {
            // Remove the stream from remoteStreams?
            console.log("We are ignoring a removestream event: " + event);
        };
        this.peerconnection.onsignalingstatechange = function (event) {
            if (!(self && self.peerconnection)) return;
            console.info("Signaling: " + this.peerconnection.signalingState);
            if (self.peerconnection.signalingState === 'stable') {
                self.wasstable = true;
            }
            self.updateModifySourcesQueue();
        };
        /**
         * The oniceconnectionstatechange event handler contains the code to execute when the iceconnectionstatechange event,
         * of type Event, is received by this RTCPeerConnection. Such an event is sent when the value of
         * RTCPeerConnection.iceConnectionState changes.
         *
         * @param event the event containing information about the change
         */
        this.peerconnection.oniceconnectionstatechange = function (event) {
            if (!(self && self.peerconnection)) return;
            console.log("(TIME) ICE " + self.peerconnection.iceConnectionState +
                ":\t", window.performance.now());
            self.updateModifySourcesQueue();
            switch (self.peerconnection.iceConnectionState) {
                case 'connected':
                    
                    // Informs interested parties that the connection has been restored.
                    if (self.peerconnection.signalingState === 'stable' && self.isreconnect)
                        self.eventEmitter.emit(XMPPEvents.CONNECTION_RESTORED);
                    self.isreconnect = false;
                    
                    break;
                case 'disconnected':
                    self.isreconnect = true;
                    // Informs interested parties that the connection has been interrupted.
                    if (self.wasstable)
                        self.eventEmitter.emit(XMPPEvents.CONNECTION_INTERRUPTED);
                    break;
                case 'failed':
                    self.eventEmitter.emit(XMPPEvents.CONFERENCE_SETUP_FAILED);
                    break;
            }
            onIceConnectionStateChange(self.sid, self);
        };
        this.peerconnection.onnegotiationneeded = function (event) {
            self.eventEmitter.emit(XMPPEvents.PEERCONNECTION_READY, self);
        };
        if (APP.RTC.localAudio) {
            self.peerconnection.addStream(APP.RTC.localAudio.getOriginalStream());
        }
        if (APP.RTC.localVideo) {
            self.peerconnection.addStream(APP.RTC.localVideo.getOriginalStream());
        }
    };
    
    function onIceConnectionStateChange(sid, session) {
        switch (session.peerconnection.iceConnectionState) {
            case 'checking':
                session.timeChecking = (new Date()).getTime();
                session.firstconnect = true;
                break;
            case 'completed': // on caller side
            case 'connected':
                if (session.firstconnect) {
                    session.firstconnect = false;
                    var metadata = {};
                    metadata.setupTime
                        = (new Date()).getTime() - session.timeChecking;
                    session.peerconnection.getStats(function (res) {
                        if(res && res.result) {
                            res.result().forEach(function (report) {
                                if (report.type == 'googCandidatePair' &&
                                    report.stat('googActiveConnection') == 'true') {
                                    metadata.localCandidateType
                                        = report.stat('googLocalCandidateType');
                                    metadata.remoteCandidateType
                                        = report.stat('googRemoteCandidateType');
                                    
                                    // log pair as well so we can get nice pie
                                    // charts
                                    metadata.candidatePair
                                        = report.stat('googLocalCandidateType') +
                                        ';' +
                                        report.stat('googRemoteCandidateType');
                                    
                                    if (report.stat('googRemoteAddress').indexOf('[') === 0)
                                    {
                                        metadata.ipv6 = true;
                                    }
                                }
                            });
                        }
                    });
                }
                break;
        }
    }
    
    JingleSessionPC.prototype.accept = function () {
        this.state = 'active';
        
        var pranswer = this.peerconnection.localDescription;
        if (!pranswer || pranswer.type != 'pranswer') {
            return;
        }
        console.log('going from pranswer to answer');
        if (this.usetrickle) {
            // remove candidates already sent from session-accept
            var lines = SDPUtil.find_lines(pranswer.sdp, 'a=candidate:');
            for (var i = 0; i < lines.length; i++) {
                pranswer.sdp = pranswer.sdp.replace(lines[i] + '\r\n', '');
            }
        }
        while (SDPUtil.find_line(pranswer.sdp, 'a=inactive')) {
            // FIXME: change any inactive to sendrecv or whatever they were originally
            pranswer.sdp = pranswer.sdp.replace('a=inactive', 'a=sendrecv');
        }
        var prsdp = new SDP(pranswer.sdp);
        if (config.webrtcIceTcpDisable) {
            prsdp.removeTcpCandidates = true;
        }
        if (config.webrtcIceUdpDisable) {
            prsdp.removeUdpCandidates = true;
        }
        var accept = $iq({to: this.peerjid,
            type: 'set'})
            .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                action: 'session-accept',
                initiator: this.initiator,
                responder: this.responder,
                sid: this.sid });
        // FIXME why do we generate session-accept in 3 different places ?
        prsdp.toJingle(
            accept,
            this.initiator == this.me ? 'initiator' : 'responder',
            this.localStreamsSSRC);
        var sdp = this.peerconnection.localDescription.sdp;
        while (SDPUtil.find_line(sdp, 'a=inactive')) {
            // FIXME: change any inactive to sendrecv or whatever they were originally
            sdp = sdp.replace('a=inactive', 'a=sendrecv');
        }
        var self = this;
        this.peerconnection.setLocalDescription(new RTCSessionDescription({type: 'answer', sdp: sdp}),
            function () {
                //console.log('setLocalDescription success');
                self.setLocalDescription();
                
                SSRCReplacement.processSessionInit(accept);
                
                self.connection.sendIQ(accept,
                    function () {
                        var ack = {};
                        ack.source = 'answer';
                        $(document).trigger('ack.jingle', [self.sid, ack]);
                    },
                    function (stanza) {
                        var error = ($(stanza).find('error').length) ? {
                            code: $(stanza).find('error').attr('code'),
                            reason: $(stanza).find('error :first')[0].tagName
                        }:{};
                        error.source = 'answer';
                        JingleSessionPC.onJingleError(self.sid, error);
                    },
                    10000);
            },
            function (e) {
                console.error('setLocalDescription failed', e);
                self.eventEmitter.emit(XMPPEvents.CONFERENCE_SETUP_FAILED);
            }
        );
    };
    
    JingleSessionPC.prototype.terminate = function (reason) {
        this.state = 'ended';
        this.reason = reason;
        this.peerconnection.close();
        if (this.statsinterval !== null) {
            window.clearInterval(this.statsinterval);
            this.statsinterval = null;
        }
    };
    
    JingleSessionPC.prototype.active = function () {
        return this.state == 'active';
    };
    
    JingleSessionPC.prototype.sendIceCandidate = function (candidate) {
        var self = this;
        if (candidate && !this.lasticecandidate) {
            var ice = SDPUtil.iceparams(this.localSDP.media[candidate.sdpMLineIndex], this.localSDP.session);
            var jcand = SDPUtil.candidateToJingle(candidate.candidate);
            if (!(ice && jcand)) {
                console.error('failed to get ice && jcand');
                return;
            }
            ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';
            
            if (jcand.type === 'srflx') {
                this.hadstuncandidate = true;
            } else if (jcand.type === 'relay') {
                this.hadturncandidate = true;
            }
            
            if (this.usetrickle) {
                if (this.usedrip) {
                    if (this.drip_container.length === 0) {
                        // start 20ms callout
                        window.setTimeout(function () {
                            if (self.drip_container.length === 0) return;
                            self.sendIceCandidates(self.drip_container);
                            self.drip_container = [];
                        }, 20);
                        
                    }
                    this.drip_container.push(candidate);
                    return;
                } else {
                    self.sendIceCandidate([candidate]);
                }
            }
        } else {
            //console.log('sendIceCandidate: last candidate.');
            if (!this.usetrickle) {
                //console.log('should send full offer now...');
                //FIXME why do we generate session-accept in 3 different places ?
                var init = $iq({to: this.peerjid,
                    type: 'set'})
                    .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                        action: this.peerconnection.localDescription.type == 'offer' ? 'session-initiate' : 'session-accept',
                        initiator: this.initiator,
                        sid: this.sid});
                this.localSDP = new SDP(this.peerconnection.localDescription.sdp);
                if (config.webrtcIceTcpDisable) {
                    this.localSDP.removeTcpCandidates = true;
                }
                if (config.webrtcIceUdpDisable) {
                    this.localSDP.removeUdpCandidates = true;
                }
                var sendJingle = function (ssrc) {
                    if(!ssrc)
                        ssrc = {};
                    self.localSDP.toJingle(
                        init,
                        self.initiator == self.me ? 'initiator' : 'responder',
                        ssrc);
                    
                    SSRCReplacement.processSessionInit(init);
                    
                    self.connection.sendIQ(init,
                        function () {
                            //console.log('session initiate ack');
                            var ack = {};
                            ack.source = 'offer';
                            $(document).trigger('ack.jingle', [self.sid, ack]);
                        },
                        function (stanza) {
                            self.state = 'error';
                            self.peerconnection.close();
                            var error = ($(stanza).find('error').length) ? {
                                code: $(stanza).find('error').attr('code'),
                                reason: $(stanza).find('error :first')[0].tagName,
                            }:{};
                            error.source = 'offer';
                            JingleSessionPC.onJingleError(self.sid, error);
                        },
                        10000);
                };
                sendJingle();
            }
            this.lasticecandidate = true;
            console.log('Have we encountered any srflx candidates? ' + this.hadstuncandidate);
            console.log('Have we encountered any relay candidates? ' + this.hadturncandidate);
            
            if (!(this.hadstuncandidate || this.hadturncandidate) && this.peerconnection.signalingState != 'closed') {
                $(document).trigger('nostuncandidates.jingle', [this.sid]);
            }
        }
    };
    
    JingleSessionPC.prototype.sendIceCandidates = function (candidates) {
        console.log('sendIceCandidates', candidates);
        var cand = $iq({to: this.peerjid, type: 'set'})
            .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                action: 'transport-info',
                initiator: this.initiator,
                sid: this.sid});
        for (var mid = 0; mid < this.localSDP.media.length; mid++) {
            var cands = candidates.filter(function (el) { return el.sdpMLineIndex == mid; });
            var mline = SDPUtil.parse_mline(this.localSDP.media[mid].split('\r\n')[0]);
            if (cands.length > 0) {
                var ice = SDPUtil.iceparams(this.localSDP.media[mid], this.localSDP.session);
                ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';
                cand.c('content', {creator: this.initiator == this.me ? 'initiator' : 'responder',
                    name: (cands[0].sdpMid? cands[0].sdpMid : mline.media)
                }).c('transport', ice);
                for (var i = 0; i < cands.length; i++) {
                    cand.c('candidate', SDPUtil.candidateToJingle(cands[i].candidate)).up();
                }
                // add fingerprint
                if (SDPUtil.find_line(this.localSDP.media[mid], 'a=fingerprint:', this.localSDP.session)) {
                    var tmp = SDPUtil.parse_fingerprint(SDPUtil.find_line(this.localSDP.media[mid], 'a=fingerprint:', this.localSDP.session));
                    tmp.required = true;
                    cand.c(
                        'fingerprint',
                        {xmlns: 'urn:xmpp:jingle:apps:dtls:0'})
                        .t(tmp.fingerprint);
                    delete tmp.fingerprint;
                    cand.attrs(tmp);
                    cand.up();
                }
                cand.up(); // transport
                cand.up(); // content
            }
        }
        // might merge last-candidate notification into this, but it is called alot later. See webrtc issue #2340
        //console.log('was this the last candidate', this.lasticecandidate);
        this.connection.sendIQ(cand,
            function () {
                var ack = {};
                ack.source = 'transportinfo';
                $(document).trigger('ack.jingle', [this.sid, ack]);
            },
            function (stanza) {
                var error = ($(stanza).find('error').length) ? {
                    code: $(stanza).find('error').attr('code'),
                    reason: $(stanza).find('error :first')[0].tagName,
                }:{};
                error.source = 'transportinfo';
                JingleSessionPC.onJingleError(this.sid, error);
            },
            10000);
    };
    
    
    JingleSessionPC.prototype.sendOffer = function () {
        //console.log('sendOffer...');
        var self = this;
        this.peerconnection.createOffer(function (sdp) {
                self.createdOffer(sdp);
            },
            function (e) {
                console.error('createOffer failed', e);
            },
            this.media_constraints
        );
    };
    
    // FIXME createdOffer is never used in jitsi-meet
    JingleSessionPC.prototype.createdOffer = function (sdp) {
        //console.log('createdOffer', sdp);
        var self = this;
        this.localSDP = new SDP(sdp.sdp);
        //this.localSDP.mangle();
        var sendJingle = function () {
            var init = $iq({to: this.peerjid,
                type: 'set'})
                .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                    action: 'session-initiate',
                    initiator: this.initiator,
                    sid: this.sid});
            self.localSDP.toJingle(
                init,
                this.initiator == this.me ? 'initiator' : 'responder',
                this.localStreamsSSRC);
            
            SSRCReplacement.processSessionInit(init);
            
            self.connection.sendIQ(init,
                function () {
                    var ack = {};
                    ack.source = 'offer';
                    $(document).trigger('ack.jingle', [self.sid, ack]);
                },
                function (stanza) {
                    self.state = 'error';
                    self.peerconnection.close();
                    var error = ($(stanza).find('error').length) ? {
                        code: $(stanza).find('error').attr('code'),
                        reason: $(stanza).find('error :first')[0].tagName,
                    }:{};
                    error.source = 'offer';
                    JingleSessionPC.onJingleError(self.sid, error);
                },
                10000);
        };
        sdp.sdp = this.localSDP.raw;
        this.peerconnection.setLocalDescription(sdp,
            function () {
                if(self.usetrickle)
                {
                    sendJingle();
                }
                self.setLocalDescription();
                //console.log('setLocalDescription success');
            },
            function (e) {
                console.error('setLocalDescription failed', e);
                self.eventEmitter.emit(XMPPEvents.CONFERENCE_SETUP_FAILED);
            }
        );
        var cands = SDPUtil.find_lines(this.localSDP.raw, 'a=candidate:');
        for (var i = 0; i < cands.length; i++) {
            var cand = SDPUtil.parse_icecandidate(cands[i]);
            if (cand.type == 'srflx') {
                this.hadstuncandidate = true;
            } else if (cand.type == 'relay') {
                this.hadturncandidate = true;
            }
        }
    };
    
    JingleSessionPC.prototype.readSsrcInfo = function (contents) {
        var self = this;
        $(contents).each(function (idx, content) {
            var name = $(content).attr('name');
            var mediaType = this.getAttribute('name');
            var ssrcs = $(content).find('description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
            ssrcs.each(function () {
                var ssrc = this.getAttribute('ssrc');
                $(this).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each(
                    function () {
                        var owner = this.getAttribute('owner');
                        self.ssrcOwners[ssrc] = owner;
                    }
                );
            });
        });
    };
    
    JingleSessionPC.prototype.getSsrcOwner = function (ssrc) {
        return this.ssrcOwners[ssrc];
    };
    
    JingleSessionPC.prototype.setRemoteDescription = function (elem, desctype) {
        this.remoteSDP = new SDP('');
        if (config.webrtcIceTcpDisable) {
            this.remoteSDP.removeTcpCandidates = true;
        }
        if (config.webrtcIceUdpDisable) {
            this.remoteSDP.removeUdpCandidates = true;
        }
        
        this.remoteSDP.fromJingle(elem);
        this.readSsrcInfo($(elem).find(">content"));
        if (this.peerconnection.remoteDescription !== null) {
            console.log('setRemoteDescription when remote description is not null, should be pranswer', this.peerconnection.remoteDescription);
            if (this.peerconnection.remoteDescription.type == 'pranswer') {
                var pranswer = new SDP(this.peerconnection.remoteDescription.sdp);
                for (var i = 0; i < pranswer.media.length; i++) {
                    // make sure we have ice ufrag and pwd
                    if (!SDPUtil.find_line(this.remoteSDP.media[i], 'a=ice-ufrag:', this.remoteSDP.session)) {
                        if (SDPUtil.find_line(pranswer.media[i], 'a=ice-ufrag:', pranswer.session)) {
                            this.remoteSDP.media[i] += SDPUtil.find_line(pranswer.media[i], 'a=ice-ufrag:', pranswer.session) + '\r\n';
                        } else {
                            console.warn('no ice ufrag?');
                        }
                        if (SDPUtil.find_line(pranswer.media[i], 'a=ice-pwd:', pranswer.session)) {
                            this.remoteSDP.media[i] += SDPUtil.find_line(pranswer.media[i], 'a=ice-pwd:', pranswer.session) + '\r\n';
                        } else {
                            console.warn('no ice pwd?');
                        }
                    }
                    // copy over candidates
                    var lines = SDPUtil.find_lines(pranswer.media[i], 'a=candidate:');
                    for (var j = 0; j < lines.length; j++) {
                        this.remoteSDP.media[i] += lines[j] + '\r\n';
                    }
                }
                this.remoteSDP.raw = this.remoteSDP.session + this.remoteSDP.media.join('');
            }
        }
        var remotedesc = new RTCSessionDescription({type: desctype, sdp: this.remoteSDP.raw});
        
        this.peerconnection.setRemoteDescription(remotedesc,
            function () {
                //console.log('setRemoteDescription success');
            },
            function (e) {
                console.error('setRemoteDescription error', e);
                JingleSessionPC.onJingleFatalError(self, e);
            }
        );
    };
    
    /**
     * Adds remote ICE candidates to this Jingle session.
     * @param elem An array of Jingle "content" elements?
     */
    JingleSessionPC.prototype.addIceCandidate = function (elem) {
        var self = this;
        if (this.peerconnection.signalingState == 'closed') {
            return;
        }
        if (!this.peerconnection.remoteDescription && this.peerconnection.signalingState == 'have-local-offer') {
            console.log('trickle ice candidate arriving before session accept...');
            // create a PRANSWER for setRemoteDescription
            if (!this.remoteSDP) {
                var cobbled = 'v=0\r\n' +
                    'o=- 1923518516 2 IN IP4 0.0.0.0\r\n' +// FIXME
                    's=-\r\n' +
                    't=0 0\r\n';
                // first, take some things from the local description
                for (var i = 0; i < this.localSDP.media.length; i++) {
                    cobbled += SDPUtil.find_line(this.localSDP.media[i], 'm=') + '\r\n';
                    cobbled += SDPUtil.find_lines(this.localSDP.media[i], 'a=rtpmap:').join('\r\n') + '\r\n';
                    if (SDPUtil.find_line(this.localSDP.media[i], 'a=mid:')) {
                        cobbled += SDPUtil.find_line(this.localSDP.media[i], 'a=mid:') + '\r\n';
                    }
                    cobbled += 'a=inactive\r\n';
                }
                this.remoteSDP = new SDP(cobbled);
            }
            // then add things like ice and dtls from remote candidate
            elem.each(function () {
                for (var i = 0; i < self.remoteSDP.media.length; i++) {
                    if (SDPUtil.find_line(self.remoteSDP.media[i], 'a=mid:' + $(this).attr('name')) ||
                        self.remoteSDP.media[i].indexOf('m=' + $(this).attr('name')) === 0) {
                        if (!SDPUtil.find_line(self.remoteSDP.media[i], 'a=ice-ufrag:')) {
                            var tmp = $(this).find('transport');
                            self.remoteSDP.media[i] += 'a=ice-ufrag:' + tmp.attr('ufrag') + '\r\n';
                            self.remoteSDP.media[i] += 'a=ice-pwd:' + tmp.attr('pwd') + '\r\n';
                            tmp = $(this).find('transport>fingerprint');
                            if (tmp.length) {
                                self.remoteSDP.media[i] += 'a=fingerprint:' + tmp.attr('hash') + ' ' + tmp.text() + '\r\n';
                            } else {
                                console.log('no dtls fingerprint (webrtc issue #1718?)');
                                self.remoteSDP.media[i] += 'a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:BAADBAADBAADBAADBAADBAADBAADBAADBAADBAAD\r\n';
                            }
                            break;
                        }
                    }
                }
            });
            this.remoteSDP.raw = this.remoteSDP.session + this.remoteSDP.media.join('');
            
            // we need a complete SDP with ice-ufrag/ice-pwd in all parts
            // this makes the assumption that the PRANSWER is constructed such that the ice-ufrag is in all mediaparts
            // but it could be in the session part as well. since the code above constructs this sdp this can't happen however
            var iscomplete = this.remoteSDP.media.filter(function (mediapart) {
                    return SDPUtil.find_line(mediapart, 'a=ice-ufrag:');
                }).length == this.remoteSDP.media.length;
            
            if (iscomplete) {
                console.log('setting pranswer');
                try {
                    this.peerconnection.setRemoteDescription(new RTCSessionDescription({type: 'pranswer', sdp: this.remoteSDP.raw }),
                        function() {
                        },
                        function(e) {
                            console.log('setRemoteDescription pranswer failed', e.toString());
                        });
                } catch (e) {
                    console.error('setting pranswer failed', e);
                }
            } else {
                //console.log('not yet setting pranswer');
            }
        }
        // operate on each content element
        elem.each(function () {
            // would love to deactivate this, but firefox still requires it
            var idx = -1;
            var i;
            for (i = 0; i < self.remoteSDP.media.length; i++) {
                if (SDPUtil.find_line(self.remoteSDP.media[i], 'a=mid:' + $(this).attr('name')) ||
                    self.remoteSDP.media[i].indexOf('m=' + $(this).attr('name')) === 0) {
                    idx = i;
                    break;
                }
            }
            if (idx == -1) { // fall back to localdescription
                for (i = 0; i < self.localSDP.media.length; i++) {
                    if (SDPUtil.find_line(self.localSDP.media[i], 'a=mid:' + $(this).attr('name')) ||
                        self.localSDP.media[i].indexOf('m=' + $(this).attr('name')) === 0) {
                        idx = i;
                        break;
                    }
                }
            }
            var name = $(this).attr('name');
            // TODO: check ice-pwd and ice-ufrag?
            $(this).find('transport>candidate').each(function () {
                var line, candidate;
                var protocol = this.getAttribute('protocol');
                protocol =
                    (typeof protocol === 'string') ? protocol.toLowerCase() : '';
                if ((config.webrtcIceTcpDisable && protocol == 'tcp') ||
                    (config.webrtcIceUdpDisable && protocol == 'udp')) {
                    return;
                }
                
                line = SDPUtil.candidateFromJingle(this);
                candidate = new RTCIceCandidate({sdpMLineIndex: idx,
                    sdpMid: name,
                    candidate: line});
                try {
                    self.peerconnection.addIceCandidate(candidate);
                } catch (e) {
                    console.error('addIceCandidate failed', e.toString(), line);
                }
            });
        });
    };
    
    JingleSessionPC.prototype.sendAnswer = function (provisional) {
        //console.log('createAnswer', provisional);
        var self = this;
        this.peerconnection.createAnswer(
            function (sdp) {
                self.createdAnswer(sdp, provisional);
            },
            function (e) {
                console.error('createAnswer failed', e);
                self.eventEmitter.emit(XMPPEvents.CONFERENCE_SETUP_FAILED);
            },
            this.media_constraints
        );
    };
    
    JingleSessionPC.prototype.createdAnswer = function (sdp, provisional) {
        //console.log('createAnswer callback');
        var self = this;
        this.localSDP = new SDP(sdp.sdp);
        //this.localSDP.mangle();
        this.usepranswer = provisional === true;
        if (this.usetrickle) {
            if (this.usepranswer) {
                sdp.type = 'pranswer';
                for (var i = 0; i < this.localSDP.media.length; i++) {
                    this.localSDP.media[i] = this.localSDP.media[i].replace('a=sendrecv\r\n', 'a=inactive\r\n');
                }
                this.localSDP.raw = this.localSDP.session + '\r\n' + this.localSDP.media.join('');
            }
        }
        var sendJingle = function (ssrcs) {
            // FIXME why do we generate session-accept in 3 different places ?
            var accept = $iq({to: self.peerjid,
                type: 'set'})
                .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                    action: 'session-accept',
                    initiator: self.initiator,
                    responder: self.responder,
                    sid: self.sid });
            if (config.webrtcIceTcpDisable) {
                self.localSDP.removeTcpCandidates = true;
            }
            if (config.webrtcIceUdpDisable) {
                self.localSDP.removeUdpCandidates = true;
            }
            self.localSDP.toJingle(
                accept,
                self.initiator == self.me ? 'initiator' : 'responder',
                ssrcs);
            
            SSRCReplacement.processSessionInit(accept);
            
            self.connection.sendIQ(accept,
                function () {
                    var ack = {};
                    ack.source = 'answer';
                    $(document).trigger('ack.jingle', [self.sid, ack]);
                },
                function (stanza) {
                    var error = ($(stanza).find('error').length) ? {
                        code: $(stanza).find('error').attr('code'),
                        reason: $(stanza).find('error :first')[0].tagName,
                    }:{};
                    error.source = 'answer';
                    JingleSessionPC.onJingleError(self.sid, error);
                },
                10000);
        };
        sdp.sdp = this.localSDP.raw;
        this.peerconnection.setLocalDescription(sdp,
            function () {
                
                //console.log('setLocalDescription success');
                if (self.usetrickle && !self.usepranswer) {
                    sendJingle();
                }
                self.setLocalDescription();
            },
            function (e) {
                console.error('setLocalDescription failed', e);
                self.eventEmitter.emit(XMPPEvents.CONFERENCE_SETUP_FAILED);
            }
        );
        var cands = SDPUtil.find_lines(this.localSDP.raw, 'a=candidate:');
        for (var j = 0; j < cands.length; j++) {
            var cand = SDPUtil.parse_icecandidate(cands[j]);
            if (cand.type == 'srflx') {
                this.hadstuncandidate = true;
            } else if (cand.type == 'relay') {
                this.hadturncandidate = true;
            }
        }
    };
    
    JingleSessionPC.prototype.sendTerminate = function (reason, text) {
        var self = this,
            term = $iq({to: this.peerjid,
                type: 'set'})
                .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                    action: 'session-terminate',
                    initiator: this.initiator,
                    sid: this.sid})
                .c('reason')
                .c(reason || 'success');
        
        if (text) {
            term.up().c('text').t(text);
        }
        
        this.connection.sendIQ(term,
            function () {
                self.peerconnection.close();
                self.peerconnection = null;
                self.terminate();
                var ack = {};
                ack.source = 'terminate';
                $(document).trigger('ack.jingle', [self.sid, ack]);
            },
            function (stanza) {
                var error = ($(stanza).find('error').length) ? {
                    code: $(stanza).find('error').attr('code'),
                    reason: $(stanza).find('error :first')[0].tagName,
                }:{};
                $(document).trigger('ack.jingle', [self.sid, error]);
            },
            10000);
        if (this.statsinterval !== null) {
            window.clearInterval(this.statsinterval);
            this.statsinterval = null;
        }
    };
    
    /**
     * Handles a Jingle source-add message for this Jingle session.
     * @param elem An array of Jingle "content" elements.
     */
    JingleSessionPC.prototype.addSource = function (elem) {
        
        var self = this;
        // FIXME: dirty waiting
        if (!this.peerconnection.localDescription) {
            console.warn("addSource - localDescription not ready yet");
            setTimeout(function()
                {
                    self.addSource(elem);
                },
                200
            );
            return;
        }
        
        console.log('addssrc', new Date().getTime());
        console.log('ice', this.peerconnection.iceConnectionState);
        
        this.readSsrcInfo(elem);
        
        var sdp = new SDP(this.peerconnection.remoteDescription.sdp);
        var mySdp = new SDP(this.peerconnection.localDescription.sdp);
        
        $(elem).each(function (idx, content) {
            var name = $(content).attr('name');
            var lines = '';
            $(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
                var semantics = this.getAttribute('semantics');
                var ssrcs = $(this).find('>source').map(function () {
                    return this.getAttribute('ssrc');
                }).get();
                
                if (ssrcs.length) {
                    lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\r\n';
                }
            });
            var tmp = $(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]'); // can handle both >source and >description>source
            tmp.each(function () {
                var ssrc = $(this).attr('ssrc');
                if(mySdp.containsSSRC(ssrc)){
                    /**
                     * This happens when multiple participants change their streams at the same time and
                     * ColibriFocus.modifySources have to wait for stable state. In the meantime multiple
                     * addssrc are scheduled for update IQ. See
                     */
                    console.warn("Got add stream request for my own ssrc: "+ssrc);
                    return;
                }
                if (sdp.containsSSRC(ssrc)) {
                    console.warn("Source-add request for existing SSRC: " + ssrc);
                    return;
                }
                $(this).find('>parameter').each(function () {
                    lines += 'a=ssrc:' + ssrc + ' ' + $(this).attr('name');
                    if ($(this).attr('value') && $(this).attr('value').length)
                        lines += ':' + $(this).attr('value');
                    lines += '\r\n';
                });
            });
            sdp.media.forEach(function(media, idx) {
                if (!SDPUtil.find_line(media, 'a=mid:' + name))
                    return;
                sdp.media[idx] += lines;
                if (!self.addssrc[idx]) self.addssrc[idx] = '';
                self.addssrc[idx] += lines;
            });
            sdp.raw = sdp.session + sdp.media.join('');
        });
        
        this.modifySourcesQueue.push(function() {
            // When a source is added and if this is FF, a new channel is allocated
            // for receiving the added source. We need to diffuse the SSRC of this
            // new recvonly channel to the rest of the peers.
            console.log('modify sources done');
            
            var newSdp = new SDP(self.peerconnection.localDescription.sdp);
            console.log("SDPs", mySdp, newSdp);
            self.notifyMySSRCUpdate(mySdp, newSdp);
        });
    };
    
    /**
     * Handles a Jingle source-remove message for this Jingle session.
     * @param elem An array of Jingle "content" elements.
     */
    JingleSessionPC.prototype.removeSource = function (elem) {
        
        var self = this;
        // FIXME: dirty waiting
        if (!this.peerconnection.localDescription) {
            console.warn("removeSource - localDescription not ready yet");
            setTimeout(function() {
                    self.removeSource(elem);
                },
                200
            );
            return;
        }
        
        console.log('removessrc', new Date().getTime());
        console.log('ice', this.peerconnection.iceConnectionState);
        var sdp = new SDP(this.peerconnection.remoteDescription.sdp);
        var mySdp = new SDP(this.peerconnection.localDescription.sdp);
        
        $(elem).each(function (idx, content) {
            var name = $(content).attr('name');
            var lines = '';
            $(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
                var semantics = this.getAttribute('semantics');
                var ssrcs = $(this).find('>source').map(function () {
                    return this.getAttribute('ssrc');
                }).get();
                
                if (ssrcs.length) {
                    lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\r\n';
                }
            });
            var tmp = $(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]'); // can handle both >source and >description>source
            tmp.each(function () {
                var ssrc = $(this).attr('ssrc');
                // This should never happen, but can be useful for bug detection
                if(mySdp.containsSSRC(ssrc)){
                    console.error("Got remove stream request for my own ssrc: "+ssrc);
                    return;
                }
                $(this).find('>parameter').each(function () {
                    lines += 'a=ssrc:' + ssrc + ' ' + $(this).attr('name');
                    if ($(this).attr('value') && $(this).attr('value').length)
                        lines += ':' + $(this).attr('value');
                    lines += '\r\n';
                });
            });
            sdp.media.forEach(function(media, idx) {
                if (!SDPUtil.find_line(media, 'a=mid:' + name))
                    return;
                sdp.media[idx] += lines;
                if (!self.removessrc[idx]) self.removessrc[idx] = '';
                self.removessrc[idx] += lines;
            });
            sdp.raw = sdp.session + sdp.media.join('');
        });
        
        this.modifySourcesQueue.push(function() {
            // When a source is removed and if this is FF, the recvonly channel that
            // receives the remote stream is deactivated . We need to diffuse the
            // recvonly SSRC removal to the rest of the peers.
            console.log('modify sources done');
            
            var newSdp = new SDP(self.peerconnection.localDescription.sdp);
            console.log("SDPs", mySdp, newSdp);
            self.notifyMySSRCUpdate(mySdp, newSdp);
        });
    };
    
    JingleSessionPC.prototype._modifySources = function (successCallback, queueCallback) {
        var self = this;
        
        if (this.peerconnection.signalingState == 'closed') return;
        if (!(this.addssrc.length || this.removessrc.length || this.pendingop !== null || this.switchstreams)){
            // There is nothing to do since scheduled job might have been executed by another succeeding call
            this.setLocalDescription();
            if(successCallback){
                successCallback();
            }
            queueCallback();
            return;
        }
        
        // Reset switch streams flag
        this.switchstreams = false;
        
        var sdp = new SDP(this.peerconnection.remoteDescription.sdp);
        
        // add sources
        this.addssrc.forEach(function(lines, idx) {
            sdp.media[idx] += lines;
        });
        this.addssrc = [];
        
        // remove sources
        this.removessrc.forEach(function(lines, idx) {
            lines = lines.split('\r\n');
            lines.pop(); // remove empty last element;
            lines.forEach(function(line) {
                sdp.media[idx] = sdp.media[idx].replace(line + '\r\n', '');
            });
        });
        this.removessrc = [];
        
        sdp.raw = sdp.session + sdp.media.join('');
        this.peerconnection.setRemoteDescription(new RTCSessionDescription({type: 'offer', sdp: sdp.raw}),
            function() {
                
                if(self.signalingState == 'closed') {
                    console.error("createAnswer attempt on closed state");
                    queueCallback("createAnswer attempt on closed state");
                    return;
                }
                
                self.peerconnection.createAnswer(
                    function(modifiedAnswer) {
                        // change video direction, see https://github.com/jitsi/jitmeet/issues/41
                        if (self.pendingop !== null) {
                            var sdp = new SDP(modifiedAnswer.sdp);
                            if (sdp.media.length > 1) {
                                switch(self.pendingop) {
                                    case 'mute':
                                        sdp.media[1] = sdp.media[1].replace('a=sendrecv', 'a=recvonly');
                                        break;
                                    case 'unmute':
                                        sdp.media[1] = sdp.media[1].replace('a=recvonly', 'a=sendrecv');
                                        break;
                                }
                                sdp.raw = sdp.session + sdp.media.join('');
                                modifiedAnswer.sdp = sdp.raw;
                            }
                            self.pendingop = null;
                        }
                        
                        // FIXME: pushing down an answer while ice connection state
                        // is still checking is bad...
                        //console.log(self.peerconnection.iceConnectionState);
                        
                        // trying to work around another chrome bug
                        //modifiedAnswer.sdp = modifiedAnswer.sdp.replace(/a=setup:active/g, 'a=setup:actpass');
                        self.peerconnection.setLocalDescription(modifiedAnswer,
                            function() {
                                //console.log('modified setLocalDescription ok');
                                self.setLocalDescription();
                                if(successCallback){
                                    successCallback();
                                }
                                queueCallback();
                            },
                            function(error) {
                                console.error('modified setLocalDescription failed', error);
                                queueCallback(error);
                            }
                        );
                    },
                    function(error) {
                        console.error('modified answer failed', error);
                        queueCallback(error);
                    }
                );
            },
            function(error) {
                console.error('modify failed', error);
                queueCallback(error);
            }
        );
    };
    
    
    /**
     * Switches video streams.
     * @param newStream new stream that will be used as video of this session.
     * @param oldStream old video stream of this session.
     * @param successCallback callback executed after successful stream switch.
     * @param isAudio whether the streams are audio (if true) or video (if false).
     */
    JingleSessionPC.prototype.switchStreams =
        function (newStream, oldStream, successCallback, isAudio) {
            var self = this;
            var sender, newTrack;
            var senderKind = isAudio ? 'audio' : 'video';
            // Remember SDP to figure out added/removed SSRCs
            var oldSdp = null;
            
            if (self.peerconnection) {
                if (self.peerconnection.localDescription) {
                    oldSdp = new SDP(self.peerconnection.localDescription.sdp);
                }
                if (RTCBrowserType.getBrowserType() ===
                    RTCBrowserType.RTC_BROWSER_FIREFOX) {
                    // On Firefox we don't replace MediaStreams as this messes up the
                    // m-lines (which can't be removed in Plan Unified) and brings a lot
                    // of complications. Instead, we use the RTPSender and replace just
                    // the track.
                    
                    // Find the right sender (for audio or video)
                    self.peerconnection.peerconnection.getSenders().some(function (s) {
                        if (s.track && s.track.kind === senderKind) {
                            sender = s;
                            return true;
                        }
                    });
                    
                    if (sender) {
                        // We assume that our streams have a single track, either audio
                        // or video.
                        newTrack = isAudio ? newStream.getAudioTracks()[0] :
                            newStream.getVideoTracks()[0];
                        sender.replaceTrack(newTrack)
                            .then(function() {
                                console.log("Replaced a track, isAudio=" + isAudio);
                            })
                            .catch(function(err) {
                                console.log("Failed to replace a track: " + err);
                            });
                    } else {
                        console.log("Cannot switch tracks: no RTPSender.");
                    }
                } else {
                    self.peerconnection.removeStream(oldStream, true);
                    if (newStream) {
                        self.peerconnection.addStream(newStream);
                    }
                }
            }
            
            // Conference is not active
            if (!oldSdp) {
                successCallback();
                return;
            }
            
            self.switchstreams = true;
            self.modifySourcesQueue.push(function() {
                console.log('modify sources done');
                
                successCallback();
                
                var newSdp = new SDP(self.peerconnection.localDescription.sdp);
                console.log("SDPs", oldSdp, newSdp);
                self.notifyMySSRCUpdate(oldSdp, newSdp);
            });
        };
    
    /**
     * Figures out added/removed ssrcs and send update IQs.
     * @param old_sdp SDP object for old description.
     * @param new_sdp SDP object for new description.
     */
    JingleSessionPC.prototype.notifyMySSRCUpdate = function (old_sdp, new_sdp) {
        
        if (!(this.peerconnection.signalingState == 'stable' &&
            this.peerconnection.iceConnectionState == 'connected')){
            console.log("Too early to send updates");
            return;
        }
        
        // send source-remove IQ.
        sdpDiffer = new SDPDiffer(new_sdp, old_sdp);
        var remove = $iq({to: this.peerjid, type: 'set'})
            .c('jingle', {
                xmlns: 'urn:xmpp:jingle:1',
                action: 'source-remove',
                initiator: this.initiator,
                sid: this.sid
            }
        );
        var removed = sdpDiffer.toJingle(remove);
        
        // Let 'source-remove' IQ through the hack and see if we're allowed to send
        // it in the current form
        if (removed)
            remove = SSRCReplacement.processSourceRemove(remove);
        
        if (removed && remove) {
            console.info("Sending source-remove", remove);
            this.connection.sendIQ(remove,
                function (res) {
                    console.info('got remove result', res);
                },
                function (err) {
                    console.error('got remove error', err);
                }
            );
        } else {
            console.log('removal not necessary');
        }
        
        // send source-add IQ.
        var sdpDiffer = new SDPDiffer(old_sdp, new_sdp);
        var add = $iq({to: this.peerjid, type: 'set'})
            .c('jingle', {
                xmlns: 'urn:xmpp:jingle:1',
                action: 'source-add',
                initiator: this.initiator,
                sid: this.sid
            }
        );
        var added = sdpDiffer.toJingle(add);
        
        // Let 'source-add' IQ through the hack and see if we're allowed to send
        // it in the current form
        if (added)
            add = SSRCReplacement.processSourceAdd(add);
        
        if (added && add) {
            console.info("Sending source-add", add);
            this.connection.sendIQ(add,
                function (res) {
                    console.info('got add result', res);
                },
                function (err) {
                    console.error('got add error', err);
                }
            );
        } else {
            console.log('addition not necessary');
        }
    };
    
    /**
     * Mutes/unmutes the (local) video i.e. enables/disables all video tracks.
     *
     * @param mute <tt>true</tt> to mute the (local) video i.e. to disable all video
     * tracks; otherwise, <tt>false</tt>
     * @param callback a function to be invoked with <tt>mute</tt> after all video
     * tracks have been enabled/disabled. The function may, optionally, return
     * another function which is to be invoked after the whole mute/unmute operation
     * has completed successfully.
     * @param options an object which specifies optional arguments such as the
     * <tt>boolean</tt> key <tt>byUser</tt> with default value <tt>true</tt> which
     * specifies whether the method was initiated in response to a user command (in
     * contrast to an automatic decision made by the application logic)
     */
    JingleSessionPC.prototype.setVideoMute = function (mute, callback, options) {
        var byUser;
        
        if (options) {
            byUser = options.byUser;
            if (typeof byUser === 'undefined') {
                byUser = true;
            }
        } else {
            byUser = true;
        }
        // The user's command to mute the (local) video takes precedence over any
        // automatic decision made by the application logic.
        if (byUser) {
            this.videoMuteByUser = mute;
        } else if (this.videoMuteByUser) {
            return;
        }
        
        this.hardMuteVideo(mute);
        
        var self = this;
        var oldSdp = null;
        if(self.peerconnection) {
            if(self.peerconnection.localDescription) {
                oldSdp = new SDP(self.peerconnection.localDescription.sdp);
            }
        }
        
        this.modifySourcesQueue.push(function() {
            console.log('modify sources done');
            
            callback(mute);
            
            var newSdp = new SDP(self.peerconnection.localDescription.sdp);
            console.log("SDPs", oldSdp, newSdp);
            self.notifyMySSRCUpdate(oldSdp, newSdp);
        });
    };
    
    JingleSessionPC.prototype.hardMuteVideo = function (muted) {
        this.pendingop = muted ? 'mute' : 'unmute';
    };
    
    JingleSessionPC.prototype.sendMute = function (muted, content) {
        var info = $iq({to: this.peerjid,
            type: 'set'})
            .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                action: 'session-info',
                initiator: this.initiator,
                sid: this.sid });
        info.c(muted ? 'mute' : 'unmute', {xmlns: 'urn:xmpp:jingle:apps:rtp:info:1'});
        info.attrs({'creator': this.me == this.initiator ? 'creator' : 'responder'});
        if (content) {
            info.attrs({'name': content});
        }
        this.connection.send(info);
    };
    
    JingleSessionPC.prototype.sendRinging = function () {
        var info = $iq({to: this.peerjid,
            type: 'set'})
            .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
                action: 'session-info',
                initiator: this.initiator,
                sid: this.sid });
        info.c('ringing', {xmlns: 'urn:xmpp:jingle:apps:rtp:info:1'});
        this.connection.send(info);
    };
    
    JingleSessionPC.prototype.getStats = function (interval) {
        var self = this;
        var recv = {audio: 0, video: 0};
        var lost = {audio: 0, video: 0};
        var lastrecv = {audio: 0, video: 0};
        var lastlost = {audio: 0, video: 0};
        var loss = {audio: 0, video: 0};
        var delta = {audio: 0, video: 0};
        this.statsinterval = window.setInterval(function () {
            if (self && self.peerconnection && self.peerconnection.getStats) {
                self.peerconnection.getStats(function (stats) {
                    var results = stats.result();
                    // TODO: there are so much statistics you can get from this..
                    for (var i = 0; i < results.length; ++i) {
                        if (results[i].type == 'ssrc') {
                            var packetsrecv = results[i].stat('packetsReceived');
                            var packetslost = results[i].stat('packetsLost');
                            if (packetsrecv && packetslost) {
                                packetsrecv = parseInt(packetsrecv, 10);
                                packetslost = parseInt(packetslost, 10);
                                
                                if (results[i].stat('googFrameRateReceived')) {
                                    lastlost.video = lost.video;
                                    lastrecv.video = recv.video;
                                    recv.video = packetsrecv;
                                    lost.video = packetslost;
                                } else {
                                    lastlost.audio = lost.audio;
                                    lastrecv.audio = recv.audio;
                                    recv.audio = packetsrecv;
                                    lost.audio = packetslost;
                                }
                            }
                        }
                    }
                    delta.audio = recv.audio - lastrecv.audio;
                    delta.video = recv.video - lastrecv.video;
                    loss.audio = (delta.audio > 0) ? Math.ceil(100 * (lost.audio - lastlost.audio) / delta.audio) : 0;
                    loss.video = (delta.video > 0) ? Math.ceil(100 * (lost.video - lastlost.video) / delta.video) : 0;
                    $(document).trigger('packetloss.jingle', [self.sid, loss]);
                });
            }
        }, interval || 3000);
        return this.statsinterval;
    };
    
    JingleSessionPC.onJingleError = function (session, error)
    {
        console.error("Jingle error", error);
    };
    
    JingleSessionPC.onJingleFatalError = function (session, error)
    {
        this.service.sessionTerminated = true;
        this.connection.emuc.doLeave();
        this.eventEmitter.emit(XMPPEvents.CONFERENCE_SETUP_FAILED);
        this.eventEmitter.emit(XMPPEvents.JINGLE_FATAL_ERROR, session, error);
    };
    
    JingleSessionPC.prototype.setLocalDescription = function () {
        var self = this;
        var newssrcs = [];
        var session = transform.parse(this.peerconnection.localDescription.sdp);
        var i;
        session.media.forEach(function (media) {
            
            if (media.ssrcs && media.ssrcs.length > 0) {
                // TODO(gp) maybe exclude FID streams?
                media.ssrcs.forEach(function (ssrc) {
                    if (ssrc.attribute !== 'cname') {
                        return;
                    }
                    newssrcs.push({
                        'ssrc': ssrc.id,
                        'type': media.type
                    });
                });
            }
            else if(self.localStreamsSSRC && self.localStreamsSSRC[media.type])
            {
                newssrcs.push({
                    'ssrc': self.localStreamsSSRC[media.type],
                    'type': media.type
                });
            }
            
        });
        
        console.log('new ssrcs', newssrcs);
        
        // Bind us as local SSRCs owner
        if (newssrcs.length > 0) {
            
            if (config.advertiseSSRCsInPresence) {
                // This is only for backward compatibility with clients which
                // don't support getting sources from Jingle (i.e. jirecon).
                this.connection.emuc.clearPresenceMedia();
            }
            
            for (i = 0; i < newssrcs.length; i++) {
                var ssrc = newssrcs[i].ssrc;
                var myJid = self.connection.emuc.myroomjid;
                self.ssrcOwners[ssrc] = myJid;
                
                if (config.advertiseSSRCsInPresence) {
                    // This is only for backward compatibility with clients which
                    // don't support getting sources from Jingle (i.e. jirecon).
                    this.connection.emuc.addMediaToPresence(
                        i+1, newssrcs[i].type, ssrc, newssrcs[i].direction);
                }
            }
            
            if (config.advertiseSSRCsInPresence) {
                this.connection.emuc.sendPresence();
            }
        }
    };
    
    // an attempt to work around https://github.com/jitsi/jitmeet/issues/32
    // TODO: is this hack (along with the XMPPEvent-s used only for it) still needed
    // now that we announce an SSRC for receive-only streams?
    function sendKeyframe(pc) {
        console.log('sendkeyframe', pc.iceConnectionState);
        if (pc.iceConnectionState !== 'connected') return; // safe...
        pc.setRemoteDescription(
            pc.remoteDescription,
            function () {
                pc.createAnswer(
                    function (modifiedAnswer) {
                        pc.setLocalDescription(
                            modifiedAnswer,
                            function () {
                                // noop
                            },
                            function (error) {
                                console.log('triggerKeyframe setLocalDescription failed', error);
                                eventEmitter.emit(XMPPEvents.SET_LOCAL_DESCRIPTION_ERROR);
                            }
                        );
                    },
                    function (error) {
                        console.log('triggerKeyframe createAnswer failed', error);
                        eventEmitter.emit(XMPPEvents.CREATE_ANSWER_ERROR);
                    }
                );
            },
            function (error) {
                console.log('triggerKeyframe setRemoteDescription failed', error);
                eventEmitter.emit(XMPPEvents.SET_REMOTE_DESCRIPTION_ERROR);
            }
        );
    }
    
    /**
     * Handles 'onaddstream' events from the RTCPeerConnection.
     * @param event the 'onaddstream' event.
     */
    JingleSessionPC.prototype.remoteStreamAdded = function (event) {
        var self = this;
        var ssrc;
        var ssrclines;
        var streamId = APP.RTC.getStreamID(event.stream);
        
        // look up an associated JID for a stream id
        if (!streamId) {
            console.error("No stream ID for", event.stream);
        } else if (streamId.indexOf('mixedmslabel') === -1) {
            // look only at a=ssrc: and _not_ at a=ssrc-group: lines
            
            ssrclines = SDPUtil.find_lines(
                this.peerconnection.remoteDescription.sdp,
                'a=ssrc:');
            ssrclines = ssrclines.filter(function (line) {
                // NOTE(gp) previously we filtered on the mslabel, but that property
                // is not always present.
                // return line.indexOf('mslabel:' + event.stream.label) !== -1;
                
                if (RTCBrowserType.isTemasysPluginUsed()) {
                    return ((line.indexOf('mslabel:' + streamId) !== -1));
                } else {
                    return ((line.indexOf('msid:' + streamId) !== -1));
                }
            });
            if (ssrclines.length) {
                ssrc = ssrclines[0].substring(7).split(' ')[0];
                
                if (!self.ssrcOwners[ssrc]) {
                    console.error("No SSRC owner known for: " + ssrc);
                    return;
                }
                event.peerjid = self.ssrcOwners[ssrc];
                console.log('Adding remote stream, SSRC ' + ssrc +
                    ', associated jid ' + event.peerjid);
            } else {
                console.error("No SSRC lines for ", streamId);
            }
        }
        
        APP.RTC.createRemoteStream(event, ssrc);
    };
    
    module.exports = JingleSessionPC;
    
},{"../../service/xmpp/XMPPEvents":188,"../RTC/RTCBrowserType":7,"./JingleSession":58,"./LocalSSRCReplacement":60,"./SDP":61,"./SDPDiffer":62,"./SDPUtil":63,"./TraceablePeerConnection":64,"async":75,"sdp-transform":120}],60:[function(require,module,exports){
    /* global $ */
    
    /*
     Here we do modifications of local video SSRCs. There are 2 situations we have
     to handle:
    
     1. We generate SSRC for local recvonly video stream. This is the case when we
     have no local camera and it is not generated automatically, but SSRC=1 is
     used implicitly. If that happens RTCP packets will be dropped by the JVB
     and we won't be able to request video key frames correctly.
    
     2. A hack to re-use SSRC of the first video stream for any new stream created
     in future. It turned out that Chrome may keep on using the SSRC of removed
     video stream in RTCP even though a new one has been created. So we just
     want to avoid that by re-using it. Jingle 'source-remove'/'source-add'
     notifications are blocked once first video SSRC is advertised to the focus.
    
     What this hack does:
    
     1. Stores the SSRC of the first video stream created by
     a) scanning Jingle session-accept/session-invite for existing video SSRC
     b) watching for 'source-add' for new video stream if it has not been
     created in step a)
     2. Exposes method 'mungeLocalVideoSSRC' which replaces any new video SSRC with
     the stored one. It is called by 'TracablePeerConnection' before local SDP is
     returned to the other parts of the application.
     3. Scans 'source-remove'/'source-add' notifications for stored video SSRC and
     blocks those notifications. This makes Jicofo and all participants think
     that it exists all the time even if the video stream has been removed or
     replaced locally. Thanks to that there is no additional signaling activity
     on video mute or when switching to the desktop stream.
     */
    
    var SDP = require('./SDP');
    var RTCBrowserType = require('../RTC/RTCBrowserType');
    
    /**
     * The hack is enabled on all browsers except FF by default
     * FIXME finish the hack once removeStream method is implemented in FF
     * @type {boolean}
     */
    var isEnabled = !RTCBrowserType.isFirefox();
    
    /**
     * Stored SSRC of local video stream.
     */
    var localVideoSSRC;
    
    /**
     * SSRC used for recvonly video stream when we have no local camera.
     * This is in order to tell Chrome what SSRC should be used in RTCP requests
     * instead of 1.
     */
    var localRecvOnlySSRC;
    
    /**
     * cname for <tt>localRecvOnlySSRC</tt>
     */
    var localRecvOnlyCName;
    
    /**
     * Method removes <source> element which describes <tt>localVideoSSRC</tt>
     * from given Jingle IQ.
     * @param modifyIq 'source-add' or 'source-remove' Jingle IQ.
     * @param actionName display name of the action which will be printed in log
     *        messages.
     * @returns {*} modified Jingle IQ, so that it does not contain <source> element
     *          corresponding to <tt>localVideoSSRC</tt> or <tt>null</tt> if no
     *          other SSRCs left to be signaled after removing it.
     */
    var filterOutSource = function (modifyIq, actionName) {
        var modifyIqTree = $(modifyIq.tree());
        
        if (!localVideoSSRC)
            return modifyIqTree[0];
        
        var videoSSRC = modifyIqTree.find(
            '>jingle>content[name="video"]' +
            '>description>source[ssrc="' + localVideoSSRC + '"]');
        
        if (!videoSSRC.length) {
            return modifyIqTree[0];
        }
        
        console.info(
            'Blocking ' + actionName + ' for local video SSRC: ' + localVideoSSRC);
        
        videoSSRC.remove();
        
        // Check if any sources still left to be added/removed
        if (modifyIqTree.find('>jingle>content>description>source').length) {
            return modifyIqTree[0];
        } else {
            return null;
        }
    };
    
    /**
     * Scans given Jingle IQ for video SSRC and stores it.
     * @param jingleIq the Jingle IQ to be scanned for video SSRC.
     */
    var storeLocalVideoSSRC = function (jingleIq) {
        var videoSSRCs =
            $(jingleIq.tree())
                .find('>jingle>content[name="video"]>description>source');
        
        videoSSRCs.each(function (idx, ssrcElem) {
            if (localVideoSSRC)
                return;
            // We consider SSRC real only if it has msid attribute
            // recvonly streams in FF do not have it as well as local SSRCs
            // we generate for recvonly streams in Chrome
            var ssrSel = $(ssrcElem);
            var msid = ssrSel.find('>parameter[name="msid"]');
            if (msid.length) {
                var ssrcVal = ssrSel.attr('ssrc');
                if (ssrcVal) {
                    localVideoSSRC = ssrcVal;
                    console.info('Stored local video SSRC' +
                        ' for future re-use: ' + localVideoSSRC);
                }
            }
        });
    };
    
    /**
     * Generates new SSRC for local video recvonly stream.
     * FIXME what about eventual SSRC collision ?
     */
    function generateRecvonlySSRC() {
        //
        localRecvOnlySSRC =
            Math.random().toString(10).substring(2, 11);
        localRecvOnlyCName =
            Math.random().toString(36).substring(2);
        console.info(
            "Generated local recvonly SSRC: " + localRecvOnlySSRC +
            ", cname: " + localRecvOnlyCName);
    }
    
    var LocalSSRCReplacement = {
        /**
         * Method must be called before 'session-initiate' or 'session-invite' is
         * sent. Scans the IQ for local video SSRC and stores it if detected.
         *
         * @param sessionInit our 'session-initiate' or 'session-accept' Jingle IQ
         *        which will be scanned for local video SSRC.
         */
        processSessionInit: function (sessionInit) {
            if (!isEnabled)
                return;
            
            if (localVideoSSRC) {
                console.error("Local SSRC stored already: " + localVideoSSRC);
                return;
            }
            storeLocalVideoSSRC(sessionInit);
        },
        /**
         * If we have local video SSRC stored searched given
         * <tt>localDescription</tt> for video SSRC and makes sure it is replaced
         * with the stored one.
         * @param localDescription local description object that will have local
         *        video SSRC replaced with the stored one
         * @returns modified <tt>localDescription</tt> object.
         */
        mungeLocalVideoSSRC: function (localDescription) {
            if (!isEnabled)
                return localDescription;
            
            if (!localDescription) {
                console.warn("localDescription is null or undefined");
                return localDescription;
            }
            
            // IF we have local video SSRC stored make sure it is replaced
            // with old SSRC
            if (localVideoSSRC) {
                var newSdp = new SDP(localDescription.sdp);
                if (newSdp.media[1].indexOf("a=ssrc:") !== -1 &&
                    !newSdp.containsSSRC(localVideoSSRC)) {
                    // Get new video SSRC
                    var map = newSdp.getMediaSsrcMap();
                    var videoPart = map[1];
                    var videoSSRCs = videoPart.ssrcs;
                    var newSSRC = Object.keys(videoSSRCs)[0];
                    
                    console.info(
                        "Replacing new video SSRC: " + newSSRC +
                        " with " + localVideoSSRC);
                    
                    localDescription.sdp =
                        newSdp.raw.replace(
                            new RegExp('a=ssrc:' + newSSRC, 'g'),
                            'a=ssrc:' + localVideoSSRC);
                }
            } else {
                // Make sure we have any SSRC for recvonly video stream
                var sdp = new SDP(localDescription.sdp);
                
                if (sdp.media[1] && sdp.media[1].indexOf('a=ssrc:') === -1 &&
                    sdp.media[1].indexOf('a=recvonly') !== -1) {
                    
                    if (!localRecvOnlySSRC) {
                        generateRecvonlySSRC();
                    }
                    
                    console.info('No SSRC in video recvonly stream' +
                        ' - adding SSRC: ' + localRecvOnlySSRC);
                    
                    sdp.media[1] += 'a=ssrc:' + localRecvOnlySSRC +
                        ' cname:' + localRecvOnlyCName + '\r\n';
                    
                    localDescription.sdp = sdp.session + sdp.media.join('');
                }
            }
            return localDescription;
        },
        /**
         * Method must be called before 'source-add' notification is sent. In case
         * we have local video SSRC advertised already it will be removed from the
         * notification. If no other SSRCs are described by given IQ null will be
         * returned which means that there is no point in sending the notification.
         * @param sourceAdd 'source-add' Jingle IQ to be processed
         * @returns modified 'source-add' IQ which can be sent to the focus or
         *          <tt>null</tt> if no notification shall be sent. It is no longer
         *          a Strophe IQ Builder instance, but DOM element tree.
         */
        processSourceAdd: function (sourceAdd) {
            if (!isEnabled)
                return sourceAdd;
            
            if (!localVideoSSRC) {
                // Store local SSRC if available
                storeLocalVideoSSRC(sourceAdd);
                return sourceAdd;
            } else {
                return filterOutSource(sourceAdd, 'source-add');
            }
        },
        /**
         * Method must be called before 'source-remove' notification is sent.
         * Removes local video SSRC from the notification. If there are no other
         * SSRCs described in the given IQ <tt>null</tt> will be returned which
         * means that there is no point in sending the notification.
         * @param sourceRemove 'source-remove' Jingle IQ to be processed
         * @returns modified 'source-remove' IQ which can be sent to the focus or
         *          <tt>null</tt> if no notification shall be sent. It is no longer
         *          a Strophe IQ Builder instance, but DOM element tree.
         */
        processSourceRemove: function (sourceRemove) {
            if (!isEnabled)
                return sourceRemove;
            
            return filterOutSource(sourceRemove, 'source-remove');
        },
        
        /**
         * Turns the hack on or off
         * @param enabled <tt>true</tt> to enable the hack or <tt>false</tt>
         *                to disable it
         */
        setEnabled: function (enabled) {
            isEnabled = enabled;
        }
    };
    
    module.exports = LocalSSRCReplacement;
    
},{"../RTC/RTCBrowserType":7,"./SDP":61}],61:[function(require,module,exports){
    /* jshint -W101 */
    /* jshint -W117 */
    var SDPUtil = require("./SDPUtil");
    
    // SDP STUFF
    function SDP(sdp) {
        /**
         * Whether or not to remove TCP ice candidates when translating from/to jingle.
         * @type {boolean}
         */
        this.removeTcpCandidates = false;
        
        /**
         * Whether or not to remove UDP ice candidates when translating from/to jingle.
         * @type {boolean}
         */
        this.removeUdpCandidates = false;
        
        this.media = sdp.split('\r\nm=');
        for (var i = 1; i < this.media.length; i++) {
            this.media[i] = 'm=' + this.media[i];
            if (i != this.media.length - 1) {
                this.media[i] += '\r\n';
            }
        }
        this.session = this.media.shift() + '\r\n';
        this.raw = this.session + this.media.join('');
    }
    
    /**
     * Returns map of MediaChannel mapped per channel idx.
     */
    SDP.prototype.getMediaSsrcMap = function() {
        var self = this;
        var media_ssrcs = {};
        var tmp;
        for (var mediaindex = 0; mediaindex < self.media.length; mediaindex++) {
            tmp = SDPUtil.find_lines(self.media[mediaindex], 'a=ssrc:');
            var mid = SDPUtil.parse_mid(SDPUtil.find_line(self.media[mediaindex], 'a=mid:'));
            var media = {
                mediaindex: mediaindex,
                mid: mid,
                ssrcs: {},
                ssrcGroups: []
            };
            media_ssrcs[mediaindex] = media;
            tmp.forEach(function (line) {
                var linessrc = line.substring(7).split(' ')[0];
                // allocate new ChannelSsrc
                if(!media.ssrcs[linessrc]) {
                    media.ssrcs[linessrc] = {
                        ssrc: linessrc,
                        lines: []
                    };
                }
                media.ssrcs[linessrc].lines.push(line);
            });
            tmp = SDPUtil.find_lines(self.media[mediaindex], 'a=ssrc-group:');
            tmp.forEach(function(line){
                var semantics = line.substr(0, idx).substr(13);
                var ssrcs = line.substr(14 + semantics.length).split(' ');
                if (ssrcs.length) {
                    media.ssrcGroups.push({
                        semantics: semantics,
                        ssrcs: ssrcs
                    });
                }
            });
        }
        return media_ssrcs;
    };
    /**
     * Returns <tt>true</tt> if this SDP contains given SSRC.
     * @param ssrc the ssrc to check.
     * @returns {boolean} <tt>true</tt> if this SDP contains given SSRC.
     */
    SDP.prototype.containsSSRC = function(ssrc) {
        var medias = this.getMediaSsrcMap();
        Object.keys(medias).forEach(function(mediaindex){
            var media = medias[mediaindex];
            //console.log("Check", channel, ssrc);
            if(Object.keys(media.ssrcs).indexOf(ssrc) != -1){
                return true;
            }
        });
        return false;
    };
    
    // remove iSAC and CN from SDP
    SDP.prototype.mangle = function () {
        var i, j, mline, lines, rtpmap, newdesc;
        for (i = 0; i < this.media.length; i++) {
            lines = this.media[i].split('\r\n');
            lines.pop(); // remove empty last element
            mline = SDPUtil.parse_mline(lines.shift());
            if (mline.media != 'audio')
                continue;
            newdesc = '';
            mline.fmt.length = 0;
            for (j = 0; j < lines.length; j++) {
                if (lines[j].substr(0, 9) == 'a=rtpmap:') {
                    rtpmap = SDPUtil.parse_rtpmap(lines[j]);
                    if (rtpmap.name == 'CN' || rtpmap.name == 'ISAC')
                        continue;
                    mline.fmt.push(rtpmap.id);
                    newdesc += lines[j] + '\r\n';
                } else {
                    newdesc += lines[j] + '\r\n';
                }
            }
            this.media[i] = SDPUtil.build_mline(mline) + '\r\n';
            this.media[i] += newdesc;
        }
        this.raw = this.session + this.media.join('');
    };
    
    // remove lines matching prefix from session section
    SDP.prototype.removeSessionLines = function(prefix) {
        var self = this;
        var lines = SDPUtil.find_lines(this.session, prefix);
        lines.forEach(function(line) {
            self.session = self.session.replace(line + '\r\n', '');
        });
        this.raw = this.session + this.media.join('');
        return lines;
    };
    
    // remove lines matching prefix from a media section specified by mediaindex
    // TODO: non-numeric mediaindex could match mid
    SDP.prototype.removeMediaLines = function(mediaindex, prefix) {
        var self = this;
        var lines = SDPUtil.find_lines(this.media[mediaindex], prefix);
        lines.forEach(function(line) {
            self.media[mediaindex] = self.media[mediaindex].replace(line + '\r\n', '');
        });
        this.raw = this.session + this.media.join('');
        return lines;
    };
    
    // add content's to a jingle element
    SDP.prototype.toJingle = function (elem, thecreator, ssrcs) {
        //    console.log("SSRC" + ssrcs["audio"] + " - " + ssrcs["video"]);
        var i, j, k, mline, ssrc, rtpmap, tmp, lines;
        // new bundle plan
        if (SDPUtil.find_line(this.session, 'a=group:')) {
            lines = SDPUtil.find_lines(this.session, 'a=group:');
            for (i = 0; i < lines.length; i++) {
                tmp = lines[i].split(' ');
                var semantics = tmp.shift().substr(8);
                elem.c('group', {xmlns: 'urn:xmpp:jingle:apps:grouping:0', semantics:semantics});
                for (j = 0; j < tmp.length; j++) {
                    elem.c('content', {name: tmp[j]}).up();
                }
                elem.up();
            }
        }
        for (i = 0; i < this.media.length; i++) {
            mline = SDPUtil.parse_mline(this.media[i].split('\r\n')[0]);
            if (!(mline.media === 'audio' ||
                mline.media === 'video' ||
                mline.media === 'application'))
            {
                continue;
            }
            if (SDPUtil.find_line(this.media[i], 'a=ssrc:')) {
                ssrc = SDPUtil.find_line(this.media[i], 'a=ssrc:').substring(7).split(' ')[0]; // take the first
            } else {
                if(ssrcs && ssrcs[mline.media]) {
                    ssrc = ssrcs[mline.media];
                } else {
                    ssrc = false;
                }
            }
            
            elem.c('content', {creator: thecreator, name: mline.media});
            if (SDPUtil.find_line(this.media[i], 'a=mid:')) {
                // prefer identifier from a=mid if present
                var mid = SDPUtil.parse_mid(SDPUtil.find_line(this.media[i], 'a=mid:'));
                elem.attrs({ name: mid });
            }
            
            if (SDPUtil.find_line(this.media[i], 'a=rtpmap:').length) {
                elem.c('description',
                    {xmlns: 'urn:xmpp:jingle:apps:rtp:1',
                        media: mline.media });
                if (ssrc) {
                    elem.attrs({ssrc: ssrc});
                }
                for (j = 0; j < mline.fmt.length; j++) {
                    rtpmap = SDPUtil.find_line(this.media[i], 'a=rtpmap:' + mline.fmt[j]);
                    elem.c('payload-type', SDPUtil.parse_rtpmap(rtpmap));
                    // put any 'a=fmtp:' + mline.fmt[j] lines into <param name=foo value=bar/>
                    if (SDPUtil.find_line(this.media[i], 'a=fmtp:' + mline.fmt[j])) {
                        tmp = SDPUtil.parse_fmtp(SDPUtil.find_line(this.media[i], 'a=fmtp:' + mline.fmt[j]));
                        for (k = 0; k < tmp.length; k++) {
                            elem.c('parameter', tmp[k]).up();
                        }
                    }
                    this.rtcpFbToJingle(i, elem, mline.fmt[j]); // XEP-0293 -- map a=rtcp-fb
                    
                    elem.up();
                }
                if (SDPUtil.find_line(this.media[i], 'a=crypto:', this.session)) {
                    elem.c('encryption', {required: 1});
                    var crypto = SDPUtil.find_lines(this.media[i], 'a=crypto:', this.session);
                    crypto.forEach(function(line) {
                        elem.c('crypto', SDPUtil.parse_crypto(line)).up();
                    });
                    elem.up(); // end of encryption
                }
                
                if (ssrc) {
                    // new style mapping
                    elem.c('source', { ssrc: ssrc, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
                    // FIXME: group by ssrc and support multiple different ssrcs
                    var ssrclines = SDPUtil.find_lines(this.media[i], 'a=ssrc:');
                    if(ssrclines.length > 0) {
                        ssrclines.forEach(function (line) {
                            var idx = line.indexOf(' ');
                            var linessrc = line.substr(0, idx).substr(7);
                            if (linessrc != ssrc) {
                                elem.up();
                                ssrc = linessrc;
                                elem.c('source', { ssrc: ssrc, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
                            }
                            var kv = line.substr(idx + 1);
                            elem.c('parameter');
                            if (kv.indexOf(':') == -1) {
                                elem.attrs({ name: kv });
                            } else {
                                var k = kv.split(':', 2)[0];
                                elem.attrs({ name: k });
                                
                                var v = kv.split(':', 2)[1];
                                v = SDPUtil.filter_special_chars(v);
                                elem.attrs({ value: v });
                            }
                            elem.up();
                        });
                    } else {
                        elem.up();
                        elem.c('source', { ssrc: ssrc, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
                        elem.c('parameter');
                        elem.attrs({name: "cname", value:Math.random().toString(36).substring(7)});
                        elem.up();
                        var msid = null;
                        if(mline.media == "audio") {
                            msid = APP.RTC.localAudio.getId();
                        } else {
                            msid = APP.RTC.localVideo.getId();
                        }
                        if(msid !== null) {
                            msid = SDPUtil.filter_special_chars(msid);
                            elem.c('parameter');
                            elem.attrs({name: "msid", value:msid});
                            elem.up();
                            elem.c('parameter');
                            elem.attrs({name: "mslabel", value:msid});
                            elem.up();
                            elem.c('parameter');
                            elem.attrs({name: "label", value:msid});
                            elem.up();
                        }
                    }
                    elem.up();
                    
                    // XEP-0339 handle ssrc-group attributes
                    var ssrc_group_lines = SDPUtil.find_lines(this.media[i], 'a=ssrc-group:');
                    ssrc_group_lines.forEach(function(line) {
                        var idx = line.indexOf(' ');
                        var semantics = line.substr(0, idx).substr(13);
                        var ssrcs = line.substr(14 + semantics.length).split(' ');
                        if (ssrcs.length) {
                            elem.c('ssrc-group', { semantics: semantics, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
                            ssrcs.forEach(function(ssrc) {
                                elem.c('source', { ssrc: ssrc })
                                    .up();
                            });
                            elem.up();
                        }
                    });
                }
                
                if (SDPUtil.find_line(this.media[i], 'a=rtcp-mux')) {
                    elem.c('rtcp-mux').up();
                }
                
                // XEP-0293 -- map a=rtcp-fb:*
                this.rtcpFbToJingle(i, elem, '*');
                
                // XEP-0294
                if (SDPUtil.find_line(this.media[i], 'a=extmap:')) {
                    lines = SDPUtil.find_lines(this.media[i], 'a=extmap:');
                    for (j = 0; j < lines.length; j++) {
                        tmp = SDPUtil.parse_extmap(lines[j]);
                        elem.c('rtp-hdrext', { xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',
                            uri: tmp.uri,
                            id: tmp.value });
                        if (tmp.hasOwnProperty('direction')) {
                            switch (tmp.direction) {
                                case 'sendonly':
                                    elem.attrs({senders: 'responder'});
                                    break;
                                case 'recvonly':
                                    elem.attrs({senders: 'initiator'});
                                    break;
                                case 'sendrecv':
                                    elem.attrs({senders: 'both'});
                                    break;
                                case 'inactive':
                                    elem.attrs({senders: 'none'});
                                    break;
                            }
                        }
                        // TODO: handle params
                        elem.up();
                    }
                }
                elem.up(); // end of description
            }
            
            // map ice-ufrag/pwd, dtls fingerprint, candidates
            this.transportToJingle(i, elem);
            
            if (SDPUtil.find_line(this.media[i], 'a=sendrecv', this.session)) {
                elem.attrs({senders: 'both'});
            } else if (SDPUtil.find_line(this.media[i], 'a=sendonly', this.session)) {
                elem.attrs({senders: 'initiator'});
            } else if (SDPUtil.find_line(this.media[i], 'a=recvonly', this.session)) {
                elem.attrs({senders: 'responder'});
            } else if (SDPUtil.find_line(this.media[i], 'a=inactive', this.session)) {
                elem.attrs({senders: 'none'});
            }
            if (mline.port == '0') {
                // estos hack to reject an m-line
                elem.attrs({senders: 'rejected'});
            }
            elem.up(); // end of content
        }
        elem.up();
        return elem;
    };
    
    SDP.prototype.transportToJingle = function (mediaindex, elem) {
        var tmp, sctpmap, sctpAttrs, fingerprints;
        var self = this;
        elem.c('transport');
        
        // XEP-0343 DTLS/SCTP
        if (SDPUtil.find_line(this.media[mediaindex], 'a=sctpmap:').length)
        {
            sctpmap = SDPUtil.find_line(
                this.media[mediaindex], 'a=sctpmap:', self.session);
            if (sctpmap)
            {
                sctpAttrs = SDPUtil.parse_sctpmap(sctpmap);
                elem.c('sctpmap',
                    {
                        xmlns: 'urn:xmpp:jingle:transports:dtls-sctp:1',
                        number: sctpAttrs[0], /* SCTP port */
                        protocol: sctpAttrs[1] /* protocol */
                    });
                // Optional stream count attribute
                if (sctpAttrs.length > 2)
                    elem.attrs({ streams: sctpAttrs[2]});
                elem.up();
            }
        }
        // XEP-0320
        fingerprints = SDPUtil.find_lines(this.media[mediaindex], 'a=fingerprint:', this.session);
        fingerprints.forEach(function(line) {
            tmp = SDPUtil.parse_fingerprint(line);
            tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';
            elem.c('fingerprint').t(tmp.fingerprint);
            delete tmp.fingerprint;
            line = SDPUtil.find_line(self.media[mediaindex], 'a=setup:', self.session);
            if (line) {
                tmp.setup = line.substr(8);
            }
            elem.attrs(tmp);
            elem.up(); // end of fingerprint
        });
        tmp = SDPUtil.iceparams(this.media[mediaindex], this.session);
        if (tmp) {
            tmp.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';
            elem.attrs(tmp);
            // XEP-0176
            if (SDPUtil.find_line(this.media[mediaindex], 'a=candidate:', this.session)) { // add any a=candidate lines
                var lines = SDPUtil.find_lines(this.media[mediaindex], 'a=candidate:', this.session);
                lines.forEach(function (line) {
                    var candidate = SDPUtil.candidateToJingle(line);
                    var protocol = (candidate &&
                    typeof candidate.protocol === 'string')
                        ? candidate.protocol.toLowerCase() : '';
                    if ((self.removeTcpCandidates && protocol === 'tcp') ||
                        (self.removeUdpCandidates && protocol === 'udp')) {
                        return;
                    }
                    elem.c('candidate', candidate).up();
                });
            }
        }
        elem.up(); // end of transport
    };
    
    SDP.prototype.rtcpFbToJingle = function (mediaindex, elem, payloadtype) { // XEP-0293
        var lines = SDPUtil.find_lines(this.media[mediaindex], 'a=rtcp-fb:' + payloadtype);
        lines.forEach(function (line) {
            var tmp = SDPUtil.parse_rtcpfb(line);
            if (tmp.type == 'trr-int') {
                elem.c('rtcp-fb-trr-int', {xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0', value: tmp.params[0]});
                elem.up();
            } else {
                elem.c('rtcp-fb', {xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0', type: tmp.type});
                if (tmp.params.length > 0) {
                    elem.attrs({'subtype': tmp.params[0]});
                }
                elem.up();
            }
        });
    };
    
    SDP.prototype.rtcpFbFromJingle = function (elem, payloadtype) { // XEP-0293
        var media = '';
        var tmp = elem.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
        if (tmp.length) {
            media += 'a=rtcp-fb:' + '*' + ' ' + 'trr-int' + ' ';
            if (tmp.attr('value')) {
                media += tmp.attr('value');
            } else {
                media += '0';
            }
            media += '\r\n';
        }
        tmp = elem.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
        tmp.each(function () {
            media += 'a=rtcp-fb:' + payloadtype + ' ' + $(this).attr('type');
            if ($(this).attr('subtype')) {
                media += ' ' + $(this).attr('subtype');
            }
            media += '\r\n';
        });
        return media;
    };
    
    // construct an SDP from a jingle stanza
    SDP.prototype.fromJingle = function (jingle) {
        var self = this;
        this.raw = 'v=0\r\n' +
            'o=- 1923518516 2 IN IP4 0.0.0.0\r\n' +// FIXME
            's=-\r\n' +
            't=0 0\r\n';
        // http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04#section-8
        if ($(jingle).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]').length) {
            $(jingle).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]').each(function (idx, group) {
                var contents = $(group).find('>content').map(function (idx, content) {
                    return content.getAttribute('name');
                }).get();
                if (contents.length > 0) {
                    self.raw += 'a=group:' + (group.getAttribute('semantics') || group.getAttribute('type')) + ' ' + contents.join(' ') + '\r\n';
                }
            });
        }
        
        this.session = this.raw;
        jingle.find('>content').each(function () {
            var m = self.jingle2media($(this));
            self.media.push(m);
        });
        
        // reconstruct msid-semantic -- apparently not necessary
        /*
         var msid = SDPUtil.parse_ssrc(this.raw);
         if (msid.hasOwnProperty('mslabel')) {
         this.session += "a=msid-semantic: WMS " + msid.mslabel + "\r\n";
         }
         */
        
        this.raw = this.session + this.media.join('');
    };
    
    // translate a jingle content element into an an SDP media part
    SDP.prototype.jingle2media = function (content) {
        var media = '',
            desc = content.find('description'),
            ssrc = desc.attr('ssrc'),
            self = this,
            tmp;
        var sctp = content.find(
            '>transport>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]');
        
        tmp = { media: desc.attr('media') };
        tmp.port = '1';
        if (content.attr('senders') == 'rejected') {
            // estos hack to reject an m-line.
            tmp.port = '0';
        }
        if (content.find('>transport>fingerprint').length || desc.find('encryption').length) {
            if (sctp.length)
                tmp.proto = 'DTLS/SCTP';
            else
                tmp.proto = 'RTP/SAVPF';
        } else {
            tmp.proto = 'RTP/AVPF';
        }
        if (!sctp.length) {
            tmp.fmt = desc.find('payload-type').map(
                function () { return this.getAttribute('id'); }).get();
            media += SDPUtil.build_mline(tmp) + '\r\n';
        } else {
            media += 'm=application 1 DTLS/SCTP ' + sctp.attr('number') + '\r\n';
            media += 'a=sctpmap:' + sctp.attr('number') +
                ' ' + sctp.attr('protocol');
            
            var streamCount = sctp.attr('streams');
            if (streamCount)
                media += ' ' + streamCount + '\r\n';
            else
                media += '\r\n';
        }
        
        media += 'c=IN IP4 0.0.0.0\r\n';
        if (!sctp.length)
            media += 'a=rtcp:1 IN IP4 0.0.0.0\r\n';
        tmp = content.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
        if (tmp.length) {
            if (tmp.attr('ufrag')) {
                media += SDPUtil.build_iceufrag(tmp.attr('ufrag')) + '\r\n';
            }
            if (tmp.attr('pwd')) {
                media += SDPUtil.build_icepwd(tmp.attr('pwd')) + '\r\n';
            }
            tmp.find('>fingerprint').each(function () {
                // FIXME: check namespace at some point
                media += 'a=fingerprint:' + this.getAttribute('hash');
                media += ' ' + $(this).text();
                media += '\r\n';
                if (this.getAttribute('setup')) {
                    media += 'a=setup:' + this.getAttribute('setup') + '\r\n';
                }
            });
        }
        switch (content.attr('senders')) {
            case 'initiator':
                media += 'a=sendonly\r\n';
                break;
            case 'responder':
                media += 'a=recvonly\r\n';
                break;
            case 'none':
                media += 'a=inactive\r\n';
                break;
            case 'both':
                media += 'a=sendrecv\r\n';
                break;
        }
        media += 'a=mid:' + content.attr('name') + '\r\n';
        
        // <description><rtcp-mux/></description>
        // see http://code.google.com/p/libjingle/issues/detail?id=309 -- no spec though
        // and http://mail.jabber.org/pipermail/jingle/2011-December/001761.html
        if (desc.find('rtcp-mux').length) {
            media += 'a=rtcp-mux\r\n';
        }
        
        if (desc.find('encryption').length) {
            desc.find('encryption>crypto').each(function () {
                media += 'a=crypto:' + this.getAttribute('tag');
                media += ' ' + this.getAttribute('crypto-suite');
                media += ' ' + this.getAttribute('key-params');
                if (this.getAttribute('session-params')) {
                    media += ' ' + this.getAttribute('session-params');
                }
                media += '\r\n';
            });
        }
        desc.find('payload-type').each(function () {
            media += SDPUtil.build_rtpmap(this) + '\r\n';
            if ($(this).find('>parameter').length) {
                media += 'a=fmtp:' + this.getAttribute('id') + ' ';
                media += $(this).find('parameter').map(function () {
                    return (this.getAttribute('name')
                            ? (this.getAttribute('name') + '=') : '') +
                        this.getAttribute('value');
                }).get().join('; ');
                media += '\r\n';
            }
            // xep-0293
            media += self.rtcpFbFromJingle($(this), this.getAttribute('id'));
        });
        
        // xep-0293
        media += self.rtcpFbFromJingle(desc, '*');
        
        // xep-0294
        tmp = desc.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]');
        tmp.each(function () {
            media += 'a=extmap:' + this.getAttribute('id') + ' ' + this.getAttribute('uri') + '\r\n';
        });
        
        content.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]>candidate').each(function () {
            var protocol = this.getAttribute('protocol');
            protocol = (typeof protocol === 'string') ? protocol.toLowerCase(): '';
            
            if ((self.removeTcpCandidates && protocol === 'tcp') ||
                (self.removeUdpCandidates && protocol === 'udp')) {
                return;
            }
            
            media += SDPUtil.candidateFromJingle(this);
        });
        
        // XEP-0339 handle ssrc-group attributes
        content.find('description>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
            var semantics = this.getAttribute('semantics');
            var ssrcs = $(this).find('>source').map(function() {
                return this.getAttribute('ssrc');
            }).get();
            
            if (ssrcs.length) {
                media += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\r\n';
            }
        });
        
        tmp = content.find('description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
        tmp.each(function () {
            var ssrc = this.getAttribute('ssrc');
            $(this).find('>parameter').each(function () {
                var name = this.getAttribute('name');
                var value = this.getAttribute('value');
                value = SDPUtil.filter_special_chars(value);
                media += 'a=ssrc:' + ssrc + ' ' + name;
                if (value && value.length)
                    media += ':' + value;
                media += '\r\n';
            });
        });
        
        return media;
    };
    
    
    module.exports = SDP;
    
    
},{"./SDPUtil":63}],62:[function(require,module,exports){
    var SDPUtil = require("./SDPUtil");
    
    function SDPDiffer(mySDP, otherSDP)
    {
        this.mySDP = mySDP;
        this.otherSDP = otherSDP;
    }
    
    /**
     * Returns map of MediaChannel that contains media contained in
     * 'mySDP', but not contained in 'otherSdp'. Mapped by channel idx.
     */
    SDPDiffer.prototype.getNewMedia = function() {
        
        // this could be useful in Array.prototype.
        function arrayEquals(array) {
            // if the other array is a falsy value, return
            if (!array)
                return false;
            
            // compare lengths - can save a lot of time
            if (this.length != array.length)
                return false;
            
            for (var i = 0, l=this.length; i < l; i++) {
                // Check if we have nested arrays
                if (this[i] instanceof Array && array[i] instanceof Array) {
                    // recurse into the nested arrays
                    if (!this[i].equals(array[i]))
                        return false;
                }
                else if (this[i] != array[i]) {
                    // Warning - two different object instances will never be
                    // equal: {x:20} != {x:20}
                    return false;
                }
            }
            return true;
        }
        
        var myMedias = this.mySDP.getMediaSsrcMap();
        var othersMedias = this.otherSDP.getMediaSsrcMap();
        var newMedia = {};
        Object.keys(othersMedias).forEach(function(othersMediaIdx) {
            var myMedia = myMedias[othersMediaIdx];
            var othersMedia = othersMedias[othersMediaIdx];
            if(!myMedia && othersMedia) {
                // Add whole channel
                newMedia[othersMediaIdx] = othersMedia;
                return;
            }
            // Look for new ssrcs across the channel
            Object.keys(othersMedia.ssrcs).forEach(function(ssrc) {
                if(Object.keys(myMedia.ssrcs).indexOf(ssrc) === -1) {
                    // Allocate channel if we've found ssrc that doesn't exist in
                    // our channel
                    if(!newMedia[othersMediaIdx]){
                        newMedia[othersMediaIdx] = {
                            mediaindex: othersMedia.mediaindex,
                            mid: othersMedia.mid,
                            ssrcs: {},
                            ssrcGroups: []
                        };
                    }
                    newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];
                }
            });
            
            // Look for new ssrc groups across the channels
            othersMedia.ssrcGroups.forEach(function(otherSsrcGroup){
                
                // try to match the other ssrc-group with an ssrc-group of ours
                var matched = false;
                for (var i = 0; i < myMedia.ssrcGroups.length; i++) {
                    var mySsrcGroup = myMedia.ssrcGroups[i];
                    if (otherSsrcGroup.semantics == mySsrcGroup.semantics &&
                        arrayEquals.apply(otherSsrcGroup.ssrcs,
                            [mySsrcGroup.ssrcs])) {
                        
                        matched = true;
                        break;
                    }
                }
                
                if (!matched) {
                    // Allocate channel if we've found an ssrc-group that doesn't
                    // exist in our channel
                    
                    if(!newMedia[othersMediaIdx]){
                        newMedia[othersMediaIdx] = {
                            mediaindex: othersMedia.mediaindex,
                            mid: othersMedia.mid,
                            ssrcs: {},
                            ssrcGroups: []
                        };
                    }
                    newMedia[othersMediaIdx].ssrcGroups.push(otherSsrcGroup);
                }
            });
        });
        return newMedia;
    };
    
    /**
     * TODO: document!
     */
    SDPDiffer.prototype.toJingle = function(modify) {
        var sdpMediaSsrcs = this.getNewMedia();
        
        var modified = false;
        Object.keys(sdpMediaSsrcs).forEach(function(mediaindex){
            modified = true;
            var media = sdpMediaSsrcs[mediaindex];
            modify.c('content', {name: media.mid});
            
            modify.c('description',
                {xmlns:'urn:xmpp:jingle:apps:rtp:1', media: media.mid});
            // FIXME: not completely sure this operates on blocks and / or handles
            // different ssrcs correctly
            // generate sources from lines
            Object.keys(media.ssrcs).forEach(function(ssrcNum) {
                var mediaSsrc = media.ssrcs[ssrcNum];
                modify.c('source', { xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
                modify.attrs({ssrc: mediaSsrc.ssrc});
                // iterate over ssrc lines
                mediaSsrc.lines.forEach(function (line) {
                    var idx = line.indexOf(' ');
                    var kv = line.substr(idx + 1);
                    modify.c('parameter');
                    if (kv.indexOf(':') == -1) {
                        modify.attrs({ name: kv });
                    } else {
                        var nv = kv.split(':', 2);
                        var name = nv[0];
                        var value = SDPUtil.filter_special_chars(nv[1]);
                        modify.attrs({ name: name });
                        modify.attrs({ value: value });
                    }
                    modify.up(); // end of parameter
                });
                modify.up(); // end of source
            });
            
            // generate source groups from lines
            media.ssrcGroups.forEach(function(ssrcGroup) {
                if (ssrcGroup.ssrcs.length) {
                    
                    modify.c('ssrc-group', {
                        semantics: ssrcGroup.semantics,
                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
                    });
                    
                    ssrcGroup.ssrcs.forEach(function (ssrc) {
                        modify.c('source', { ssrc: ssrc })
                            .up(); // end of source
                    });
                    modify.up(); // end of ssrc-group
                }
            });
            
            modify.up(); // end of description
            modify.up(); // end of content
        });
        
        return modified;
    };
    
    module.exports = SDPDiffer;
},{"./SDPUtil":63}],63:[function(require,module,exports){
    /* jshint -W101 */
    var SDPUtil = {
        filter_special_chars: function (text) {
            return text.replace(/[\\\/\{,\}\+]/g, "");
        },
        iceparams: function (mediadesc, sessiondesc) {
            var data = null;
            if (SDPUtil.find_line(mediadesc, 'a=ice-ufrag:', sessiondesc) &&
                SDPUtil.find_line(mediadesc, 'a=ice-pwd:', sessiondesc)) {
                data = {
                    ufrag: SDPUtil.parse_iceufrag(SDPUtil.find_line(mediadesc, 'a=ice-ufrag:', sessiondesc)),
                    pwd: SDPUtil.parse_icepwd(SDPUtil.find_line(mediadesc, 'a=ice-pwd:', sessiondesc))
                };
            }
            return data;
        },
        parse_iceufrag: function (line) {
            return line.substring(12);
        },
        build_iceufrag: function (frag) {
            return 'a=ice-ufrag:' + frag;
        },
        parse_icepwd: function (line) {
            return line.substring(10);
        },
        build_icepwd: function (pwd) {
            return 'a=ice-pwd:' + pwd;
        },
        parse_mid: function (line) {
            return line.substring(6);
        },
        parse_mline: function (line) {
            var parts = line.substring(2).split(' '),
                data = {};
            data.media = parts.shift();
            data.port = parts.shift();
            data.proto = parts.shift();
            if (parts[parts.length - 1] === '') { // trailing whitespace
                parts.pop();
            }
            data.fmt = parts;
            return data;
        },
        build_mline: function (mline) {
            return 'm=' + mline.media + ' ' + mline.port + ' ' + mline.proto + ' ' + mline.fmt.join(' ');
        },
        parse_rtpmap: function (line) {
            var parts = line.substring(9).split(' '),
                data = {};
            data.id = parts.shift();
            parts = parts[0].split('/');
            data.name = parts.shift();
            data.clockrate = parts.shift();
            data.channels = parts.length ? parts.shift() : '1';
            return data;
        },
        /**
         * Parses SDP line "a=sctpmap:..." and extracts SCTP port from it.
         * @param line eg. "a=sctpmap:5000 webrtc-datachannel"
         * @returns [SCTP port number, protocol, streams]
         */
        parse_sctpmap: function (line)
        {
            var parts = line.substring(10).split(' ');
            var sctpPort = parts[0];
            var protocol = parts[1];
            // Stream count is optional
            var streamCount = parts.length > 2 ? parts[2] : null;
            return [sctpPort, protocol, streamCount];// SCTP port
        },
        build_rtpmap: function (el) {
            var line = 'a=rtpmap:' + el.getAttribute('id') + ' ' + el.getAttribute('name') + '/' + el.getAttribute('clockrate');
            if (el.getAttribute('channels') && el.getAttribute('channels') != '1') {
                line += '/' + el.getAttribute('channels');
            }
            return line;
        },
        parse_crypto: function (line) {
            var parts = line.substring(9).split(' '),
                data = {};
            data.tag = parts.shift();
            data['crypto-suite'] = parts.shift();
            data['key-params'] = parts.shift();
            if (parts.length) {
                data['session-params'] = parts.join(' ');
            }
            return data;
        },
        parse_fingerprint: function (line) { // RFC 4572
            var parts = line.substring(14).split(' '),
                data = {};
            data.hash = parts.shift();
            data.fingerprint = parts.shift();
            // TODO assert that fingerprint satisfies 2UHEX *(":" 2UHEX) ?
            return data;
        },
        parse_fmtp: function (line) {
            var parts = line.split(' '),
                i, key, value,
                data = [];
            parts.shift();
            parts = parts.join(' ').split(';');
            for (i = 0; i < parts.length; i++) {
                key = parts[i].split('=')[0];
                while (key.length && key[0] == ' ') {
                    key = key.substring(1);
                }
                value = parts[i].split('=')[1];
                if (key && value) {
                    data.push({name: key, value: value});
                } else if (key) {
                    // rfc 4733 (DTMF) style stuff
                    data.push({name: '', value: key});
                }
            }
            return data;
        },
        parse_icecandidate: function (line) {
            var candidate = {},
                elems = line.split(' ');
            candidate.foundation = elems[0].substring(12);
            candidate.component = elems[1];
            candidate.protocol = elems[2].toLowerCase();
            candidate.priority = elems[3];
            candidate.ip = elems[4];
            candidate.port = elems[5];
            // elems[6] => "typ"
            candidate.type = elems[7];
            candidate.generation = 0; // default value, may be overwritten below
            for (var i = 8; i < elems.length; i += 2) {
                switch (elems[i]) {
                    case 'raddr':
                        candidate['rel-addr'] = elems[i + 1];
                        break;
                    case 'rport':
                        candidate['rel-port'] = elems[i + 1];
                        break;
                    case 'generation':
                        candidate.generation = elems[i + 1];
                        break;
                    case 'tcptype':
                        candidate.tcptype = elems[i + 1];
                        break;
                    default: // TODO
                        console.log('parse_icecandidate not translating "' + elems[i] + '" = "' + elems[i + 1] + '"');
                }
            }
            candidate.network = '1';
            candidate.id = Math.random().toString(36).substr(2, 10); // not applicable to SDP -- FIXME: should be unique, not just random
            return candidate;
        },
        build_icecandidate: function (cand) {
            var line = ['a=candidate:' + cand.foundation, cand.component, cand.protocol, cand.priority, cand.ip, cand.port, 'typ', cand.type].join(' ');
            line += ' ';
            switch (cand.type) {
                case 'srflx':
                case 'prflx':
                case 'relay':
                    if (cand.hasOwnAttribute('rel-addr') && cand.hasOwnAttribute('rel-port')) {
                        line += 'raddr';
                        line += ' ';
                        line += cand['rel-addr'];
                        line += ' ';
                        line += 'rport';
                        line += ' ';
                        line += cand['rel-port'];
                        line += ' ';
                    }
                    break;
            }
            if (cand.hasOwnAttribute('tcptype')) {
                line += 'tcptype';
                line += ' ';
                line += cand.tcptype;
                line += ' ';
            }
            line += 'generation';
            line += ' ';
            line += cand.hasOwnAttribute('generation') ? cand.generation : '0';
            return line;
        },
        parse_ssrc: function (desc) {
            // proprietary mapping of a=ssrc lines
            // TODO: see "Jingle RTP Source Description" by Juberti and P. Thatcher on google docs
            // and parse according to that
            var lines = desc.split('\r\n'),
                data = {};
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].substring(0, 7) == 'a=ssrc:') {
                    var idx = lines[i].indexOf(' ');
                    data[lines[i].substr(idx + 1).split(':', 2)[0]] = lines[i].substr(idx + 1).split(':', 2)[1];
                }
            }
            return data;
        },
        parse_rtcpfb: function (line) {
            var parts = line.substr(10).split(' ');
            var data = {};
            data.pt = parts.shift();
            data.type = parts.shift();
            data.params = parts;
            return data;
        },
        parse_extmap: function (line) {
            var parts = line.substr(9).split(' ');
            var data = {};
            data.value = parts.shift();
            if (data.value.indexOf('/') != -1) {
                data.direction = data.value.substr(data.value.indexOf('/') + 1);
                data.value = data.value.substr(0, data.value.indexOf('/'));
            } else {
                data.direction = 'both';
            }
            data.uri = parts.shift();
            data.params = parts;
            return data;
        },
        find_line: function (haystack, needle, sessionpart) {
            var lines = haystack.split('\r\n');
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].substring(0, needle.length) == needle) {
                    return lines[i];
                }
            }
            if (!sessionpart) {
                return false;
            }
            // search session part
            lines = sessionpart.split('\r\n');
            for (var j = 0; j < lines.length; j++) {
                if (lines[j].substring(0, needle.length) == needle) {
                    return lines[j];
                }
            }
            return false;
        },
        find_lines: function (haystack, needle, sessionpart) {
            var lines = haystack.split('\r\n'),
                needles = [];
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].substring(0, needle.length) == needle)
                    needles.push(lines[i]);
            }
            if (needles.length || !sessionpart) {
                return needles;
            }
            // search session part
            lines = sessionpart.split('\r\n');
            for (var j = 0; j < lines.length; j++) {
                if (lines[j].substring(0, needle.length) == needle) {
                    needles.push(lines[j]);
                }
            }
            return needles;
        },
        candidateToJingle: function (line) {
            // a=candidate:2979166662 1 udp 2113937151 192.168.2.100 57698 typ host generation 0
            //      <candidate component=... foundation=... generation=... id=... ip=... network=... port=... priority=... protocol=... type=.../>
            if (line.indexOf('candidate:') === 0) {
                line = 'a=' + line;
            } else if (line.substring(0, 12) != 'a=candidate:') {
                console.log('parseCandidate called with a line that is not a candidate line');
                console.log(line);
                return null;
            }
            if (line.substring(line.length - 2) == '\r\n') // chomp it
                line = line.substring(0, line.length - 2);
            var candidate = {},
                elems = line.split(' '),
                i;
            if (elems[6] != 'typ') {
                console.log('did not find typ in the right place');
                console.log(line);
                return null;
            }
            candidate.foundation = elems[0].substring(12);
            candidate.component = elems[1];
            candidate.protocol = elems[2].toLowerCase();
            candidate.priority = elems[3];
            candidate.ip = elems[4];
            candidate.port = elems[5];
            // elems[6] => "typ"
            candidate.type = elems[7];
            
            candidate.generation = '0'; // default, may be overwritten below
            for (i = 8; i < elems.length; i += 2) {
                switch (elems[i]) {
                    case 'raddr':
                        candidate['rel-addr'] = elems[i + 1];
                        break;
                    case 'rport':
                        candidate['rel-port'] = elems[i + 1];
                        break;
                    case 'generation':
                        candidate.generation = elems[i + 1];
                        break;
                    case 'tcptype':
                        candidate.tcptype = elems[i + 1];
                        break;
                    default: // TODO
                        console.log('not translating "' + elems[i] + '" = "' + elems[i + 1] + '"');
                }
            }
            candidate.network = '1';
            candidate.id = Math.random().toString(36).substr(2, 10); // not applicable to SDP -- FIXME: should be unique, not just random
            return candidate;
        },
        candidateFromJingle: function (cand) {
            var line = 'a=candidate:';
            line += cand.getAttribute('foundation');
            line += ' ';
            line += cand.getAttribute('component');
            line += ' ';
            line += cand.getAttribute('protocol'); //.toUpperCase(); // chrome M23 doesn't like this
            line += ' ';
            line += cand.getAttribute('priority');
            line += ' ';
            line += cand.getAttribute('ip');
            line += ' ';
            line += cand.getAttribute('port');
            line += ' ';
            line += 'typ';
            line += ' ' + cand.getAttribute('type');
            line += ' ';
            switch (cand.getAttribute('type')) {
                case 'srflx':
                case 'prflx':
                case 'relay':
                    if (cand.getAttribute('rel-addr') && cand.getAttribute('rel-port')) {
                        line += 'raddr';
                        line += ' ';
                        line += cand.getAttribute('rel-addr');
                        line += ' ';
                        line += 'rport';
                        line += ' ';
                        line += cand.getAttribute('rel-port');
                        line += ' ';
                    }
                    break;
            }
            if (cand.getAttribute('protocol').toLowerCase() == 'tcp') {
                line += 'tcptype';
                line += ' ';
                line += cand.getAttribute('tcptype');
                line += ' ';
            }
            line += 'generation';
            line += ' ';
            line += cand.getAttribute('generation') || '0';
            return line + '\r\n';
        }
    };
    module.exports = SDPUtil;
},{}],64:[function(require,module,exports){
    /* global $, config, mozRTCPeerConnection, RTCPeerConnection,
     webkitRTCPeerConnection, RTCSessionDescription */
    /* jshint -W101 */
    var RTC = require('../RTC/RTC');
    var RTCBrowserType = require("../RTC/RTCBrowserType.js");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var SSRCReplacement = require("./LocalSSRCReplacement");
    
    function TraceablePeerConnection(ice_config, constraints, session) {
        var self = this;
        var RTCPeerConnectionType = null;
        if (RTCBrowserType.isFirefox()) {
            RTCPeerConnectionType = mozRTCPeerConnection;
        } else if (RTCBrowserType.isTemasysPluginUsed()) {
            RTCPeerConnectionType = RTCPeerConnection;
        } else {
            RTCPeerConnectionType = webkitRTCPeerConnection;
        }
        this.peerconnection = new RTCPeerConnectionType(ice_config, constraints);
        this.updateLog = [];
        this.stats = {};
        this.statsinterval = null;
        this.maxstats = 0; // limit to 300 values, i.e. 5 minutes; set to 0 to disable
        var Interop = require('sdp-interop').Interop;
        this.interop = new Interop();
        var Simulcast = require('sdp-simulcast');
        this.simulcast = new Simulcast({numOfLayers: 3, explodeRemoteSimulcast: false});
        
        // override as desired
        this.trace = function (what, info) {
            /*console.warn('WTRACE', what, info);
             if (info && RTCBrowserType.isIExplorer()) {
             if (info.length > 1024) {
             console.warn('WTRACE', what, info.substr(1024));
             }
             if (info.length > 2048) {
             console.warn('WTRACE', what, info.substr(2048));
             }
             }*/
            self.updateLog.push({
                time: new Date(),
                type: what,
                value: info || ""
            });
        };
        this.onicecandidate = null;
        this.peerconnection.onicecandidate = function (event) {
            // FIXME: this causes stack overflow with Temasys Plugin
            if (!RTCBrowserType.isTemasysPluginUsed())
                self.trace('onicecandidate', JSON.stringify(event.candidate, null, ' '));
            if (self.onicecandidate !== null) {
                self.onicecandidate(event);
            }
        };
        this.onaddstream = null;
        this.peerconnection.onaddstream = function (event) {
            self.trace('onaddstream', event.stream.id);
            if (self.onaddstream !== null) {
                self.onaddstream(event);
            }
        };
        this.onremovestream = null;
        this.peerconnection.onremovestream = function (event) {
            self.trace('onremovestream', event.stream.id);
            if (self.onremovestream !== null) {
                self.onremovestream(event);
            }
        };
        this.onsignalingstatechange = null;
        this.peerconnection.onsignalingstatechange = function (event) {
            self.trace('onsignalingstatechange', self.signalingState);
            if (self.onsignalingstatechange !== null) {
                self.onsignalingstatechange(event);
            }
        };
        this.oniceconnectionstatechange = null;
        this.peerconnection.oniceconnectionstatechange = function (event) {
            self.trace('oniceconnectionstatechange', self.iceConnectionState);
            if (self.oniceconnectionstatechange !== null) {
                self.oniceconnectionstatechange(event);
            }
        };
        this.onnegotiationneeded = null;
        this.peerconnection.onnegotiationneeded = function (event) {
            self.trace('onnegotiationneeded');
            if (self.onnegotiationneeded !== null) {
                self.onnegotiationneeded(event);
            }
        };
        self.ondatachannel = null;
        this.peerconnection.ondatachannel = function (event) {
            self.trace('ondatachannel', event);
            if (self.ondatachannel !== null) {
                self.ondatachannel(event);
            }
        };
        // XXX: do all non-firefox browsers which we support also support this?
        if (!RTCBrowserType.isFirefox() && this.maxstats) {
            this.statsinterval = window.setInterval(function() {
                self.peerconnection.getStats(function(stats) {
                    var results = stats.result();
                    var now = new Date();
                    for (var i = 0; i < results.length; ++i) {
                        results[i].names().forEach(function (name) {
                            var id = results[i].id + '-' + name;
                            if (!self.stats[id]) {
                                self.stats[id] = {
                                    startTime: now,
                                    endTime: now,
                                    values: [],
                                    times: []
                                };
                            }
                            self.stats[id].values.push(results[i].stat(name));
                            self.stats[id].times.push(now.getTime());
                            if (self.stats[id].values.length > self.maxstats) {
                                self.stats[id].values.shift();
                                self.stats[id].times.shift();
                            }
                            self.stats[id].endTime = now;
                        });
                    }
                });
                
            }, 1000);
        }
    }
    
    /**
     * Returns a string representation of a SessionDescription object.
     */
    var dumpSDP = function(description) {
        if (typeof description === 'undefined' || description === null) {
            return '';
        }
        
        return 'type: ' + description.type + '\r\n' + description.sdp;
    };
    
    /**
     * Takes a SessionDescription object and returns a "normalized" version.
     * Currently it only takes care of ordering the a=ssrc lines.
     */
    var normalizePlanB = function(desc) {
        if (typeof desc !== 'object' || desc === null ||
            typeof desc.sdp !== 'string') {
            console.warn('An empty description was passed as an argument.');
            return desc;
        }
        
        var transform = require('sdp-transform');
        var session = transform.parse(desc.sdp);
        
        if (typeof session !== 'undefined' && typeof session.media !== 'undefined' &&
            Array.isArray(session.media)) {
            session.media.forEach(function (mLine) {
                
                // Chrome appears to be picky about the order in which a=ssrc lines
                // are listed in an m-line when rtx is enabled (and thus there are
                // a=ssrc-group lines with FID semantics). Specifically if we have
                // "a=ssrc-group:FID S1 S2" and the "a=ssrc:S2" lines appear before
                // the "a=ssrc:S1" lines, SRD fails.
                // So, put SSRC which appear as the first SSRC in an FID ssrc-group
                // first.
                var firstSsrcs = [];
                var newSsrcLines = [];
                
                if (typeof mLine.ssrcGroups !== 'undefined' && Array.isArray(mLine.ssrcGroups)) {
                    mLine.ssrcGroups.forEach(function (group) {
                        if (typeof group.semantics !== 'undefined' &&
                            group.semantics === 'FID') {
                            if (typeof group.ssrcs !== 'undefined') {
                                firstSsrcs.push(Number(group.ssrcs.split(' ')[0]));
                            }
                        }
                    });
                }
                
                if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {
                    var i;
                    for (i = 0; i<mLine.ssrcs.length; i++){
                        if (typeof mLine.ssrcs[i] === 'object'
                            && typeof mLine.ssrcs[i].id !== 'undefined'
                            && !$.inArray(mLine.ssrcs[i].id, firstSsrcs)) {
                            newSsrcLines.push(mLine.ssrcs[i]);
                            delete mLine.ssrcs[i];
                        }
                    }
                    
                    for (i = 0; i<mLine.ssrcs.length; i++){
                        if (typeof mLine.ssrcs[i] !== 'undefined') {
                            newSsrcLines.push(mLine.ssrcs[i]);
                        }
                    }
                    
                    mLine.ssrcs = newSsrcLines;
                }
            });
        }
        
        var resStr = transform.write(session);
        return new RTCSessionDescription({
            type: desc.type,
            sdp: resStr
        });
    };
    
    if (TraceablePeerConnection.prototype.__defineGetter__ !== undefined) {
        TraceablePeerConnection.prototype.__defineGetter__(
            'signalingState',
            function() { return this.peerconnection.signalingState; });
        TraceablePeerConnection.prototype.__defineGetter__(
            'iceConnectionState',
            function() { return this.peerconnection.iceConnectionState; });
        TraceablePeerConnection.prototype.__defineGetter__(
            'localDescription',
            function() {
                var desc = this.peerconnection.localDescription;
                
                desc = SSRCReplacement.mungeLocalVideoSSRC(desc);
                
                this.trace('getLocalDescription::preTransform', dumpSDP(desc));
                
                // if we're running on FF, transform to Plan B first.
                if (RTCBrowserType.usesUnifiedPlan()) {
                    desc = this.interop.toPlanB(desc);
                    this.trace('getLocalDescription::postTransform (Plan B)', dumpSDP(desc));
                }
                return desc;
            });
        TraceablePeerConnection.prototype.__defineGetter__(
            'remoteDescription',
            function() {
                var desc = this.peerconnection.remoteDescription;
                this.trace('getRemoteDescription::preTransform', dumpSDP(desc));
                
                // if we're running on FF, transform to Plan B first.
                if (RTCBrowserType.usesUnifiedPlan()) {
                    desc = this.interop.toPlanB(desc);
                    this.trace('getRemoteDescription::postTransform (Plan B)', dumpSDP(desc));
                }
                return desc;
            });
    }
    
    TraceablePeerConnection.prototype.addStream = function (stream) {
        this.trace('addStream', stream.id);
        try
        {
            this.peerconnection.addStream(stream);
        }
        catch (e)
        {
            console.error(e);
        }
    };
    
    TraceablePeerConnection.prototype.removeStream = function (stream, stopStreams) {
        this.trace('removeStream', stream.id);
        if(stopStreams) {
            RTC.stopMediaStream(stream);
        }
        
        try {
            // FF doesn't support this yet.
            if (this.peerconnection.removeStream)
                this.peerconnection.removeStream(stream);
        } catch (e) {
            console.error(e);
        }
    };
    
    TraceablePeerConnection.prototype.createDataChannel = function (label, opts) {
        this.trace('createDataChannel', label, opts);
        return this.peerconnection.createDataChannel(label, opts);
    };
    
    TraceablePeerConnection.prototype.setLocalDescription
        = function (description, successCallback, failureCallback) {
        this.trace('setLocalDescription::preTransform', dumpSDP(description));
        // if we're running on FF, transform to Plan A first.
        if (RTCBrowserType.usesUnifiedPlan()) {
            description = this.interop.toUnifiedPlan(description);
            this.trace('setLocalDescription::postTransform (Plan A)', dumpSDP(description));
        }
        
        var self = this;
        this.peerconnection.setLocalDescription(description,
            function () {
                self.trace('setLocalDescriptionOnSuccess');
                successCallback();
            },
            function (err) {
                self.trace('setLocalDescriptionOnFailure', err);
                failureCallback(err);
            }
        );
        /*
         if (this.statsinterval === null && this.maxstats > 0) {
         // start gathering stats
         }
         */
    };
    
    TraceablePeerConnection.prototype.setRemoteDescription
        = function (description, successCallback, failureCallback) {
        this.trace('setRemoteDescription::preTransform', dumpSDP(description));
        // TODO the focus should squeze or explode the remote simulcast
        description = this.simulcast.mungeRemoteDescription(description);
        this.trace('setRemoteDescription::postTransform (simulcast)', dumpSDP(description));
        
        // if we're running on FF, transform to Plan A first.
        if (RTCBrowserType.usesUnifiedPlan()) {
            description = this.interop.toUnifiedPlan(description);
            this.trace('setRemoteDescription::postTransform (Plan A)', dumpSDP(description));
        }
        
        if (RTCBrowserType.usesPlanB()) {
            description = normalizePlanB(description);
        }
        
        var self = this;
        this.peerconnection.setRemoteDescription(description,
            function () {
                self.trace('setRemoteDescriptionOnSuccess');
                successCallback();
            },
            function (err) {
                self.trace('setRemoteDescriptionOnFailure', err);
                failureCallback(err);
            }
        );
        /*
         if (this.statsinterval === null && this.maxstats > 0) {
         // start gathering stats
         }
         */
    };
    
    TraceablePeerConnection.prototype.close = function () {
        this.trace('stop');
        if (this.statsinterval !== null) {
            window.clearInterval(this.statsinterval);
            this.statsinterval = null;
        }
        this.peerconnection.close();
    };
    
    TraceablePeerConnection.prototype.createOffer
        = function (successCallback, failureCallback, constraints) {
        var self = this;
        this.trace('createOffer', JSON.stringify(constraints, null, ' '));
        this.peerconnection.createOffer(
            function (offer) {
                self.trace('createOfferOnSuccess::preTransform', dumpSDP(offer));
                // NOTE this is not tested because in meet the focus generates the
                // offer.
                
                // if we're running on FF, transform to Plan B first.
                if (RTCBrowserType.usesUnifiedPlan()) {
                    offer = self.interop.toPlanB(offer);
                    self.trace('createOfferOnSuccess::postTransform (Plan B)', dumpSDP(offer));
                }
                
                offer = SSRCReplacement.mungeLocalVideoSSRC(offer);
                
                if (config.enableSimulcast && self.simulcast.isSupported()) {
                    offer = self.simulcast.mungeLocalDescription(offer);
                    self.trace('createOfferOnSuccess::postTransform (simulcast)', dumpSDP(offer));
                }
                successCallback(offer);
            },
            function(err) {
                self.trace('createOfferOnFailure', err);
                failureCallback(err);
            },
            constraints
        );
    };
    
    TraceablePeerConnection.prototype.createAnswer
        = function (successCallback, failureCallback, constraints) {
        var self = this;
        this.trace('createAnswer', JSON.stringify(constraints, null, ' '));
        this.peerconnection.createAnswer(
            function (answer) {
                self.trace('createAnswerOnSuccess::preTransform', dumpSDP(answer));
                // if we're running on FF, transform to Plan A first.
                if (RTCBrowserType.usesUnifiedPlan()) {
                    answer = self.interop.toPlanB(answer);
                    self.trace('createAnswerOnSuccess::postTransform (Plan B)', dumpSDP(answer));
                }
                
                // munge local video SSRC
                answer = SSRCReplacement.mungeLocalVideoSSRC(answer);
                
                if (config.enableSimulcast && self.simulcast.isSupported()) {
                    answer = self.simulcast.mungeLocalDescription(answer);
                    self.trace('createAnswerOnSuccess::postTransform (simulcast)', dumpSDP(answer));
                }
                successCallback(answer);
            },
            function(err) {
                self.trace('createAnswerOnFailure', err);
                failureCallback(err);
            },
            constraints
        );
    };
    
    TraceablePeerConnection.prototype.addIceCandidate
        = function (candidate, successCallback, failureCallback) {
        //var self = this;
        this.trace('addIceCandidate', JSON.stringify(candidate, null, ' '));
        this.peerconnection.addIceCandidate(candidate);
        /* maybe later
         this.peerconnection.addIceCandidate(candidate,
         function () {
         self.trace('addIceCandidateOnSuccess');
         successCallback();
         },
         function (err) {
         self.trace('addIceCandidateOnFailure', err);
         failureCallback(err);
         }
         );
         */
    };
    
    TraceablePeerConnection.prototype.getStats = function(callback, errback) {
        // TODO: Is this the correct way to handle Opera, Temasys?
        if (RTCBrowserType.isFirefox()) {
            // ignore for now...
            if(!errback)
                errback = function () {};
            this.peerconnection.getStats(null, callback, errback);
        } else {
            this.peerconnection.getStats(callback);
        }
    };
    
    module.exports = TraceablePeerConnection;
    
    
},{"../../service/xmpp/XMPPEvents":188,"../RTC/RTC":6,"../RTC/RTCBrowserType.js":7,"./LocalSSRCReplacement":60,"sdp-interop":106,"sdp-simulcast":113,"sdp-transform":120}],65:[function(require,module,exports){
    /* global $, $iq, APP, config, messageHandler,
     roomName, sessionTerminated, Strophe, Util */
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var Settings = require("../settings/Settings");
    
    var AuthenticationEvents
        = require("../../service/authentication/AuthenticationEvents");
    
    /**
     * Contains logic responsible for enabling/disabling functionality available
     * only to moderator users.
     */
    var connection = null;
    var focusUserJid;
    
    function createExpBackoffTimer(step) {
        var count = 1;
        return function (reset) {
            // Reset call
            if (reset) {
                count = 1;
                return;
            }
            // Calculate next timeout
            var timeout = Math.pow(2, count - 1);
            count += 1;
            return timeout * step;
        };
    }
    
    var getNextTimeout = createExpBackoffTimer(1000);
    var getNextErrorTimeout = createExpBackoffTimer(1000);
    // External authentication stuff
    var externalAuthEnabled = false;
    // Sip gateway can be enabled by configuring Jigasi host in config.js or
    // it will be enabled automatically if focus detects the component through
    // service discovery.
    var sipGatewayEnabled;
    
    var eventEmitter = null;
    
    var Moderator = {
        isModerator: function () {
            return connection && connection.emuc.isModerator();
        },
        
        isPeerModerator: function (peerJid) {
            return connection &&
                connection.emuc.getMemberRole(peerJid) === 'moderator';
        },
        
        isExternalAuthEnabled: function () {
            return externalAuthEnabled;
        },
        
        isSipGatewayEnabled: function () {
            return sipGatewayEnabled;
        },
        
        setConnection: function (con) {
            connection = con;
        },
        
        init: function (xmpp, emitter) {
            this.xmppService = xmpp;
            eventEmitter = emitter;
            
            sipGatewayEnabled =
                config.hosts && config.hosts.call_control !== undefined;
            
            // Message listener that talks to POPUP window
            function listener(event) {
                if (event.data && event.data.sessionId) {
                    if (event.origin !== window.location.origin) {
                        console.warn("Ignoring sessionId from different origin: " +
                            event.origin);
                        return;
                    }
                    localStorage.setItem('sessionId', event.data.sessionId);
                    // After popup is closed we will authenticate
                }
            }
            // Register
            if (window.addEventListener) {
                window.addEventListener("message", listener, false);
            } else {
                window.attachEvent("onmessage", listener);
            }
        },
        
        onMucMemberLeft: function (jid) {
            console.info("Someone left is it focus ? " + jid);
            var resource = Strophe.getResourceFromJid(jid);
            if (resource === 'focus' && !this.xmppService.sessionTerminated) {
                console.info(
                    "Focus has left the room - leaving conference");
                //hangUp();
                // We'd rather reload to have everything re-initialized
                // FIXME: show some message before reload
                location.reload();
            }
        },
        
        setFocusUserJid: function (focusJid) {
            if (!focusUserJid) {
                focusUserJid = focusJid;
                console.info("Focus jid set to: " + focusUserJid);
            }
        },
        
        getFocusUserJid: function () {
            return focusUserJid;
        },
        
        getFocusComponent: function () {
            // Get focus component address
            var focusComponent = config.hosts.focus;
            // If not specified use default: 'focus.domain'
            if (!focusComponent) {
                focusComponent = 'focus.' + config.hosts.domain;
            }
            return focusComponent;
        },
        
        createConferenceIq: function (roomName) {
            // Generate create conference IQ
            var elem = $iq({to: Moderator.getFocusComponent(), type: 'set'});
            
            // Session Id used for authentication
            var sessionId = localStorage.getItem('sessionId');
            var machineUID = Settings.getSettings().uid;
            
            console.info(
                "Session ID: " + sessionId + " machine UID: " + machineUID);
            
            elem.c('conference', {
                xmlns: 'http://jitsi.org/protocol/focus',
                room: roomName,
                'machine-uid': machineUID
            });
            
            if (sessionId) {
                elem.attrs({ 'session-id': sessionId});
            }
            
            if (config.hosts.bridge !== undefined) {
                elem.c(
                    'property',
                    { name: 'bridge', value: config.hosts.bridge})
                    .up();
            }
            // Tell the focus we have Jigasi configured
            if (config.hosts.call_control !== undefined) {
                elem.c(
                    'property',
                    { name: 'call_control', value: config.hosts.call_control})
                    .up();
            }
            if (config.channelLastN !== undefined) {
                elem.c(
                    'property',
                    { name: 'channelLastN', value: config.channelLastN})
                    .up();
            }
            if (config.adaptiveLastN !== undefined) {
                elem.c(
                    'property',
                    { name: 'adaptiveLastN', value: config.adaptiveLastN})
                    .up();
            }
            if (config.adaptiveSimulcast !== undefined) {
                elem.c(
                    'property',
                    { name: 'adaptiveSimulcast', value: config.adaptiveSimulcast})
                    .up();
            }
            if (config.openSctp !== undefined) {
                elem.c(
                    'property',
                    { name: 'openSctp', value: config.openSctp})
                    .up();
            }
            if(config.startAudioMuted !== undefined)
            {
                elem.c(
                    'property',
                    { name: 'startAudioMuted', value: config.startAudioMuted})
                    .up();
            }
            if(config.startVideoMuted !== undefined)
            {
                elem.c(
                    'property',
                    { name: 'startVideoMuted', value: config.startVideoMuted})
                    .up();
            }
            elem.c(
                'property',
                { name: 'simulcastMode', value: 'rewriting'})
                .up();
            elem.up();
            return elem;
        },
        
        parseSessionId: function (resultIq) {
            var sessionId = $(resultIq).find('conference').attr('session-id');
            if (sessionId) {
                console.info('Received sessionId: ' + sessionId);
                localStorage.setItem('sessionId', sessionId);
            }
        },
        
        parseConfigOptions: function (resultIq) {
            
            Moderator.setFocusUserJid(
                $(resultIq).find('conference').attr('focusjid'));
            
            var authenticationEnabled
                = $(resultIq).find(
                    '>conference>property' +
                    '[name=\'authentication\'][value=\'true\']').length > 0;
            
            console.info("Authentication enabled: " + authenticationEnabled);
            
            externalAuthEnabled = $(resultIq).find(
                    '>conference>property' +
                    '[name=\'externalAuth\'][value=\'true\']').length > 0;
            
            console.info('External authentication enabled: ' + externalAuthEnabled);
            
            if (!externalAuthEnabled) {
                // We expect to receive sessionId in 'internal' authentication mode
                Moderator.parseSessionId(resultIq);
            }
            
            var authIdentity = $(resultIq).find('>conference').attr('identity');
            
            eventEmitter.emit(AuthenticationEvents.IDENTITY_UPDATED,
                authenticationEnabled, authIdentity);
            
            // Check if focus has auto-detected Jigasi component(this will be also
            // included if we have passed our host from the config)
            if ($(resultIq).find(
                    '>conference>property' +
                    '[name=\'sipGatewayEnabled\'][value=\'true\']').length) {
                sipGatewayEnabled = true;
            }
            
            console.info("Sip gateway enabled: " + sipGatewayEnabled);
        },
        
        // FIXME: we need to show the fact that we're waiting for the focus
        // to the user(or that focus is not available)
        allocateConferenceFocus: function (roomName, callback) {
            // Try to use focus user JID from the config
            Moderator.setFocusUserJid(config.focusUserJid);
            // Send create conference IQ
            var iq = Moderator.createConferenceIq(roomName);
            var self = this;
            connection.sendIQ(
                iq,
                function (result) {
                    
                    // Setup config options
                    Moderator.parseConfigOptions(result);
                    
                    if ('true' === $(result).find('conference').attr('ready')) {
                        // Reset both timers
                        getNextTimeout(true);
                        getNextErrorTimeout(true);
                        // Exec callback
                        callback();
                    } else {
                        var waitMs = getNextTimeout();
                        console.info("Waiting for the focus... " + waitMs);
                        // Reset error timeout
                        getNextErrorTimeout(true);
                        window.setTimeout(
                            function () {
                                Moderator.allocateConferenceFocus(
                                    roomName, callback);
                            }, waitMs);
                    }
                },
                function (error) {
                    // Invalid session ? remove and try again
                    // without session ID to get a new one
                    var invalidSession
                        = $(error).find('>error>session-invalid').length;
                    if (invalidSession) {
                        console.info("Session expired! - removing");
                        localStorage.removeItem("sessionId");
                    }
                    if ($(error).find('>error>graceful-shutdown').length) {
                        eventEmitter.emit(XMPPEvents.GRACEFUL_SHUTDOWN);
                        return;
                    }
                    // Check for error returned by the reservation system
                    var reservationErr = $(error).find('>error>reservation-error');
                    if (reservationErr.length) {
                        // Trigger error event
                        var errorCode = reservationErr.attr('error-code');
                        var errorMsg;
                        if ($(error).find('>error>text')) {
                            errorMsg = $(error).find('>error>text').text();
                        }
                        eventEmitter.emit(
                            XMPPEvents.RESERVATION_ERROR, errorCode, errorMsg);
                        return;
                    }
                    // Not authorized to create new room
                    if ($(error).find('>error>not-authorized').length) {
                        console.warn("Unauthorized to start the conference", error);
                        var toDomain
                            = Strophe.getDomainFromJid(error.getAttribute('to'));
                        if (toDomain !== config.hosts.anonymousdomain) {
                            // FIXME: "is external" should come either from
                            // the focus or config.js
                            externalAuthEnabled = true;
                        }
                        eventEmitter.emit(
                            XMPPEvents.AUTHENTICATION_REQUIRED,
                            function () {
                                Moderator.allocateConferenceFocus(
                                    roomName, callback);
                            });
                        return;
                    }
                    var waitMs = getNextErrorTimeout();
                    console.error("Focus error, retry after " + waitMs, error);
                    // Show message
                    var focusComponent = Moderator.getFocusComponent();
                    var retrySec = waitMs / 1000;
                    // FIXME: message is duplicated ?
                    // Do not show in case of session invalid
                    // which means just a retry
                    if (!invalidSession) {
                        eventEmitter.emit(XMPPEvents.FOCUS_DISCONNECTED,
                            focusComponent, retrySec);
                    }
                    // Reset response timeout
                    getNextTimeout(true);
                    window.setTimeout(
                        function () {
                            Moderator.allocateConferenceFocus(roomName, callback);
                        }, waitMs);
                }
            );
        },
        
        getLoginUrl: function (roomName, urlCallback) {
            var iq = $iq({to: Moderator.getFocusComponent(), type: 'get'});
            iq.c('login-url', {
                xmlns: 'http://jitsi.org/protocol/focus',
                room: roomName,
                'machine-uid': Settings.getSettings().uid
            });
            connection.sendIQ(
                iq,
                function (result) {
                    var url = $(result).find('login-url').attr('url');
                    url = url = decodeURIComponent(url);
                    if (url) {
                        console.info("Got auth url: " + url);
                        urlCallback(url);
                    } else {
                        console.error(
                            "Failed to get auth url from the focus", result);
                    }
                },
                function (error) {
                    console.error("Get auth url error", error);
                }
            );
        },
        getPopupLoginUrl: function (roomName, urlCallback) {
            var iq = $iq({to: Moderator.getFocusComponent(), type: 'get'});
            iq.c('login-url', {
                xmlns: 'http://jitsi.org/protocol/focus',
                room: roomName,
                'machine-uid': Settings.getSettings().uid,
                popup: true
            });
            connection.sendIQ(
                iq,
                function (result) {
                    var url = $(result).find('login-url').attr('url');
                    url = url = decodeURIComponent(url);
                    if (url) {
                        console.info("Got POPUP auth url: " + url);
                        urlCallback(url);
                    } else {
                        console.error(
                            "Failed to get POPUP auth url from the focus", result);
                    }
                },
                function (error) {
                    console.error('Get POPUP auth url error', error);
                }
            );
        },
        logout: function (callback) {
            var iq = $iq({to: Moderator.getFocusComponent(), type: 'set'});
            var sessionId = localStorage.getItem('sessionId');
            if (!sessionId) {
                callback();
                return;
            }
            iq.c('logout', {
                xmlns: 'http://jitsi.org/protocol/focus',
                'session-id': sessionId
            });
            connection.sendIQ(
                iq,
                function (result) {
                    var logoutUrl = $(result).find('logout').attr('logout-url');
                    if (logoutUrl) {
                        logoutUrl = decodeURIComponent(logoutUrl);
                    }
                    console.info("Log out OK, url: " + logoutUrl, result);
                    localStorage.removeItem('sessionId');
                    callback(logoutUrl);
                },
                function (error) {
                    console.error("Logout error", error);
                }
            );
        }
    };
    
    module.exports = Moderator;
    
    
    
    
},{"../../service/authentication/AuthenticationEvents":182,"../../service/xmpp/XMPPEvents":188,"../settings/Settings":50}],66:[function(require,module,exports){
    /* global $, $iq, config, connection, focusMucJid, messageHandler,
     Toolbar, Util */
    var Moderator = require("./moderator");
    
    
    var recordingToken = null;
    var recordingEnabled;
    
    /**
     * Whether to use a jirecon component for recording, or use the videobridge
     * through COLIBRI.
     */
    var useJirecon;
    
    /**
     * The ID of the jirecon recording session. Jirecon generates it when we
     * initially start recording, and it needs to be used in subsequent requests
     * to jirecon.
     */
    var jireconRid = null;
    
    /**
     * The callback to update the recording button. Currently used from colibri
     * after receiving a pending status.
     */
    var recordingStateChangeCallback = null;
    
    function setRecordingToken(token) {
        recordingToken = token;
    }
    
    function setRecordingJirecon(state, token, callback, connection) {
        if (state == recordingEnabled){
            return;
        }
        
        var iq = $iq({to: config.hosts.jirecon, type: 'set'})
            .c('recording', {xmlns: 'http://jitsi.org/protocol/jirecon',
                action: (state === 'on') ? 'start' : 'stop',
                mucjid: connection.emuc.roomjid});
        if (state === 'off'){
            iq.attrs({rid: jireconRid});
        }
        
        console.log('Start recording');
        
        connection.sendIQ(
            iq,
            function (result) {
                // TODO wait for an IQ with the real status, since this is
                // provisional?
                jireconRid = $(result).find('recording').attr('rid');
                console.log('Recording ' +
                    ((state === 'on') ? 'started' : 'stopped') +
                    '(jirecon)' + result);
                recordingEnabled = state;
                if (state === 'off'){
                    jireconRid = null;
                }
                
                callback(state);
            },
            function (error) {
                console.log('Failed to start recording, error: ', error);
                callback(recordingEnabled);
            });
    }
    
    // Sends a COLIBRI message which enables or disables (according to 'state')
    // the recording on the bridge. Waits for the result IQ and calls 'callback'
    // with the new recording state, according to the IQ.
    function setRecordingColibri(state, token, callback, connection) {
        var elem = $iq({to: connection.emuc.focusMucJid, type: 'set'});
        elem.c('conference', {
            xmlns: 'http://jitsi.org/protocol/colibri'
        });
        elem.c('recording', {state: state, token: token});
        
        connection.sendIQ(elem,
            function (result) {
                console.log('Set recording "', state, '". Result:', result);
                var recordingElem = $(result).find('>conference>recording');
                var newState = recordingElem.attr('state');
                
                recordingEnabled = newState;
                callback(newState);
                
                if (newState === 'pending' && !recordingStateChangeCallback) {
                    recordingStateChangeCallback = callback;
                    connection.addHandler(function(iq){
                        var state = $(iq).find('recording').attr('state');
                        if (state)
                            recordingStateChangeCallback(state);
                    }, 'http://jitsi.org/protocol/colibri', 'iq', null, null, null);
                }
            },
            function (error) {
                console.warn(error);
                callback(recordingEnabled);
            }
        );
    }
    
    function setRecording(state, token, callback, connection) {
        if (useJirecon){
            setRecordingJirecon(state, token, callback, connection);
        } else {
            setRecordingColibri(state, token, callback, connection);
        }
    }
    
    var Recording = {
        init: function () {
            useJirecon = config.hosts &&
                (typeof config.hosts.jirecon != "undefined");
        },
        toggleRecording: function (tokenEmptyCallback,
                                   recordingStateChangeCallback,
                                   connection) {
            if (!Moderator.isModerator()) {
                console.log(
                    'non-focus, or conference not yet organized:' +
                    ' not enabling recording');
                return;
            }
            
            var self = this;
            // Jirecon does not (currently) support a token.
            if (!recordingToken && !useJirecon) {
                tokenEmptyCallback(function (value) {
                    setRecordingToken(value);
                    self.toggleRecording(tokenEmptyCallback,
                        recordingStateChangeCallback,
                        connection);
                });
                
                return;
            }
            
            var oldState = recordingEnabled;
            var newState = (oldState === 'off' || !oldState) ? 'on' : 'off';
            
            setRecording(newState,
                recordingToken,
                function (state) {
                    console.log("New recording state: ", state);
                    if (state === oldState) {
                        // FIXME: new focus:
                        // this will not work when moderator changes
                        // during active session. Then it will assume that
                        // recording status has changed to true, but it might have
                        // been already true(and we only received actual status from
                        // the focus).
                        //
                        // SO we start with status null, so that it is initialized
                        // here and will fail only after second click, so if invalid
                        // token was used we have to press the button twice before
                        // current status will be fetched and token will be reset.
                        //
                        // Reliable way would be to return authentication error.
                        // Or status update when moderator connects.
                        // Or we have to stop recording session when current
                        // moderator leaves the room.
                        
                        // Failed to change, reset the token because it might
                        // have been wrong
                        setRecordingToken(null);
                    }
                    recordingStateChangeCallback(state);
                    
                },
                connection
            );
        }
        
    };
    
    module.exports = Recording;
},{"./moderator":65}],67:[function(require,module,exports){
    /* jshint -W117 */
    /* a simple MUC connection plugin
     * can only handle a single MUC room
     */
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var Moderator = require("./moderator");
    
    module.exports = function(XMPP, eventEmitter) {
        Strophe.addConnectionPlugin('emuc', {
            connection: null,
            roomjid: null,
            myroomjid: null,
            members: {},
            list_members: [], // so we can elect a new focus
            presMap: {},
            preziMap: {},
            lastPresenceMap: {},
            joined: false,
            isOwner: false,
            role: null,
            focusMucJid: null,
            bridgeIsDown: false,
            init: function (conn) {
                this.connection = conn;
            },
            initPresenceMap: function (myroomjid) {
                this.presMap['to'] = myroomjid;
                this.presMap['xns'] = 'http://jabber.org/protocol/muc';
                if (APP.RTC.localAudio && APP.RTC.localAudio.isMuted()) {
                    this.addAudioInfoToPresence(true);
                }
                if (APP.RTC.localVideo && APP.RTC.localVideo.isMuted()) {
                    this.addVideoInfoToPresence(true);
                }
            },
            doJoin: function (jid, password) {
                this.myroomjid = jid;
                
                console.info("Joined MUC as " + this.myroomjid);
                
                this.initPresenceMap(this.myroomjid);
                
                if (!this.roomjid) {
                    this.roomjid = Strophe.getBareJidFromJid(jid);
                    // add handlers (just once)
                    this.connection.addHandler(this.onPresence.bind(this), null, 'presence', null, null, this.roomjid, {matchBare: true});
                    this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, 'presence', 'unavailable', null, this.roomjid, {matchBare: true});
                    this.connection.addHandler(this.onPresenceError.bind(this), null, 'presence', 'error', null, this.roomjid, {matchBare: true});
                    this.connection.addHandler(this.onMessage.bind(this), null, 'message', null, null, this.roomjid, {matchBare: true});
                }
                if (password !== undefined) {
                    this.presMap['password'] = password;
                }
                this.sendPresence();
            },
            doLeave: function () {
                console.log("do leave", this.myroomjid);
                var pres = $pres({to: this.myroomjid, type: 'unavailable' });
                this.presMap.length = 0;
                this.connection.send(pres);
            },
            createNonAnonymousRoom: function () {
                // http://xmpp.org/extensions/xep-0045.html#createroom-reserved
                
                var getForm = $iq({type: 'get', to: this.roomjid})
                    .c('query', {xmlns: 'http://jabber.org/protocol/muc#owner'})
                    .c('x', {xmlns: 'jabber:x:data', type: 'submit'});
                
                var self = this;
                
                this.connection.sendIQ(getForm, function (form) {
                    
                    if (!$(form).find(
                            '>query>x[xmlns="jabber:x:data"]' +
                            '>field[var="muc#roomconfig_whois"]').length) {
                        
                        console.error('non-anonymous rooms not supported');
                        return;
                    }
                    
                    var formSubmit = $iq({to: this.roomjid, type: 'set'})
                        .c('query', {xmlns: 'http://jabber.org/protocol/muc#owner'});
                    
                    formSubmit.c('x', {xmlns: 'jabber:x:data', type: 'submit'});
                    
                    formSubmit.c('field', {'var': 'FORM_TYPE'})
                        .c('value')
                        .t('http://jabber.org/protocol/muc#roomconfig').up().up();
                    
                    formSubmit.c('field', {'var': 'muc#roomconfig_whois'})
                        .c('value').t('anyone').up().up();
                    
                    self.connection.sendIQ(formSubmit);
                    
                }, function (error) {
                    console.error("Error getting room configuration form");
                });
            },
            onPresence: function (pres) {
                var from = pres.getAttribute('from');
                
                // What is this for? A workaround for something?
                if (pres.getAttribute('type')) {
                    return true;
                }
                
                // Parse etherpad tag.
                var etherpad = $(pres).find('>etherpad');
                if (etherpad.length) {
                    if (config.etherpad_base) {
                        eventEmitter.emit(XMPPEvents.ETHERPAD, etherpad.text());
                    }
                }
                
                var url;
                // Parse prezi tag.
                var presentation = $(pres).find('>prezi');
                if (presentation.length) {
                    url = presentation.attr('url');
                    var current = presentation.find('>current').text();
                    
                    console.log('presentation info received from', from, url);
                    
                    if (this.preziMap[from] == null) {
                        this.preziMap[from] = url;
                        
                        $(document).trigger('presentationadded.muc', [from, url, current]);
                    }
                    else {
                        $(document).trigger('gotoslide.muc', [from, url, current]);
                    }
                }
                else if (this.preziMap[from] != null) {
                    url = this.preziMap[from];
                    delete this.preziMap[from];
                    $(document).trigger('presentationremoved.muc', [from, url]);
                }
                
                // store the last presence for participant
                this.lastPresenceMap[from] = {};
                
                // Parse audio info tag.
                var audioMuted = $(pres).find('>audiomuted');
                if (audioMuted.length) {
                    eventEmitter.emit(XMPPEvents.PARTICIPANT_AUDIO_MUTED,
                        from, (audioMuted.text() === "true"));
                }
                
                // Parse video info tag.
                var videoMuted = $(pres).find('>videomuted');
                if (videoMuted.length) {
                    var value = (videoMuted.text() === "true");
                    this.lastPresenceMap[from].videoMuted = value;
                    eventEmitter.emit(XMPPEvents.PARTICIPANT_VIDEO_MUTED, from, value);
                }
                
                var startMuted = $(pres).find('>startmuted');
                if (startMuted.length && Moderator.isPeerModerator(from)) {
                    eventEmitter.emit(XMPPEvents.START_MUTED_SETTING_CHANGED,
                        startMuted.attr("audio") === "true",
                        startMuted.attr("video") === "true");
                }
                
                var devices = $(pres).find('>devices');
                if(devices.length)
                {
                    var audio = devices.find('>audio');
                    var video = devices.find('>video');
                    var devicesValues = {audio: false, video: false};
                    if(audio.length && audio.text() === "true")
                    {
                        devicesValues.audio = true;
                    }
                    
                    if(video.length && video.text() === "true")
                    {
                        devicesValues.video = true;
                    }
                    eventEmitter.emit(XMPPEvents.DEVICE_AVAILABLE,
                        Strophe.getResourceFromJid(from), devicesValues);
                }
                
                var videoType = $(pres).find('>videoType');
                if (videoType.length)
                {
                    if (videoType.text().length)
                    {
                        eventEmitter.emit(XMPPEvents.PARTICIPANT_VIDEO_TYPE_CHANGED,
                            Strophe.getResourceFromJid(from), videoType.text());
                    }
                }
                
                var stats = $(pres).find('>stats');
                if (stats.length) {
                    var statsObj = {};
                    Strophe.forEachChild(stats[0], "stat", function (el) {
                        statsObj[el.getAttribute("name")] = el.getAttribute("value");
                    });
                    eventEmitter.emit(XMPPEvents.REMOTE_STATS, from, statsObj);
                }
                
                // Parse status.
                if ($(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length) {
                    this.isOwner = true;
                    this.createNonAnonymousRoom();
                }
                
                // Parse roles.
                var member = {};
                member.show = $(pres).find('>show').text();
                member.status = $(pres).find('>status').text();
                var tmp = $(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item');
                member.affiliation = tmp.attr('affiliation');
                member.role = tmp.attr('role');
                
                // Focus recognition
                member.jid = tmp.attr('jid');
                member.isFocus = false;
                if (member.jid
                    && member.jid.indexOf(Moderator.getFocusUserJid() + "/") == 0) {
                    member.isFocus = true;
                }
                
                var nicktag = $(pres).find('>nick[xmlns="http://jabber.org/protocol/nick"]');
                member.displayName = (nicktag.length > 0 ? nicktag.text() : null);
                
                if (from == this.myroomjid) {
                    if (member.affiliation == 'owner') this.isOwner = true;
                    if (this.role !== member.role) {
                        this.role = member.role;
                        
                        eventEmitter.emit(XMPPEvents.LOCAL_ROLE_CHANGED,
                            from, member, pres, Moderator.isModerator());
                    }
                    if (!this.joined) {
                        this.joined = true;
                        console.log("(TIME) MUC joined:\t",
                            window.performance.now());
                        eventEmitter.emit(XMPPEvents.MUC_JOINED, from, member);
                        this.list_members.push(from);
                    }
                } else if (this.members[from] === undefined) {
                    // new participant
                    this.members[from] = member;
                    this.list_members.push(from);
                    console.log('entered', from, member);
                    if (member.isFocus) {
                        this.focusMucJid = from;
                        console.info("Ignore focus: " + from + ", real JID: " + member.jid);
                    }
                    else {
                        var id = $(pres).find('>userId').text();
                        var email = $(pres).find('>email');
                        if (email.length > 0) {
                            id = email.text();
                        }
                        eventEmitter.emit(XMPPEvents.MUC_MEMBER_JOINED, from, id, member.displayName);
                    }
                } else {
                    // Presence update for existing participant
                    // Watch role change:
                    if (this.members[from].role != member.role) {
                        this.members[from].role = member.role;
                        eventEmitter.emit(XMPPEvents.MUC_ROLE_CHANGED,
                            member.role, member.displayName);
                    }
                    
                    // store the new
                    if(member.displayName)
                        this.members[from].displayName = member.displayName;
                }
                
                // Always trigger presence to update bindings
                this.parsePresence(from, member, pres);
                
                // Trigger status message update
                if (member.status) {
                    eventEmitter.emit(XMPPEvents.PRESENCE_STATUS, from, member);
                }
                
                return true;
            },
            onPresenceUnavailable: function (pres) {
                var from = pres.getAttribute('from');
                // room destroyed ?
                if ($(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]' +
                        '>destroy').length) {
                    var reason;
                    var reasonSelect = $(pres).find(
                        '>x[xmlns="http://jabber.org/protocol/muc#user"]' +
                        '>destroy>reason');
                    if (reasonSelect.length) {
                        reason = reasonSelect.text();
                    }
                    XMPP.disposeConference(false);
                    eventEmitter.emit(XMPPEvents.MUC_DESTROYED, reason);
                    return true;
                }
                
                // Status code 110 indicates that this notification is "self-presence".
                if (!$(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length) {
                    delete this.members[from];
                    this.list_members.splice(this.list_members.indexOf(from), 1);
                    this.onParticipantLeft(from);
                }
                // If the status code is 110 this means we're leaving and we would like
                // to remove everyone else from our view, so we trigger the event.
                else if (this.list_members.length > 1) {
                    for (var i = 0; i < this.list_members.length; i++) {
                        var member = this.list_members[i];
                        delete this.members[i];
                        this.list_members.splice(i, 1);
                        this.onParticipantLeft(member);
                    }
                }
                if ($(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length) {
                    $(document).trigger('kicked.muc', [from]);
                    if (this.myroomjid === from) {
                        XMPP.disposeConference(false);
                        eventEmitter.emit(XMPPEvents.KICKED);
                    }
                }
                
                if (this.lastPresenceMap[from] != null) {
                    delete this.lastPresenceMap[from];
                }
                
                return true;
            },
            onPresenceError: function (pres) {
                var from = pres.getAttribute('from');
                if ($(pres).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                    console.log('on password required', from);
                    var self = this;
                    eventEmitter.emit(XMPPEvents.PASSWORD_REQUIRED, function (value) {
                        self.doJoin(from, value);
                    });
                } else if ($(pres).find(
                        '>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                    var toDomain = Strophe.getDomainFromJid(pres.getAttribute('to'));
                    if (toDomain === config.hosts.anonymousdomain) {
                        // enter the room by replying with 'not-authorized'. This would
                        // result in reconnection from authorized domain.
                        // We're either missing Jicofo/Prosody config for anonymous
                        // domains or something is wrong.
                        //                    XMPP.promptLogin();
                        eventEmitter.emit(XMPPEvents.ROOM_JOIN_ERROR, pres);
                        
                    } else {
                        console.warn('onPresError ', pres);
                        eventEmitter.emit(XMPPEvents.ROOM_CONNECT_ERROR, pres);
                    }
                } else {
                    console.warn('onPresError ', pres);
                    eventEmitter.emit(XMPPEvents.ROOM_CONNECT_ERROR, pres);
                }
                return true;
            },
            sendMessage: function (body, nickname) {
                var msg = $msg({to: this.roomjid, type: 'groupchat'});
                msg.c('body', body).up();
                if (nickname) {
                    msg.c('nick', {xmlns: 'http://jabber.org/protocol/nick'}).t(nickname).up().up();
                }
                this.connection.send(msg);
                eventEmitter.emit(XMPPEvents.SENDING_CHAT_MESSAGE, body);
            },
            setSubject: function (subject) {
                var msg = $msg({to: this.roomjid, type: 'groupchat'});
                msg.c('subject', subject);
                this.connection.send(msg);
                console.log("topic changed to " + subject);
            },
            onMessage: function (msg) {
                // FIXME: this is a hack. but jingle on muc makes nickchanges hard
                var from = msg.getAttribute('from');
                var nick =
                    $(msg).find('>nick[xmlns="http://jabber.org/protocol/nick"]')
                        .text() ||
                    Strophe.getResourceFromJid(from);
                
                var txt = $(msg).find('>body').text();
                var type = msg.getAttribute("type");
                if (type == "error") {
                    eventEmitter.emit(XMPPEvents.CHAT_ERROR_RECEIVED,
                        $(msg).find('>text').text(), txt);
                    return true;
                }
                
                var subject = $(msg).find('>subject');
                if (subject.length) {
                    var subjectText = subject.text();
                    if (subjectText || subjectText == "") {
                        eventEmitter.emit(XMPPEvents.SUBJECT_CHANGED, subjectText);
                        console.log("Subject is changed to " + subjectText);
                    }
                }
                
                // xep-0203 delay
                var stamp = $(msg).find('>delay').attr('stamp');
                
                if (!stamp) {
                    // or xep-0091 delay, UTC timestamp
                    stamp = $(msg).find('>[xmlns="jabber:x:delay"]').attr('stamp');
                    
                    if (stamp) {
                        // the format is CCYYMMDDThh:mm:ss
                        var dateParts = stamp.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
                        stamp = dateParts[1] + "-" + dateParts[2] + "-" + dateParts[3] + "Z";
                    }
                }
                
                if (txt) {
                    console.log('chat', nick, txt);
                    eventEmitter.emit(XMPPEvents.MESSAGE_RECEIVED,
                        from, nick, txt, this.myroomjid, stamp);
                }
                return true;
            },
            lockRoom: function (key, onSuccess, onError, onNotSupported) {
                //http://xmpp.org/extensions/xep-0045.html#roomconfig
                var ob = this;
                this.connection.sendIQ($iq({to: this.roomjid, type: 'get'}).c('query', {xmlns: 'http://jabber.org/protocol/muc#owner'}),
                    function (res) {
                        if ($(res).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
                            var formsubmit = $iq({to: ob.roomjid, type: 'set'}).c('query', {xmlns: 'http://jabber.org/protocol/muc#owner'});
                            formsubmit.c('x', {xmlns: 'jabber:x:data', type: 'submit'});
                            formsubmit.c('field', {'var': 'FORM_TYPE'}).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();
                            formsubmit.c('field', {'var': 'muc#roomconfig_roomsecret'}).c('value').t(key).up().up();
                            // Fixes a bug in prosody 0.9.+ https://code.google.com/p/lxmppd/issues/detail?id=373
                            formsubmit.c('field', {'var': 'muc#roomconfig_whois'}).c('value').t('anyone').up().up();
                            // FIXME: is muc#roomconfig_passwordprotectedroom required?
                            ob.connection.sendIQ(formsubmit,
                                onSuccess,
                                onError);
                        } else {
                            onNotSupported();
                        }
                    }, onError);
            },
            kick: function (jid) {
                var kickIQ = $iq({to: this.roomjid, type: 'set'})
                    .c('query', {xmlns: 'http://jabber.org/protocol/muc#admin'})
                    .c('item', {nick: Strophe.getResourceFromJid(jid), role: 'none'})
                    .c('reason').t('You have been kicked.').up().up().up();
                
                this.connection.sendIQ(
                    kickIQ,
                    function (result) {
                        console.log('Kick participant with jid: ', jid, result);
                    },
                    function (error) {
                        console.log('Kick participant error: ', error);
                    });
            },
            sendPresence: function () {
                if (!this.presMap['to']) {
                    // Too early to send presence - not initialized
                    return;
                }
                var pres = $pres({to: this.presMap['to'] });
                pres.c('x', {xmlns: this.presMap['xns']});
                
                if (this.presMap['password']) {
                    pres.c('password').t(this.presMap['password']).up();
                }
                
                pres.up();
                
                // Send XEP-0115 'c' stanza that contains our capabilities info
                if (this.connection.caps) {
                    this.connection.caps.node = config.clientNode;
                    pres.c('c', this.connection.caps.generateCapsAttrs()).up();
                }
                
                pres.c('user-agent', {xmlns: 'http://jitsi.org/jitmeet/user-agent'})
                    .t(navigator.userAgent).up();
                
                if (this.presMap['bridgeIsDown']) {
                    pres.c('bridgeIsDown').up();
                }
                
                if (this.presMap['email']) {
                    pres.c('email').t(this.presMap['email']).up();
                }
                
                if (this.presMap['userId']) {
                    pres.c('userId').t(this.presMap['userId']).up();
                }
                
                if (this.presMap['displayName']) {
                    // XEP-0172
                    pres.c('nick', {xmlns: 'http://jabber.org/protocol/nick'})
                        .t(this.presMap['displayName']).up();
                }
                
                if(this.presMap["devices"])
                {
                    pres.c('devices').c('audio').t(this.presMap['devices'].audio).up()
                        .c('video').t(this.presMap['devices'].video).up().up();
                }
                if (this.presMap['audions']) {
                    pres.c('audiomuted', {xmlns: this.presMap['audions']})
                        .t(this.presMap['audiomuted']).up();
                }
                
                if (this.presMap['videons']) {
                    pres.c('videomuted', {xmlns: this.presMap['videons']})
                        .t(this.presMap['videomuted']).up();
                }
                
                if (this.presMap['videoTypeNs']) {
                    pres.c('videoType', { xmlns: this.presMap['videoTypeNs'] })
                        .t(this.presMap['videoType']).up();
                }
                
                if (this.presMap['statsns']) {
                    var stats = pres.c('stats', {xmlns: this.presMap['statsns']});
                    for (var stat in this.presMap["stats"])
                        if (this.presMap["stats"][stat] != null)
                            stats.c("stat", {name: stat, value: this.presMap["stats"][stat]}).up();
                    pres.up();
                }
                
                if (this.presMap['prezins']) {
                    pres.c('prezi',
                        {xmlns: this.presMap['prezins'],
                            'url': this.presMap['preziurl']})
                        .c('current').t(this.presMap['prezicurrent']).up().up();
                }
                
                // This is only for backward compatibility with clients which
                // don't support getting sources from Jingle (i.e. jirecon).
                if (this.presMap['medians']) {
                    pres.c('media', {xmlns: this.presMap['medians']});
                    var sourceNumber = 0;
                    Object.keys(this.presMap).forEach(function (key) {
                        if (key.indexOf('source') >= 0) {
                            sourceNumber++;
                        }
                    });
                    if (sourceNumber > 0) {
                        for (var i = 1; i <= sourceNumber / 3; i++) {
                            pres.c('source',
                                {
                                    type: this.presMap['source' + i + '_type'],
                                    ssrc: this.presMap['source' + i + '_ssrc'],
                                    direction: this.presMap['source' + i + '_direction']
                                    || 'sendrecv'
                                }
                            ).up();
                        }
                    }
                    pres.up();
                }
                
                if(this.presMap["startMuted"] !== undefined)
                {
                    pres.c("startmuted", {audio: this.presMap["startMuted"].audio,
                        video: this.presMap["startMuted"].video,
                        xmlns: "http://jitsi.org/jitmeet/start-muted"});
                    delete this.presMap["startMuted"];
                }
                
                if (config.token) {
                    pres.c('token', { xmlns: 'http://jitsi.org/jitmeet/auth-token'}).t(config.token).up();
                }
                
                pres.up();
                this.connection.send(pres);
            },
            addDisplayNameToPresence: function (displayName) {
                this.presMap['displayName'] = displayName;
            },
            // This is only for backward compatibility with clients which
            // don't support getting sources from Jingle (i.e. jirecon).
            addMediaToPresence: function (sourceNumber, mtype, ssrcs, direction) {
                if (!this.presMap['medians'])
                    this.presMap['medians'] = 'http://estos.de/ns/mjs';
                
                this.presMap['source' + sourceNumber + '_type'] = mtype;
                this.presMap['source' + sourceNumber + '_ssrc'] = ssrcs;
                this.presMap['source' + sourceNumber + '_direction'] = direction;
            },
            // This is only for backward compatibility with clients which
            // don't support getting sources from Jingle (i.e. jirecon).
            clearPresenceMedia: function () {
                var self = this;
                Object.keys(this.presMap).forEach(function (key) {
                    if (key.indexOf('source') != -1) {
                        delete self.presMap[key];
                    }
                });
            },
            addDevicesToPresence: function (devices) {
                this.presMap['devices'] = devices;
            },
            /**
             * Adds the info about the type of our video stream.
             * @param videoType 'camera' or 'screen'
             */
            addVideoTypeToPresence: function (videoType) {
                this.presMap['videoTypeNs'] = 'http://jitsi.org/jitmeet/video';
                this.presMap['videoType'] = videoType;
            },
            addPreziToPresence: function (url, currentSlide) {
                this.presMap['prezins'] = 'http://jitsi.org/jitmeet/prezi';
                this.presMap['preziurl'] = url;
                this.presMap['prezicurrent'] = currentSlide;
            },
            removePreziFromPresence: function () {
                delete this.presMap['prezins'];
                delete this.presMap['preziurl'];
                delete this.presMap['prezicurrent'];
            },
            addCurrentSlideToPresence: function (currentSlide) {
                this.presMap['prezicurrent'] = currentSlide;
            },
            getPrezi: function (roomjid) {
                return this.preziMap[roomjid];
            },
            addAudioInfoToPresence: function (isMuted) {
                this.presMap['audions'] = 'http://jitsi.org/jitmeet/audio';
                this.presMap['audiomuted'] = isMuted.toString();
            },
            addVideoInfoToPresence: function (isMuted) {
                this.presMap['videons'] = 'http://jitsi.org/jitmeet/video';
                this.presMap['videomuted'] = isMuted.toString();
            },
            addConnectionInfoToPresence: function (stats) {
                this.presMap['statsns'] = 'http://jitsi.org/jitmeet/stats';
                this.presMap['stats'] = stats;
            },
            findJidFromResource: function (resourceJid) {
                if (resourceJid &&
                    resourceJid === Strophe.getResourceFromJid(this.myroomjid)) {
                    return this.myroomjid;
                }
                var peerJid = null;
                Object.keys(this.members).some(function (jid) {
                    peerJid = jid;
                    return Strophe.getResourceFromJid(jid) === resourceJid;
                });
                return peerJid;
            },
            addBridgeIsDownToPresence: function () {
                this.presMap['bridgeIsDown'] = true;
            },
            addEmailToPresence: function (email) {
                this.presMap['email'] = email;
            },
            addUserIdToPresence: function (userId) {
                this.presMap['userId'] = userId;
            },
            addStartMutedToPresence: function (audio, video) {
                this.presMap["startMuted"] = {audio: audio, video: video};
            },
            isModerator: function () {
                return this.role === 'moderator';
            },
            getMemberRole: function (peerJid) {
                if (this.members[peerJid]) {
                    return this.members[peerJid].role;
                }
                return null;
            },
            onParticipantLeft: function (jid) {
                
                eventEmitter.emit(XMPPEvents.MUC_MEMBER_LEFT, jid);
                
                this.connection.jingle.terminateByJid(jid);
                
                if (this.getPrezi(jid)) {
                    $(document).trigger('presentationremoved.muc',
                        [jid, this.getPrezi(jid)]);
                }
                
                Moderator.onMucMemberLeft(jid);
            },
            parsePresence: function (from, member, pres) {
                if($(pres).find(">bridgeIsDown").length > 0 && !this.bridgeIsDown) {
                    this.bridgeIsDown = true;
                    eventEmitter.emit(XMPPEvents.BRIDGE_DOWN);
                }
                
                if(member.isFocus)
                    return;
                
                var displayName = !config.displayJids
                    ? member.displayName : Strophe.getResourceFromJid(from);
                
                if (displayName && displayName.length > 0) {
                    eventEmitter.emit(XMPPEvents.DISPLAY_NAME_CHANGED, from, displayName);
                }
                
                var id = $(pres).find('>userID').text();
                var email = $(pres).find('>email');
                if (email.length > 0) {
                    id = email.text();
                }
                
                eventEmitter.emit(XMPPEvents.USER_ID_CHANGED, from, id);
            }
        });
    };
    
    
},{"../../service/xmpp/XMPPEvents":188,"./moderator":65}],68:[function(require,module,exports){
    /* jshint -W117 */
    /* jshint -W101 */
    
    var JingleSession = require("./JingleSessionPC");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var RTCBrowserType = require("../RTC/RTCBrowserType");
    
    
    module.exports = function(XMPP, eventEmitter) {
        Strophe.addConnectionPlugin('jingle', {
            connection: null,
            sessions: {},
            jid2session: {},
            ice_config: {iceServers: []},
            pc_constraints: {},
            activecall: null,
            media_constraints: {
                mandatory: {
                    'OfferToReceiveAudio': true,
                    'OfferToReceiveVideo': true
                }
                // MozDontOfferDataChannel: true when this is firefox
            },
            init: function (conn) {
                this.connection = conn;
                if (this.connection.disco) {
                    // http://xmpp.org/extensions/xep-0167.html#support
                    // http://xmpp.org/extensions/xep-0176.html#support
                    this.connection.disco.addFeature('urn:xmpp:jingle:1');
                    this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:1');
                    this.connection.disco.addFeature('urn:xmpp:jingle:transports:ice-udp:1');
                    this.connection.disco.addFeature('urn:xmpp:jingle:apps:dtls:0');
                    this.connection.disco.addFeature('urn:xmpp:jingle:transports:dtls-sctp:1');
                    this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:audio');
                    this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:video');
                    
                    if (RTCBrowserType.isChrome() || RTCBrowserType.isOpera() ||
                        RTCBrowserType.isTemasysPluginUsed()) {
                        this.connection.disco.addFeature('urn:ietf:rfc:4588');
                    }
                    
                    // this is dealt with by SDP O/A so we don't need to announce this
                    //this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:rtcp-fb:0'); // XEP-0293
                    //this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:rtp-hdrext:0'); // XEP-0294
                    
                    this.connection.disco.addFeature('urn:ietf:rfc:5761'); // rtcp-mux
                    this.connection.disco.addFeature('urn:ietf:rfc:5888'); // a=group, e.g. bundle
                    
                    //this.connection.disco.addFeature('urn:ietf:rfc:5576'); // a=ssrc
                }
                this.connection.addHandler(this.onJingle.bind(this), 'urn:xmpp:jingle:1', 'iq', 'set', null, null);
            },
            onJingle: function (iq) {
                var sid = $(iq).find('jingle').attr('sid');
                var action = $(iq).find('jingle').attr('action');
                var fromJid = iq.getAttribute('from');
                // send ack first
                var ack = $iq({type: 'result',
                    to: fromJid,
                    id: iq.getAttribute('id')
                });
                console.log('on jingle ' + action + ' from ' + fromJid, iq);
                var sess = this.sessions[sid];
                if ('session-initiate' != action) {
                    if (sess === null) {
                        ack.type = 'error';
                        ack.c('error', {type: 'cancel'})
                            .c('item-not-found', {xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'}).up()
                            .c('unknown-session', {xmlns: 'urn:xmpp:jingle:errors:1'});
                        this.connection.send(ack);
                        return true;
                    }
                    // local jid is not checked
                    if (fromJid != sess.peerjid) {
                        console.warn('jid mismatch for session id', sid, fromJid, sess.peerjid);
                        ack.type = 'error';
                        ack.c('error', {type: 'cancel'})
                            .c('item-not-found', {xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'}).up()
                            .c('unknown-session', {xmlns: 'urn:xmpp:jingle:errors:1'});
                        this.connection.send(ack);
                        return true;
                    }
                } else if (sess !== undefined) {
                    // existing session with same session id
                    // this might be out-of-order if the sess.peerjid is the same as from
                    ack.type = 'error';
                    ack.c('error', {type: 'cancel'})
                        .c('service-unavailable', {xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'}).up();
                    console.warn('duplicate session id', sid);
                    this.connection.send(ack);
                    return true;
                }
                // FIXME: check for a defined action
                this.connection.send(ack);
                // see http://xmpp.org/extensions/xep-0166.html#concepts-session
                switch (action) {
                    case 'session-initiate':
                        console.log("(TIME) received session-initiate:\t",
                            window.performance.now());
                        var startMuted = $(iq).find('jingle>startmuted');
                        if (startMuted && startMuted.length > 0) {
                            var audioMuted = startMuted.attr("audio");
                            var videoMuted = startMuted.attr("video");
                            eventEmitter.emit(XMPPEvents.START_MUTED_FROM_FOCUS,
                                audioMuted === "true", videoMuted === "true");
                        }
                        sess = new JingleSession(
                            $(iq).attr('to'), $(iq).find('jingle').attr('sid'),
                            this.connection, XMPP, eventEmitter);
                        // configure session
                        
                        sess.media_constraints = this.media_constraints;
                        sess.pc_constraints = this.pc_constraints;
                        sess.ice_config = this.ice_config;
                        
                        sess.initialize(fromJid, false);
                        // FIXME: setRemoteDescription should only be done when this call is to be accepted
                        sess.setOffer($(iq).find('>jingle'));
                        
                        this.sessions[sess.sid] = sess;
                        this.jid2session[sess.peerjid] = sess;
                        
                        // the callback should either
                        // .sendAnswer and .accept
                        // or .sendTerminate -- not necessarily synchronous
                        
                        // TODO: do we check activecall == null?
                        this.connection.jingle.activecall = sess;
                        
                        eventEmitter.emit(XMPPEvents.CALL_INCOMING, sess);
                        
                        // TODO: check affiliation and/or role
                        console.log('emuc data for', sess.peerjid,
                            this.connection.emuc.members[sess.peerjid]);
                        sess.sendAnswer();
                        sess.accept();
                        break;
                    case 'session-accept':
                        sess.setAnswer($(iq).find('>jingle'));
                        sess.accept();
                        $(document).trigger('callaccepted.jingle', [sess.sid]);
                        break;
                    case 'session-terminate':
                        if (!sess) {
                            break;
                        }
                        console.log('terminating...', sess.sid);
                        sess.terminate();
                        this.terminate(sess.sid);
                        if ($(iq).find('>jingle>reason').length) {
                            $(document).trigger('callterminated.jingle', [
                                sess.sid,
                                sess.peerjid,
                                $(iq).find('>jingle>reason>:first')[0].tagName,
                                $(iq).find('>jingle>reason>text').text()
                            ]);
                        } else {
                            $(document).trigger('callterminated.jingle',
                                [sess.sid, sess.peerjid]);
                        }
                        break;
                    case 'transport-info':
                        sess.addIceCandidate($(iq).find('>jingle>content'));
                        break;
                    case 'session-info':
                        var affected;
                        if ($(iq).find('>jingle>ringing[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').length) {
                            $(document).trigger('ringing.jingle', [sess.sid]);
                        } else if ($(iq).find('>jingle>mute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').length) {
                            affected = $(iq).find('>jingle>mute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').attr('name');
                            $(document).trigger('mute.jingle', [sess.sid, affected]);
                        } else if ($(iq).find('>jingle>unmute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').length) {
                            affected = $(iq).find('>jingle>unmute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').attr('name');
                            $(document).trigger('unmute.jingle', [sess.sid, affected]);
                        }
                        break;
                    case 'addsource': // FIXME: proprietary, un-jingleish
                    case 'source-add': // FIXME: proprietary
                        sess.addSource($(iq).find('>jingle>content'));
                        break;
                    case 'removesource': // FIXME: proprietary, un-jingleish
                    case 'source-remove': // FIXME: proprietary
                        sess.removeSource($(iq).find('>jingle>content'));
                        break;
                    default:
                        console.warn('jingle action not implemented', action);
                        break;
                }
                return true;
            },
            initiate: function (peerjid, myjid) { // initiate a new jinglesession to peerjid
                var sess = new JingleSession(myjid || this.connection.jid,
                    Math.random().toString(36).substr(2, 12), // random string
                    this.connection, XMPP, eventEmitter);
                // configure session
                
                sess.media_constraints = this.media_constraints;
                sess.pc_constraints = this.pc_constraints;
                sess.ice_config = this.ice_config;
                
                sess.initialize(peerjid, true);
                this.sessions[sess.sid] = sess;
                this.jid2session[sess.peerjid] = sess;
                sess.sendOffer();
                return sess;
            },
            terminate: function (sid, reason, text) { // terminate by sessionid (or all sessions)
                if (sid === null || sid === undefined) {
                    for (sid in this.sessions) {
                        if (this.sessions[sid].state != 'ended') {
                            this.sessions[sid].sendTerminate(reason || (!this.sessions[sid].active()) ? 'cancel' : null, text);
                            this.sessions[sid].terminate();
                        }
                        delete this.jid2session[this.sessions[sid].peerjid];
                        delete this.sessions[sid];
                    }
                } else if (this.sessions.hasOwnProperty(sid)) {
                    if (this.sessions[sid].state != 'ended') {
                        this.sessions[sid].sendTerminate(reason || (!this.sessions[sid].active()) ? 'cancel' : null, text);
                        this.sessions[sid].terminate();
                    }
                    delete this.jid2session[this.sessions[sid].peerjid];
                    delete this.sessions[sid];
                }
            },
            // Used to terminate a session when an unavailable presence is received.
            terminateByJid: function (jid) {
                if (this.jid2session.hasOwnProperty(jid)) {
                    var sess = this.jid2session[jid];
                    if (sess) {
                        sess.terminate();
                        console.log('peer went away silently', jid);
                        delete this.sessions[sess.sid];
                        delete this.jid2session[jid];
                        $(document).trigger('callterminated.jingle',
                            [sess.sid, jid], 'gone');
                    }
                }
            },
            terminateRemoteByJid: function (jid, reason) {
                if (this.jid2session.hasOwnProperty(jid)) {
                    var sess = this.jid2session[jid];
                    if (sess) {
                        sess.sendTerminate(reason || (!sess.active()) ? 'kick' : null);
                        sess.terminate();
                        console.log('terminate peer with jid', sess.sid, jid);
                        delete this.sessions[sess.sid];
                        delete this.jid2session[jid];
                        $(document).trigger('callterminated.jingle',
                            [sess.sid, jid, 'kicked']);
                    }
                }
            },
            getStunAndTurnCredentials: function () {
                // get stun and turn configuration from server via xep-0215
                // uses time-limited credentials as described in
                // http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00
                //
                // see https://code.google.com/p/prosody-modules/source/browse/mod_turncredentials/mod_turncredentials.lua
                // for a prosody module which implements this
                //
                // currently, this doesn't work with updateIce and therefore credentials with a long
                // validity have to be fetched before creating the peerconnection
                // TODO: implement refresh via updateIce as described in
                //      https://code.google.com/p/webrtc/issues/detail?id=1650
                var self = this;
                this.connection.sendIQ(
                    $iq({type: 'get', to: this.connection.domain})
                        .c('services', {xmlns: 'urn:xmpp:extdisco:1'}).c('service', {host: 'turn.' + this.connection.domain}),
                    function (res) {
                        var iceservers = [];
                        $(res).find('>services>service').each(function (idx, el) {
                            el = $(el);
                            var dict = {};
                            var type = el.attr('type');
                            switch (type) {
                                case 'stun':
                                    dict.url = 'stun:' + el.attr('host');
                                    if (el.attr('port')) {
                                        dict.url += ':' + el.attr('port');
                                    }
                                    iceservers.push(dict);
                                    break;
                                case 'turn':
                                case 'turns':
                                    dict.url = type + ':';
                                    if (el.attr('username')) { // https://code.google.com/p/webrtc/issues/detail?id=1508
                                        if (navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10) < 28) {
                                            dict.url += el.attr('username') + '@';
                                        } else {
                                            dict.username = el.attr('username'); // only works in M28
                                        }
                                    }
                                    dict.url += el.attr('host');
                                    if (el.attr('port') && el.attr('port') != '3478') {
                                        dict.url += ':' + el.attr('port');
                                    }
                                    if (el.attr('transport') && el.attr('transport') != 'udp') {
                                        dict.url += '?transport=' + el.attr('transport');
                                    }
                                    if (el.attr('password')) {
                                        dict.credential = el.attr('password');
                                    }
                                    iceservers.push(dict);
                                    break;
                            }
                        });
                        self.ice_config.iceServers = iceservers;
                    },
                    function (err) {
                        console.warn('getting turn credentials failed', err);
                        console.warn('is mod_turncredentials or similar installed?');
                    }
                );
                // implement push?
            },
            
            /**
             * Returns the data saved in 'updateLog' in a format to be logged.
             */
            getLog: function () {
                var data = {};
                var self = this;
                Object.keys(this.sessions).forEach(function (sid) {
                    var session = self.sessions[sid];
                    if (session.peerconnection && session.peerconnection.updateLog) {
                        // FIXME: should probably be a .dump call
                        data["jingle_" + session.sid] = {
                            updateLog: session.peerconnection.updateLog,
                            stats: session.peerconnection.stats,
                            url: window.location.href
                        };
                    }
                });
                return data;
            }
        });
    };
    
    
},{"../../service/xmpp/XMPPEvents":188,"../RTC/RTCBrowserType":7,"./JingleSessionPC":59}],69:[function(require,module,exports){
    /* global Strophe */
    module.exports = function () {
        
        Strophe.addConnectionPlugin('logger', {
            // logs raw stanzas and makes them available for download as JSON
            connection: null,
            log: [],
            init: function (conn) {
                this.connection = conn;
                this.connection.rawInput = this.log_incoming.bind(this);
                this.connection.rawOutput = this.log_outgoing.bind(this);
            },
            log_incoming: function (stanza) {
                this.log.push([new Date().getTime(), 'incoming', stanza]);
            },
            log_outgoing: function (stanza) {
                this.log.push([new Date().getTime(), 'outgoing', stanza]);
            }
        });
    };
},{}],70:[function(require,module,exports){
    /* global $, $iq, config, connection, focusMucJid, forceMuted,
     setAudioMuted, Strophe */
    /**
     * Moderate connection plugin.
     */
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    
    module.exports = function (XMPP, eventEmitter) {
        Strophe.addConnectionPlugin('moderate', {
            connection: null,
            init: function (conn) {
                this.connection = conn;
                
                this.connection.addHandler(this.onMute.bind(this),
                    'http://jitsi.org/jitmeet/audio',
                    'iq',
                    'set',
                    null,
                    null);
            },
            setMute: function (jid, mute) {
                console.info("set mute", mute);
                var iqToFocus =
                    $iq({to: this.connection.emuc.focusMucJid, type: 'set'})
                        .c('mute', {
                            xmlns: 'http://jitsi.org/jitmeet/audio',
                            jid: jid
                        })
                        .t(mute.toString())
                        .up();
                
                this.connection.sendIQ(
                    iqToFocus,
                    function (result) {
                        console.log('set mute', result);
                    },
                    function (error) {
                        console.log('set mute error', error);
                    });
            },
            onMute: function (iq) {
                var from = iq.getAttribute('from');
                if (from !== this.connection.emuc.focusMucJid) {
                    console.warn("Ignored mute from non focus peer");
                    return false;
                }
                var mute = $(iq).find('mute');
                if (mute.length) {
                    var doMuteAudio = mute.text() === "true";
                    eventEmitter.emit(XMPPEvents.AUDIO_MUTED_BY_FOCUS, doMuteAudio);
                    XMPP.forceMuted = doMuteAudio;
                }
                return true;
            },
            eject: function (jid) {
                // We're not the focus, so can't terminate
                //connection.jingle.terminateRemoteByJid(jid, 'kick');
                this.connection.emuc.kick(jid);
            }
        });
    };
},{"../../service/xmpp/XMPPEvents":188}],71:[function(require,module,exports){
    /* global $, $iq, Strophe */
    
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    
    /**
     * Ping every 20 sec
     */
    var PING_INTERVAL = 20000;
    
    /**
     * Ping timeout error after 15 sec of waiting.
     */
    var PING_TIMEOUT = 15000;
    
    /**
     * Will close the connection after 3 consecutive ping errors.
     */
    var PING_THRESHOLD = 3;
    
    /**
     * XEP-0199 ping plugin.
     *
     * Registers "urn:xmpp:ping" namespace under Strophe.NS.PING.
     */
    module.exports = function (XMPP, eventEmitter) {
        Strophe.addConnectionPlugin('ping', {
            
            connection: null,
            
            failedPings: 0,
            
            /**
             * Initializes the plugin. Method called by Strophe.
             * @param connection Strophe connection instance.
             */
            init: function (connection) {
                this.connection = connection;
                Strophe.addNamespace('PING', "urn:xmpp:ping");
            },
            
            /**
             * Sends "ping" to given <tt>jid</tt>
             * @param jid the JID to which ping request will be sent.
             * @param success callback called on success.
             * @param error callback called on error.
             * @param timeout ms how long are we going to wait for the response. On
             *        timeout <tt>error<//t> callback is called with undefined error
             *        argument.
             */
            ping: function (jid, success, error, timeout) {
                var iq = $iq({type: 'get', to: jid});
                iq.c('ping', {xmlns: Strophe.NS.PING});
                this.connection.sendIQ(iq, success, error, timeout);
            },
            
            /**
             * Checks if given <tt>jid</tt> has XEP-0199 ping support.
             * @param jid the JID to be checked for ping support.
             * @param callback function with boolean argument which will be
             * <tt>true</tt> if XEP-0199 ping is supported by given <tt>jid</tt>
             */
            hasPingSupport: function (jid, callback) {
                this.connection.disco.info(
                    jid, null,
                    function (result) {
                        var ping = $(result).find('>>feature[var="urn:xmpp:ping"]');
                        callback(ping.length > 0);
                    },
                    function (error) {
                        console.error("Ping feature discovery error", error);
                        callback(false);
                    }
                );
            },
            
            /**
             * Starts to send ping in given interval to specified remote JID.
             * This plugin supports only one such task and <tt>stopInterval</tt>
             * must be called before starting a new one.
             * @param remoteJid remote JID to which ping requests will be sent to.
             * @param interval task interval in ms.
             */
            startInterval: function (remoteJid, interval) {
                if (this.intervalId) {
                    console.error("Ping task scheduled already");
                    return;
                }
                if (!interval)
                    interval = PING_INTERVAL;
                var self = this;
                this.intervalId = window.setInterval(function () {
                    self.ping(remoteJid,
                        function (result) {
                            // Ping OK
                            self.failedPings = 0;
                        },
                        function (error) {
                            self.failedPings += 1;
                            console.error(
                                "Ping " + (error ? "error" : "timeout"), error);
                            if (self.failedPings >= PING_THRESHOLD) {
                                self.connection.disconnect();
                            }
                        }, PING_TIMEOUT);
                }, interval);
                console.info("XMPP pings will be sent every " + interval + " ms");
            },
            
            /**
             * Stops current "ping"  interval task.
             */
            stopInterval: function () {
                if (this.intervalId) {
                    window.clearInterval(this.intervalId);
                    this.intervalId = null;
                    this.failedPings = 0;
                    console.info("Ping interval cleared");
                }
            }
        });
    };
    
},{"../../service/xmpp/XMPPEvents":188}],72:[function(require,module,exports){
    /* jshint -W117 */
    module.exports = function() {
        Strophe.addConnectionPlugin('rayo',
            {
                RAYO_XMLNS: 'urn:xmpp:rayo:1',
                connection: null,
                init: function (conn) {
                    this.connection = conn;
                    if (this.connection.disco) {
                        this.connection.disco.addFeature('urn:xmpp:rayo:client:1');
                    }
                    
                    this.connection.addHandler(
                        this.onRayo.bind(this), this.RAYO_XMLNS, 'iq', 'set',
                        null, null);
                },
                onRayo: function (iq) {
                    console.info("Rayo IQ", iq);
                },
                dial: function (to, from, roomName, roomPass) {
                    var self = this;
                    var req = $iq(
                        {
                            type: 'set',
                            to: this.connection.emuc.focusMucJid
                        }
                    );
                    req.c('dial',
                        {
                            xmlns: this.RAYO_XMLNS,
                            to: to,
                            from: from
                        });
                    req.c('header',
                        {
                            name: 'JvbRoomName',
                            value: roomName
                        }).up();
                    
                    if (roomPass !== null && roomPass.length) {
                        
                        req.c('header',
                            {
                                name: 'JvbRoomPassword',
                                value: roomPass
                            }).up();
                    }
                    
                    this.connection.sendIQ(
                        req,
                        function (result) {
                            console.info('Dial result ', result);
                            
                            var resource = $(result).find('ref').attr('uri');
                            self.call_resource = resource.substr('xmpp:'.length);
                            console.info(
                                "Received call resource: " + self.call_resource);
                        },
                        function (error) {
                            console.info('Dial error ', error);
                        }
                    );
                },
                hang_up: function () {
                    if (!this.call_resource) {
                        console.warn("No call in progress");
                        return;
                    }
                    
                    var self = this;
                    var req = $iq(
                        {
                            type: 'set',
                            to: this.call_resource
                        }
                    );
                    req.c('hangup',
                        {
                            xmlns: this.RAYO_XMLNS
                        });
                    
                    this.connection.sendIQ(
                        req,
                        function (result) {
                            console.info('Hangup result ', result);
                            self.call_resource = null;
                        },
                        function (error) {
                            console.info('Hangup error ', error);
                            self.call_resource = null;
                        }
                    );
                }
            }
        );
    };
    
},{}],73:[function(require,module,exports){
    /* global Strophe */
    /**
     * Strophe logger implementation. Logs from level WARN and above.
     */
    module.exports = function () {
        
        Strophe.log = function (level, msg) {
            switch (level) {
                case Strophe.LogLevel.WARN:
                    console.warn("Strophe: " + msg);
                    break;
                case Strophe.LogLevel.ERROR:
                case Strophe.LogLevel.FATAL:
                    console.error("Strophe: " + msg);
                    break;
            }
        };
        
        Strophe.getStatusString = function (status) {
            switch (status) {
                case Strophe.Status.ERROR:
                    return "ERROR";
                case Strophe.Status.CONNECTING:
                    return "CONNECTING";
                case Strophe.Status.CONNFAIL:
                    return "CONNFAIL";
                case Strophe.Status.AUTHENTICATING:
                    return "AUTHENTICATING";
                case Strophe.Status.AUTHFAIL:
                    return "AUTHFAIL";
                case Strophe.Status.CONNECTED:
                    return "CONNECTED";
                case Strophe.Status.DISCONNECTED:
                    return "DISCONNECTED";
                case Strophe.Status.DISCONNECTING:
                    return "DISCONNECTING";
                case Strophe.Status.ATTACHED:
                    return "ATTACHED";
                default:
                    return "unknown";
            }
        };
    };
    
},{}],74:[function(require,module,exports){
    /* global $, APP, config, Strophe, Base64, $msg */
    /* jshint -W101 */
    var Moderator = require("./moderator");
    var EventEmitter = require("events");
    var Recording = require("./recording");
    var SDP = require("./SDP");
    var SDPUtil = require("./SDPUtil");
    var Settings = require("../settings/Settings");
    var Pako = require("pako");
    var StreamEventTypes = require("../../service/RTC/StreamEventTypes");
    var RTCEvents = require("../../service/RTC/RTCEvents");
    var XMPPEvents = require("../../service/xmpp/XMPPEvents");
    var retry = require('retry');
    var RandomUtil = require("../util/RandomUtil");
    
    var eventEmitter = new EventEmitter();
    var connection = null;
    var authenticatedUser = false;
    
    /**
     * Utility method that generates user name based on random hex values.
     * Eg. 12345678-1234-1234-12345678
     * @returns {string}
     */
    function generateUserName() {
        return RandomUtil.random8digitsHex() + "-" + RandomUtil.random4digitsHex() + "-" +
            RandomUtil.random4digitsHex() + "-" + RandomUtil.random8digitsHex();
    }
    
    function connect(jid, password) {
        
        var faultTolerantConnect = retry.operation({
            retries: 3
        });
        
        // fault tolerant connect
        faultTolerantConnect.attempt(function () {
            
            connection = XMPP.createConnection();
            Moderator.setConnection(connection);
            
            connection.jingle.pc_constraints = APP.RTC.getPCConstraints();
            if (config.useIPv6) {
                // https://code.google.com/p/webrtc/issues/detail?id=2828
                if (!connection.jingle.pc_constraints.optional)
                    connection.jingle.pc_constraints.optional = [];
                connection.jingle.pc_constraints.optional.push({googIPv6: true});
            }
            
            // Include user info in MUC presence
            var settings = Settings.getSettings();
            if (settings.email) {
                connection.emuc.addEmailToPresence(settings.email);
            }
            if (settings.uid) {
                connection.emuc.addUserIdToPresence(settings.uid);
            }
            if (settings.displayName) {
                connection.emuc.addDisplayNameToPresence(settings.displayName);
            }
            
            
            // connection.connect() starts the connection process.
            //
            // As the connection process proceeds, the user supplied callback will
            // be triggered multiple times with status updates. The callback should
            // take two arguments - the status code and the error condition.
            //
            // The status code will be one of the values in the Strophe.Status
            // constants. The error condition will be one of the conditions defined
            // in RFC 3920 or the condition ‘strophe-parsererror’.
            //
            // The Parameters wait, hold and route are optional and only relevant
            // for BOSH connections. Please see XEP 124 for a more detailed
            // explanation of the optional parameters.
            //
            // Connection status constants for use by the connection handler
            // callback.
            //
            //  Status.ERROR - An error has occurred (websockets specific)
            //  Status.CONNECTING - The connection is currently being made
            //  Status.CONNFAIL - The connection attempt failed
            //  Status.AUTHENTICATING - The connection is authenticating
            //  Status.AUTHFAIL - The authentication attempt failed
            //  Status.CONNECTED - The connection has succeeded
            //  Status.DISCONNECTED - The connection has been terminated
            //  Status.DISCONNECTING - The connection is currently being terminated
            //  Status.ATTACHED - The connection has been attached
            
            var anonymousConnectionFailed = false;
            var connectionFailed = false;
            var lastErrorMsg;
            connection.connect(jid, password, function (status, msg) {
                console.log("(TIME) Strophe " + Strophe.getStatusString(status) +
                    (msg ? "[" + msg + "]" : "") +
                    "\t:" + window.performance.now());
                if (status === Strophe.Status.CONNECTED) {
                    if (config.useStunTurn) {
                        connection.jingle.getStunAndTurnCredentials();
                    }
                    
                    console.info("My Jabber ID: " + connection.jid);
                    
                    // Schedule ping ?
                    var pingJid = connection.domain;
                    connection.ping.hasPingSupport(
                        pingJid,
                        function (hasPing) {
                            if (hasPing)
                                connection.ping.startInterval(pingJid);
                            else
                                console.warn("Ping NOT supported by " + pingJid);
                        }
                    );
                    
                    if (password)
                        authenticatedUser = true;
                    maybeDoJoin();
                } else if (status === Strophe.Status.CONNFAIL) {
                    if (msg === 'x-strophe-bad-non-anon-jid') {
                        anonymousConnectionFailed = true;
                    } else {
                        connectionFailed = true;
                    }
                    lastErrorMsg = msg;
                } else if (status === Strophe.Status.DISCONNECTED) {
                    // Stop ping interval
                    connection.ping.stopInterval();
                    if (anonymousConnectionFailed) {
                        // prompt user for username and password
                        XMPP.promptLogin();
                    } else {
                        
                        // Strophe already has built-in HTTP/BOSH error handling and
                        // request retry logic. Requests are resent automatically
                        // until their error count reaches 5. Strophe.js disconnects
                        // if the error count is > 5. We are not replicating this
                        // here.
                        //
                        // The "problem" is that failed HTTP/BOSH requests don't
                        // trigger a callback with a status update, so when a
                        // callback with status Strophe.Status.DISCONNECTED arrives,
                        // we can't be sure if it's a graceful disconnect or if it's
                        // triggered by some HTTP/BOSH error.
                        //
                        // But that's a minor issue in Jitsi Meet as we never
                        // disconnect anyway, not even when the user closes the
                        // browser window (which is kind of wrong, but the point is
                        // that we should never ever get disconnected).
                        //
                        // On the other hand, failed connections due to XMPP layer
                        // errors, trigger a callback with status Strophe.Status.CONNFAIL.
                        //
                        // Here we implement retry logic for failed connections due
                        // to XMPP layer errors and we display an error to the user
                        // if we get disconnected from the XMPP server permanently.
                        
                        // If the connection failed, retry.
                        if (connectionFailed &&
                            faultTolerantConnect.retry("connection-failed")) {
                            return;
                        }
                        
                        // If we failed to connect to the XMPP server, fire an event
                        // to let all the interested module now about it.
                        eventEmitter.emit(XMPPEvents.CONNECTION_FAILED,
                            msg ? msg : lastErrorMsg);
                    }
                } else if (status === Strophe.Status.AUTHFAIL) {
                    // wrong password or username, prompt user
                    XMPP.promptLogin();
                    
                }
            });
        });
    }
    
    
    function maybeDoJoin() {
        if (connection && connection.connected &&
            Strophe.getResourceFromJid(connection.jid) &&
            (APP.RTC.localAudio || APP.RTC.localVideo)) {
            // .connected is true while connecting?
            doJoin();
        }
    }
    
    function doJoin() {
        eventEmitter.emit(XMPPEvents.READY_TO_JOIN);
    }
    
    function initStrophePlugins()
    {
        require("./strophe.emuc")(XMPP, eventEmitter);
        require("./strophe.jingle")(XMPP, eventEmitter);
        require("./strophe.moderate")(XMPP, eventEmitter);
        require("./strophe.util")();
        require("./strophe.ping")(XMPP, eventEmitter);
        require("./strophe.rayo")();
        require("./strophe.logger")();
    }
    
    /**
     * If given <tt>localStream</tt> is video one this method will advertise it's
     * video type in MUC presence.
     * @param localStream new or modified <tt>LocalStream</tt>.
     */
    function broadcastLocalVideoType(localStream) {
        if (localStream.videoType)
            XMPP.addToPresence('videoType', localStream.videoType);
    }
    
    function registerListeners() {
        APP.RTC.addStreamListener(
            function (localStream) {
                maybeDoJoin();
                broadcastLocalVideoType(localStream);
            },
            StreamEventTypes.EVENT_TYPE_LOCAL_CREATED
        );
        APP.RTC.addStreamListener(
            broadcastLocalVideoType,
            StreamEventTypes.EVENT_TYPE_LOCAL_CHANGED
        );
        APP.RTC.addListener(RTCEvents.AVAILABLE_DEVICES_CHANGED, function (devices) {
            XMPP.addToPresence("devices", devices);
        });
    }
    
    var unload = (function () {
        var unloaded = false;
        
        return function () {
            if (unloaded) { return; }
            unloaded = true;
            
            if (connection && connection.connected) {
                // ensure signout
                $.ajax({
                    type: 'POST',
                    url: config.bosh,
                    async: false,
                    cache: false,
                    contentType: 'application/xml',
                    data: "<body rid='" +
                    (connection.rid || connection._proto.rid) +
                    "' xmlns='http://jabber.org/protocol/httpbind' sid='" +
                    (connection.sid || connection._proto.sid)  +
                    "' type='terminate'>" +
                    "<presence xmlns='jabber:client' type='unavailable'/>" +
                    "</body>",
                    success: function (data) {
                        console.log('signed out');
                        console.log(data);
                    },
                    error: function (XMLHttpRequest, textStatus, errorThrown) {
                        console.log('signout error',
                            textStatus + ' (' + errorThrown + ')');
                    }
                });
            }
            XMPP.disposeConference(true);
        };
    })();
    
    function setupEvents() {
        // In recent versions of FF the 'beforeunload' event is not fired when the
        // window or the tab is closed. It is only fired when we leave the page
        // (change URL). If this participant doesn't unload properly, then it
        // becomes a ghost for the rest of the participants that stay in the
        // conference. Thankfully handling the 'unload' event in addition to the
        // 'beforeunload' event seems to guarantee the execution of the 'unload'
        // method at least once.
        //
        // The 'unload' method can safely be run multiple times, it will actually do
        // something only the first time that it's run, so we're don't have to worry
        // about browsers that fire both events.
        
        $(window).bind('beforeunload', unload);
        $(window).bind('unload', unload);
    }
    
    var XMPP = {
        getConnection: function(){ return connection; },
        sessionTerminated: false,
        
        /**
         * XMPP connection status
         */
        Status: Strophe.Status,
        
        /**
         * Remembers if we were muted by the focus.
         * @type {boolean}
         */
        forceMuted: false,
        start: function () {
            setupEvents();
            initStrophePlugins();
            registerListeners();
            Moderator.init(this, eventEmitter);
            Recording.init();
            var configDomain = config.hosts.anonymousdomain || config.hosts.domain;
            // Force authenticated domain if room is appended with '?login=true'
            if (config.hosts.anonymousdomain &&
                window.location.search.indexOf("login=true") !== -1) {
                configDomain = config.hosts.domain;
            }
            var jid = configDomain || window.location.hostname;
            var password = null;
            if (config.token) {
                password = config.token;
                if (config.id) {
                    jid = config.id + "@" + jid;
                } else {
                    jid = generateUserName() + "@" + jid;
                }
            }
            connect(jid, password);
        },
        createConnection: function () {
            var bosh = config.bosh || '/http-bind';
            // adds the room name used to the bosh connection
            return new Strophe.Connection(bosh + '?ROOM=' + APP.UI.getRoomNode());
        },
        getStatusString: function (status) {
            return Strophe.getStatusString(status);
        },
        promptLogin: function () {
            eventEmitter.emit(XMPPEvents.PROMPT_FOR_LOGIN, connect);
        },
        joinRoom: function(roomName, useNicks, nick) {
            var roomjid = roomName;
            
            if (useNicks) {
                if (nick) {
                    roomjid += '/' + nick;
                } else {
                    roomjid += '/' + Strophe.getNodeFromJid(connection.jid);
                }
            } else {
                var tmpJid = Strophe.getNodeFromJid(connection.jid);
                
                if(!authenticatedUser)
                    tmpJid = tmpJid.substr(0, 8);
                
                roomjid += '/' + tmpJid;
            }
            connection.emuc.doJoin(roomjid);
        },
        myJid: function () {
            if(!connection)
                return null;
            return connection.emuc.myroomjid;
        },
        myResource: function () {
            if(!connection || ! connection.emuc.myroomjid)
                return null;
            return Strophe.getResourceFromJid(connection.emuc.myroomjid);
        },
        getLastPresence: function (from) {
            if(!connection)
                return null;
            return connection.emuc.lastPresenceMap[from];
        },
        disposeConference: function (onUnload) {
            var handler = connection.jingle.activecall;
            if (handler && handler.peerconnection) {
                // FIXME: probably removing streams is not required and close() should
                // be enough
                if (APP.RTC.localAudio) {
                    handler.peerconnection.removeStream(
                        APP.RTC.localAudio.getOriginalStream(), onUnload);
                }
                if (APP.RTC.localVideo) {
                    handler.peerconnection.removeStream(
                        APP.RTC.localVideo.getOriginalStream(), onUnload);
                }
                handler.peerconnection.close();
            }
            eventEmitter.emit(XMPPEvents.DISPOSE_CONFERENCE, onUnload);
            connection.jingle.activecall = null;
            if (!onUnload) {
                this.sessionTerminated = true;
                connection.emuc.doLeave();
            }
        },
        addListener: function(type, listener) {
            eventEmitter.on(type, listener);
        },
        removeListener: function (type, listener) {
            eventEmitter.removeListener(type, listener);
        },
        allocateConferenceFocus: function(roomName, callback) {
            Moderator.allocateConferenceFocus(roomName, callback);
        },
        getLoginUrl: function (roomName, callback) {
            Moderator.getLoginUrl(roomName, callback);
        },
        getPopupLoginUrl: function (roomName, callback) {
            Moderator.getPopupLoginUrl(roomName, callback);
        },
        isModerator: function () {
            return Moderator.isModerator();
        },
        isSipGatewayEnabled: function () {
            return Moderator.isSipGatewayEnabled();
        },
        isExternalAuthEnabled: function () {
            return Moderator.isExternalAuthEnabled();
        },
        isConferenceInProgress: function () {
            return connection && connection.jingle.activecall &&
                connection.jingle.activecall.peerconnection;
        },
        switchStreams: function (stream, oldStream, callback, isAudio) {
            if (this.isConferenceInProgress()) {
                // FIXME: will block switchInProgress on true value in case of exception
                connection.jingle.activecall.switchStreams(stream, oldStream, callback, isAudio);
            } else {
                // We are done immediately
                console.warn("No conference handler or conference not started yet");
                callback();
            }
        },
        sendVideoInfoPresence: function (mute) {
            if(!connection)
                return;
            connection.emuc.addVideoInfoToPresence(mute);
            connection.emuc.sendPresence();
        },
        setVideoMute: function (mute, callback, options) {
            if(!connection)
                return;
            var self = this;
            var localCallback = function (mute) {
                self.sendVideoInfoPresence(mute);
                return callback(mute);
            };
            
            if(connection.jingle.activecall)
            {
                connection.jingle.activecall.setVideoMute(
                    mute, localCallback, options);
            }
            else {
                localCallback(mute);
            }
            
        },
        setAudioMute: function (mute, callback) {
            if (!(connection && APP.RTC.localAudio)) {
                return false;
            }
            
            if (this.forceMuted && !mute) {
                console.info("Asking focus for unmute");
                connection.moderate.setMute(connection.emuc.myroomjid, mute);
                // FIXME: wait for result before resetting muted status
                this.forceMuted = false;
            }
            
            if (mute == APP.RTC.localAudio.isMuted()) {
                // Nothing to do
                return true;
            }
            
            APP.RTC.localAudio.setMute(mute);
            this.sendAudioInfoPresence(mute, callback);
            return true;
        },
        sendAudioInfoPresence: function(mute, callback) {
            if(connection) {
                connection.emuc.addAudioInfoToPresence(mute);
                connection.emuc.sendPresence();
            }
            callback();
            return true;
        },
        toggleRecording: function (tokenEmptyCallback,
                                   recordingStateChangeCallback) {
            Recording.toggleRecording(tokenEmptyCallback,
                recordingStateChangeCallback, connection);
        },
        addToPresence: function (name, value, dontSend) {
            switch (name) {
                case "displayName":
                    connection.emuc.addDisplayNameToPresence(value);
                    break;
                case "prezi":
                    connection.emuc.addPreziToPresence(value, 0);
                    break;
                case "preziSlide":
                    connection.emuc.addCurrentSlideToPresence(value);
                    break;
                case "connectionQuality":
                    connection.emuc.addConnectionInfoToPresence(value);
                    break;
                case "email":
                    connection.emuc.addEmailToPresence(value);
                    break;
                case "devices":
                    connection.emuc.addDevicesToPresence(value);
                    break;
                case "videoType":
                    connection.emuc.addVideoTypeToPresence(value);
                    break;
                case "startMuted":
                    if(!Moderator.isModerator())
                        return;
                    connection.emuc.addStartMutedToPresence(value[0],
                        value[1]);
                    break;
                default :
                    console.log("Unknown tag for presence: " + name);
                    return;
            }
            if (!dontSend)
                connection.emuc.sendPresence();
        },
        /**
         * Sends 'data' as a log message to the focus. Returns true iff a message
         * was sent.
         * @param data
         * @returns {boolean} true iff a message was sent.
         */
        sendLogs: function (data) {
            if(!connection.emuc.focusMucJid)
                return false;
            
            var deflate = true;
            
            var content = JSON.stringify(data);
            if (deflate) {
                content = String.fromCharCode.apply(null, Pako.deflateRaw(content));
            }
            content = Base64.encode(content);
            // XEP-0337-ish
            var message = $msg({to: connection.emuc.focusMucJid, type: 'normal'});
            message.c('log', { xmlns: 'urn:xmpp:eventlog',
                id: 'PeerConnectionStats'});
            message.c('message').t(content).up();
            if (deflate) {
                message.c('tag', {name: "deflated", value: "true"}).up();
            }
            message.up();
            
            connection.send(message);
            return true;
        },
        // Gets the logs from strophe.jingle.
        getJingleLog: function () {
            return connection.jingle ? connection.jingle.getLog() : {};
        },
        // Gets the logs from strophe.
        getXmppLog: function () {
            return connection.logger ? connection.logger.log : null;
        },
        getPrezi: function () {
            return connection.emuc.getPrezi(this.myJid());
        },
        removePreziFromPresence: function () {
            connection.emuc.removePreziFromPresence();
            connection.emuc.sendPresence();
        },
        sendChatMessage: function (message, nickname) {
            connection.emuc.sendMessage(message, nickname);
        },
        setSubject: function (topic) {
            connection.emuc.setSubject(topic);
        },
        lockRoom: function (key, onSuccess, onError, onNotSupported) {
            connection.emuc.lockRoom(key, onSuccess, onError, onNotSupported);
        },
        dial: function (to, from, roomName,roomPass) {
            connection.rayo.dial(to, from, roomName,roomPass);
        },
        setMute: function (jid, mute) {
            connection.moderate.setMute(jid, mute);
        },
        eject: function (jid) {
            connection.moderate.eject(jid);
        },
        logout: function (callback) {
            Moderator.logout(callback);
        },
        findJidFromResource: function (resource) {
            return connection.emuc.findJidFromResource(resource);
        },
        getMembers: function () {
            return connection.emuc.members;
        },
        getJidFromSSRC: function (ssrc) {
            if (!this.isConferenceInProgress())
                return null;
            return connection.jingle.activecall.getSsrcOwner(ssrc);
        },
        // Returns true iff we have joined the MUC.
        isMUCJoined: function () {
            return connection === null ? false : connection.emuc.joined;
        },
        getSessions: function () {
            return connection.jingle.sessions;
        },
        removeStream: function (stream) {
            if (!this.isConferenceInProgress())
                return;
            connection.jingle.activecall.peerconnection.removeStream(stream);
        },
        filter_special_chars: function (text) {
            return SDPUtil.filter_special_chars(text);
        }
    };
    
    module.exports = XMPP;
    
},{"../../service/RTC/RTCEvents":178,"../../service/RTC/StreamEventTypes":180,"../../service/xmpp/XMPPEvents":188,"../settings/Settings":50,"../util/RandomUtil":57,"./SDP":61,"./SDPUtil":63,"./moderator":65,"./recording":66,"./strophe.emuc":67,"./strophe.jingle":68,"./strophe.logger":69,"./strophe.moderate":70,"./strophe.ping":71,"./strophe.rayo":72,"./strophe.util":73,"events":79,"pako":86,"retry":102}],75:[function(require,module,exports){
    (function (process){
        /*!
         * async
         * https://github.com/caolan/async
         *
         * Copyright 2010-2014 Caolan McMahon
         * Released under the MIT license
         */
        /*jshint onevar: false, indent:4 */
        /*global setImmediate: false, setTimeout: false, console: false */
        (function () {
            
            var async = {};
            
            // global on the server, window in the browser
            var root, previous_async;
            
            root = this;
            if (root != null) {
                previous_async = root.async;
            }
            
            async.noConflict = function () {
                root.async = previous_async;
                return async;
            };
            
            function only_once(fn) {
                var called = false;
                return function() {
                    if (called) throw new Error("Callback was already called.");
                    called = true;
                    fn.apply(root, arguments);
                }
            }
            
            //// cross-browser compatiblity functions ////
            
            var _toString = Object.prototype.toString;
            
            var _isArray = Array.isArray || function (obj) {
                    return _toString.call(obj) === '[object Array]';
                };
            
            var _each = function (arr, iterator) {
                if (arr.forEach) {
                    return arr.forEach(iterator);
                }
                for (var i = 0; i < arr.length; i += 1) {
                    iterator(arr[i], i, arr);
                }
            };
            
            var _map = function (arr, iterator) {
                if (arr.map) {
                    return arr.map(iterator);
                }
                var results = [];
                _each(arr, function (x, i, a) {
                    results.push(iterator(x, i, a));
                });
                return results;
            };
            
            var _reduce = function (arr, iterator, memo) {
                if (arr.reduce) {
                    return arr.reduce(iterator, memo);
                }
                _each(arr, function (x, i, a) {
                    memo = iterator(memo, x, i, a);
                });
                return memo;
            };
            
            var _keys = function (obj) {
                if (Object.keys) {
                    return Object.keys(obj);
                }
                var keys = [];
                for (var k in obj) {
                    if (obj.hasOwnProperty(k)) {
                        keys.push(k);
                    }
                }
                return keys;
            };
            
            //// exported async module functions ////
            
            //// nextTick implementation with browser-compatible fallback ////
            if (typeof process === 'undefined' || !(process.nextTick)) {
                if (typeof setImmediate === 'function') {
                    async.nextTick = function (fn) {
                        // not a direct alias for IE10 compatibility
                        setImmediate(fn);
                    };
                    async.setImmediate = async.nextTick;
                }
                else {
                    async.nextTick = function (fn) {
                        setTimeout(fn, 0);
                    };
                    async.setImmediate = async.nextTick;
                }
            }
            else {
                async.nextTick = process.nextTick;
                if (typeof setImmediate !== 'undefined') {
                    async.setImmediate = function (fn) {
                        // not a direct alias for IE10 compatibility
                        setImmediate(fn);
                    };
                }
                else {
                    async.setImmediate = async.nextTick;
                }
            }
            
            async.each = function (arr, iterator, callback) {
                callback = callback || function () {};
                if (!arr.length) {
                    return callback();
                }
                var completed = 0;
                _each(arr, function (x) {
                    iterator(x, only_once(done) );
                });
                function done(err) {
                    if (err) {
                        callback(err);
                        callback = function () {};
                    }
                    else {
                        completed += 1;
                        if (completed >= arr.length) {
                            callback();
                        }
                    }
                }
            };
            async.forEach = async.each;
            
            async.eachSeries = function (arr, iterator, callback) {
                callback = callback || function () {};
                if (!arr.length) {
                    return callback();
                }
                var completed = 0;
                var iterate = function () {
                    iterator(arr[completed], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                iterate();
                            }
                        }
                    });
                };
                iterate();
            };
            async.forEachSeries = async.eachSeries;
            
            async.eachLimit = function (arr, limit, iterator, callback) {
                var fn = _eachLimit(limit);
                fn.apply(null, [arr, iterator, callback]);
            };
            async.forEachLimit = async.eachLimit;
            
            var _eachLimit = function (limit) {
                
                return function (arr, iterator, callback) {
                    callback = callback || function () {};
                    if (!arr.length || limit <= 0) {
                        return callback();
                    }
                    var completed = 0;
                    var started = 0;
                    var running = 0;
                    
                    (function replenish () {
                        if (completed >= arr.length) {
                            return callback();
                        }
                        
                        while (running < limit && started < arr.length) {
                            started += 1;
                            running += 1;
                            iterator(arr[started - 1], function (err) {
                                if (err) {
                                    callback(err);
                                    callback = function () {};
                                }
                                else {
                                    completed += 1;
                                    running -= 1;
                                    if (completed >= arr.length) {
                                        callback();
                                    }
                                    else {
                                        replenish();
                                    }
                                }
                            });
                        }
                    })();
                };
            };
            
            
            var doParallel = function (fn) {
                return function () {
                    var args = Array.prototype.slice.call(arguments);
                    return fn.apply(null, [async.each].concat(args));
                };
            };
            var doParallelLimit = function(limit, fn) {
                return function () {
                    var args = Array.prototype.slice.call(arguments);
                    return fn.apply(null, [_eachLimit(limit)].concat(args));
                };
            };
            var doSeries = function (fn) {
                return function () {
                    var args = Array.prototype.slice.call(arguments);
                    return fn.apply(null, [async.eachSeries].concat(args));
                };
            };
            
            
            var _asyncMap = function (eachfn, arr, iterator, callback) {
                arr = _map(arr, function (x, i) {
                    return {index: i, value: x};
                });
                if (!callback) {
                    eachfn(arr, function (x, callback) {
                        iterator(x.value, function (err) {
                            callback(err);
                        });
                    });
                } else {
                    var results = [];
                    eachfn(arr, function (x, callback) {
                        iterator(x.value, function (err, v) {
                            results[x.index] = v;
                            callback(err);
                        });
                    }, function (err) {
                        callback(err, results);
                    });
                }
            };
            async.map = doParallel(_asyncMap);
            async.mapSeries = doSeries(_asyncMap);
            async.mapLimit = function (arr, limit, iterator, callback) {
                return _mapLimit(limit)(arr, iterator, callback);
            };
            
            var _mapLimit = function(limit) {
                return doParallelLimit(limit, _asyncMap);
            };
            
            // reduce only has a series version, as doing reduce in parallel won't
            // work in many situations.
            async.reduce = function (arr, memo, iterator, callback) {
                async.eachSeries(arr, function (x, callback) {
                    iterator(memo, x, function (err, v) {
                        memo = v;
                        callback(err);
                    });
                }, function (err) {
                    callback(err, memo);
                });
            };
            // inject alias
            async.inject = async.reduce;
            // foldl alias
            async.foldl = async.reduce;
            
            async.reduceRight = function (arr, memo, iterator, callback) {
                var reversed = _map(arr, function (x) {
                    return x;
                }).reverse();
                async.reduce(reversed, memo, iterator, callback);
            };
            // foldr alias
            async.foldr = async.reduceRight;
            
            var _filter = function (eachfn, arr, iterator, callback) {
                var results = [];
                arr = _map(arr, function (x, i) {
                    return {index: i, value: x};
                });
                eachfn(arr, function (x, callback) {
                    iterator(x.value, function (v) {
                        if (v) {
                            results.push(x);
                        }
                        callback();
                    });
                }, function (err) {
                    callback(_map(results.sort(function (a, b) {
                        return a.index - b.index;
                    }), function (x) {
                        return x.value;
                    }));
                });
            };
            async.filter = doParallel(_filter);
            async.filterSeries = doSeries(_filter);
            // select alias
            async.select = async.filter;
            async.selectSeries = async.filterSeries;
            
            var _reject = function (eachfn, arr, iterator, callback) {
                var results = [];
                arr = _map(arr, function (x, i) {
                    return {index: i, value: x};
                });
                eachfn(arr, function (x, callback) {
                    iterator(x.value, function (v) {
                        if (!v) {
                            results.push(x);
                        }
                        callback();
                    });
                }, function (err) {
                    callback(_map(results.sort(function (a, b) {
                        return a.index - b.index;
                    }), function (x) {
                        return x.value;
                    }));
                });
            };
            async.reject = doParallel(_reject);
            async.rejectSeries = doSeries(_reject);
            
            var _detect = function (eachfn, arr, iterator, main_callback) {
                eachfn(arr, function (x, callback) {
                    iterator(x, function (result) {
                        if (result) {
                            main_callback(x);
                            main_callback = function () {};
                        }
                        else {
                            callback();
                        }
                    });
                }, function (err) {
                    main_callback();
                });
            };
            async.detect = doParallel(_detect);
            async.detectSeries = doSeries(_detect);
            
            async.some = function (arr, iterator, main_callback) {
                async.each(arr, function (x, callback) {
                    iterator(x, function (v) {
                        if (v) {
                            main_callback(true);
                            main_callback = function () {};
                        }
                        callback();
                    });
                }, function (err) {
                    main_callback(false);
                });
            };
            // any alias
            async.any = async.some;
            
            async.every = function (arr, iterator, main_callback) {
                async.each(arr, function (x, callback) {
                    iterator(x, function (v) {
                        if (!v) {
                            main_callback(false);
                            main_callback = function () {};
                        }
                        callback();
                    });
                }, function (err) {
                    main_callback(true);
                });
            };
            // all alias
            async.all = async.every;
            
            async.sortBy = function (arr, iterator, callback) {
                async.map(arr, function (x, callback) {
                    iterator(x, function (err, criteria) {
                        if (err) {
                            callback(err);
                        }
                        else {
                            callback(null, {value: x, criteria: criteria});
                        }
                    });
                }, function (err, results) {
                    if (err) {
                        return callback(err);
                    }
                    else {
                        var fn = function (left, right) {
                            var a = left.criteria, b = right.criteria;
                            return a < b ? -1 : a > b ? 1 : 0;
                        };
                        callback(null, _map(results.sort(fn), function (x) {
                            return x.value;
                        }));
                    }
                });
            };
            
            async.auto = function (tasks, callback) {
                callback = callback || function () {};
                var keys = _keys(tasks);
                var remainingTasks = keys.length
                if (!remainingTasks) {
                    return callback();
                }
                
                var results = {};
                
                var listeners = [];
                var addListener = function (fn) {
                    listeners.unshift(fn);
                };
                var removeListener = function (fn) {
                    for (var i = 0; i < listeners.length; i += 1) {
                        if (listeners[i] === fn) {
                            listeners.splice(i, 1);
                            return;
                        }
                    }
                };
                var taskComplete = function () {
                    remainingTasks--
                    _each(listeners.slice(0), function (fn) {
                        fn();
                    });
                };
                
                addListener(function () {
                    if (!remainingTasks) {
                        var theCallback = callback;
                        // prevent final callback from calling itself if it errors
                        callback = function () {};
                        
                        theCallback(null, results);
                    }
                });
                
                _each(keys, function (k) {
                    var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                    var taskCallback = function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        if (err) {
                            var safeResults = {};
                            _each(_keys(results), function(rkey) {
                                safeResults[rkey] = results[rkey];
                            });
                            safeResults[k] = args;
                            callback(err, safeResults);
                            // stop subsequent errors hitting callback multiple times
                            callback = function () {};
                        }
                        else {
                            results[k] = args;
                            async.setImmediate(taskComplete);
                        }
                    };
                    var requires = task.slice(0, Math.abs(task.length - 1)) || [];
                    var ready = function () {
                        return _reduce(requires, function (a, x) {
                                return (a && results.hasOwnProperty(x));
                            }, true) && !results.hasOwnProperty(k);
                    };
                    if (ready()) {
                        task[task.length - 1](taskCallback, results);
                    }
                    else {
                        var listener = function () {
                            if (ready()) {
                                removeListener(listener);
                                task[task.length - 1](taskCallback, results);
                            }
                        };
                        addListener(listener);
                    }
                });
            };
            
            async.retry = function(times, task, callback) {
                var DEFAULT_TIMES = 5;
                var attempts = [];
                // Use defaults if times not passed
                if (typeof times === 'function') {
                    callback = task;
                    task = times;
                    times = DEFAULT_TIMES;
                }
                // Make sure times is a number
                times = parseInt(times, 10) || DEFAULT_TIMES;
                var wrappedTask = function(wrappedCallback, wrappedResults) {
                    var retryAttempt = function(task, finalAttempt) {
                        return function(seriesCallback) {
                            task(function(err, result){
                                seriesCallback(!err || finalAttempt, {err: err, result: result});
                            }, wrappedResults);
                        };
                    };
                    while (times) {
                        attempts.push(retryAttempt(task, !(times-=1)));
                    }
                    async.series(attempts, function(done, data){
                        data = data[data.length - 1];
                        (wrappedCallback || callback)(data.err, data.result);
                    });
                }
                // If a callback is passed, run this as a controll flow
                return callback ? wrappedTask() : wrappedTask
            };
            
            async.waterfall = function (tasks, callback) {
                callback = callback || function () {};
                if (!_isArray(tasks)) {
                    var err = new Error('First argument to waterfall must be an array of functions');
                    return callback(err);
                }
                if (!tasks.length) {
                    return callback();
                }
                var wrapIterator = function (iterator) {
                    return function (err) {
                        if (err) {
                            callback.apply(null, arguments);
                            callback = function () {};
                        }
                        else {
                            var args = Array.prototype.slice.call(arguments, 1);
                            var next = iterator.next();
                            if (next) {
                                args.push(wrapIterator(next));
                            }
                            else {
                                args.push(callback);
                            }
                            async.setImmediate(function () {
                                iterator.apply(null, args);
                            });
                        }
                    };
                };
                wrapIterator(async.iterator(tasks))();
            };
            
            var _parallel = function(eachfn, tasks, callback) {
                callback = callback || function () {};
                if (_isArray(tasks)) {
                    eachfn.map(tasks, function (fn, callback) {
                        if (fn) {
                            fn(function (err) {
                                var args = Array.prototype.slice.call(arguments, 1);
                                if (args.length <= 1) {
                                    args = args[0];
                                }
                                callback.call(null, err, args);
                            });
                        }
                    }, callback);
                }
                else {
                    var results = {};
                    eachfn.each(_keys(tasks), function (k, callback) {
                        tasks[k](function (err) {
                            var args = Array.prototype.slice.call(arguments, 1);
                            if (args.length <= 1) {
                                args = args[0];
                            }
                            results[k] = args;
                            callback(err);
                        });
                    }, function (err) {
                        callback(err, results);
                    });
                }
            };
            
            async.parallel = function (tasks, callback) {
                _parallel({ map: async.map, each: async.each }, tasks, callback);
            };
            
            async.parallelLimit = function(tasks, limit, callback) {
                _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
            };
            
            async.series = function (tasks, callback) {
                callback = callback || function () {};
                if (_isArray(tasks)) {
                    async.mapSeries(tasks, function (fn, callback) {
                        if (fn) {
                            fn(function (err) {
                                var args = Array.prototype.slice.call(arguments, 1);
                                if (args.length <= 1) {
                                    args = args[0];
                                }
                                callback.call(null, err, args);
                            });
                        }
                    }, callback);
                }
                else {
                    var results = {};
                    async.eachSeries(_keys(tasks), function (k, callback) {
                        tasks[k](function (err) {
                            var args = Array.prototype.slice.call(arguments, 1);
                            if (args.length <= 1) {
                                args = args[0];
                            }
                            results[k] = args;
                            callback(err);
                        });
                    }, function (err) {
                        callback(err, results);
                    });
                }
            };
            
            async.iterator = function (tasks) {
                var makeCallback = function (index) {
                    var fn = function () {
                        if (tasks.length) {
                            tasks[index].apply(null, arguments);
                        }
                        return fn.next();
                    };
                    fn.next = function () {
                        return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                    };
                    return fn;
                };
                return makeCallback(0);
            };
            
            async.apply = function (fn) {
                var args = Array.prototype.slice.call(arguments, 1);
                return function () {
                    return fn.apply(
                        null, args.concat(Array.prototype.slice.call(arguments))
                    );
                };
            };
            
            var _concat = function (eachfn, arr, fn, callback) {
                var r = [];
                eachfn(arr, function (x, cb) {
                    fn(x, function (err, y) {
                        r = r.concat(y || []);
                        cb(err);
                    });
                }, function (err) {
                    callback(err, r);
                });
            };
            async.concat = doParallel(_concat);
            async.concatSeries = doSeries(_concat);
            
            async.whilst = function (test, iterator, callback) {
                if (test()) {
                    iterator(function (err) {
                        if (err) {
                            return callback(err);
                        }
                        async.whilst(test, iterator, callback);
                    });
                }
                else {
                    callback();
                }
            };
            
            async.doWhilst = function (iterator, test, callback) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (test.apply(null, args)) {
                        async.doWhilst(iterator, test, callback);
                    }
                    else {
                        callback();
                    }
                });
            };
            
            async.until = function (test, iterator, callback) {
                if (!test()) {
                    iterator(function (err) {
                        if (err) {
                            return callback(err);
                        }
                        async.until(test, iterator, callback);
                    });
                }
                else {
                    callback();
                }
            };
            
            async.doUntil = function (iterator, test, callback) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (!test.apply(null, args)) {
                        async.doUntil(iterator, test, callback);
                    }
                    else {
                        callback();
                    }
                });
            };
            
            async.queue = function (worker, concurrency) {
                if (concurrency === undefined) {
                    concurrency = 1;
                }
                function _insert(q, data, pos, callback) {
                    if (!q.started){
                        q.started = true;
                    }
                    if (!_isArray(data)) {
                        data = [data];
                    }
                    if(data.length == 0) {
                        // call drain immediately if there are no tasks
                        return async.setImmediate(function() {
                            if (q.drain) {
                                q.drain();
                            }
                        });
                    }
                    _each(data, function(task) {
                        var item = {
                            data: task,
                            callback: typeof callback === 'function' ? callback : null
                        };
                        
                        if (pos) {
                            q.tasks.unshift(item);
                        } else {
                            q.tasks.push(item);
                        }
                        
                        if (q.saturated && q.tasks.length === q.concurrency) {
                            q.saturated();
                        }
                        async.setImmediate(q.process);
                    });
                }
                
                var workers = 0;
                var q = {
                    tasks: [],
                    concurrency: concurrency,
                    saturated: null,
                    empty: null,
                    drain: null,
                    started: false,
                    paused: false,
                    push: function (data, callback) {
                        _insert(q, data, false, callback);
                    },
                    kill: function () {
                        q.drain = null;
                        q.tasks = [];
                    },
                    unshift: function (data, callback) {
                        _insert(q, data, true, callback);
                    },
                    process: function () {
                        if (!q.paused && workers < q.concurrency && q.tasks.length) {
                            var task = q.tasks.shift();
                            if (q.empty && q.tasks.length === 0) {
                                q.empty();
                            }
                            workers += 1;
                            var next = function () {
                                workers -= 1;
                                if (task.callback) {
                                    task.callback.apply(task, arguments);
                                }
                                if (q.drain && q.tasks.length + workers === 0) {
                                    q.drain();
                                }
                                q.process();
                            };
                            var cb = only_once(next);
                            worker(task.data, cb);
                        }
                    },
                    length: function () {
                        return q.tasks.length;
                    },
                    running: function () {
                        return workers;
                    },
                    idle: function() {
                        return q.tasks.length + workers === 0;
                    },
                    pause: function () {
                        if (q.paused === true) { return; }
                        q.paused = true;
                        q.process();
                    },
                    resume: function () {
                        if (q.paused === false) { return; }
                        q.paused = false;
                        q.process();
                    }
                };
                return q;
            };
            
            async.priorityQueue = function (worker, concurrency) {
                
                function _compareTasks(a, b){
                    return a.priority - b.priority;
                };
                
                function _binarySearch(sequence, item, compare) {
                    var beg = -1,
                        end = sequence.length - 1;
                    while (beg < end) {
                        var mid = beg + ((end - beg + 1) >>> 1);
                        if (compare(item, sequence[mid]) >= 0) {
                            beg = mid;
                        } else {
                            end = mid - 1;
                        }
                    }
                    return beg;
                }
                
                function _insert(q, data, priority, callback) {
                    if (!q.started){
                        q.started = true;
                    }
                    if (!_isArray(data)) {
                        data = [data];
                    }
                    if(data.length == 0) {
                        // call drain immediately if there are no tasks
                        return async.setImmediate(function() {
                            if (q.drain) {
                                q.drain();
                            }
                        });
                    }
                    _each(data, function(task) {
                        var item = {
                            data: task,
                            priority: priority,
                            callback: typeof callback === 'function' ? callback : null
                        };
                        
                        q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
                        
                        if (q.saturated && q.tasks.length === q.concurrency) {
                            q.saturated();
                        }
                        async.setImmediate(q.process);
                    });
                }
                
                // Start with a normal queue
                var q = async.queue(worker, concurrency);
                
                // Override push to accept second parameter representing priority
                q.push = function (data, priority, callback) {
                    _insert(q, data, priority, callback);
                };
                
                // Remove unshift function
                delete q.unshift;
                
                return q;
            };
            
            async.cargo = function (worker, payload) {
                var working     = false,
                    tasks       = [];
                
                var cargo = {
                    tasks: tasks,
                    payload: payload,
                    saturated: null,
                    empty: null,
                    drain: null,
                    drained: true,
                    push: function (data, callback) {
                        if (!_isArray(data)) {
                            data = [data];
                        }
                        _each(data, function(task) {
                            tasks.push({
                                data: task,
                                callback: typeof callback === 'function' ? callback : null
                            });
                            cargo.drained = false;
                            if (cargo.saturated && tasks.length === payload) {
                                cargo.saturated();
                            }
                        });
                        async.setImmediate(cargo.process);
                    },
                    process: function process() {
                        if (working) return;
                        if (tasks.length === 0) {
                            if(cargo.drain && !cargo.drained) cargo.drain();
                            cargo.drained = true;
                            return;
                        }
                        
                        var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);
                        
                        var ds = _map(ts, function (task) {
                            return task.data;
                        });
                        
                        if(cargo.empty) cargo.empty();
                        working = true;
                        worker(ds, function () {
                            working = false;
                            
                            var args = arguments;
                            _each(ts, function (data) {
                                if (data.callback) {
                                    data.callback.apply(null, args);
                                }
                            });
                            
                            process();
                        });
                    },
                    length: function () {
                        return tasks.length;
                    },
                    running: function () {
                        return working;
                    }
                };
                return cargo;
            };
            
            var _console_fn = function (name) {
                return function (fn) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    fn.apply(null, args.concat([function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (typeof console !== 'undefined') {
                            if (err) {
                                if (console.error) {
                                    console.error(err);
                                }
                            }
                            else if (console[name]) {
                                _each(args, function (x) {
                                    console[name](x);
                                });
                            }
                        }
                    }]));
                };
            };
            async.log = _console_fn('log');
            async.dir = _console_fn('dir');
            /*async.info = _console_fn('info');
             async.warn = _console_fn('warn');
             async.error = _console_fn('error');*/
            
            async.memoize = function (fn, hasher) {
                var memo = {};
                var queues = {};
                hasher = hasher || function (x) {
                        return x;
                    };
                var memoized = function () {
                    var args = Array.prototype.slice.call(arguments);
                    var callback = args.pop();
                    var key = hasher.apply(null, args);
                    if (key in memo) {
                        async.nextTick(function () {
                            callback.apply(null, memo[key]);
                        });
                    }
                    else if (key in queues) {
                        queues[key].push(callback);
                    }
                    else {
                        queues[key] = [callback];
                        fn.apply(null, args.concat([function () {
                            memo[key] = arguments;
                            var q = queues[key];
                            delete queues[key];
                            for (var i = 0, l = q.length; i < l; i++) {
                                q[i].apply(null, arguments);
                            }
                        }]));
                    }
                };
                memoized.memo = memo;
                memoized.unmemoized = fn;
                return memoized;
            };
            
            async.unmemoize = function (fn) {
                return function () {
                    return (fn.unmemoized || fn).apply(null, arguments);
                };
            };
            
            async.times = function (count, iterator, callback) {
                var counter = [];
                for (var i = 0; i < count; i++) {
                    counter.push(i);
                }
                return async.map(counter, iterator, callback);
            };
            
            async.timesSeries = function (count, iterator, callback) {
                var counter = [];
                for (var i = 0; i < count; i++) {
                    counter.push(i);
                }
                return async.mapSeries(counter, iterator, callback);
            };
            
            async.seq = function (/* functions... */) {
                var fns = arguments;
                return function () {
                    var that = this;
                    var args = Array.prototype.slice.call(arguments);
                    var callback = args.pop();
                    async.reduce(fns, args, function (newargs, fn, cb) {
                            fn.apply(that, newargs.concat([function () {
                                var err = arguments[0];
                                var nextargs = Array.prototype.slice.call(arguments, 1);
                                cb(err, nextargs);
                            }]))
                        },
                        function (err, results) {
                            callback.apply(that, [err].concat(results));
                        });
                };
            };
            
            async.compose = function (/* functions... */) {
                return async.seq.apply(null, Array.prototype.reverse.call(arguments));
            };
            
            var _applyEach = function (eachfn, fns /*args...*/) {
                var go = function () {
                    var that = this;
                    var args = Array.prototype.slice.call(arguments);
                    var callback = args.pop();
                    return eachfn(fns, function (fn, cb) {
                            fn.apply(that, args.concat([cb]));
                        },
                        callback);
                };
                if (arguments.length > 2) {
                    var args = Array.prototype.slice.call(arguments, 2);
                    return go.apply(this, args);
                }
                else {
                    return go;
                }
            };
            async.applyEach = doParallel(_applyEach);
            async.applyEachSeries = doSeries(_applyEach);
            
            async.forever = function (fn, callback) {
                function next(err) {
                    if (err) {
                        if (callback) {
                            return callback(err);
                        }
                        throw err;
                    }
                    fn(next);
                }
                next();
            };
            
            // Node.js
            if (typeof module !== 'undefined' && module.exports) {
                module.exports = async;
            }
            // AMD / RequireJS
            else if (typeof define !== 'undefined' && define.amd) {
                define([], function () {
                    return async;
                });
            }
            // included directly via <script> tag
            else {
                root.async = async;
            }
            
        }());
        
    }).call(this,require('_process'))
    
},{"_process":80}],76:[function(require,module,exports){
    (function (global){
        
        ; jQuery = global.jQuery = require("/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js");
        ; var __browserify_shim_require__=require;(function browserifyShim(module, define, require) {
            /*!
             Autosize 1.18.13
             license: MIT
             http://www.jacklmoore.com/autosize
             */
            (function ($) {
                var
                    defaults = {
                        className: 'autosizejs',
                        id: 'autosizejs',
                        append: '\n',
                        callback: false,
                        resizeDelay: 10,
                        placeholder: true
                    },
                
                // border:0 is unnecessary, but avoids a bug in Firefox on OSX
                    copy = '<textarea tabindex="-1" style="position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;"/>',
                
                // line-height is conditionally included because IE7/IE8/old Opera do not return the correct value.
                    typographyStyles = [
                        'fontFamily',
                        'fontSize',
                        'fontWeight',
                        'fontStyle',
                        'letterSpacing',
                        'textTransform',
                        'wordSpacing',
                        'textIndent',
                        'whiteSpace'
                    ],
                
                // to keep track which textarea is being mirrored when adjust() is called.
                    mirrored,
                
                // the mirror element, which is used to calculate what size the mirrored element should be.
                    mirror = $(copy).data('autosize', true)[0];
                
                // test that line-height can be accurately copied.
                mirror.style.lineHeight = '99px';
                if ($(mirror).css('lineHeight') === '99px') {
                    typographyStyles.push('lineHeight');
                }
                mirror.style.lineHeight = '';
                
                $.fn.autosize = function (options) {
                    if (!this.length) {
                        return this;
                    }
                    
                    options = $.extend({}, defaults, options || {});
                    
                    if (mirror.parentNode !== document.body) {
                        $(document.body).append(mirror);
                    }
                    
                    return this.each(function () {
                        var
                            ta = this,
                            $ta = $(ta),
                            maxHeight,
                            minHeight,
                            boxOffset = 0,
                            callback = $.isFunction(options.callback),
                            originalStyles = {
                                height: ta.style.height,
                                overflow: ta.style.overflow,
                                overflowY: ta.style.overflowY,
                                wordWrap: ta.style.wordWrap,
                                resize: ta.style.resize
                            },
                            timeout,
                            width = $ta.width(),
                            taResize = $ta.css('resize');
                        
                        if ($ta.data('autosize')) {
                            // exit if autosize has already been applied, or if the textarea is the mirror element.
                            return;
                        }
                        $ta.data('autosize', true);
                        
                        if ($ta.css('box-sizing') === 'border-box' || $ta.css('-moz-box-sizing') === 'border-box' || $ta.css('-webkit-box-sizing') === 'border-box'){
                            boxOffset = $ta.outerHeight() - $ta.height();
                        }
                        
                        // IE8 and lower return 'auto', which parses to NaN, if no min-height is set.
                        minHeight = Math.max(parseInt($ta.css('minHeight'), 10) - boxOffset || 0, $ta.height());
                        
                        $ta.css({
                            overflow: 'hidden',
                            overflowY: 'hidden',
                            wordWrap: 'break-word' // horizontal overflow is hidden, so break-word is necessary for handling words longer than the textarea width
                        });
                        
                        if (taResize === 'vertical') {
                            $ta.css('resize','none');
                        } else if (taResize === 'both') {
                            $ta.css('resize', 'horizontal');
                        }
                        
                        // The mirror width must exactly match the textarea width, so using getBoundingClientRect because it doesn't round the sub-pixel value.
                        // window.getComputedStyle, getBoundingClientRect returning a width are unsupported, but also unneeded in IE8 and lower.
                        function setWidth() {
                            var width;
                            var style = window.getComputedStyle ? window.getComputedStyle(ta, null) : false;
                            
                            if (style) {
                                
                                width = ta.getBoundingClientRect().width;
                                
                                if (width === 0 || typeof width !== 'number') {
                                    width = parseInt(style.width,10);
                                }
                                
                                $.each(['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'], function(i,val){
                                    width -= parseInt(style[val],10);
                                });
                            } else {
                                width = $ta.width();
                            }
                            
                            mirror.style.width = Math.max(width,0) + 'px';
                        }
                        
                        function initMirror() {
                            var styles = {};
                            
                            mirrored = ta;
                            mirror.className = options.className;
                            mirror.id = options.id;
                            maxHeight = parseInt($ta.css('maxHeight'), 10);
                            
                            // mirror is a duplicate textarea located off-screen that
                            // is automatically updated to contain the same text as the
                            // original textarea.  mirror always has a height of 0.
                            // This gives a cross-browser supported way getting the actual
                            // height of the text, through the scrollTop property.
                            $.each(typographyStyles, function(i,val){
                                styles[val] = $ta.css(val);
                            });
                            
                            $(mirror).css(styles).attr('wrap', $ta.attr('wrap'));
                            
                            setWidth();
                            
                            // Chrome-specific fix:
                            // When the textarea y-overflow is hidden, Chrome doesn't reflow the text to account for the space
                            // made available by removing the scrollbar. This workaround triggers the reflow for Chrome.
                            if (window.chrome) {
                                var width = ta.style.width;
                                ta.style.width = '0px';
                                var ignore = ta.offsetWidth;
                                ta.style.width = width;
                            }
                        }
                        
                        // Using mainly bare JS in this function because it is going
                        // to fire very often while typing, and needs to very efficient.
                        function adjust() {
                            var height, original;
                            
                            if (mirrored !== ta) {
                                initMirror();
                            } else {
                                setWidth();
                            }
                            
                            if (!ta.value && options.placeholder) {
                                // If the textarea is empty, copy the placeholder text into 
                                // the mirror control and use that for sizing so that we 
                                // don't end up with placeholder getting trimmed.
                                mirror.value = ($ta.attr("placeholder") || '');
                            } else {
                                mirror.value = ta.value;
                            }
                            
                            mirror.value += options.append || '';
                            mirror.style.overflowY = ta.style.overflowY;
                            original = parseInt(ta.style.height,10);
                            
                            // Setting scrollTop to zero is needed in IE8 and lower for the next step to be accurately applied
                            mirror.scrollTop = 0;
                            
                            mirror.scrollTop = 9e4;
                            
                            // Using scrollTop rather than scrollHeight because scrollHeight is non-standard and includes padding.
                            height = mirror.scrollTop;
                            
                            if (maxHeight && height > maxHeight) {
                                ta.style.overflowY = 'scroll';
                                height = maxHeight;
                            } else {
                                ta.style.overflowY = 'hidden';
                                if (height < minHeight) {
                                    height = minHeight;
                                }
                            }
                            
                            height += boxOffset;
                            
                            if (original !== height) {
                                ta.style.height = height + 'px';
                                if (callback) {
                                    options.callback.call(ta,ta);
                                }
                                $ta.trigger('autosize.resized');
                            }
                        }
                        
                        function resize () {
                            clearTimeout(timeout);
                            timeout = setTimeout(function(){
                                var newWidth = $ta.width();
                                
                                if (newWidth !== width) {
                                    width = newWidth;
                                    adjust();
                                }
                            }, parseInt(options.resizeDelay,10));
                        }
                        
                        if ('onpropertychange' in ta) {
                            if ('oninput' in ta) {
                                // Detects IE9.  IE9 does not fire onpropertychange or oninput for deletions,
                                // so binding to onkeyup to catch most of those occasions.  There is no way that I
                                // know of to detect something like 'cut' in IE9.
                                $ta.on('input.autosize keyup.autosize', adjust);
                            } else {
                                // IE7 / IE8
                                $ta.on('propertychange.autosize', function(){
                                    if(event.propertyName === 'value'){
                                        adjust();
                                    }
                                });
                            }
                        } else {
                            // Modern Browsers
                            $ta.on('input.autosize', adjust);
                        }
                        
                        // Set options.resizeDelay to false if using fixed-width textarea elements.
                        // Uses a timeout and width check to reduce the amount of times adjust needs to be called after window resize.
                        
                        if (options.resizeDelay !== false) {
                            $(window).on('resize.autosize', resize);
                        }
                        
                        // Event for manual triggering if needed.
                        // Should only be needed when the value of the textarea is changed through JavaScript rather than user input.
                        $ta.on('autosize.resize', adjust);
                        
                        // Event for manual triggering that also forces the styles to update as well.
                        // Should only be needed if one of typography styles of the textarea change, and the textarea is already the target of the adjust method.
                        $ta.on('autosize.resizeIncludeStyle', function() {
                            mirrored = null;
                            adjust();
                        });
                        
                        $ta.on('autosize.destroy', function(){
                            mirrored = null;
                            clearTimeout(timeout);
                            $(window).off('resize', resize);
                            $ta
                                .off('autosize')
                                .off('.autosize')
                                .css(originalStyles)
                                .removeData('autosize');
                        });
                        
                        // Call adjust in case the textarea already contains text.
                        adjust();
                    });
                };
            }(jQuery || $)); // jQuery or jQuery-like library, such as Zepto
            
        }).call(global, module, undefined, undefined);
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js":84}],77:[function(require,module,exports){
    (function (global){
        
        ; jQuery = global.jQuery = require("/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js");
        ; var __browserify_shim_require__=require;(function browserifyShim(module, define, require) {
            /* ========================================================================
             * Bootstrap: popover.js v3.1.1
             * http://getbootstrap.com/javascript/#popovers
             * ========================================================================
             * Copyright 2011-2014 Twitter, Inc.
             * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
             * ======================================================================== */
            
            
            +function ($) {
                'use strict';
                
                // POPOVER PUBLIC CLASS DEFINITION
                // ===============================
                
                var Popover = function (element, options) {
                    this.init('popover', element, options)
                }
                
                if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
                
                Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
                    placement: 'right',
                    trigger: 'click',
                    content: '',
                    template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
                })
                
                
                // NOTE: POPOVER EXTENDS tooltip.js
                // ================================
                
                Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
                
                Popover.prototype.constructor = Popover
                
                Popover.prototype.getDefaults = function () {
                    return Popover.DEFAULTS
                }
                
                Popover.prototype.setContent = function () {
                    var $tip    = this.tip()
                    var title   = this.getTitle()
                    var content = this.getContent()
                    
                    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
                    $tip.find('.popover-content')[ // we use append for html objects to maintain js events
                        this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
                        ](content)
                    
                    $tip.removeClass('fade top bottom left right in')
                    
                    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
                    // this manually by checking the contents.
                    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
                }
                
                Popover.prototype.hasContent = function () {
                    return this.getTitle() || this.getContent()
                }
                
                Popover.prototype.getContent = function () {
                    var $e = this.$element
                    var o  = this.options
                    
                    return $e.attr('data-content')
                        || (typeof o.content == 'function' ?
                            o.content.call($e[0]) :
                            o.content)
                }
                
                Popover.prototype.arrow = function () {
                    return this.$arrow = this.$arrow || this.tip().find('.arrow')
                }
                
                Popover.prototype.tip = function () {
                    if (!this.$tip) this.$tip = $(this.options.template)
                    return this.$tip
                }
                
                
                // POPOVER PLUGIN DEFINITION
                // =========================
                
                var old = $.fn.popover
                
                $.fn.popover = function (option) {
                    return this.each(function () {
                        var $this   = $(this)
                        var data    = $this.data('bs.popover')
                        var options = typeof option == 'object' && option
                        
                        if (!data && option == 'destroy') return
                        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
                        if (typeof option == 'string') data[option]()
                    })
                }
                
                $.fn.popover.Constructor = Popover
                
                
                // POPOVER NO CONFLICT
                // ===================
                
                $.fn.popover.noConflict = function () {
                    $.fn.popover = old
                    return this
                }
                
            }(jQuery);
            
        }).call(global, module, undefined, undefined);
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js":84}],78:[function(require,module,exports){
    (function (global){
        
        ; jQuery = global.jQuery = require("/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js");
        ; var __browserify_shim_require__=require;(function browserifyShim(module, define, require) {
            /* ========================================================================
             * Bootstrap: tooltip.js v3.1.1
             * http://getbootstrap.com/javascript/#tooltip
             * Inspired by the original jQuery.tipsy by Jason Frame
             * ========================================================================
             * Copyright 2011-2014 Twitter, Inc.
             * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
             * ======================================================================== */
            
            
            +function ($) {
                'use strict';
                
                // TOOLTIP PUBLIC CLASS DEFINITION
                // ===============================
                
                var Tooltip = function (element, options) {
                    this.type       =
                        this.options    =
                            this.enabled    =
                                this.timeout    =
                                    this.hoverState =
                                        this.$element   = null
                    
                    this.init('tooltip', element, options)
                }
                
                Tooltip.DEFAULTS = {
                    animation: true,
                    placement: 'top',
                    selector: false,
                    template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
                    trigger: 'hover focus',
                    title: '',
                    delay: 0,
                    html: false,
                    container: false
                }
                
                Tooltip.prototype.init = function (type, element, options) {
                    this.enabled  = true
                    this.type     = type
                    this.$element = $(element)
                    this.options  = this.getOptions(options)
                    
                    var triggers = this.options.trigger.split(' ')
                    
                    for (var i = triggers.length; i--;) {
                        var trigger = triggers[i]
                        
                        if (trigger == 'click') {
                            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
                        } else if (trigger != 'manual') {
                            var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
                            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
                            
                            this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
                            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
                        }
                    }
                    
                    this.options.selector ?
                        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
                        this.fixTitle()
                }
                
                Tooltip.prototype.getDefaults = function () {
                    return Tooltip.DEFAULTS
                }
                
                Tooltip.prototype.getOptions = function (options) {
                    options = $.extend({}, this.getDefaults(), this.$element.data(), options)
                    
                    if (options.delay && typeof options.delay == 'number') {
                        options.delay = {
                            show: options.delay,
                            hide: options.delay
                        }
                    }
                    
                    return options
                }
                
                Tooltip.prototype.getDelegateOptions = function () {
                    var options  = {}
                    var defaults = this.getDefaults()
                    
                    this._options && $.each(this._options, function (key, value) {
                        if (defaults[key] != value) options[key] = value
                    })
                    
                    return options
                }
                
                Tooltip.prototype.enter = function (obj) {
                    var self = obj instanceof this.constructor ?
                        obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)
                    
                    clearTimeout(self.timeout)
                    
                    self.hoverState = 'in'
                    
                    if (!self.options.delay || !self.options.delay.show) return self.show()
                    
                    self.timeout = setTimeout(function () {
                        if (self.hoverState == 'in') self.show()
                    }, self.options.delay.show)
                }
                
                Tooltip.prototype.leave = function (obj) {
                    var self = obj instanceof this.constructor ?
                        obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)
                    
                    clearTimeout(self.timeout)
                    
                    self.hoverState = 'out'
                    
                    if (!self.options.delay || !self.options.delay.hide) return self.hide()
                    
                    self.timeout = setTimeout(function () {
                        if (self.hoverState == 'out') self.hide()
                    }, self.options.delay.hide)
                }
                
                Tooltip.prototype.show = function () {
                    var e = $.Event('show.bs.' + this.type)
                    
                    if (this.hasContent() && this.enabled) {
                        this.$element.trigger(e)
                        
                        if (e.isDefaultPrevented()) return
                        var that = this;
                        
                        var $tip = this.tip()
                        
                        this.setContent()
                        
                        if (this.options.animation) $tip.addClass('fade')
                        
                        var placement = typeof this.options.placement == 'function' ?
                            this.options.placement.call(this, $tip[0], this.$element[0]) :
                            this.options.placement
                        
                        var autoToken = /\s?auto?\s?/i
                        var autoPlace = autoToken.test(placement)
                        if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
                        
                        $tip
                            .detach()
                            .css({ top: 0, left: 0, display: 'block' })
                            .addClass(placement)
                        
                        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
                        
                        var pos          = this.getPosition()
                        var actualWidth  = $tip[0].offsetWidth
                        var actualHeight = $tip[0].offsetHeight
                        
                        if (autoPlace) {
                            var $parent = this.$element.parent()
                            
                            var orgPlacement = placement
                            var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
                            var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
                            var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
                            var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left
                            
                            placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
                                placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
                                    placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
                                        placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
                                            placement
                            
                            $tip
                                .removeClass(orgPlacement)
                                .addClass(placement)
                        }
                        
                        var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
                        
                        this.applyPlacement(calculatedOffset, placement)
                        this.hoverState = null
                        
                        var complete = function() {
                            that.$element.trigger('shown.bs.' + that.type)
                        }
                        
                        $.support.transition && this.$tip.hasClass('fade') ?
                            $tip
                                .one($.support.transition.end, complete)
                                .emulateTransitionEnd(150) :
                            complete()
                    }
                }
                
                Tooltip.prototype.applyPlacement = function (offset, placement) {
                    var replace
                    var $tip   = this.tip()
                    var width  = $tip[0].offsetWidth
                    var height = $tip[0].offsetHeight
                    
                    // manually read margins because getBoundingClientRect includes difference
                    var marginTop = parseInt($tip.css('margin-top'), 10)
                    var marginLeft = parseInt($tip.css('margin-left'), 10)
                    
                    // we must check for NaN for ie 8/9
                    if (isNaN(marginTop))  marginTop  = 0
                    if (isNaN(marginLeft)) marginLeft = 0
                    
                    offset.top  = offset.top  + marginTop
                    offset.left = offset.left + marginLeft
                    
                    // $.fn.offset doesn't round pixel values
                    // so we use setOffset directly with our own function B-0
                    $.offset.setOffset($tip[0], $.extend({
                        using: function (props) {
                            $tip.css({
                                top: Math.round(props.top),
                                left: Math.round(props.left)
                            })
                        }
                    }, offset), 0)
                    
                    $tip.addClass('in')
                    
                    // check to see if placing tip in new offset caused the tip to resize itself
                    var actualWidth  = $tip[0].offsetWidth
                    var actualHeight = $tip[0].offsetHeight
                    
                    if (placement == 'top' && actualHeight != height) {
                        replace = true
                        offset.top = offset.top + height - actualHeight
                    }
                    
                    if (/bottom|top/.test(placement)) {
                        var delta = 0
                        
                        if (offset.left < 0) {
                            delta       = offset.left * -2
                            offset.left = 0
                            
                            $tip.offset(offset)
                            
                            actualWidth  = $tip[0].offsetWidth
                            actualHeight = $tip[0].offsetHeight
                        }
                        
                        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
                    } else {
                        this.replaceArrow(actualHeight - height, actualHeight, 'top')
                    }
                    
                    if (replace) $tip.offset(offset)
                }
                
                Tooltip.prototype.replaceArrow = function (delta, dimension, position) {
                    this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + '%') : '')
                }
                
                Tooltip.prototype.setContent = function () {
                    var $tip  = this.tip()
                    var title = this.getTitle()
                    
                    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
                    $tip.removeClass('fade in top bottom left right')
                }
                
                Tooltip.prototype.hide = function () {
                    var that = this
                    var $tip = this.tip()
                    var e    = $.Event('hide.bs.' + this.type)
                    
                    function complete() {
                        if (that.hoverState != 'in') $tip.detach()
                        that.$element.trigger('hidden.bs.' + that.type)
                    }
                    
                    this.$element.trigger(e)
                    
                    if (e.isDefaultPrevented()) return
                    
                    $tip.removeClass('in')
                    
                    $.support.transition && this.$tip.hasClass('fade') ?
                        $tip
                            .one($.support.transition.end, complete)
                            .emulateTransitionEnd(150) :
                        complete()
                    
                    this.hoverState = null
                    
                    return this
                }
                
                Tooltip.prototype.fixTitle = function () {
                    var $e = this.$element
                    if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
                        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
                    }
                }
                
                Tooltip.prototype.hasContent = function () {
                    return this.getTitle()
                }
                
                Tooltip.prototype.getPosition = function () {
                    var el = this.$element[0]
                    return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
                        width: el.offsetWidth,
                        height: el.offsetHeight
                    }, this.$element.offset())
                }
                
                Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
                    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
                        placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
                            placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
                                /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
                }
                
                Tooltip.prototype.getTitle = function () {
                    var title
                    var $e = this.$element
                    var o  = this.options
                    
                    title = $e.attr('data-original-title')
                        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
                    
                    return title
                }
                
                Tooltip.prototype.tip = function () {
                    return this.$tip = this.$tip || $(this.options.template)
                }
                
                Tooltip.prototype.arrow = function () {
                    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
                }
                
                Tooltip.prototype.validate = function () {
                    if (!this.$element[0].parentNode) {
                        this.hide()
                        this.$element = null
                        this.options  = null
                    }
                }
                
                Tooltip.prototype.enable = function () {
                    this.enabled = true
                }
                
                Tooltip.prototype.disable = function () {
                    this.enabled = false
                }
                
                Tooltip.prototype.toggleEnabled = function () {
                    this.enabled = !this.enabled
                }
                
                Tooltip.prototype.toggle = function (e) {
                    var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this
                    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
                }
                
                Tooltip.prototype.destroy = function () {
                    clearTimeout(this.timeout)
                    this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
                }
                
                
                // TOOLTIP PLUGIN DEFINITION
                // =========================
                
                var old = $.fn.tooltip
                
                $.fn.tooltip = function (option) {
                    return this.each(function () {
                        var $this   = $(this)
                        var data    = $this.data('bs.tooltip')
                        var options = typeof option == 'object' && option
                        
                        if (!data && option == 'destroy') return
                        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
                        if (typeof option == 'string') data[option]()
                    })
                }
                
                $.fn.tooltip.Constructor = Tooltip
                
                
                // TOOLTIP NO CONFLICT
                // ===================
                
                $.fn.tooltip.noConflict = function () {
                    $.fn.tooltip = old
                    return this
                }
                
            }(jQuery);
            
        }).call(global, module, undefined, undefined);
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js":84}],79:[function(require,module,exports){
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    
    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;
    
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    
    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;
    
    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
        this._maxListeners = n;
        return this;
    };
    
    EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;
        
        if (!this._events)
            this._events = {};
        
        // If there is no 'error' event listener then throw.
        if (type === 'error') {
            if (!this._events.error ||
                (isObject(this._events.error) && !this._events.error.length)) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er; // Unhandled 'error' event
                }
                throw TypeError('Uncaught, unspecified "error" event.');
            }
        }
        
        handler = this._events[type];
        
        if (isUndefined(handler))
            return false;
        
        if (isFunction(handler)) {
            switch (arguments.length) {
                // fast cases
                case 1:
                    handler.call(this);
                    break;
                case 2:
                    handler.call(this, arguments[1]);
                    break;
                case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;
                // slower
                default:
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++)
                        args[i - 1] = arguments[i];
                    handler.apply(this, args);
            }
        } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
            
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
        }
        
        return true;
    };
    
    EventEmitter.prototype.addListener = function(type, listener) {
        var m;
        
        if (!isFunction(listener))
            throw TypeError('listener must be a function');
        
        if (!this._events)
            this._events = {};
        
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (this._events.newListener)
            this.emit('newListener', type,
                isFunction(listener.listener) ?
                    listener.listener : listener);
        
        if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
        else if (isObject(this._events[type]))
        // If we've already got an array, just append.
            this._events[type].push(listener);
        else
        // Adding the second element, need to change to array.
            this._events[type] = [this._events[type], listener];
        
        // Check for listener leak
        if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
            } else {
                m = EventEmitter.defaultMaxListeners;
            }
            
            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                if (typeof console.trace === 'function') {
                    // not supported in IE 10
                    console.trace();
                }
            }
        }
        
        return this;
    };
    
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    
    EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener))
            throw TypeError('listener must be a function');
        
        var fired = false;
        
        function g() {
            this.removeListener(type, g);
            
            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }
        
        g.listener = listener;
        this.on(type, g);
        
        return this;
    };
    
    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;
        
        if (!isFunction(listener))
            throw TypeError('listener must be a function');
        
        if (!this._events || !this._events[type])
            return this;
        
        list = this._events[type];
        length = list.length;
        position = -1;
        
        if (list === listener ||
            (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
            
        } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
                if (list[i] === listener ||
                    (list[i].listener && list[i].listener === listener)) {
                    position = i;
                    break;
                }
            }
            
            if (position < 0)
                return this;
            
            if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
            } else {
                list.splice(position, 1);
            }
            
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
        }
        
        return this;
    };
    
    EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;
        
        if (!this._events)
            return this;
        
        // not listening for removeListener, no need to emit
        if (!this._events.removeListener) {
            if (arguments.length === 0)
                this._events = {};
            else if (this._events[type])
                delete this._events[type];
            return this;
        }
        
        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
        }
        
        listeners = this._events[type];
        
        if (isFunction(listeners)) {
            this.removeListener(type, listeners);
        } else {
            // LIFO order
            while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];
        
        return this;
    };
    
    EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type])
            ret = [];
        else if (isFunction(this._events[type]))
            ret = [this._events[type]];
        else
            ret = this._events[type].slice();
        return ret;
    };
    
    EventEmitter.listenerCount = function(emitter, type) {
        var ret;
        if (!emitter._events || !emitter._events[type])
            ret = 0;
        else if (isFunction(emitter._events[type]))
            ret = 1;
        else
            ret = emitter._events[type].length;
        return ret;
    };
    
    function isFunction(arg) {
        return typeof arg === 'function';
    }
    
    function isNumber(arg) {
        return typeof arg === 'number';
    }
    
    function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
    }
    
    function isUndefined(arg) {
        return arg === void 0;
    }
    
},{}],80:[function(require,module,exports){
    // shim for using process in browser
    
    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    
    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;
        
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }
    
    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };
    
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};
    
    function noop() {}
    
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    
    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };
    
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    
},{}],81:[function(require,module,exports){
    // i18next, v1.7.7
    // Copyright (c)2014 Jan Mühlemann (jamuhl).
    // Distributed under MIT license
    // http://i18next.com
    (function() {
        
        // add indexOf to non ECMA-262 standard compliant browsers
        if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
                "use strict";
                if (this == null) {
                    throw new TypeError();
                }
                var t = Object(this);
                var len = t.length >>> 0;
                if (len === 0) {
                    return -1;
                }
                var n = 0;
                if (arguments.length > 0) {
                    n = Number(arguments[1]);
                    if (n != n) { // shortcut for verifying if it's NaN
                        n = 0;
                    } else if (n != 0 && n != Infinity && n != -Infinity) {
                        n = (n > 0 || -1) * Math.floor(Math.abs(n));
                    }
                }
                if (n >= len) {
                    return -1;
                }
                var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
                for (; k < len; k++) {
                    if (k in t && t[k] === searchElement) {
                        return k;
                    }
                }
                return -1;
            }
        }
        
        // add lastIndexOf to non ECMA-262 standard compliant browsers
        if (!Array.prototype.lastIndexOf) {
            Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
                "use strict";
                if (this == null) {
                    throw new TypeError();
                }
                var t = Object(this);
                var len = t.length >>> 0;
                if (len === 0) {
                    return -1;
                }
                var n = len;
                if (arguments.length > 1) {
                    n = Number(arguments[1]);
                    if (n != n) {
                        n = 0;
                    } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                        n = (n > 0 || -1) * Math.floor(Math.abs(n));
                    }
                }
                var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
                for (; k >= 0; k--) {
                    if (k in t && t[k] === searchElement) {
                        return k;
                    }
                }
                return -1;
            };
        }
        
        // Add string trim for IE8.
        if (typeof String.prototype.trim !== 'function') {
            String.prototype.trim = function() {
                return this.replace(/^\s+|\s+$/g, '');
            }
        }
        
        var root = this
            , $ = root.jQuery || root.Zepto
            , i18n = {}
            , resStore = {}
            , currentLng
            , replacementCounter = 0
            , languages = []
            , initialized = false
            , sync = {};
        
        
        
        // Export the i18next object for **CommonJS**. 
        // If we're not in CommonJS, add `i18n` to the
        // global object or to jquery.
        if (typeof module !== 'undefined' && module.exports) {
            if (!$) {
                try {
                    $ = require('jquery');
                } catch(e) {
                    // just ignore
                }
            }
            if ($) {
                $.i18n = $.i18n || i18n;
            }
            module.exports = i18n;
        } else {
            if ($) {
                $.i18n = $.i18n || i18n;
            }
            
            root.i18n = root.i18n || i18n;
        }
        sync = {
            
            load: function(lngs, options, cb) {
                if (options.useLocalStorage) {
                    sync._loadLocal(lngs, options, function(err, store) {
                        var missingLngs = [];
                        for (var i = 0, len = lngs.length; i < len; i++) {
                            if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                        }
                        
                        if (missingLngs.length > 0) {
                            sync._fetch(missingLngs, options, function(err, fetched) {
                                f.extend(store, fetched);
                                sync._storeLocal(fetched);
                                
                                cb(null, store);
                            });
                        } else {
                            cb(null, store);
                        }
                    });
                } else {
                    sync._fetch(lngs, options, function(err, store){
                        cb(null, store);
                    });
                }
            },
            
            _loadLocal: function(lngs, options, cb) {
                var store = {}
                    , nowMS = new Date().getTime();
                
                if(window.localStorage) {
                    
                    var todo = lngs.length;
                    
                    f.each(lngs, function(key, lng) {
                        var local = window.localStorage.getItem('res_' + lng);
                        
                        if (local) {
                            local = JSON.parse(local);
                            
                            if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                                store[lng] = local;
                            }
                        }
                        
                        todo--; // wait for all done befor callback
                        if (todo === 0) cb(null, store);
                    });
                }
            },
            
            _storeLocal: function(store) {
                if(window.localStorage) {
                    for (var m in store) {
                        store[m].i18nStamp = new Date().getTime();
                        f.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                    }
                }
                return;
            },
            
            _fetch: function(lngs, options, cb) {
                var ns = options.ns
                    , store = {};
                
                if (!options.dynamicLoad) {
                    var todo = ns.namespaces.length * lngs.length
                        , errors;
                    
                    // load each file individual
                    f.each(ns.namespaces, function(nsIndex, nsValue) {
                        f.each(lngs, function(lngIndex, lngValue) {
                            
                            // Call this once our translation has returned.
                            var loadComplete = function(err, data) {
                                if (err) {
                                    errors = errors || [];
                                    errors.push(err);
                                }
                                store[lngValue] = store[lngValue] || {};
                                store[lngValue][nsValue] = data;
                                
                                todo--; // wait for all done befor callback
                                if (todo === 0) cb(errors, store);
                            };
                            
                            if(typeof options.customLoad == 'function'){
                                // Use the specified custom callback.
                                options.customLoad(lngValue, nsValue, options, loadComplete);
                            } else {
                                //~ // Use our inbuilt sync.
                                sync._fetchOne(lngValue, nsValue, options, loadComplete);
                            }
                        });
                    });
                } else {
                    // Call this once our translation has returned.
                    var loadComplete = function(err, data) {
                        cb(null, data);
                    };
                    
                    if(typeof options.customLoad == 'function'){
                        // Use the specified custom callback.
                        options.customLoad(lngs, ns.namespaces, options, loadComplete);
                    } else {
                        var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                        // load all needed stuff once
                        f.ajax({
                            url: url,
                            success: function(data, status, xhr) {
                                f.log('loaded: ' + url);
                                loadComplete(null, data);
                            },
                            error : function(xhr, status, error) {
                                f.log('failed loading: ' + url);
                                loadComplete('failed loading resource.json error: ' + error);
                            },
                            dataType: "json",
                            async : options.getAsync
                        });
                    }
                }
            },
            
            _fetchOne: function(lng, ns, options, done) {
                var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
                f.ajax({
                    url: url,
                    success: function(data, status, xhr) {
                        f.log('loaded: ' + url);
                        done(null, data);
                    },
                    error : function(xhr, status, error) {
                        if ((status && status == 200) || (xhr && xhr.status && xhr.status == 200)) {
                            // file loaded but invalid json, stop waste time !
                            f.error('There is a typo in: ' + url);
                        } else if ((status && status == 404) || (xhr && xhr.status && xhr.status == 404)) {
                            f.log('Does not exist: ' + url);
                        } else {
                            var theStatus = status ? status : ((xhr && xhr.status) ? xhr.status : null);
                            f.log(theStatus + ' when loading ' + url);
                        }
                        
                        done(error, {});
                    },
                    dataType: "json",
                    async : options.getAsync
                });
            },
            
            postMissing: function(lng, ns, key, defaultValue, lngs) {
                var payload = {};
                payload[key] = defaultValue;
                
                var urls = [];
                
                if (o.sendMissingTo === 'fallback' && o.fallbackLng[0] !== false) {
                    for (var i = 0; i < o.fallbackLng.length; i++) {
                        urls.push({lng: o.fallbackLng[i], url: applyReplacement(o.resPostPath, { lng: o.fallbackLng[i], ns: ns })});
                    }
                } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng[0] === false) ) {
                    urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
                } else if (o.sendMissingTo === 'all') {
                    for (var i = 0, l = lngs.length; i < l; i++) {
                        urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                    }
                }
                
                for (var y = 0, len = urls.length; y < len; y++) {
                    var item = urls[y];
                    f.ajax({
                        url: item.url,
                        type: o.sendType,
                        data: payload,
                        success: function(data, status, xhr) {
                            f.log('posted missing key \'' + key + '\' to: ' + item.url);
                            
                            // add key to resStore
                            var keys = key.split('.');
                            var x = 0;
                            var value = resStore[item.lng][ns];
                            while (keys[x]) {
                                if (x === keys.length - 1) {
                                    value = value[keys[x]] = defaultValue;
                                } else {
                                    value = value[keys[x]] = value[keys[x]] || {};
                                }
                                x++;
                            }
                        },
                        error : function(xhr, status, error) {
                            f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                        },
                        dataType: "json",
                        async : o.postAsync
                    });
                }
            },
            
            reload: reload
        };
        // defaults
        var o = {
            lng: undefined,
            load: 'all',
            preload: [],
            lowerCaseLng: false,
            returnObjectTrees: false,
            fallbackLng: ['dev'],
            fallbackNS: [],
            detectLngQS: 'setLng',
            detectLngFromLocalStorage: false,
            ns: 'translation',
            fallbackOnNull: true,
            fallbackOnEmpty: false,
            fallbackToDefaultNS: false,
            nsseparator: ':',
            keyseparator: '.',
            selectorAttr: 'data-i18n',
            debug: false,
            
            resGetPath: 'locales/__lng__/__ns__.json',
            resPostPath: 'locales/add/__lng__/__ns__',
            
            getAsync: true,
            postAsync: true,
            
            resStore: undefined,
            useLocalStorage: false,
            localStorageExpirationTime: 7*24*60*60*1000,
            
            dynamicLoad: false,
            sendMissing: false,
            sendMissingTo: 'fallback', // current | all
            sendType: 'POST',
            
            interpolationPrefix: '__',
            interpolationSuffix: '__',
            defaultVariables: false,
            reusePrefix: '$t(',
            reuseSuffix: ')',
            pluralSuffix: '_plural',
            pluralNotFound: ['plural_not_found', Math.random()].join(''),
            contextNotFound: ['context_not_found', Math.random()].join(''),
            escapeInterpolation: false,
            indefiniteSuffix: '_indefinite',
            indefiniteNotFound: ['indefinite_not_found', Math.random()].join(''),
            
            setJqueryExt: true,
            defaultValueFromContent: true,
            useDataAttrOptions: false,
            cookieExpirationTime: undefined,
            useCookie: true,
            cookieName: 'i18next',
            cookieDomain: undefined,
            
            objectTreeKeyHandler: undefined,
            postProcess: undefined,
            parseMissingKey: undefined,
            missingKeyHandler: sync.postMissing,
            
            shortcutFunction: 'sprintf' // or: defaultValue
        };
        function _extend(target, source) {
            if (!source || typeof source === 'function') {
                return target;
            }
            
            for (var attr in source) { target[attr] = source[attr]; }
            return target;
        }
        
        function _deepExtend(target, source) {
            for (var prop in source)
                if (prop in target)
                    _deepExtend(target[prop], source[prop]);
                else
                    target[prop] = source[prop];
            return target;
        }
        
        function _each(object, callback, args) {
            var name, i = 0,
                length = object.length,
                isObj = length === undefined || Object.prototype.toString.apply(object) !== '[object Array]' || typeof object === "function";
            
            if (args) {
                if (isObj) {
                    for (name in object) {
                        if (callback.apply(object[name], args) === false) {
                            break;
                        }
                    }
                } else {
                    for ( ; i < length; ) {
                        if (callback.apply(object[i++], args) === false) {
                            break;
                        }
                    }
                }
                
                // A special, fast, case for the most common use of each
            } else {
                if (isObj) {
                    for (name in object) {
                        if (callback.call(object[name], name, object[name]) === false) {
                            break;
                        }
                    }
                } else {
                    for ( ; i < length; ) {
                        if (callback.call(object[i], i, object[i++]) === false) {
                            break;
                        }
                    }
                }
            }
            
            return object;
        }
        
        var _entityMap = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#x2F;'
        };
        
        function _escape(data) {
            if (typeof data === 'string') {
                return data.replace(/[&<>"'\/]/g, function (s) {
                    return _entityMap[s];
                });
            }else{
                return data;
            }
        }
        
        function _ajax(options) {
            
            // v0.5.0 of https://github.com/goloroden/http.js
            var getXhr = function (callback) {
                // Use the native XHR object if the browser supports it.
                if (window.XMLHttpRequest) {
                    return callback(null, new XMLHttpRequest());
                } else if (window.ActiveXObject) {
                    // In Internet Explorer check for ActiveX versions of the XHR object.
                    try {
                        return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                    } catch (e) {
                        return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                    }
                }
                
                // If no XHR support was found, throw an error.
                return callback(new Error());
            };
            
            var encodeUsingUrlEncoding = function (data) {
                if(typeof data === 'string') {
                    return data;
                }
                
                var result = [];
                for(var dataItem in data) {
                    if(data.hasOwnProperty(dataItem)) {
                        result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                    }
                }
                
                return result.join('&');
            };
            
            var utf8 = function (text) {
                text = text.replace(/\r\n/g, '\n');
                var result = '';
                
                for(var i = 0; i < text.length; i++) {
                    var c = text.charCodeAt(i);
                    
                    if(c < 128) {
                        result += String.fromCharCode(c);
                    } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                    } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                    }
                }
                
                return result;
            };
            
            var base64 = function (text) {
                var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                
                text = utf8(text);
                var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;
                
                do {
                    chr1 = text.charCodeAt(i++);
                    chr2 = text.charCodeAt(i++);
                    chr3 = text.charCodeAt(i++);
                    
                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;
                    
                    if(isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if(isNaN(chr3)) {
                        enc4 = 64;
                    }
                    
                    result +=
                        keyStr.charAt(enc1) +
                        keyStr.charAt(enc2) +
                        keyStr.charAt(enc3) +
                        keyStr.charAt(enc4);
                    chr1 = chr2 = chr3 = '';
                    enc1 = enc2 = enc3 = enc4 = '';
                } while(i < text.length);
                
                return result;
            };
            
            var mergeHeaders = function () {
                // Use the first header object as base.
                var result = arguments[0];
                
                // Iterate through the remaining header objects and add them.
                for(var i = 1; i < arguments.length; i++) {
                    var currentHeaders = arguments[i];
                    for(var header in currentHeaders) {
                        if(currentHeaders.hasOwnProperty(header)) {
                            result[header] = currentHeaders[header];
                        }
                    }
                }
                
                // Return the merged headers.
                return result;
            };
            
            var ajax = function (method, url, options, callback) {
                // Adjust parameters.
                if(typeof options === 'function') {
                    callback = options;
                    options = {};
                }
                
                // Set default parameter values.
                options.cache = options.cache || false;
                options.data = options.data || {};
                options.headers = options.headers || {};
                options.jsonp = options.jsonp || false;
                options.async = options.async === undefined ? true : options.async;
                
                // Merge the various header objects.
                var headers = mergeHeaders({
                    'accept': '*/*',
                    'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
                }, ajax.headers, options.headers);
                
                // Encode the data according to the content-type.
                var payload;
                if (headers['content-type'] === 'application/json') {
                    payload = JSON.stringify(options.data);
                } else {
                    payload = encodeUsingUrlEncoding(options.data);
                }
                
                // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
                // if neccessary.
                if(method === 'GET') {
                    // Setup the query string.
                    var queryString = [];
                    if(payload) {
                        queryString.push(payload);
                        payload = null;
                    }
                    
                    // Handle caching.
                    if(!options.cache) {
                        queryString.push('_=' + (new Date()).getTime());
                    }
                    
                    // If neccessary prepare the query string for a JSONP call.
                    if(options.jsonp) {
                        queryString.push('callback=' + options.jsonp);
                        queryString.push('jsonp=' + options.jsonp);
                    }
                    
                    // Merge the query string and attach it to the url.
                    queryString = queryString.join('&');
                    if (queryString.length > 1) {
                        if (url.indexOf('?') > -1) {
                            url += '&' + queryString;
                        } else {
                            url += '?' + queryString;
                        }
                    }
                    
                    // Make a JSONP call if neccessary.
                    if(options.jsonp) {
                        var head = document.getElementsByTagName('head')[0];
                        var script = document.createElement('script');
                        script.type = 'text/javascript';
                        script.src = url;
                        head.appendChild(script);
                        return;
                    }
                }
                
                // Since we got here, it is no JSONP request, so make a normal XHR request.
                getXhr(function (err, xhr) {
                    if(err) return callback(err);
                    
                    // Open the request.
                    xhr.open(method, url, options.async);
                    
                    // Set the request headers.
                    for(var header in headers) {
                        if(headers.hasOwnProperty(header)) {
                            xhr.setRequestHeader(header, headers[header]);
                        }
                    }
                    
                    // Handle the request events.
                    xhr.onreadystatechange = function () {
                        if(xhr.readyState === 4) {
                            var data = xhr.responseText || '';
                            
                            // If no callback is given, return.
                            if(!callback) {
                                return;
                            }
                            
                            // Return an object that provides access to the data as text and JSON.
                            callback(xhr.status, {
                                text: function () {
                                    return data;
                                },
                                
                                json: function () {
                                    try {
                                        return JSON.parse(data)
                                    } catch (e) {
                                        f.error('Can not parse JSON. URL: ' + url);
                                        return {};
                                    }
                                }
                            });
                        }
                    };
                    
                    // Actually send the XHR request.
                    xhr.send(payload);
                });
            };
            
            // Define the external interface.
            var http = {
                authBasic: function (username, password) {
                    ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
                },
                
                connect: function (url, options, callback) {
                    return ajax('CONNECT', url, options, callback);
                },
                
                del: function (url, options, callback) {
                    return ajax('DELETE', url, options, callback);
                },
                
                get: function (url, options, callback) {
                    return ajax('GET', url, options, callback);
                },
                
                head: function (url, options, callback) {
                    return ajax('HEAD', url, options, callback);
                },
                
                headers: function (headers) {
                    ajax.headers = headers || {};
                },
                
                isAllowed: function (url, verb, callback) {
                    this.options(url, function (status, data) {
                        callback(data.text().indexOf(verb) !== -1);
                    });
                },
                
                options: function (url, options, callback) {
                    return ajax('OPTIONS', url, options, callback);
                },
                
                patch: function (url, options, callback) {
                    return ajax('PATCH', url, options, callback);
                },
                
                post: function (url, options, callback) {
                    return ajax('POST', url, options, callback);
                },
                
                put: function (url, options, callback) {
                    return ajax('PUT', url, options, callback);
                },
                
                trace: function (url, options, callback) {
                    return ajax('TRACE', url, options, callback);
                }
            };
            
            
            var methode = options.type ? options.type.toLowerCase() : 'get';
            
            http[methode](options.url, options, function (status, data) {
                // file: protocol always gives status code 0, so check for data
                if (status === 200 || (status === 0 && data.text())) {
                    options.success(data.json(), status, null);
                } else {
                    options.error(data.text(), status, null);
                }
            });
        }
        
        var _cookie = {
            create: function(name,value,minutes,domain) {
                var expires;
                if (minutes) {
                    var date = new Date();
                    date.setTime(date.getTime()+(minutes*60*1000));
                    expires = "; expires="+date.toGMTString();
                }
                else expires = "";
                domain = (domain)? "domain="+domain+";" : "";
                document.cookie = name+"="+value+expires+";"+domain+"path=/";
            },
            
            read: function(name) {
                var nameEQ = name + "=";
                var ca = document.cookie.split(';');
                for(var i=0;i < ca.length;i++) {
                    var c = ca[i];
                    while (c.charAt(0)==' ') c = c.substring(1,c.length);
                    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
                }
                return null;
            },
            
            remove: function(name) {
                this.create(name,"",-1);
            }
        };
        
        var cookie_noop = {
            create: function(name,value,minutes,domain) {},
            read: function(name) { return null; },
            remove: function(name) {}
        };
        
        
        
        // move dependent functions to a container so that
        // they can be overriden easier in no jquery environment (node.js)
        var f = {
            extend: $ ? $.extend : _extend,
            deepExtend: _deepExtend,
            each: $ ? $.each : _each,
            ajax: $ ? $.ajax : (typeof document !== 'undefined' ? _ajax : function() {}),
            cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
            detectLanguage: detectLanguage,
            escape: _escape,
            log: function(str) {
                if (o.debug && typeof console !== "undefined") console.log(str);
            },
            error: function(str) {
                if (typeof console !== "undefined") console.error(str);
            },
            getCountyIndexOfLng: function(lng) {
                var lng_index = 0;
                if (lng === 'nb-NO' || lng === 'nn-NO' || lng === 'nb-no' || lng === 'nn-no') lng_index = 1;
                return lng_index;
            },
            toLanguages: function(lng) {
                var log = this.log;
                
                function applyCase(l) {
                    var ret = l;
                    
                    if (typeof l === 'string' && l.indexOf('-') > -1) {
                        var parts = l.split('-');
                        
                        ret = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                    } else {
                        ret = o.lowerCaseLng ? l.toLowerCase() : l;
                    }
                    
                    return ret;
                }
                
                var languages = [];
                var whitelist = o.lngWhitelist || false;
                var addLanguage = function(language){
                    //reject langs not whitelisted
                    if(!whitelist || whitelist.indexOf(language) > -1){
                        languages.push(language);
                    }else{
                        log('rejecting non-whitelisted language: ' + language);
                    }
                };
                if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                    var parts = lng.split('-');
                    
                    if (o.load !== 'unspecific') addLanguage(applyCase(lng));
                    if (o.load !== 'current') addLanguage(applyCase(parts[this.getCountyIndexOfLng(lng)]));
                } else {
                    addLanguage(applyCase(lng));
                }
                
                for (var i = 0; i < o.fallbackLng.length; i++) {
                    if (languages.indexOf(o.fallbackLng[i]) === -1 && o.fallbackLng[i]) languages.push(applyCase(o.fallbackLng[i]));
                }
                return languages;
            },
            regexEscape: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            regexReplacementEscape: function(strOrFn) {
                if (typeof strOrFn === 'string') {
                    return strOrFn.replace(/\$/g, "$$$$");
                } else {
                    return strOrFn;
                }
            },
            localStorage: {
                setItem: function(key, value) {
                    if (window.localStorage) {
                        try {
                            window.localStorage.setItem(key, value);
                        } catch (e) {
                            f.log('failed to set value for key "' + key + '" to localStorage.');
                        }
                    }
                }
            }
        };
        function init(options, cb) {
            
            if (typeof options === 'function') {
                cb = options;
                options = {};
            }
            options = options || {};
            
            // override defaults with passed in options
            f.extend(o, options);
            delete o.fixLng; /* passed in each time */
            
            // override functions: .log(), .detectLanguage(), etc
            if (o.functions) {
                delete o.functions;
                f.extend(f, options.functions);
            }
            
            // create namespace object if namespace is passed in as string
            if (typeof o.ns == 'string') {
                o.ns = { namespaces: [o.ns], defaultNs: o.ns};
            }
            
            // fallback namespaces
            if (typeof o.fallbackNS == 'string') {
                o.fallbackNS = [o.fallbackNS];
            }
            
            // fallback languages
            if (typeof o.fallbackLng == 'string' || typeof o.fallbackLng == 'boolean') {
                o.fallbackLng = [o.fallbackLng];
            }
            
            // escape prefix/suffix
            o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
            o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);
            
            if (!o.lng) o.lng = f.detectLanguage();
            
            languages = f.toLanguages(o.lng);
            currentLng = languages[0];
            f.log('currentLng set to: ' + currentLng);
            
            if (o.useCookie && f.cookie.read(o.cookieName) !== currentLng){ //cookie is unset or invalid
                f.cookie.create(o.cookieName, currentLng, o.cookieExpirationTime, o.cookieDomain);
            }
            if (o.detectLngFromLocalStorage && typeof document !== 'undefined' && window.localStorage) {
                f.localStorage.setItem('i18next_lng', currentLng);
            }
            
            var lngTranslate = translate;
            if (options.fixLng) {
                lngTranslate = function(key, options) {
                    options = options || {};
                    options.lng = options.lng || lngTranslate.lng;
                    return translate(key, options);
                };
                lngTranslate.lng = currentLng;
            }
            
            pluralExtensions.setCurrentLng(currentLng);
            
            // add JQuery extensions
            if ($ && o.setJqueryExt) addJqueryFunct();
            
            // jQuery deferred
            var deferred;
            if ($ && $.Deferred) {
                deferred = $.Deferred();
            }
            
            // return immidiatly if res are passed in
            if (o.resStore) {
                resStore = o.resStore;
                initialized = true;
                if (cb) cb(lngTranslate);
                if (deferred) deferred.resolve(lngTranslate);
                if (deferred) return deferred.promise();
                return;
            }
            
            // languages to load
            var lngsToLoad = f.toLanguages(o.lng);
            if (typeof o.preload === 'string') o.preload = [o.preload];
            for (var i = 0, l = o.preload.length; i < l; i++) {
                var pres = f.toLanguages(o.preload[i]);
                for (var y = 0, len = pres.length; y < len; y++) {
                    if (lngsToLoad.indexOf(pres[y]) < 0) {
                        lngsToLoad.push(pres[y]);
                    }
                }
            }
            
            // else load them
            i18n.sync.load(lngsToLoad, o, function(err, store) {
                resStore = store;
                initialized = true;
                
                if (cb) cb(lngTranslate);
                if (deferred) deferred.resolve(lngTranslate);
            });
            
            if (deferred) return deferred.promise();
        }
        function preload(lngs, cb) {
            if (typeof lngs === 'string') lngs = [lngs];
            for (var i = 0, l = lngs.length; i < l; i++) {
                if (o.preload.indexOf(lngs[i]) < 0) {
                    o.preload.push(lngs[i]);
                }
            }
            return init(cb);
        }
        
        function addResourceBundle(lng, ns, resources, deep) {
            if (typeof ns !== 'string') {
                resources = ns;
                ns = o.ns.defaultNs;
            } else if (o.ns.namespaces.indexOf(ns) < 0) {
                o.ns.namespaces.push(ns);
            }
            
            resStore[lng] = resStore[lng] || {};
            resStore[lng][ns] = resStore[lng][ns] || {};
            
            if (deep) {
                f.deepExtend(resStore[lng][ns], resources);
            } else {
                f.extend(resStore[lng][ns], resources);
            }
        }
        
        function hasResourceBundle(lng, ns) {
            if (typeof ns !== 'string') {
                ns = o.ns.defaultNs;
            }
            
            resStore[lng] = resStore[lng] || {};
            var res = resStore[lng][ns] || {};
            
            var hasValues = false;
            for(var prop in res) {
                if (res.hasOwnProperty(prop)) {
                    hasValues = true;
                }
            }
            
            return hasValues;
        }
        
        function removeResourceBundle(lng, ns) {
            if (typeof ns !== 'string') {
                ns = o.ns.defaultNs;
            }
            
            resStore[lng] = resStore[lng] || {};
            resStore[lng][ns] = {};
        }
        
        function addResource(lng, ns, key, value) {
            if (typeof ns !== 'string') {
                resource = ns;
                ns = o.ns.defaultNs;
            } else if (o.ns.namespaces.indexOf(ns) < 0) {
                o.ns.namespaces.push(ns);
            }
            
            resStore[lng] = resStore[lng] || {};
            resStore[lng][ns] = resStore[lng][ns] || {};
            
            var keys = key.split(o.keyseparator);
            var x = 0;
            var node = resStore[lng][ns];
            var origRef = node;
            
            while (keys[x]) {
                if (x == keys.length - 1)
                    node[keys[x]] = value;
                else {
                    if (node[keys[x]] == null)
                        node[keys[x]] = {};
                    
                    node = node[keys[x]];
                }
                x++;
            }
        }
        
        function addResources(lng, ns, resources) {
            if (typeof ns !== 'string') {
                resource = ns;
                ns = o.ns.defaultNs;
            } else if (o.ns.namespaces.indexOf(ns) < 0) {
                o.ns.namespaces.push(ns);
            }
            
            for (var m in resources) {
                if (typeof resources[m] === 'string') addResource(lng, ns, m, resources[m]);
            }
        }
        
        function setDefaultNamespace(ns) {
            o.ns.defaultNs = ns;
        }
        
        function loadNamespace(namespace, cb) {
            loadNamespaces([namespace], cb);
        }
        
        function loadNamespaces(namespaces, cb) {
            var opts = {
                dynamicLoad: o.dynamicLoad,
                resGetPath: o.resGetPath,
                getAsync: o.getAsync,
                customLoad: o.customLoad,
                ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
            };
            
            // languages to load
            var lngsToLoad = f.toLanguages(o.lng);
            if (typeof o.preload === 'string') o.preload = [o.preload];
            for (var i = 0, l = o.preload.length; i < l; i++) {
                var pres = f.toLanguages(o.preload[i]);
                for (var y = 0, len = pres.length; y < len; y++) {
                    if (lngsToLoad.indexOf(pres[y]) < 0) {
                        lngsToLoad.push(pres[y]);
                    }
                }
            }
            
            // check if we have to load
            var lngNeedLoad = [];
            for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
                var needLoad = false;
                var resSet = resStore[lngsToLoad[a]];
                if (resSet) {
                    for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                        if (!resSet[namespaces[b]]) needLoad = true;
                    }
                } else {
                    needLoad = true;
                }
                
                if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
            }
            
            if (lngNeedLoad.length) {
                i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                    var todo = namespaces.length * lngNeedLoad.length;
                    
                    // load each file individual
                    f.each(namespaces, function(nsIndex, nsValue) {
                        
                        // append namespace to namespace array
                        if (o.ns.namespaces.indexOf(nsValue) < 0) {
                            o.ns.namespaces.push(nsValue);
                        }
                        
                        f.each(lngNeedLoad, function(lngIndex, lngValue) {
                            resStore[lngValue] = resStore[lngValue] || {};
                            resStore[lngValue][nsValue] = store[lngValue][nsValue];
                            
                            todo--; // wait for all done befor callback
                            if (todo === 0 && cb) {
                                if (o.useLocalStorage) i18n.sync._storeLocal(resStore);
                                cb();
                            }
                        });
                    });
                });
            } else {
                if (cb) cb();
            }
        }
        
        function setLng(lng, options, cb) {
            if (typeof options === 'function') {
                cb = options;
                options = {};
            } else if (!options) {
                options = {};
            }
            
            options.lng = lng;
            return init(options, cb);
        }
        
        function lng() {
            return currentLng;
        }
        
        function reload(cb) {
            resStore = {};
            setLng(currentLng, cb);
        }
        function addJqueryFunct() {
            // $.t shortcut
            $.t = $.t || translate;
            
            function parse(ele, key, options) {
                if (key.length === 0) return;
                
                var attr = 'text';
                
                if (key.indexOf('[') === 0) {
                    var parts = key.split(']');
                    key = parts[1];
                    attr = parts[0].substr(1, parts[0].length-1);
                }
                
                if (key.indexOf(';') === key.length-1) {
                    key = key.substr(0, key.length-2);
                }
                
                var optionsToUse;
                if (attr === 'html') {
                    optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                    ele.html($.t(key, optionsToUse));
                } else if (attr === 'text') {
                    optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.text() }, options) : options;
                    ele.text($.t(key, optionsToUse));
                } else if (attr === 'prepend') {
                    optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                    ele.prepend($.t(key, optionsToUse));
                } else if (attr === 'append') {
                    optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                    ele.append($.t(key, optionsToUse));
                } else if (attr.indexOf("data-") === 0) {
                    var dataAttr = attr.substr(("data-").length);
                    optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.data(dataAttr) }, options) : options;
                    var translated = $.t(key, optionsToUse);
                    //we change into the data cache
                    ele.data(dataAttr, translated);
                    //we change into the dom
                    ele.attr(attr, translated);
                } else {
                    optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.attr(attr) }, options) : options;
                    ele.attr(attr, $.t(key, optionsToUse));
                }
            }
            
            function localize(ele, options) {
                var key = ele.attr(o.selectorAttr);
                if (!key && typeof key !== 'undefined' && key !== false) key = ele.text() || ele.val();
                if (!key) return;
                
                var target = ele
                    , targetSelector = ele.data("i18n-target");
                if (targetSelector) {
                    target = ele.find(targetSelector) || ele;
                }
                
                if (!options && o.useDataAttrOptions === true) {
                    options = ele.data("i18n-options");
                }
                options = options || {};
                
                if (key.indexOf(';') >= 0) {
                    var keys = key.split(';');
                    
                    $.each(keys, function(m, k) {
                        if (k !== '') parse(target, k, options);
                    });
                    
                } else {
                    parse(target, key, options);
                }
                
                if (o.useDataAttrOptions === true) ele.data("i18n-options", options);
            }
            
            // fn
            $.fn.i18n = function (options) {
                return this.each(function() {
                    // localize element itself
                    localize($(this), options);
                    
                    // localize childs
                    var elements =  $(this).find('[' + o.selectorAttr + ']');
                    elements.each(function() {
                        localize($(this), options);
                    });
                });
            };
        }
        function applyReplacement(str, replacementHash, nestedKey, options) {
            if (!str) return str;
            
            options = options || replacementHash; // first call uses replacement hash combined with options
            if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;
            
            var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
                , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
                , unEscapingSuffix = 'HTML'+suffix;
            
            var hash = replacementHash.replace && typeof replacementHash.replace === 'object' ? replacementHash.replace : replacementHash;
            f.each(hash, function(key, value) {
                var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
                if (typeof value === 'object' && value !== null) {
                    str = applyReplacement(str, value, nextKey, options);
                } else {
                    if (options.escapeInterpolation || o.escapeInterpolation) {
                        str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), f.regexReplacementEscape(value));
                        str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(f.escape(value)));
                    } else {
                        str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(value));
                    }
                    // str = options.escapeInterpolation;
                }
            });
            return str;
        }
        
        // append it to functions
        f.applyReplacement = applyReplacement;
        
        function applyReuse(translated, options) {
            var comma = ',';
            var options_open = '{';
            var options_close = '}';
            
            var opts = f.extend({}, options);
            delete opts.postProcess;
            
            while (translated.indexOf(o.reusePrefix) != -1) {
                replacementCounter++;
                if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
                var index_of_opening = translated.lastIndexOf(o.reusePrefix);
                var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
                var token = translated.substring(index_of_opening, index_of_end_of_closing);
                var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');
                
                if (index_of_end_of_closing <= index_of_opening) {
                    f.error('there is an missing closing in following translation value', translated);
                    return '';
                }
                
                if (token_without_symbols.indexOf(comma) != -1) {
                    var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                    if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                        var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                        var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                        try {
                            opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                            token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                        } catch (e) {
                        }
                    }
                }
                
                var translated_token = _translate(token_without_symbols, opts);
                translated = translated.replace(token, f.regexReplacementEscape(translated_token));
            }
            return translated;
        }
        
        function hasContext(options) {
            return (options.context && (typeof options.context == 'string' || typeof options.context == 'number'));
        }
        
        function needsPlural(options, lng) {
            return (options.count !== undefined && typeof options.count != 'string'/* && pluralExtensions.needsPlural(lng, options.count)*/);
        }
        
        function needsIndefiniteArticle(options) {
            return (options.indefinite_article !== undefined && typeof options.indefinite_article != 'string' && options.indefinite_article);
        }
        
        function exists(key, options) {
            options = options || {};
            
            var notFound = _getDefaultValue(key, options)
                , found = _find(key, options);
            
            return found !== undefined || found === notFound;
        }
        
        function translate(key, options) {
            options = options || {};
            
            if (!initialized) {
                f.log('i18next not finished initialization. you might have called t function before loading resources finished.')
                return options.defaultValue || '';
            };
            replacementCounter = 0;
            return _translate.apply(null, arguments);
        }
        
        function _getDefaultValue(key, options) {
            return (options.defaultValue !== undefined) ? options.defaultValue : key;
        }
        
        function _injectSprintfProcessor() {
            
            var values = [];
            
            // mh: build array from second argument onwards
            for (var i = 1; i < arguments.length; i++) {
                values.push(arguments[i]);
            }
            
            return {
                postProcess: 'sprintf',
                sprintf:     values
            };
        }
        
        function _translate(potentialKeys, options) {
            if (options && typeof options !== 'object') {
                if (o.shortcutFunction === 'sprintf') {
                    // mh: gettext like sprintf syntax found, automatically create sprintf processor
                    options = _injectSprintfProcessor.apply(null, arguments);
                } else if (o.shortcutFunction === 'defaultValue') {
                    options = {
                        defaultValue: options
                    }
                }
            } else {
                options = options || {};
            }
            
            if (typeof o.defaultVariables === 'object') {
                options = f.extend({}, o.defaultVariables, options);
            }
            
            if (potentialKeys === undefined || potentialKeys === null || potentialKeys === '') return '';
            
            if (typeof potentialKeys === 'string') {
                potentialKeys = [potentialKeys];
            }
            
            var key = potentialKeys[0];
            
            if (potentialKeys.length > 1) {
                for (var i = 0; i < potentialKeys.length; i++) {
                    key = potentialKeys[i];
                    if (exists(key, options)) {
                        break;
                    }
                }
            }
            
            var notFound = _getDefaultValue(key, options)
                , found = _find(key, options)
                , lngs = options.lng ? f.toLanguages(options.lng, options.fallbackLng) : languages
                , ns = options.ns || o.ns.defaultNs
                , parts;
            
            // split ns and key
            if (key.indexOf(o.nsseparator) > -1) {
                parts = key.split(o.nsseparator);
                ns = parts[0];
                key = parts[1];
            }
            
            if (found === undefined && o.sendMissing && typeof o.missingKeyHandler === 'function') {
                if (options.lng) {
                    o.missingKeyHandler(lngs[0], ns, key, notFound, lngs);
                } else {
                    o.missingKeyHandler(o.lng, ns, key, notFound, lngs);
                }
            }
            
            var postProcessor = options.postProcess || o.postProcess;
            if (found !== undefined && postProcessor) {
                if (postProcessors[postProcessor]) {
                    found = postProcessors[postProcessor](found, key, options);
                }
            }
            
            // process notFound if function exists
            var splitNotFound = notFound;
            if (notFound.indexOf(o.nsseparator) > -1) {
                parts = notFound.split(o.nsseparator);
                splitNotFound = parts[1];
            }
            if (splitNotFound === key && o.parseMissingKey) {
                notFound = o.parseMissingKey(notFound);
            }
            
            if (found === undefined) {
                notFound = applyReplacement(notFound, options);
                notFound = applyReuse(notFound, options);
                
                if (postProcessor && postProcessors[postProcessor]) {
                    var val = _getDefaultValue(key, options);
                    found = postProcessors[postProcessor](val, key, options);
                }
            }
            
            return (found !== undefined) ? found : notFound;
        }
        
        function _find(key, options) {
            options = options || {};
            
            var optionWithoutCount, translated
                , notFound = _getDefaultValue(key, options)
                , lngs = languages;
            
            if (!resStore) { return notFound; } // no resStore to translate from
            
            // CI mode
            if (lngs[0].toLowerCase() === 'cimode') return notFound;
            
            // passed in lng
            if (options.lngs) lngs = options.lngs;
            if (options.lng) {
                lngs = f.toLanguages(options.lng, options.fallbackLng);
                
                if (!resStore[lngs[0]]) {
                    var oldAsync = o.getAsync;
                    o.getAsync = false;
                    
                    i18n.sync.load(lngs, o, function(err, store) {
                        f.extend(resStore, store);
                        o.getAsync = oldAsync;
                    });
                }
            }
            
            var ns = options.ns || o.ns.defaultNs;
            if (key.indexOf(o.nsseparator) > -1) {
                var parts = key.split(o.nsseparator);
                ns = parts[0];
                key = parts[1];
            }
            
            if (hasContext(options)) {
                optionWithoutCount = f.extend({}, options);
                delete optionWithoutCount.context;
                optionWithoutCount.defaultValue = o.contextNotFound;
                
                var contextKey = ns + o.nsseparator + key + '_' + options.context;
                
                translated = translate(contextKey, optionWithoutCount);
                if (translated != o.contextNotFound) {
                    return applyReplacement(translated, { context: options.context }); // apply replacement for context only
                } // else continue translation with original/nonContext key
            }
            
            if (needsPlural(options, lngs[0])) {
                optionWithoutCount = f.extend({ lngs: [lngs[0]]}, options);
                delete optionWithoutCount.count;
                delete optionWithoutCount.lng;
                optionWithoutCount.defaultValue = o.pluralNotFound;
                
                var pluralKey;
                if (!pluralExtensions.needsPlural(lngs[0], options.count)) {
                    pluralKey = ns + o.nsseparator + key;
                } else {
                    pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
                    var pluralExtension = pluralExtensions.get(lngs[0], options.count);
                    if (pluralExtension >= 0) {
                        pluralKey = pluralKey + '_' + pluralExtension;
                    } else if (pluralExtension === 1) {
                        pluralKey = ns + o.nsseparator + key; // singular
                    }
                }
                
                translated = translate(pluralKey, optionWithoutCount);
                
                if (translated != o.pluralNotFound) {
                    return applyReplacement(translated, {
                        count: options.count,
                        interpolationPrefix: options.interpolationPrefix,
                        interpolationSuffix: options.interpolationSuffix
                    }); // apply replacement for count only
                } else if (lngs.length > 1) {
                    // remove failed lng
                    var clone = lngs.slice();
                    clone.shift();
                    options = f.extend(options, { lngs: clone });
                    delete options.lng;
                    // retry with fallbacks
                    translated = translate(ns + o.nsseparator + key, options);
                    if (translated != o.pluralNotFound) return translated;
                } else {
                    return translated;
                }
            }
            
            if (needsIndefiniteArticle(options)) {
                var optionsWithoutIndef = f.extend({}, options);
                delete optionsWithoutIndef.indefinite_article;
                optionsWithoutIndef.defaultValue = o.indefiniteNotFound;
                // If we don't have a count, we want the indefinite, if we do have a count, and needsPlural is false
                var indefiniteKey = ns + o.nsseparator + key + (((options.count && !needsPlural(options, lngs[0])) || !options.count) ? o.indefiniteSuffix : "");
                translated = translate(indefiniteKey, optionsWithoutIndef);
                if (translated != o.indefiniteNotFound) {
                    return translated;
                }
            }
            
            var found;
            var keys = key.split(o.keyseparator);
            for (var i = 0, len = lngs.length; i < len; i++ ) {
                if (found !== undefined) break;
                
                var l = lngs[i];
                
                var x = 0;
                var value = resStore[l] && resStore[l][ns];
                while (keys[x]) {
                    value = value && value[keys[x]];
                    x++;
                }
                if (value !== undefined) {
                    var valueType = Object.prototype.toString.apply(value);
                    if (typeof value === 'string') {
                        value = applyReplacement(value, options);
                        value = applyReuse(value, options);
                    } else if (valueType === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                        value = value.join('\n');
                        value = applyReplacement(value, options);
                        value = applyReuse(value, options);
                    } else if (value === null && o.fallbackOnNull === true) {
                        value = undefined;
                    } else if (value !== null) {
                        if (!o.returnObjectTrees && !options.returnObjectTrees) {
                            if (o.objectTreeKeyHandler && typeof o.objectTreeKeyHandler == 'function') {
                                value = o.objectTreeKeyHandler(key, value, l, ns, options);
                            } else {
                                value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                                    'returned an object instead of string.';
                                f.log(value);
                            }
                        } else if (valueType !== '[object Number]' && valueType !== '[object Function]' && valueType !== '[object RegExp]') {
                            var copy = (valueType === '[object Array]') ? [] : {}; // apply child translation on a copy
                            f.each(value, function(m) {
                                copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                            });
                            value = copy;
                        }
                    }
                    
                    if (typeof value === 'string' && value.trim() === '' && o.fallbackOnEmpty === true)
                        value = undefined;
                    
                    found = value;
                }
            }
            
            if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) {
                // set flag for fallback lookup - avoid recursion
                options.isFallbackLookup = true;
                
                if (o.fallbackNS.length) {
                    
                    for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                        found = _find(o.fallbackNS[y] + o.nsseparator + key, options);
                        
                        if (found || (found==="" && o.fallbackOnEmpty === false)) {
                            /* compare value without namespace */
                            var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                                , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;
                            
                            if (foundValue !== notFoundValue) break;
                        }
                    }
                } else {
                    found = _find(key, options); // fallback to default NS
                }
                options.isFallbackLookup = false;
            }
            
            return found;
        }
        function detectLanguage() {
            var detectedLng;
            var whitelist = o.lngWhitelist || [];
            var userLngChoices = [];
            
            // get from qs
            var qsParm = [];
            if (typeof window !== 'undefined') {
                (function() {
                    var query = window.location.search.substring(1);
                    var params = query.split('&');
                    for (var i=0; i<params.length; i++) {
                        var pos = params[i].indexOf('=');
                        if (pos > 0) {
                            var key = params[i].substring(0,pos);
                            if (key == o.detectLngQS) {
                                userLngChoices.push(params[i].substring(pos+1));
                            }
                        }
                    }
                })();
            }
            
            // get from cookie
            if (o.useCookie && typeof document !== 'undefined') {
                var c = f.cookie.read(o.cookieName);
                if (c) userLngChoices.push(c);
            }
            
            // get from localStorage
            if (o.detectLngFromLocalStorage && typeof window !== 'undefined' && window.localStorage) {
                userLngChoices.push(window.localStorage.getItem('i18next_lng'));
            }
            
            // get from navigator
            if (typeof navigator !== 'undefined') {
                if (navigator.languages) { // chrome only; not an array, so can't use .push.apply instead of iterating
                    for (var i=0;i<navigator.languages.length;i++) {
                        userLngChoices.push(navigator.languages[i]);
                    }
                }
                if (navigator.userLanguage) {
                    userLngChoices.push(navigator.userLanguage);
                }
                if (navigator.language) {
                    userLngChoices.push(navigator.language);
                }
            }
            
            (function() {
                for (var i=0;i<userLngChoices.length;i++) {
                    var lng = userLngChoices[i];
                    
                    if (lng.indexOf('-') > -1) {
                        var parts = lng.split('-');
                        lng = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                    }
                    
                    if (whitelist.length === 0 || whitelist.indexOf(lng) > -1) {
                        detectedLng = lng;
                        break;
                    }
                }
            })();
            
            //fallback
            if (!detectedLng){
                detectedLng = o.fallbackLng[0];
            }
            
            return detectedLng;
        }
        // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
        
        /* [code, name, numbers, pluralsType] */
        var _rules = [
            ["ach", "Acholi", [1,2], 1],
            ["af", "Afrikaans",[1,2], 2],
            ["ak", "Akan", [1,2], 1],
            ["am", "Amharic", [1,2], 1],
            ["an", "Aragonese",[1,2], 2],
            ["ar", "Arabic", [0,1,2,3,11,100],5],
            ["arn", "Mapudungun",[1,2], 1],
            ["ast", "Asturian", [1,2], 2],
            ["ay", "Aymará", [1], 3],
            ["az", "Azerbaijani",[1,2],2],
            ["be", "Belarusian",[1,2,5],4],
            ["bg", "Bulgarian",[1,2], 2],
            ["bn", "Bengali", [1,2], 2],
            ["bo", "Tibetan", [1], 3],
            ["br", "Breton", [1,2], 1],
            ["bs", "Bosnian", [1,2,5],4],
            ["ca", "Catalan", [1,2], 2],
            ["cgg", "Chiga", [1], 3],
            ["cs", "Czech", [1,2,5],6],
            ["csb", "Kashubian",[1,2,5],7],
            ["cy", "Welsh", [1,2,3,8],8],
            ["da", "Danish", [1,2], 2],
            ["de", "German", [1,2], 2],
            ["dev", "Development Fallback", [1,2], 2],
            ["dz", "Dzongkha", [1], 3],
            ["el", "Greek", [1,2], 2],
            ["en", "English", [1,2], 2],
            ["eo", "Esperanto",[1,2], 2],
            ["es", "Spanish", [1,2], 2],
            ["es_ar","Argentinean Spanish", [1,2], 2],
            ["et", "Estonian", [1,2], 2],
            ["eu", "Basque", [1,2], 2],
            ["fa", "Persian", [1], 3],
            ["fi", "Finnish", [1,2], 2],
            ["fil", "Filipino", [1,2], 1],
            ["fo", "Faroese", [1,2], 2],
            ["fr", "French", [1,2], 9],
            ["fur", "Friulian", [1,2], 2],
            ["fy", "Frisian", [1,2], 2],
            ["ga", "Irish", [1,2,3,7,11],10],
            ["gd", "Scottish Gaelic",[1,2,3,20],11],
            ["gl", "Galician", [1,2], 2],
            ["gu", "Gujarati", [1,2], 2],
            ["gun", "Gun", [1,2], 1],
            ["ha", "Hausa", [1,2], 2],
            ["he", "Hebrew", [1,2], 2],
            ["hi", "Hindi", [1,2], 2],
            ["hr", "Croatian", [1,2,5],4],
            ["hu", "Hungarian",[1,2], 2],
            ["hy", "Armenian", [1,2], 2],
            ["ia", "Interlingua",[1,2],2],
            ["id", "Indonesian",[1], 3],
            ["is", "Icelandic",[1,2], 12],
            ["it", "Italian", [1,2], 2],
            ["ja", "Japanese", [1], 3],
            ["jbo", "Lojban", [1], 3],
            ["jv", "Javanese", [0,1], 13],
            ["ka", "Georgian", [1], 3],
            ["kk", "Kazakh", [1], 3],
            ["km", "Khmer", [1], 3],
            ["kn", "Kannada", [1,2], 2],
            ["ko", "Korean", [1], 3],
            ["ku", "Kurdish", [1,2], 2],
            ["kw", "Cornish", [1,2,3,4],14],
            ["ky", "Kyrgyz", [1], 3],
            ["lb", "Letzeburgesch",[1,2],2],
            ["ln", "Lingala", [1,2], 1],
            ["lo", "Lao", [1], 3],
            ["lt", "Lithuanian",[1,2,10],15],
            ["lv", "Latvian", [1,2,0],16],
            ["mai", "Maithili", [1,2], 2],
            ["mfe", "Mauritian Creole",[1,2],1],
            ["mg", "Malagasy", [1,2], 1],
            ["mi", "Maori", [1,2], 1],
            ["mk", "Macedonian",[1,2],17],
            ["ml", "Malayalam",[1,2], 2],
            ["mn", "Mongolian",[1,2], 2],
            ["mnk", "Mandinka", [0,1,2],18],
            ["mr", "Marathi", [1,2], 2],
            ["ms", "Malay", [1], 3],
            ["mt", "Maltese", [1,2,11,20],19],
            ["nah", "Nahuatl", [1,2], 2],
            ["nap", "Neapolitan",[1,2], 2],
            ["nb", "Norwegian Bokmal",[1,2],2],
            ["ne", "Nepali", [1,2], 2],
            ["nl", "Dutch", [1,2], 2],
            ["nn", "Norwegian Nynorsk",[1,2],2],
            ["no", "Norwegian",[1,2], 2],
            ["nso", "Northern Sotho",[1,2],2],
            ["oc", "Occitan", [1,2], 1],
            ["or", "Oriya", [2,1], 2],
            ["pa", "Punjabi", [1,2], 2],
            ["pap", "Papiamento",[1,2], 2],
            ["pl", "Polish", [1,2,5],7],
            ["pms", "Piemontese",[1,2], 2],
            ["ps", "Pashto", [1,2], 2],
            ["pt", "Portuguese",[1,2], 2],
            ["pt_br","Brazilian Portuguese",[1,2], 2],
            ["rm", "Romansh", [1,2], 2],
            ["ro", "Romanian", [1,2,20],20],
            ["ru", "Russian", [1,2,5],4],
            ["sah", "Yakut", [1], 3],
            ["sco", "Scots", [1,2], 2],
            ["se", "Northern Sami",[1,2], 2],
            ["si", "Sinhala", [1,2], 2],
            ["sk", "Slovak", [1,2,5],6],
            ["sl", "Slovenian",[5,1,2,3],21],
            ["so", "Somali", [1,2], 2],
            ["son", "Songhay", [1,2], 2],
            ["sq", "Albanian", [1,2], 2],
            ["sr", "Serbian", [1,2,5],4],
            ["su", "Sundanese",[1], 3],
            ["sv", "Swedish", [1,2], 2],
            ["sw", "Swahili", [1,2], 2],
            ["ta", "Tamil", [1,2], 2],
            ["te", "Telugu", [1,2], 2],
            ["tg", "Tajik", [1,2], 1],
            ["th", "Thai", [1], 3],
            ["ti", "Tigrinya", [1,2], 1],
            ["tk", "Turkmen", [1,2], 2],
            ["tr", "Turkish", [1,2], 1],
            ["tt", "Tatar", [1], 3],
            ["ug", "Uyghur", [1], 3],
            ["uk", "Ukrainian",[1,2,5],4],
            ["ur", "Urdu", [1,2], 2],
            ["uz", "Uzbek", [1,2], 1],
            ["vi", "Vietnamese",[1], 3],
            ["wa", "Walloon", [1,2], 1],
            ["wo", "Wolof", [1], 3],
            ["yo", "Yoruba", [1,2], 2],
            ["zh", "Chinese", [1], 3]
        ];
        
        var _rulesPluralsTypes = {
            1: function(n) {return Number(n > 1);},
            2: function(n) {return Number(n != 1);},
            3: function(n) {return 0;},
            4: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
            5: function(n) {return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5);},
            6: function(n) {return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2);},
            7: function(n) {return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
            8: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3);},
            9: function(n) {return Number(n >= 2);},
            10: function(n) {return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;},
            11: function(n) {return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3);},
            12: function(n) {return Number(n%10!=1 || n%100==11);},
            13: function(n) {return Number(n !== 0);},
            14: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3);},
            15: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2);},
            16: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2);},
            17: function(n) {return Number(n==1 || n%10==1 ? 0 : 1);},
            18: function(n) {return Number(0 ? 0 : n==1 ? 1 : 2);},
            19: function(n) {return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3);},
            20: function(n) {return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2);},
            21: function(n) {return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
        };
        
        var pluralExtensions = {
            
            rules: (function () {
                var l, rules = {};
                for (l=_rules.length; l-- ;) {
                    rules[_rules[l][0]] = {
                        name: _rules[l][1],
                        numbers: _rules[l][2],
                        plurals: _rulesPluralsTypes[_rules[l][3]]
                    }
                }
                return rules;
            }()),
            
            // you can add your own pluralExtensions
            addRule: function(lng, obj) {
                pluralExtensions.rules[lng] = obj;
            },
            
            setCurrentLng: function(lng) {
                if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                    var parts = lng.split('-');
                    
                    pluralExtensions.currentRule = {
                        lng: lng,
                        rule: pluralExtensions.rules[parts[0]]
                    };
                }
            },
            
            needsPlural: function(lng, count) {
                var parts = lng.split('-');
                
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule;
                } else {
                    ext = pluralExtensions.rules[parts[f.getCountyIndexOfLng(lng)]];
                }
                
                if (ext && ext.numbers.length <= 1) {
                    return false;
                } else {
                    return this.get(lng, count) !== 1;
                }
            },
            
            get: function(lng, count) {
                var parts = lng.split('-');
                
                function getResult(l, c) {
                    var ext;
                    if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                        ext = pluralExtensions.currentRule.rule;
                    } else {
                        ext = pluralExtensions.rules[l];
                    }
                    if (ext) {
                        var i;
                        if (ext.noAbs) {
                            i = ext.plurals(c);
                        } else {
                            i = ext.plurals(Math.abs(c));
                        }
                        
                        var number = ext.numbers[i];
                        if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                            if (number === 2) {
                                number = -1; // regular plural
                            } else if (number === 1) {
                                number = 1; // singular
                            }
                        }//console.log(count + '-' + number);
                        return number;
                    } else {
                        return c === 1 ? '1' : '-1';
                    }
                }
                
                return getResult(parts[f.getCountyIndexOfLng(lng)], count);
            }
            
        };
        var postProcessors = {};
        var addPostProcessor = function(name, fc) {
            postProcessors[name] = fc;
        };
        // sprintf support
        var sprintf = (function() {
            function get_type(variable) {
                return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
            }
            function str_repeat(input, multiplier) {
                for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
                return output.join('');
            }
            
            var str_format = function() {
                if (!str_format.cache.hasOwnProperty(arguments[0])) {
                    str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
                }
                return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
            };
            
            str_format.format = function(parse_tree, argv) {
                var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
                for (i = 0; i < tree_length; i++) {
                    node_type = get_type(parse_tree[i]);
                    if (node_type === 'string') {
                        output.push(parse_tree[i]);
                    }
                    else if (node_type === 'array') {
                        match = parse_tree[i]; // convenience purposes only
                        if (match[2]) { // keyword argument
                            arg = argv[cursor];
                            for (k = 0; k < match[2].length; k++) {
                                if (!arg.hasOwnProperty(match[2][k])) {
                                    throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                                }
                                arg = arg[match[2][k]];
                            }
                        }
                        else if (match[1]) { // positional argument (explicit)
                            arg = argv[match[1]];
                        }
                        else { // positional argument (implicit)
                            arg = argv[cursor++];
                        }
                        
                        if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                            throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                        }
                        switch (match[8]) {
                            case 'b': arg = arg.toString(2); break;
                            case 'c': arg = String.fromCharCode(arg); break;
                            case 'd': arg = parseInt(arg, 10); break;
                            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                            case 'o': arg = arg.toString(8); break;
                            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                            case 'u': arg = Math.abs(arg); break;
                            case 'x': arg = arg.toString(16); break;
                            case 'X': arg = arg.toString(16).toUpperCase(); break;
                        }
                        arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                        pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                        pad_length = match[6] - String(arg).length;
                        pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                        output.push(match[5] ? arg + pad : pad + arg);
                    }
                }
                return output.join('');
            };
            
            str_format.cache = {};
            
            str_format.parse = function(fmt) {
                var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
                while (_fmt) {
                    if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                        parse_tree.push(match[0]);
                    }
                    else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                        parse_tree.push('%');
                    }
                    else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                        if (match[2]) {
                            arg_names |= 1;
                            var field_list = [], replacement_field = match[2], field_match = [];
                            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                    if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1]);
                                    }
                                    else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1]);
                                    }
                                    else {
                                        throw('[sprintf] huh?');
                                    }
                                }
                            }
                            else {
                                throw('[sprintf] huh?');
                            }
                            match[2] = field_list;
                        }
                        else {
                            arg_names |= 2;
                        }
                        if (arg_names === 3) {
                            throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                        }
                        parse_tree.push(match);
                    }
                    else {
                        throw('[sprintf] huh?');
                    }
                    _fmt = _fmt.substring(match[0].length);
                }
                return parse_tree;
            };
            
            return str_format;
        })();
        
        var vsprintf = function(fmt, argv) {
            argv.unshift(fmt);
            return sprintf.apply(null, argv);
        };
        
        addPostProcessor("sprintf", function(val, key, opts) {
            if (!opts.sprintf) return val;
            
            if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
                return vsprintf(val, opts.sprintf);
            } else if (typeof opts.sprintf === 'object') {
                return sprintf(val, opts.sprintf);
            }
            
            return val;
        });
        // public api interface
        i18n.init = init;
        i18n.setLng = setLng;
        i18n.preload = preload;
        i18n.addResourceBundle = addResourceBundle;
        i18n.hasResourceBundle = hasResourceBundle;
        i18n.addResource = addResource;
        i18n.addResources = addResources;
        i18n.removeResourceBundle = removeResourceBundle;
        i18n.loadNamespace = loadNamespace;
        i18n.loadNamespaces = loadNamespaces;
        i18n.setDefaultNamespace = setDefaultNamespace;
        i18n.t = translate;
        i18n.translate = translate;
        i18n.exists = exists;
        i18n.detectLanguage = f.detectLanguage;
        i18n.pluralExtensions = pluralExtensions;
        i18n.sync = sync;
        i18n.functions = f;
        i18n.lng = lng;
        i18n.addPostProcessor = addPostProcessor;
        i18n.options = o;
        
    })();
},{"jquery":84}],82:[function(require,module,exports){
    (function (global){
        
        ; jQuery = global.jQuery = require("/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js");
        ; var __browserify_shim_require__=require;(function browserifyShim(module, define, require) {
            /*! jQuery-Impromptu - v6.0.0 - 2014-12-27
             * http://trentrichardson.com/Impromptu
             * Copyright (c) 2014 Trent Richardson; Licensed MIT */
            (function(root, factory) {
                if (typeof define === 'function' && define.amd) {
                    define(['jquery'], factory);
                } else {
                    factory(root.jQuery);
                }
            }(this, function($) {
                'use strict';
                
                // ########################################################################
                // Base object
                // ########################################################################
                
                /**
                 * Imp - Impromptu object - passing no params will not open, only return the instance
                 * @param message String/Object - String of html or Object of states
                 * @param options Object - Options to set the prompt
                 * @return Imp - the instance of this Impromptu object
                 */
                var Imp = function(message, options){
                    var t = this;
                    t.id = Imp.count++;
                    
                    Imp.lifo.push(t);
                    
                    if(message){
                        t.open(message, options);
                    }
                    return t;
                };
                
                // ########################################################################
                // static properties and methods
                // ########################################################################
                
                /**
                 * defaults - the default options
                 */
                Imp.defaults = {
                    prefix:'jqi',
                    classes: {
                        box: '',
                        fade: '',
                        prompt: '',
                        form: '',
                        close: '',
                        title: '',
                        message: '',
                        buttons: '',
                        button: '',
                        defaultButton: ''
                    },
                    title: '',
                    closeText: '&times;',
                    buttons: {
                        Ok: true
                    },
                    loaded: function(e){},
                    submit: function(e,v,m,f){},
                    close: function(e,v,m,f){},
                    statechanging: function(e, from, to){},
                    statechanged: function(e, to){},
                    opacity: 0.6,
                    zIndex: 999,
                    overlayspeed: 'slow',
                    promptspeed: 'fast',
                    show: 'fadeIn',
                    hide: 'fadeOut',
                    focus: 0,
                    defaultButton: 0,
                    useiframe: false,
                    top: '15%',
                    position: {
                        container: null,
                        x: null,
                        y: null,
                        arrow: null,
                        width: null
                    },
                    persistent: true,
                    timeout: 0,
                    states: {},
                    state: {
                        name: null,
                        title: '',
                        html: '',
                        buttons: {
                            Ok: true
                        },
                        focus: 0,
                        defaultButton: 0,
                        position: {
                            container: null,
                            x: null,
                            y: null,
                            arrow: null,
                            width: null
                        },
                        submit: function(e,v,m,f){
                            return true;
                        }
                    }
                };
                
                /**
                 * setDefaults - Sets the default options
                 * @param o Object - Options to set as defaults
                 * @return void
                 */
                Imp.setDefaults = function(o) {
                    Imp.defaults = $.extend({}, Imp.defaults, o);
                };
                
                /**
                 * setStateDefaults - Sets the default options for a state
                 * @param o Object - Options to set as defaults
                 * @return void
                 */
                Imp.setStateDefaults = function(o) {
                    Imp.defaults.state = $.extend({}, Imp.defaults.state, o);
                };
                
                /**
                 * @var Int - A counter used to provide a unique ID for new prompts
                 */
                Imp.count = 0;
                
                /**
                 * @var Array - An array of Impromptu intances in a LIFO queue (last in first out)
                 */
                Imp.lifo = [];
                
                /**
                 * getLast - get the last element from the queue (doesn't pop, just returns)
                 * @return Imp - the instance of this Impromptu object or false if queue is empty
                 */
                Imp.getLast = function(){
                    var l = Imp.lifo.length;
                    return (l > 0)? Imp.lifo[l-1] : false;
                };
                
                /**
                 * removeFromStack - remove an element from the lifo stack by its id
                 * @param id int - id of the instance to remove
                 * @return api - The api of the element removed from the stack or void
                 */
                Imp.removeFromStack = function(id){
                    for(var i=Imp.lifo.length-1; i>=0; i--){
                        if(Imp.lifo[i].id === id){
                            return Imp.lifo.splice(i,1)[0];
                        }
                    }
                };
                
                // ########################################################################
                // extend our object instance properties and methods
                // ########################################################################
                Imp.prototype = {
                    
                    /**
                     * @var Int - A unique id, simply an autoincremented number
                     */
                    id: null,
                    
                    /**
                     * open - Opens the prompt
                     * @param message String/Object - String of html or Object of states
                     * @param options Object - Options to set the prompt
                     * @return Imp - the instance of this Impromptu object
                     */
                    open: function(message, options) {
                        var t = this;
                        
                        t.options = $.extend({},Imp.defaults,options);
                        
                        // Be sure any previous timeouts are destroyed
                        if(t.timeout){
                            clearTimeout(t.timeout);
                        }
                        t.timeout = false;
                        
                        var opts = t.options,
                            $body = $(document.body),
                            $window = $(window);
                        
                        //build the box and fade
                        var msgbox = '<div class="'+ opts.prefix +'box '+ opts.classes.box +'">';
                        if(opts.useiframe && ($('object, applet').length > 0)) {
                            msgbox += '<iframe src="javascript:false;" style="display:block;position:absolute;z-index:-1;" class="'+ opts.prefix +'fade '+ opts.classes.fade +'"></iframe>';
                        } else {
                            msgbox += '<div class="'+ opts.prefix +'fade '+ opts.classes.fade +'"></div>';
                        }
                        msgbox += '<div class="'+ opts.prefix +' '+ opts.classes.prompt +'">'+
                            '<form action="javascript:false;" onsubmit="return false;" class="'+ opts.prefix +'form '+ opts.classes.form +'">'+
                            '<div class="'+ opts.prefix +'close '+ opts.classes.close +'">'+ opts.closeText +'</div>'+
                            '<div class="'+ opts.prefix +'states"></div>'+
                            '</form>'+
                            '</div>'+
                            '</div>';
                        
                        t.jqib = $(msgbox).appendTo($body);
                        t.jqi = t.jqib.children('.'+ opts.prefix);
                        t.jqif = t.jqib.children('.'+ opts.prefix +'fade');
                        
                        //if a string was passed, convert to a single state
                        if(message.constructor === String){
                            message = {
                                state0: {
                                    title: opts.title,
                                    html: message,
                                    buttons: opts.buttons,
                                    position: opts.position,
                                    focus: opts.focus,
                                    defaultButton: opts.defaultButton,
                                    submit: opts.submit
                                }
                            };
                        }
                        
                        //build the states
                        t.options.states = {};
                        var k,v;
                        for(k in message){
                            v = $.extend({},Imp.defaults.state,{name:k},message[k]);
                            t.addState(v.name, v);
                            
                            if(t.currentStateName === ''){
                                t.currentStateName = v.name;
                            }
                        }
                        
                        //Events
                        t.jqi.on('click', '.'+ opts.prefix +'buttons button', function(e){
                            var $t = $(this),
                                $state = $t.parents('.'+ opts.prefix +'state'),
                                stateobj = t.options.states[$state.data('jqi-name')],
                                msg = $state.children('.'+ opts.prefix +'message'),
                                clicked = stateobj.buttons[$t.text()] || stateobj.buttons[$t.html()],
                                forminputs = {};
                            
                            // if for some reason we couldn't get the value
                            if(clicked === undefined){
                                for(var i in stateobj.buttons){
                                    if(stateobj.buttons[i].title === $t.text() || stateobj.buttons[i].title === $t.html()){
                                        clicked = stateobj.buttons[i].value;
                                    }
                                }
                            }
                            
                            //collect all form element values from all states.
                            $.each(t.jqi.children('form').serializeArray(),function(i,obj){
                                if (forminputs[obj.name] === undefined) {
                                    forminputs[obj.name] = obj.value;
                                } else if (typeof forminputs[obj.name] === Array || typeof forminputs[obj.name] === 'object') {
                                    forminputs[obj.name].push(obj.value);
                                } else {
                                    forminputs[obj.name] = [forminputs[obj.name],obj.value];
                                }
                            });
                            
                            // trigger an event
                            var promptsubmite = new $.Event('impromptu:submit');
                            promptsubmite.stateName = stateobj.name;
                            promptsubmite.state = $state;
                            $state.trigger(promptsubmite, [clicked, msg, forminputs]);
                            
                            if(!promptsubmite.isDefaultPrevented()){
                                t.close(true, clicked,msg,forminputs);
                            }
                        });
                        
                        // if the fade is clicked blink the prompt
                        var fadeClicked = function(){
                            if(opts.persistent){
                                var offset = (opts.top.toString().indexOf('%') >= 0? ($window.height()*(parseInt(opts.top,10)/100)) : parseInt(opts.top,10)),
                                    top = parseInt(t.jqi.css('top').replace('px',''),10) - offset;
                                
                                //$window.scrollTop(top);
                                $('html,body').animate({ scrollTop: top }, 'fast', function(){
                                    var i = 0;
                                    t.jqib.addClass(opts.prefix +'warning');
                                    var intervalid = setInterval(function(){
                                        t.jqib.toggleClass(opts.prefix +'warning');
                                        if(i++ > 1){
                                            clearInterval(intervalid);
                                            t.jqib.removeClass(opts.prefix +'warning');
                                        }
                                    }, 100);
                                });
                            }
                            else {
                                t.close(true);
                            }
                        };
                        
                        // listen for esc or tab keys
                        var keyDownEventHandler = function(e){
                            var key = (window.event) ? event.keyCode : e.keyCode;
                            
                            //escape key closes
                            if(key === 27) {
                                fadeClicked();
                            }
                            
                            //enter key pressed trigger the default button if its not on it, ignore if it is a textarea
                            if(key === 13){
                                var $defBtn = t.getCurrentState().find('.'+ opts.prefix +'defaultbutton');
                                var $tgt = $(e.target);
                                
                                if($tgt.is('textarea,.'+opts.prefix+'button') === false && $defBtn.length > 0){
                                    e.preventDefault();
                                    $defBtn.click();
                                }
                            }
                            
                            //constrain tabs, tabs should iterate through the state and not leave
                            if (key === 9){
                                var $inputels = $('input,select,textarea,button',t.getCurrentState());
                                var fwd = !e.shiftKey && e.target === $inputels[$inputels.length-1];
                                var back = e.shiftKey && e.target === $inputels[0];
                                if (fwd || back) {
                                    setTimeout(function(){
                                        if (!$inputels){
                                            return;
                                        }
                                        var el = $inputels[back===true ? $inputels.length-1 : 0];
                                        
                                        if (el){
                                            el.focus();
                                        }
                                    },10);
                                    return false;
                                }
                            }
                        };
                        
                        t.position();
                        t.style();
                        
                        // store copy of the window resize function for interal use only
                        t._windowResize = function(e){
                            t.position(e);
                        };
                        $window.resize({ animate: false }, t._windowResize);
                        
                        t.jqif.click(fadeClicked);
                        t.jqi.find('.'+ opts.prefix +'close').click(function(){ t.close(); });
                        t.jqib.on("keydown",keyDownEventHandler)
                            .on('impromptu:loaded', opts.loaded)
                            .on('impromptu:close', opts.close)
                            .on('impromptu:statechanging', opts.statechanging)
                            .on('impromptu:statechanged', opts.statechanged);
                        
                        // Show it
                        t.jqif[opts.show](opts.overlayspeed);
                        t.jqi[opts.show](opts.promptspeed, function(){
                            
                            var $firstState = t.jqi.find('.'+ opts.prefix +'states .'+ opts.prefix +'state').eq(0);
                            t.goToState($firstState.data('jqi-name'));
                            
                            t.jqib.trigger('impromptu:loaded');
                        });
                        
                        // Timeout
                        if(opts.timeout > 0){
                            t.timeout = setTimeout(function(){ t.close(true); },opts.timeout);
                        }
                        
                        return t;
                    },
                    
                    /**
                     * close - Closes the prompt
                     * @param callback Function - called when the transition is complete
                     * @param clicked String - value of the button clicked (only used internally)
                     * @param msg jQuery - The state message body (only used internally)
                     * @param forvals Object - key/value pairs of all form field names and values (only used internally)
                     * @return Imp - the instance of this Impromptu object
                     */
                    close: function(callCallback, clicked, msg, formvals){
                        var t = this;
                        Imp.removeFromStack(t.id);
                        
                        if(t.timeout){
                            clearTimeout(t.timeout);
                            t.timeout = false;
                        }
                        
                        if(t.jqib){
                            t.jqib[t.options.hide]('fast',function(){
                                
                                t.jqib.trigger('impromptu:close', [clicked,msg,formvals]);
                                
                                t.jqib.remove();
                                
                                $(window).off('resize', t._windowResize);
                                
                                if(typeof callCallback === 'function'){
                                    callCallback();
                                }
                            });
                        }
                        t.currentStateName = "";
                        
                        return t;
                    },
                    
                    /**
                     * addState - Injects a state into the prompt
                     * @param statename String - Name of the state
                     * @param stateobj Object - options for the state
                     * @param afterState String - selector of the state to insert after
                     * @return jQuery - the newly created state
                     */
                    addState: function(statename, stateobj, afterState) {
                        var t = this,
                            state = '',
                            $state = null,
                            arrow = '',
                            title = '',
                            opts = t.options,
                            $jqistates = $('.'+ opts.prefix +'states'),
                            buttons = [],
                            showHtml,defbtn,k,v,l,i=0;
                        
                        stateobj = $.extend({},Imp.defaults.state, {name:statename}, stateobj);
                        
                        if(stateobj.position.arrow !== null){
                            arrow = '<div class="'+ opts.prefix + 'arrow '+ opts.prefix + 'arrow'+ stateobj.position.arrow +'"></div>';
                        }
                        if(stateobj.title && stateobj.title !== ''){
                            title = '<div class="lead '+ opts.prefix + 'title '+ opts.classes.title +'">'+  stateobj.title +'</div>';
                        }
                        
                        showHtml = stateobj.html;
                        if (typeof stateobj.html === 'function') {
                            showHtml = 'Error: html function must return text';
                        }
                        
                        state += '<div class="'+ opts.prefix + 'state" data-jqi-name="'+ statename +'" style="display:none;">'+
                            arrow + title +
                            '<div class="'+ opts.prefix +'message '+ opts.classes.message +'">' + showHtml +'</div>'+
                            '<div class="'+ opts.prefix +'buttons '+ opts.classes.buttons +'"'+ ($.isEmptyObject(stateobj.buttons)? 'style="display:none;"':'') +'>';
                        
                        // state buttons may be in object or array, lets convert objects to arrays
                        if($.isArray(stateobj.buttons)){
                            buttons = stateobj.buttons;
                        }
                        else if($.isPlainObject(stateobj.buttons)){
                            for(k in stateobj.buttons){
                                if(stateobj.buttons.hasOwnProperty(k)){
                                    buttons.push({ title: k, value: stateobj.buttons[k] });
                                }
                            }
                        }
                        
                        // iterate over each button and create them
                        for(i=0, l=buttons.length; i<l; i++){
                            v = buttons[i],
                                defbtn = stateobj.focus === i || (isNaN(stateobj.focus) && stateobj.defaultButton === i) ? (opts.prefix + 'defaultbutton ' + opts.classes.defaultButton) : '';
                            
                            state += '<button class="'+ opts.classes.button +' '+ opts.prefix + 'button '+ defbtn;
                            
                            if(typeof v.classes !== "undefined"){
                                state += ' '+ ($.isArray(v.classes)? v.classes.join(' ') : v.classes) + ' ';
                            }
                            
                            state += '" name="' + opts.prefix + '_' + statename + '_button' + v.title.replace(/[^a-z0-9]+/gi,'') + '" value="' + v.value + '">' + v.title + '</button>';
                        }
                        
                        state += '</div></div>';
                        
                        $state = $(state);
                        
                        $state.on('impromptu:submit', stateobj.submit);
                        
                        if(afterState !== undefined){
                            $jqistates.find('[data-jqi-name="'+afterState+'"]').after($state);
                        }
                        else{
                            $jqistates.append($state);
                        }
                        
                        t.options.states[statename] = stateobj;
                        
                        return $state;
                    },
                    
                    /**
                     * removeState - Removes a state from the prompt
                     * @param state String - Name of the state
                     * @param newState String - Name of the state to transition to
                     * @return Boolean - returns true on success, false on failure
                     */
                    removeState: function(state, newState) {
                        var t = this,
                            $state = t.getState(state),
                            rm = function(){ $state.remove(); };
                        
                        if($state.length === 0){
                            return false;
                        }
                        
                        // transition away from it before deleting
                        if($state.css('display') !== 'none'){
                            if(newState !== undefined && t.getState(newState).length > 0){
                                t.goToState(newState, false, rm);
                            }
                            else if($state.next().length > 0){
                                t.nextState(rm);
                            }
                            else if($state.prev().length > 0){
                                t.prevState(rm);
                            }
                            else{
                                t.close();
                            }
                        }
                        else{
                            $state.slideUp('slow', rm);
                        }
                        
                        return true;
                    },
                    
                    /**
                     * getApi - Get the api, so you can extract it from $.prompt stack
                     * @return jQuery - the prompt
                     */
                    getApi: function() {
                        return this;
                    },
                    
                    /**
                     * getBox - Get the box containing fade and prompt
                     * @return jQuery - the prompt
                     */
                    getBox: function() {
                        return this.jqib;
                    },
                    
                    /**
                     * getPrompt - Get the prompt
                     * @return jQuery - the prompt
                     */
                    getPrompt: function() {
                        return this.jqi;
                    },
                    
                    /**
                     * getState - Get the state by its name
                     * @param statename String - Name of the state
                     * @return jQuery - the state
                     */
                    getState: function(statename) {
                        return this.jqi.find('[data-jqi-name="'+ statename +'"]');
                    },
                    
                    /**
                     * getCurrentState - Get the current visible state
                     * @return jQuery - the current visible state
                     */
                    getCurrentState: function() {
                        return this.getState(this.getCurrentStateName());
                    },
                    
                    /**
                     * getCurrentStateName - Get the name of the current visible state/substate
                     * @return String - the current visible state's name
                     */
                    getCurrentStateName: function() {
                        return this.currentStateName;
                    },
                    
                    /**
                     * position - Repositions the prompt (Used internally)
                     * @return void
                     */
                    position: function(e){
                        var t = this,
                            restoreFx = $.fx.off,
                            $state = t.getCurrentState(),
                            stateObj = t.options.states[$state.data('jqi-name')],
                            pos = stateObj? stateObj.position : undefined,
                            $window = $(window),
                            bodyHeight = document.body.scrollHeight, //$(document.body).outerHeight(true),
                            windowHeight = $(window).height(),
                            documentHeight = $(document).height(),
                            height = bodyHeight > windowHeight ? bodyHeight : windowHeight,
                            top = parseInt($window.scrollTop(),10) + (t.options.top.toString().indexOf('%') >= 0?
                                    (windowHeight*(parseInt(t.options.top,10)/100)) : parseInt(t.options.top,10));
                        
                        // when resizing the window turn off animation
                        if(e !== undefined && e.data.animate === false){
                            $.fx.off = true;
                        }
                        
                        t.jqib.css({
                            position: "absolute",
                            height: height,
                            width: "100%",
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0
                        });
                        t.jqif.css({
                            position: "fixed",
                            height: height,
                            width: "100%",
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0
                        });
                        
                        // tour positioning
                        if(pos && pos.container){
                            var offset = $(pos.container).offset();
                            
                            if($.isPlainObject(offset) && offset.top !== undefined){
                                t.jqi.css({
                                    position: "absolute"
                                });
                                t.jqi.animate({
                                    top: offset.top + pos.y,
                                    left: offset.left + pos.x,
                                    marginLeft: 0,
                                    width: (pos.width !== undefined)? pos.width : null
                                });
                                top = (offset.top + pos.y) - (t.options.top.toString().indexOf('%') >= 0? (windowHeight*(parseInt(t.options.top,10)/100)) : parseInt(t.options.top,10));
                                $('html,body').animate({ scrollTop: top }, 'slow', 'swing', function(){});
                            }
                        }
                        // custom state width animation
                        else if(pos && pos.width){
                            t.jqi.css({
                                position: "absolute",
                                left: '50%'
                            });
                            t.jqi.animate({
                                top: pos.y || top,
                                left: pos.x || '50%',
                                marginLeft: ((pos.width/2)*-1),
                                width: pos.width
                            });
                        }
                        // standard prompt positioning
                        else{
                            t.jqi.css({
                                position: "absolute",
                                top: top,
                                left: '50%',//$window.width()/2,
                                marginLeft: ((t.jqi.outerWidth(false)/2)*-1)
                            });
                        }
                        
                        // restore fx settings
                        if(e !== undefined && e.data.animate === false){
                            $.fx.off = restoreFx;
                        }
                    },
                    
                    /**
                     * style - Restyles the prompt (Used internally)
                     * @return void
                     */
                    style: function(){
                        var t = this;
                        
                        t.jqif.css({
                            zIndex: t.options.zIndex,
                            display: "none",
                            opacity: t.options.opacity
                        });
                        t.jqi.css({
                            zIndex: t.options.zIndex+1,
                            display: "none"
                        });
                        t.jqib.css({
                            zIndex: t.options.zIndex
                        });
                    },
                    
                    /**
                     * goToState - Goto the specified state
                     * @param state String - name of the state to transition to
                     * @param subState Boolean - true to be a sub state within the currently open state
                     * @param callback Function - called when the transition is complete
                     * @return jQuery - the newly active state
                     */
                    goToState: function(state, subState, callback) {
                        var t = this,
                            $jqi = t.jqi,
                            jqiopts = t.options,
                            $state = t.getState(state),
                            stateobj = jqiopts.states[$state.data('jqi-name')],
                            promptstatechanginge = new $.Event('impromptu:statechanging'),
                            opts = t.options;
                        
                        if(stateobj !== undefined){
                            
                            
                            if (typeof stateobj.html === 'function') {
                                var contentLaterFunc = stateobj.html;
                                $state.find('.' + opts.prefix +'message ').html(contentLaterFunc());
                            }
                            
                            // subState can be ommitted
                            if(typeof subState === 'function'){
                                callback = subState;
                                subState = false;
                            }
                            
                            t.jqib.trigger(promptstatechanginge, [t.getCurrentStateName(), state]);
                            
                            if(!promptstatechanginge.isDefaultPrevented() && $state.length > 0){
                                t.jqi.find('.'+ opts.prefix +'parentstate').removeClass(opts.prefix +'parentstate');
                                
                                if(subState){ // hide any open substates
                                    // get rid of any substates
                                    t.jqi.find('.'+ opts.prefix +'substate').not($state)
                                        .slideUp(jqiopts.promptspeed)
                                        .removeClass('.'+ opts.prefix +'substate')
                                        .find('.'+ opts.prefix +'arrow').hide();
                                    
                                    // add parent state class so it can be visible, but blocked
                                    t.jqi.find('.'+ opts.prefix +'state:visible').addClass(opts.prefix +'parentstate');
                                    
                                    // add substate class so we know it will be smaller
                                    $state.addClass(opts.prefix +'substate');
                                }
                                else{ // hide any open states
                                    t.jqi.find('.'+ opts.prefix +'state').not($state)
                                        .slideUp(jqiopts.promptspeed)
                                        .find('.'+ opts.prefix +'arrow').hide();
                                }
                                t.currentStateName = stateobj.name;
                                
                                $state.slideDown(jqiopts.promptspeed,function(){
                                    var $t = $(this);
                                    
                                    // if focus is a selector, find it, else its button index
                                    if(typeof(stateobj.focus) === 'string'){
                                        $t.find(stateobj.focus).eq(0).focus();
                                    }
                                    else{
                                        $t.find('.'+ opts.prefix +'defaultbutton').focus();
                                    }
                                    
                                    $t.find('.'+ opts.prefix +'arrow').show(jqiopts.promptspeed);
                                    
                                    if (typeof callback === 'function'){
                                        t.jqib.on('impromptu:statechanged', callback);
                                    }
                                    t.jqib.trigger('impromptu:statechanged', [state]);
                                    if (typeof callback === 'function'){
                                        t.jqib.off('impromptu:statechanged', callback);
                                    }
                                });
                                if(!subState){
                                    t.position();
                                }
                            } // end isDefaultPrevented()	
                        }// end stateobj !== undefined
                        
                        return $state;
                    },
                    
                    /**
                     * nextState - Transition to the next state
                     * @param callback Function - called when the transition is complete
                     * @return jQuery - the newly active state
                     */
                    nextState: function(callback) {
                        var t = this,
                            $next = t.getCurrentState().next();
                        if($next.length > 0){
                            t.goToState( $next.data('jqi-name'), callback );
                        }
                        return $next;
                    },
                    
                    /**
                     * prevState - Transition to the previous state
                     * @param callback Function - called when the transition is complete
                     * @return jQuery - the newly active state
                     */
                    prevState: function(callback) {
                        var t = this,
                            $prev = t.getCurrentState().prev();
                        if($prev.length > 0){
                            t.goToState( $prev.data('jqi-name'), callback );
                        }
                        return $prev;
                    }
                    
                };
                
                // ########################################################################
                // $.prompt will manage a queue of Impromptu instances
                // ########################################################################
                
                /**
                 * $.prompt create a new Impromptu instance and push it on the stack of instances
                 * @param message String/Object - String of html or Object of states
                 * @param options Object - Options to set the prompt
                 * @return jQuery - the jQuery object of the prompt within the modal
                 */
                $.prompt = function(message, options){
                    var api = new Imp(message, options);
                    return api.jqi;
                };
                
                /**
                 * Copy over static methods
                 */
                $.each(Imp, function(k,v){
                    $.prompt[k] = v;
                });
                
                /**
                 * Create a proxy for accessing all instance methods. The close method pops from queue.
                 */
                $.each(Imp.prototype, function(k,v){
                    $.prompt[k] = function(){
                        var api = Imp.getLast(); // always use the last instance on the stack
                        
                        if(api && typeof api[k] === "function"){
                            return api[k].apply(api, arguments);
                        }
                    };
                });
                
                // ########################################################################
                // jQuery Plugin and public access
                // ########################################################################
                
                /**
                 * Enable using $('.selector').prompt({});
                 * This will grab the html within the prompt as the prompt message
                 */
                $.fn.prompt = function(options){
                    if(options === undefined){
                        options = {};
                    }
                    if(options.withDataAndEvents === undefined){
                        options.withDataAndEvents = false;
                    }
                    
                    $.prompt($(this).clone(options.withDataAndEvents).html(),options);
                };
                
                /**
                 * Export it as Impromptu and $.prompt
                 * Can be used from here forth as new Impromptu(states, opts)
                 */
                window.Impromptu = Imp;
                
            }));
            
        }).call(global, module, undefined, undefined);
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js":84}],83:[function(require,module,exports){
    var jQuery = require('jquery');
    
    /*! jQuery UI - v1.10.3 - 2013-05-03
     * http://jqueryui.com
     * Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
     * Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
    (function( $, undefined ) {
        
        var uuid = 0,
            runiqueId = /^ui-id-\d+$/;
        
        // $.ui might exist from components with no dependencies, e.g., $.ui.position
        $.ui = $.ui || {};
        
        $.extend( $.ui, {
            version: "1.10.3",
            
            keyCode: {
                BACKSPACE: 8,
                COMMA: 188,
                DELETE: 46,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                ESCAPE: 27,
                HOME: 36,
                LEFT: 37,
                NUMPAD_ADD: 107,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                NUMPAD_ENTER: 108,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_SUBTRACT: 109,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                PERIOD: 190,
                RIGHT: 39,
                SPACE: 32,
                TAB: 9,
                UP: 38
            }
        });
        
        // plugins
        $.fn.extend({
            focus: (function( orig ) {
                return function( delay, fn ) {
                    return typeof delay === "number" ?
                        this.each(function() {
                            var elem = this;
                            setTimeout(function() {
                                $( elem ).focus();
                                if ( fn ) {
                                    fn.call( elem );
                                }
                            }, delay );
                        }) :
                        orig.apply( this, arguments );
                };
            })( $.fn.focus ),
            
            scrollParent: function() {
                var scrollParent;
                if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
                    scrollParent = this.parents().filter(function() {
                        return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
                    }).eq(0);
                } else {
                    scrollParent = this.parents().filter(function() {
                        return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
                    }).eq(0);
                }
                
                return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
            },
            
            zIndex: function( zIndex ) {
                if ( zIndex !== undefined ) {
                    return this.css( "zIndex", zIndex );
                }
                
                if ( this.length ) {
                    var elem = $( this[ 0 ] ), position, value;
                    while ( elem.length && elem[ 0 ] !== document ) {
                        // Ignore z-index if position is set to a value where z-index is ignored by the browser
                        // This makes behavior of this function consistent across browsers
                        // WebKit always returns auto if the element is positioned
                        position = elem.css( "position" );
                        if ( position === "absolute" || position === "relative" || position === "fixed" ) {
                            // IE returns 0 when zIndex is not specified
                            // other browsers return a string
                            // we ignore the case of nested elements with an explicit value of 0
                            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                            value = parseInt( elem.css( "zIndex" ), 10 );
                            if ( !isNaN( value ) && value !== 0 ) {
                                return value;
                            }
                        }
                        elem = elem.parent();
                    }
                }
                
                return 0;
            },
            
            uniqueId: function() {
                return this.each(function() {
                    if ( !this.id ) {
                        this.id = "ui-id-" + (++uuid);
                    }
                });
            },
            
            removeUniqueId: function() {
                return this.each(function() {
                    if ( runiqueId.test( this.id ) ) {
                        $( this ).removeAttr( "id" );
                    }
                });
            }
        });
        
        // selectors
        function focusable( element, isTabIndexNotNaN ) {
            var map, mapName, img,
                nodeName = element.nodeName.toLowerCase();
            if ( "area" === nodeName ) {
                map = element.parentNode;
                mapName = map.name;
                if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                    return false;
                }
                img = $( "img[usemap=#" + mapName + "]" )[0];
                return !!img && visible( img );
            }
            return ( /input|select|textarea|button|object/.test( nodeName ) ?
                    !element.disabled :
                    "a" === nodeName ?
                    element.href || isTabIndexNotNaN :
                        isTabIndexNotNaN) &&
                    // the element and all of its ancestors must be visible
                visible( element );
        }
        
        function visible( element ) {
            return $.expr.filters.visible( element ) &&
                !$( element ).parents().addBack().filter(function() {
                    return $.css( this, "visibility" ) === "hidden";
                }).length;
        }
        
        $.extend( $.expr[ ":" ], {
            data: $.expr.createPseudo ?
                $.expr.createPseudo(function( dataName ) {
                    return function( elem ) {
                        return !!$.data( elem, dataName );
                    };
                }) :
                // support: jQuery <1.8
                function( elem, i, match ) {
                    return !!$.data( elem, match[ 3 ] );
                },
            
            focusable: function( element ) {
                return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
            },
            
            tabbable: function( element ) {
                var tabIndex = $.attr( element, "tabindex" ),
                    isTabIndexNaN = isNaN( tabIndex );
                return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
            }
        });
        
        // support: jQuery <1.8
        if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
            $.each( [ "Width", "Height" ], function( i, name ) {
                var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
                    type = name.toLowerCase(),
                    orig = {
                        innerWidth: $.fn.innerWidth,
                        innerHeight: $.fn.innerHeight,
                        outerWidth: $.fn.outerWidth,
                        outerHeight: $.fn.outerHeight
                    };
                
                function reduce( elem, size, border, margin ) {
                    $.each( side, function() {
                        size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
                        if ( border ) {
                            size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
                        }
                        if ( margin ) {
                            size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
                        }
                    });
                    return size;
                }
                
                $.fn[ "inner" + name ] = function( size ) {
                    if ( size === undefined ) {
                        return orig[ "inner" + name ].call( this );
                    }
                    
                    return this.each(function() {
                        $( this ).css( type, reduce( this, size ) + "px" );
                    });
                };
                
                $.fn[ "outer" + name] = function( size, margin ) {
                    if ( typeof size !== "number" ) {
                        return orig[ "outer" + name ].call( this, size );
                    }
                    
                    return this.each(function() {
                        $( this).css( type, reduce( this, size, true, margin ) + "px" );
                    });
                };
            });
        }
        
        // support: jQuery <1.8
        if ( !$.fn.addBack ) {
            $.fn.addBack = function( selector ) {
                return this.add( selector == null ?
                        this.prevObject : this.prevObject.filter( selector )
                );
            };
        }
        
        // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
        if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
            $.fn.removeData = (function( removeData ) {
                return function( key ) {
                    if ( arguments.length ) {
                        return removeData.call( this, $.camelCase( key ) );
                    } else {
                        return removeData.call( this );
                    }
                };
            })( $.fn.removeData );
        }
        
        
        
        
        
        // deprecated
        $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
        
        $.support.selectstart = "onselectstart" in document.createElement( "div" );
        $.fn.extend({
            disableSelection: function() {
                return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
                    ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                });
            },
            
            enableSelection: function() {
                return this.unbind( ".ui-disableSelection" );
            }
        });
        
        $.extend( $.ui, {
            // $.ui.plugin is deprecated. Use $.widget() extensions instead.
            plugin: {
                add: function( module, option, set ) {
                    var i,
                        proto = $.ui[ module ].prototype;
                    for ( i in set ) {
                        proto.plugins[ i ] = proto.plugins[ i ] || [];
                        proto.plugins[ i ].push( [ option, set[ i ] ] );
                    }
                },
                call: function( instance, name, args ) {
                    var i,
                        set = instance.plugins[ name ];
                    if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
                        return;
                    }
                    
                    for ( i = 0; i < set.length; i++ ) {
                        if ( instance.options[ set[ i ][ 0 ] ] ) {
                            set[ i ][ 1 ].apply( instance.element, args );
                        }
                    }
                }
            },
            
            // only used by resizable
            hasScroll: function( el, a ) {
                
                //If overflow is hidden, the element might have extra content, but the user wants to hide it
                if ( $( el ).css( "overflow" ) === "hidden") {
                    return false;
                }
                
                var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
                    has = false;
                
                if ( el[ scroll ] > 0 ) {
                    return true;
                }
                
                // TODO: determine which cases actually cause this to happen
                // if the element doesn't have the scroll set, see if it's possible to
                // set the scroll
                el[ scroll ] = 1;
                has = ( el[ scroll ] > 0 );
                el[ scroll ] = 0;
                return has;
            }
        });
        
    })( jQuery );
    
    (function( $, undefined ) {
        
        var uuid = 0,
            slice = Array.prototype.slice,
            _cleanData = $.cleanData;
        $.cleanData = function( elems ) {
            for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                try {
                    $( elem ).triggerHandler( "remove" );
                    // http://bugs.jquery.com/ticket/8235
                } catch( e ) {}
            }
            _cleanData( elems );
        };
        
        $.widget = function( name, base, prototype ) {
            var fullName, existingConstructor, constructor, basePrototype,
            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
                proxiedPrototype = {},
                namespace = name.split( "." )[ 0 ];
            
            name = name.split( "." )[ 1 ];
            fullName = namespace + "-" + name;
            
            if ( !prototype ) {
                prototype = base;
                base = $.Widget;
            }
            
            // create selector for plugin
            $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
                return !!$.data( elem, fullName );
            };
            
            $[ namespace ] = $[ namespace ] || {};
            existingConstructor = $[ namespace ][ name ];
            constructor = $[ namespace ][ name ] = function( options, element ) {
                // allow instantiation without "new" keyword
                if ( !this._createWidget ) {
                    return new constructor( options, element );
                }
                
                // allow instantiation without initializing for simple inheritance
                // must use "new" keyword (the code above always passes args)
                if ( arguments.length ) {
                    this._createWidget( options, element );
                }
            };
            // extend with the existing constructor to carry over any static properties
            $.extend( constructor, existingConstructor, {
                version: prototype.version,
                // copy the object used to create the prototype in case we need to
                // redefine the widget later
                _proto: $.extend( {}, prototype ),
                // track widgets that inherit from this widget in case this widget is
                // redefined after a widget inherits from it
                _childConstructors: []
            });
            
            basePrototype = new base();
            // we need to make the options hash a property directly on the new instance
            // otherwise we'll modify the options hash on the prototype that we're
            // inheriting from
            basePrototype.options = $.widget.extend( {}, basePrototype.options );
            $.each( prototype, function( prop, value ) {
                if ( !$.isFunction( value ) ) {
                    proxiedPrototype[ prop ] = value;
                    return;
                }
                proxiedPrototype[ prop ] = (function() {
                    var _super = function() {
                            return base.prototype[ prop ].apply( this, arguments );
                        },
                        _superApply = function( args ) {
                            return base.prototype[ prop ].apply( this, args );
                        };
                    return function() {
                        var __super = this._super,
                            __superApply = this._superApply,
                            returnValue;
                        
                        this._super = _super;
                        this._superApply = _superApply;
                        
                        returnValue = value.apply( this, arguments );
                        
                        this._super = __super;
                        this._superApply = __superApply;
                        
                        return returnValue;
                    };
                })();
            });
            constructor.prototype = $.widget.extend( basePrototype, {
                // TODO: remove support for widgetEventPrefix
                // always use the name + a colon as the prefix, e.g., draggable:start
                // don't prefix for widgets that aren't DOM-based
                widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
            }, proxiedPrototype, {
                constructor: constructor,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName
            });
            
            // If this widget is being redefined then we need to find all widgets that
            // are inheriting from it and redefine all of them so that they inherit from
            // the new version of this widget. We're essentially trying to replace one
            // level in the prototype chain.
            if ( existingConstructor ) {
                $.each( existingConstructor._childConstructors, function( i, child ) {
                    var childPrototype = child.prototype;
                    
                    // redefine the child widget using the same prototype that was
                    // originally used, but inherit from the new version of the base
                    $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
                });
                // remove the list of existing child constructors from the old constructor
                // so the old child constructors can be garbage collected
                delete existingConstructor._childConstructors;
            } else {
                base._childConstructors.push( constructor );
            }
            
            $.widget.bridge( name, constructor );
        };
        
        $.widget.extend = function( target ) {
            var input = slice.call( arguments, 1 ),
                inputIndex = 0,
                inputLength = input.length,
                key,
                value;
            for ( ; inputIndex < inputLength; inputIndex++ ) {
                for ( key in input[ inputIndex ] ) {
                    value = input[ inputIndex ][ key ];
                    if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
                        // Clone objects
                        if ( $.isPlainObject( value ) ) {
                            target[ key ] = $.isPlainObject( target[ key ] ) ?
                                $.widget.extend( {}, target[ key ], value ) :
                                // Don't extend strings, arrays, etc. with objects
                                $.widget.extend( {}, value );
                            // Copy everything else by reference
                        } else {
                            target[ key ] = value;
                        }
                    }
                }
            }
            return target;
        };
        
        $.widget.bridge = function( name, object ) {
            var fullName = object.prototype.widgetFullName || name;
            $.fn[ name ] = function( options ) {
                var isMethodCall = typeof options === "string",
                    args = slice.call( arguments, 1 ),
                    returnValue = this;
                
                // allow multiple hashes to be passed on init
                options = !isMethodCall && args.length ?
                    $.widget.extend.apply( null, [ options ].concat(args) ) :
                    options;
                
                if ( isMethodCall ) {
                    this.each(function() {
                        var methodValue,
                            instance = $.data( this, fullName );
                        if ( !instance ) {
                            return $.error( "cannot call methods on " + name + " prior to initialization; " +
                                "attempted to call method '" + options + "'" );
                        }
                        if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
                            return $.error( "no such method '" + options + "' for " + name + " widget instance" );
                        }
                        methodValue = instance[ options ].apply( instance, args );
                        if ( methodValue !== instance && methodValue !== undefined ) {
                            returnValue = methodValue && methodValue.jquery ?
                                returnValue.pushStack( methodValue.get() ) :
                                methodValue;
                            return false;
                        }
                    });
                } else {
                    this.each(function() {
                        var instance = $.data( this, fullName );
                        if ( instance ) {
                            instance.option( options || {} )._init();
                        } else {
                            $.data( this, fullName, new object( options, this ) );
                        }
                    });
                }
                
                return returnValue;
            };
        };
        
        $.Widget = function( /* options, element */ ) {};
        $.Widget._childConstructors = [];
        
        $.Widget.prototype = {
            widgetName: "widget",
            widgetEventPrefix: "",
            defaultElement: "<div>",
            options: {
                disabled: false,
                
                // callbacks
                create: null
            },
            _createWidget: function( options, element ) {
                element = $( element || this.defaultElement || this )[ 0 ];
                this.element = $( element );
                this.uuid = uuid++;
                this.eventNamespace = "." + this.widgetName + this.uuid;
                this.options = $.widget.extend( {},
                    this.options,
                    this._getCreateOptions(),
                    options );
                
                this.bindings = $();
                this.hoverable = $();
                this.focusable = $();
                
                if ( element !== this ) {
                    $.data( element, this.widgetFullName, this );
                    this._on( true, this.element, {
                        remove: function( event ) {
                            if ( event.target === element ) {
                                this.destroy();
                            }
                        }
                    });
                    this.document = $( element.style ?
                        // element within the document
                        element.ownerDocument :
                        // element is window or document
                    element.document || element );
                    this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
                }
                
                this._create();
                this._trigger( "create", null, this._getCreateEventData() );
                this._init();
            },
            _getCreateOptions: $.noop,
            _getCreateEventData: $.noop,
            _create: $.noop,
            _init: $.noop,
            
            destroy: function() {
                this._destroy();
                // we can probably remove the unbind calls in 2.0
                // all event bindings should go through this._on()
                this.element
                    .unbind( this.eventNamespace )
                    // 1.9 BC for #7810
                    // TODO remove dual storage
                    .removeData( this.widgetName )
                    .removeData( this.widgetFullName )
                    // support: jquery <1.6.3
                    // http://bugs.jquery.com/ticket/9413
                    .removeData( $.camelCase( this.widgetFullName ) );
                this.widget()
                    .unbind( this.eventNamespace )
                    .removeAttr( "aria-disabled" )
                    .removeClass(
                    this.widgetFullName + "-disabled " +
                    "ui-state-disabled" );
                
                // clean up events and states
                this.bindings.unbind( this.eventNamespace );
                this.hoverable.removeClass( "ui-state-hover" );
                this.focusable.removeClass( "ui-state-focus" );
            },
            _destroy: $.noop,
            
            widget: function() {
                return this.element;
            },
            
            option: function( key, value ) {
                var options = key,
                    parts,
                    curOption,
                    i;
                
                if ( arguments.length === 0 ) {
                    // don't return a reference to the internal hash
                    return $.widget.extend( {}, this.options );
                }
                
                if ( typeof key === "string" ) {
                    // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                    options = {};
                    parts = key.split( "." );
                    key = parts.shift();
                    if ( parts.length ) {
                        curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
                        for ( i = 0; i < parts.length - 1; i++ ) {
                            curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                            curOption = curOption[ parts[ i ] ];
                        }
                        key = parts.pop();
                        if ( value === undefined ) {
                            return curOption[ key ] === undefined ? null : curOption[ key ];
                        }
                        curOption[ key ] = value;
                    } else {
                        if ( value === undefined ) {
                            return this.options[ key ] === undefined ? null : this.options[ key ];
                        }
                        options[ key ] = value;
                    }
                }
                
                this._setOptions( options );
                
                return this;
            },
            _setOptions: function( options ) {
                var key;
                
                for ( key in options ) {
                    this._setOption( key, options[ key ] );
                }
                
                return this;
            },
            _setOption: function( key, value ) {
                this.options[ key ] = value;
                
                if ( key === "disabled" ) {
                    this.widget()
                        .toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
                        .attr( "aria-disabled", value );
                    this.hoverable.removeClass( "ui-state-hover" );
                    this.focusable.removeClass( "ui-state-focus" );
                }
                
                return this;
            },
            
            enable: function() {
                return this._setOption( "disabled", false );
            },
            disable: function() {
                return this._setOption( "disabled", true );
            },
            
            _on: function( suppressDisabledCheck, element, handlers ) {
                var delegateElement,
                    instance = this;
                
                // no suppressDisabledCheck flag, shuffle arguments
                if ( typeof suppressDisabledCheck !== "boolean" ) {
                    handlers = element;
                    element = suppressDisabledCheck;
                    suppressDisabledCheck = false;
                }
                
                // no element argument, shuffle and use this.element
                if ( !handlers ) {
                    handlers = element;
                    element = this.element;
                    delegateElement = this.widget();
                } else {
                    // accept selectors, DOM elements
                    element = delegateElement = $( element );
                    this.bindings = this.bindings.add( element );
                }
                
                $.each( handlers, function( event, handler ) {
                    function handlerProxy() {
                        // allow widgets to customize the disabled handling
                        // - disabled as an array instead of boolean
                        // - disabled class as method for disabling individual parts
                        if ( !suppressDisabledCheck &&
                            ( instance.options.disabled === true ||
                            $( this ).hasClass( "ui-state-disabled" ) ) ) {
                            return;
                        }
                        return ( typeof handler === "string" ? instance[ handler ] : handler )
                            .apply( instance, arguments );
                    }
                    
                    // copy the guid so direct unbinding works
                    if ( typeof handler !== "string" ) {
                        handlerProxy.guid = handler.guid =
                            handler.guid || handlerProxy.guid || $.guid++;
                    }
                    
                    var match = event.match( /^(\w+)\s*(.*)$/ ),
                        eventName = match[1] + instance.eventNamespace,
                        selector = match[2];
                    if ( selector ) {
                        delegateElement.delegate( selector, eventName, handlerProxy );
                    } else {
                        element.bind( eventName, handlerProxy );
                    }
                });
            },
            
            _off: function( element, eventName ) {
                eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
                element.unbind( eventName ).undelegate( eventName );
            },
            
            _delay: function( handler, delay ) {
                function handlerProxy() {
                    return ( typeof handler === "string" ? instance[ handler ] : handler )
                        .apply( instance, arguments );
                }
                var instance = this;
                return setTimeout( handlerProxy, delay || 0 );
            },
            
            _hoverable: function( element ) {
                this.hoverable = this.hoverable.add( element );
                this._on( element, {
                    mouseenter: function( event ) {
                        $( event.currentTarget ).addClass( "ui-state-hover" );
                    },
                    mouseleave: function( event ) {
                        $( event.currentTarget ).removeClass( "ui-state-hover" );
                    }
                });
            },
            
            _focusable: function( element ) {
                this.focusable = this.focusable.add( element );
                this._on( element, {
                    focusin: function( event ) {
                        $( event.currentTarget ).addClass( "ui-state-focus" );
                    },
                    focusout: function( event ) {
                        $( event.currentTarget ).removeClass( "ui-state-focus" );
                    }
                });
            },
            
            _trigger: function( type, event, data ) {
                var prop, orig,
                    callback = this.options[ type ];
                
                data = data || {};
                event = $.Event( event );
                event.type = ( type === this.widgetEventPrefix ?
                    type :
                this.widgetEventPrefix + type ).toLowerCase();
                // the original event may come from any element
                // so we need to reset the target on the new event
                event.target = this.element[ 0 ];
                
                // copy original event properties over to the new event
                orig = event.originalEvent;
                if ( orig ) {
                    for ( prop in orig ) {
                        if ( !( prop in event ) ) {
                            event[ prop ] = orig[ prop ];
                        }
                    }
                }
                
                this.element.trigger( event, data );
                return !( $.isFunction( callback ) &&
                callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
                event.isDefaultPrevented() );
            }
        };
        
        $.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
            $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
                if ( typeof options === "string" ) {
                    options = { effect: options };
                }
                var hasOptions,
                    effectName = !options ?
                        method :
                        options === true || typeof options === "number" ?
                            defaultEffect :
                        options.effect || defaultEffect;
                options = options || {};
                if ( typeof options === "number" ) {
                    options = { duration: options };
                }
                hasOptions = !$.isEmptyObject( options );
                options.complete = callback;
                if ( options.delay ) {
                    element.delay( options.delay );
                }
                if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
                    element[ method ]( options );
                } else if ( effectName !== method && element[ effectName ] ) {
                    element[ effectName ]( options.duration, options.easing, callback );
                } else {
                    element.queue(function( next ) {
                        $( this )[ method ]();
                        if ( callback ) {
                            callback.call( element[ 0 ] );
                        }
                        next();
                    });
                }
            };
        });
        
    })( jQuery );
    
    (function( $, undefined ) {
        
        var mouseHandled = false;
        $( document ).mouseup( function() {
            mouseHandled = false;
        });
        
        $.widget("ui.mouse", {
            version: "1.10.3",
            options: {
                cancel: "input,textarea,button,select,option",
                distance: 1,
                delay: 0
            },
            _mouseInit: function() {
                var that = this;
                
                this.element
                    .bind("mousedown."+this.widgetName, function(event) {
                        return that._mouseDown(event);
                    })
                    .bind("click."+this.widgetName, function(event) {
                        if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                            $.removeData(event.target, that.widgetName + ".preventClickEvent");
                            event.stopImmediatePropagation();
                            return false;
                        }
                    });
                
                this.started = false;
            },
            
            // TODO: make sure destroying one instance of mouse doesn't mess with
            // other instances of mouse
            _mouseDestroy: function() {
                this.element.unbind("."+this.widgetName);
                if ( this._mouseMoveDelegate ) {
                    $(document)
                        .unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
                        .unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
                }
            },
            
            _mouseDown: function(event) {
                // don't let more than one widget handle mouseStart
                if( mouseHandled ) { return; }
                
                // we may have missed mouseup (out of window)
                (this._mouseStarted && this._mouseUp(event));
                
                this._mouseDownEvent = event;
                
                var that = this,
                    btnIsLeft = (event.which === 1),
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                    elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
                if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                    return true;
                }
                
                this.mouseDelayMet = !this.options.delay;
                if (!this.mouseDelayMet) {
                    this._mouseDelayTimer = setTimeout(function() {
                        that.mouseDelayMet = true;
                    }, this.options.delay);
                }
                
                if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                    this._mouseStarted = (this._mouseStart(event) !== false);
                    if (!this._mouseStarted) {
                        event.preventDefault();
                        return true;
                    }
                }
                
                // Click event may never have fired (Gecko & Opera)
                if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, this.widgetName + ".preventClickEvent");
                }
                
                // these delegates are required to keep context
                this._mouseMoveDelegate = function(event) {
                    return that._mouseMove(event);
                };
                this._mouseUpDelegate = function(event) {
                    return that._mouseUp(event);
                };
                $(document)
                    .bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
                    .bind("mouseup."+this.widgetName, this._mouseUpDelegate);
                
                event.preventDefault();
                
                mouseHandled = true;
                return true;
            },
            
            _mouseMove: function(event) {
                // IE mouseup check - mouseup happened when mouse was out of window
                if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
                    return this._mouseUp(event);
                }
                
                if (this._mouseStarted) {
                    this._mouseDrag(event);
                    return event.preventDefault();
                }
                
                if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                    this._mouseStarted =
                        (this._mouseStart(this._mouseDownEvent, event) !== false);
                    (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
                }
                
                return !this._mouseStarted;
            },
            
            _mouseUp: function(event) {
                $(document)
                    .unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
                    .unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
                
                if (this._mouseStarted) {
                    this._mouseStarted = false;
                    
                    if (event.target === this._mouseDownEvent.target) {
                        $.data(event.target, this.widgetName + ".preventClickEvent", true);
                    }
                    
                    this._mouseStop(event);
                }
                
                return false;
            },
            
            _mouseDistanceMet: function(event) {
                return (Math.max(
                        Math.abs(this._mouseDownEvent.pageX - event.pageX),
                        Math.abs(this._mouseDownEvent.pageY - event.pageY)
                    ) >= this.options.distance
                );
            },
            
            _mouseDelayMet: function(/* event */) {
                return this.mouseDelayMet;
            },
            
            // These are placeholder methods, to be overriden by extending plugin
            _mouseStart: function(/* event */) {},
            _mouseDrag: function(/* event */) {},
            _mouseStop: function(/* event */) {},
            _mouseCapture: function(/* event */) { return true; }
        });
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.widget("ui.draggable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "drag",
            options: {
                addClasses: true,
                appendTo: "parent",
                axis: false,
                connectToSortable: false,
                containment: false,
                cursor: "auto",
                cursorAt: false,
                grid: false,
                handle: false,
                helper: "original",
                iframeFix: false,
                opacity: false,
                refreshPositions: false,
                revert: false,
                revertDuration: 500,
                scope: "default",
                scroll: true,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                snap: false,
                snapMode: "both",
                snapTolerance: 20,
                stack: false,
                zIndex: false,
                
                // callbacks
                drag: null,
                start: null,
                stop: null
            },
            _create: function() {
                
                if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
                    this.element[0].style.position = "relative";
                }
                if (this.options.addClasses){
                    this.element.addClass("ui-draggable");
                }
                if (this.options.disabled){
                    this.element.addClass("ui-draggable-disabled");
                }
                
                this._mouseInit();
                
            },
            
            _destroy: function() {
                this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
                this._mouseDestroy();
            },
            
            _mouseCapture: function(event) {
                
                var o = this.options;
                
                // among others, prevent a drag on a resizable-handle
                if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                    return false;
                }
                
                //Quit if we're not on a valid handle
                this.handle = this._getHandle(event);
                if (!this.handle) {
                    return false;
                }
                
                $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
                    $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
                        .css({
                            width: this.offsetWidth+"px", height: this.offsetHeight+"px",
                            position: "absolute", opacity: "0.001", zIndex: 1000
                        })
                        .css($(this).offset())
                        .appendTo("body");
                });
                
                return true;
                
            },
            
            _mouseStart: function(event) {
                
                var o = this.options;
                
                //Create and append the visible helper
                this.helper = this._createHelper(event);
                
                this.helper.addClass("ui-draggable-dragging");
                
                //Cache the helper size
                this._cacheHelperProportions();
                
                //If ddmanager is used for droppables, set the global draggable
                if($.ui.ddmanager) {
                    $.ui.ddmanager.current = this;
                }
                
                /*
                 * - Position generation -
                 * This block generates everything position related - it's the core of draggables.
                 */
                
                //Cache the margins of the original element
                this._cacheMargins();
                
                //Store the helper's css position
                this.cssPosition = this.helper.css( "position" );
                this.scrollParent = this.helper.scrollParent();
                this.offsetParent = this.helper.offsetParent();
                this.offsetParentCssPosition = this.offsetParent.css( "position" );
                
                //The element's absolute position on the page minus margins
                this.offset = this.positionAbs = this.element.offset();
                this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                };
                
                //Reset scroll cache
                this.offset.scroll = false;
                
                $.extend(this.offset, {
                    click: { //Where the click happened, relative to the element
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
                });
                
                //Generate the original position
                this.originalPosition = this.position = this._generatePosition(event);
                this.originalPageX = event.pageX;
                this.originalPageY = event.pageY;
                
                //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
                
                //Set a containment if given in the options
                this._setContainment();
                
                //Trigger event + callbacks
                if(this._trigger("start", event) === false) {
                    this._clear();
                    return false;
                }
                
                //Recache the helper size
                this._cacheHelperProportions();
                
                //Prepare the droppable offsets
                if ($.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
                
                
                this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
                
                //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
                if ( $.ui.ddmanager ) {
                    $.ui.ddmanager.dragStart(this, event);
                }
                
                return true;
            },
            
            _mouseDrag: function(event, noPropagation) {
                // reset any necessary cached properties (see #5009)
                if ( this.offsetParentCssPosition === "fixed" ) {
                    this.offset.parent = this._getParentOffset();
                }
                
                //Compute the helpers position
                this.position = this._generatePosition(event);
                this.positionAbs = this._convertPositionTo("absolute");
                
                //Call plugins and callbacks and use the resulting position if something is returned
                if (!noPropagation) {
                    var ui = this._uiHash();
                    if(this._trigger("drag", event, ui) === false) {
                        this._mouseUp({});
                        return false;
                    }
                    this.position = ui.position;
                }
                
                if(!this.options.axis || this.options.axis !== "y") {
                    this.helper[0].style.left = this.position.left+"px";
                }
                if(!this.options.axis || this.options.axis !== "x") {
                    this.helper[0].style.top = this.position.top+"px";
                }
                if($.ui.ddmanager) {
                    $.ui.ddmanager.drag(this, event);
                }
                
                return false;
            },
            
            _mouseStop: function(event) {
                
                //If we are using droppables, inform the manager about the drop
                var that = this,
                    dropped = false;
                if ($.ui.ddmanager && !this.options.dropBehaviour) {
                    dropped = $.ui.ddmanager.drop(this, event);
                }
                
                //if a drop comes from outside (a sortable)
                if(this.dropped) {
                    dropped = this.dropped;
                    this.dropped = false;
                }
                
                //if the original element is no longer in the DOM don't bother to continue (see #8269)
                if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
                    return false;
                }
                
                if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
                    $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                        if(that._trigger("stop", event) !== false) {
                            that._clear();
                        }
                    });
                } else {
                    if(this._trigger("stop", event) !== false) {
                        this._clear();
                    }
                }
                
                return false;
            },
            
            _mouseUp: function(event) {
                //Remove frame helpers
                $("div.ui-draggable-iframeFix").each(function() {
                    this.parentNode.removeChild(this);
                });
                
                //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
                if( $.ui.ddmanager ) {
                    $.ui.ddmanager.dragStop(this, event);
                }
                
                return $.ui.mouse.prototype._mouseUp.call(this, event);
            },
            
            cancel: function() {
                
                if(this.helper.is(".ui-draggable-dragging")) {
                    this._mouseUp({});
                } else {
                    this._clear();
                }
                
                return this;
                
            },
            
            _getHandle: function(event) {
                return this.options.handle ?
                    !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
                    true;
            },
            
            _createHelper: function(event) {
                
                var o = this.options,
                    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);
                
                if(!helper.parents("body").length) {
                    helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
                }
                
                if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
                    helper.css("position", "absolute");
                }
                
                return helper;
                
            },
            
            _adjustOffsetFromHelper: function(obj) {
                if (typeof obj === "string") {
                    obj = obj.split(" ");
                }
                if ($.isArray(obj)) {
                    obj = {left: +obj[0], top: +obj[1] || 0};
                }
                if ("left" in obj) {
                    this.offset.click.left = obj.left + this.margins.left;
                }
                if ("right" in obj) {
                    this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                }
                if ("top" in obj) {
                    this.offset.click.top = obj.top + this.margins.top;
                }
                if ("bottom" in obj) {
                    this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                }
            },
            
            _getParentOffset: function() {
                
                //Get the offsetParent and cache its position
                var po = this.offsetParent.offset();
                
                // This is a special case where we need to modify a offset calculated on start, since the following happened:
                // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                    po.left += this.scrollParent.scrollLeft();
                    po.top += this.scrollParent.scrollTop();
                }
                
                //This needs to be actually done for all browsers, since pageX/pageY includes this information
                //Ugly IE fix
                if((this.offsetParent[0] === document.body) ||
                    (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                    po = { top: 0, left: 0 };
                }
                
                return {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
                };
                
            },
            
            _getRelativeOffset: function() {
                
                if(this.cssPosition === "relative") {
                    var p = this.element.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
                    };
                } else {
                    return { top: 0, left: 0 };
                }
                
            },
            
            _cacheMargins: function() {
                this.margins = {
                    left: (parseInt(this.element.css("marginLeft"),10) || 0),
                    top: (parseInt(this.element.css("marginTop"),10) || 0),
                    right: (parseInt(this.element.css("marginRight"),10) || 0),
                    bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
                };
            },
            
            _cacheHelperProportions: function() {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                };
            },
            
            _setContainment: function() {
                
                var over, c, ce,
                    o = this.options;
                
                if ( !o.containment ) {
                    this.containment = null;
                    return;
                }
                
                if ( o.containment === "window" ) {
                    this.containment = [
                        $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                        $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                        $( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
                        $( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
                    ];
                    return;
                }
                
                if ( o.containment === "document") {
                    this.containment = [
                        0,
                        0,
                        $( document ).width() - this.helperProportions.width - this.margins.left,
                        ( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
                    ];
                    return;
                }
                
                if ( o.containment.constructor === Array ) {
                    this.containment = o.containment;
                    return;
                }
                
                if ( o.containment === "parent" ) {
                    o.containment = this.helper[ 0 ].parentNode;
                }
                
                c = $( o.containment );
                ce = c[ 0 ];
                
                if( !ce ) {
                    return;
                }
                
                over = c.css( "overflow" ) !== "hidden";
                
                this.containment = [
                    ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
                    ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
                    ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
                    ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
                ];
                this.relative_container = c;
            },
            
            _convertPositionTo: function(d, pos) {
                
                if(!pos) {
                    pos = this.position;
                }
                
                var mod = d === "absolute" ? 1 : -1,
                    scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;
                
                //Cache the scroll
                if (!this.offset.scroll) {
                    this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
                }
                
                return {
                    top: (
                        pos.top	+																// The absolute mouse position
                        this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
                        ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
                    ),
                    left: (
                        pos.left +																// The absolute mouse position
                        this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
                        ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
                    )
                };
                
            },
            
            _generatePosition: function(event) {
                
                var containment, co, top, left,
                    o = this.options,
                    scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
                    pageX = event.pageX,
                    pageY = event.pageY;
                
                //Cache the scroll
                if (!this.offset.scroll) {
                    this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
                }
                
                /*
                 * - Position constraining -
                 * Constrain the position to a mix of grid, containment.
                 */
                
                // If we are not dragging yet, we won't check for options
                if ( this.originalPosition ) {
                    if ( this.containment ) {
                        if ( this.relative_container ){
                            co = this.relative_container.offset();
                            containment = [
                                this.containment[ 0 ] + co.left,
                                this.containment[ 1 ] + co.top,
                                this.containment[ 2 ] + co.left,
                                this.containment[ 3 ] + co.top
                            ];
                        }
                        else {
                            containment = this.containment;
                        }
                        
                        if(event.pageX - this.offset.click.left < containment[0]) {
                            pageX = containment[0] + this.offset.click.left;
                        }
                        if(event.pageY - this.offset.click.top < containment[1]) {
                            pageY = containment[1] + this.offset.click.top;
                        }
                        if(event.pageX - this.offset.click.left > containment[2]) {
                            pageX = containment[2] + this.offset.click.left;
                        }
                        if(event.pageY - this.offset.click.top > containment[3]) {
                            pageY = containment[3] + this.offset.click.top;
                        }
                    }
                    
                    if(o.grid) {
                        //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                        top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                        pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
                        
                        left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                        pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                    }
                    
                }
                
                return {
                    top: (
                        pageY -																	// The absolute mouse position
                        this.offset.click.top	-												// Click offset (relative to the element)
                        this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                        ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
                    ),
                    left: (
                        pageX -																	// The absolute mouse position
                        this.offset.click.left -												// Click offset (relative to the element)
                        this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                        ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
                    )
                };
                
            },
            
            _clear: function() {
                this.helper.removeClass("ui-draggable-dragging");
                if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                    this.helper.remove();
                }
                this.helper = null;
                this.cancelHelperRemoval = false;
            },
            
            // From now on bulk stuff - mainly helpers
            
            _trigger: function(type, event, ui) {
                ui = ui || this._uiHash();
                $.ui.plugin.call(this, type, [event, ui]);
                //The absolute position has to be recalculated after plugins
                if(type === "drag") {
                    this.positionAbs = this._convertPositionTo("absolute");
                }
                return $.Widget.prototype._trigger.call(this, type, event, ui);
            },
            
            plugins: {},
            
            _uiHash: function() {
                return {
                    helper: this.helper,
                    position: this.position,
                    originalPosition: this.originalPosition,
                    offset: this.positionAbs
                };
            }
            
        });
        
        $.ui.plugin.add("draggable", "connectToSortable", {
            start: function(event, ui) {
                
                var inst = $(this).data("ui-draggable"), o = inst.options,
                    uiSortable = $.extend({}, ui, { item: inst.element });
                inst.sortables = [];
                $(o.connectToSortable).each(function() {
                    var sortable = $.data(this, "ui-sortable");
                    if (sortable && !sortable.options.disabled) {
                        inst.sortables.push({
                            instance: sortable,
                            shouldRevert: sortable.options.revert
                        });
                        sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
                        sortable._trigger("activate", event, uiSortable);
                    }
                });
                
            },
            stop: function(event, ui) {
                
                //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
                var inst = $(this).data("ui-draggable"),
                    uiSortable = $.extend({}, ui, { item: inst.element });
                
                $.each(inst.sortables, function() {
                    if(this.instance.isOver) {
                        
                        this.instance.isOver = 0;
                        
                        inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
                        this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)
                        
                        //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
                        if(this.shouldRevert) {
                            this.instance.options.revert = this.shouldRevert;
                        }
                        
                        //Trigger the stop of the sortable
                        this.instance._mouseStop(event);
                        
                        this.instance.options.helper = this.instance.options._helper;
                        
                        //If the helper has been the original item, restore properties in the sortable
                        if(inst.options.helper === "original") {
                            this.instance.currentItem.css({ top: "auto", left: "auto" });
                        }
                        
                    } else {
                        this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
                        this.instance._trigger("deactivate", event, uiSortable);
                    }
                    
                });
                
            },
            drag: function(event, ui) {
                
                var inst = $(this).data("ui-draggable"), that = this;
                
                $.each(inst.sortables, function() {
                    
                    var innermostIntersecting = false,
                        thisSortable = this;
                    
                    //Copy over some variables to allow calling the sortable's native _intersectsWith
                    this.instance.positionAbs = inst.positionAbs;
                    this.instance.helperProportions = inst.helperProportions;
                    this.instance.offset.click = inst.offset.click;
                    
                    if(this.instance._intersectsWith(this.instance.containerCache)) {
                        innermostIntersecting = true;
                        $.each(inst.sortables, function () {
                            this.instance.positionAbs = inst.positionAbs;
                            this.instance.helperProportions = inst.helperProportions;
                            this.instance.offset.click = inst.offset.click;
                            if (this !== thisSortable &&
                                this.instance._intersectsWith(this.instance.containerCache) &&
                                $.contains(thisSortable.instance.element[0], this.instance.element[0])
                            ) {
                                innermostIntersecting = false;
                            }
                            return innermostIntersecting;
                        });
                    }
                    
                    
                    if(innermostIntersecting) {
                        //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
                        if(!this.instance.isOver) {
                            
                            this.instance.isOver = 1;
                            //Now we fake the start of dragging for the sortable instance,
                            //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
                            //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
                            this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
                            this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
                            this.instance.options.helper = function() { return ui.helper[0]; };
                            
                            event.target = this.instance.currentItem[0];
                            this.instance._mouseCapture(event, true);
                            this.instance._mouseStart(event, true, true);
                            
                            //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
                            this.instance.offset.click.top = inst.offset.click.top;
                            this.instance.offset.click.left = inst.offset.click.left;
                            this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
                            this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
                            
                            inst._trigger("toSortable", event);
                            inst.dropped = this.instance.element; //draggable revert needs that
                            //hack so receive/update callbacks work (mostly)
                            inst.currentItem = inst.element;
                            this.instance.fromOutside = inst;
                            
                        }
                        
                        //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
                        if(this.instance.currentItem) {
                            this.instance._mouseDrag(event);
                        }
                        
                    } else {
                        
                        //If it doesn't intersect with the sortable, and it intersected before,
                        //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
                        if(this.instance.isOver) {
                            
                            this.instance.isOver = 0;
                            this.instance.cancelHelperRemoval = true;
                            
                            //Prevent reverting on this forced stop
                            this.instance.options.revert = false;
                            
                            // The out event needs to be triggered independently
                            this.instance._trigger("out", event, this.instance._uiHash(this.instance));
                            
                            this.instance._mouseStop(event, true);
                            this.instance.options.helper = this.instance.options._helper;
                            
                            //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
                            this.instance.currentItem.remove();
                            if(this.instance.placeholder) {
                                this.instance.placeholder.remove();
                            }
                            
                            inst._trigger("fromSortable", event);
                            inst.dropped = false; //draggable revert needs that
                        }
                        
                    }
                    
                });
                
            }
        });
        
        $.ui.plugin.add("draggable", "cursor", {
            start: function() {
                var t = $("body"), o = $(this).data("ui-draggable").options;
                if (t.css("cursor")) {
                    o._cursor = t.css("cursor");
                }
                t.css("cursor", o.cursor);
            },
            stop: function() {
                var o = $(this).data("ui-draggable").options;
                if (o._cursor) {
                    $("body").css("cursor", o._cursor);
                }
            }
        });
        
        $.ui.plugin.add("draggable", "opacity", {
            start: function(event, ui) {
                var t = $(ui.helper), o = $(this).data("ui-draggable").options;
                if(t.css("opacity")) {
                    o._opacity = t.css("opacity");
                }
                t.css("opacity", o.opacity);
            },
            stop: function(event, ui) {
                var o = $(this).data("ui-draggable").options;
                if(o._opacity) {
                    $(ui.helper).css("opacity", o._opacity);
                }
            }
        });
        
        $.ui.plugin.add("draggable", "scroll", {
            start: function() {
                var i = $(this).data("ui-draggable");
                if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                    i.overflowOffset = i.scrollParent.offset();
                }
            },
            drag: function( event ) {
                
                var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;
                
                if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                    
                    if(!o.axis || o.axis !== "x") {
                        if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
                        } else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
                        }
                    }
                    
                    if(!o.axis || o.axis !== "y") {
                        if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
                        } else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
                        }
                    }
                    
                } else {
                    
                    if(!o.axis || o.axis !== "x") {
                        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                        } else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                        }
                    }
                    
                    if(!o.axis || o.axis !== "y") {
                        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                        } else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                        }
                    }
                    
                }
                
                if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(i, event);
                }
                
            }
        });
        
        $.ui.plugin.add("draggable", "snap", {
            start: function() {
                
                var i = $(this).data("ui-draggable"),
                    o = i.options;
                
                i.snapElements = [];
                
                $(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
                    var $t = $(this),
                        $o = $t.offset();
                    if(this !== i.element[0]) {
                        i.snapElements.push({
                            item: this,
                            width: $t.outerWidth(), height: $t.outerHeight(),
                            top: $o.top, left: $o.left
                        });
                    }
                });
                
            },
            drag: function(event, ui) {
                
                var ts, bs, ls, rs, l, r, t, b, i, first,
                    inst = $(this).data("ui-draggable"),
                    o = inst.options,
                    d = o.snapTolerance,
                    x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
                    y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
                
                for (i = inst.snapElements.length - 1; i >= 0; i--){
                    
                    l = inst.snapElements[i].left;
                    r = l + inst.snapElements[i].width;
                    t = inst.snapElements[i].top;
                    b = t + inst.snapElements[i].height;
                    
                    if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
                        if(inst.snapElements[i].snapping) {
                            (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                        }
                        inst.snapElements[i].snapping = false;
                        continue;
                    }
                    
                    if(o.snapMode !== "inner") {
                        ts = Math.abs(t - y2) <= d;
                        bs = Math.abs(b - y1) <= d;
                        ls = Math.abs(l - x2) <= d;
                        rs = Math.abs(r - x1) <= d;
                        if(ts) {
                            ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                        }
                        if(bs) {
                            ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
                        }
                        if(ls) {
                            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
                        }
                        if(rs) {
                            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
                        }
                    }
                    
                    first = (ts || bs || ls || rs);
                    
                    if(o.snapMode !== "outer") {
                        ts = Math.abs(t - y1) <= d;
                        bs = Math.abs(b - y2) <= d;
                        ls = Math.abs(l - x1) <= d;
                        rs = Math.abs(r - x2) <= d;
                        if(ts) {
                            ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
                        }
                        if(bs) {
                            ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                        }
                        if(ls) {
                            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
                        }
                        if(rs) {
                            ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
                        }
                    }
                    
                    if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                        (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                    }
                    inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
                    
                }
                
            }
        });
        
        $.ui.plugin.add("draggable", "stack", {
            start: function() {
                var min,
                    o = this.data("ui-draggable").options,
                    group = $.makeArray($(o.stack)).sort(function(a,b) {
                        return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
                    });
                
                if (!group.length) { return; }
                
                min = parseInt($(group[0]).css("zIndex"), 10) || 0;
                $(group).each(function(i) {
                    $(this).css("zIndex", min + i);
                });
                this.css("zIndex", (min + group.length));
            }
        });
        
        $.ui.plugin.add("draggable", "zIndex", {
            start: function(event, ui) {
                var t = $(ui.helper), o = $(this).data("ui-draggable").options;
                if(t.css("zIndex")) {
                    o._zIndex = t.css("zIndex");
                }
                t.css("zIndex", o.zIndex);
            },
            stop: function(event, ui) {
                var o = $(this).data("ui-draggable").options;
                if(o._zIndex) {
                    $(ui.helper).css("zIndex", o._zIndex);
                }
            }
        });
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        function isOverAxis( x, reference, size ) {
            return ( x > reference ) && ( x < ( reference + size ) );
        }
        
        $.widget("ui.droppable", {
            version: "1.10.3",
            widgetEventPrefix: "drop",
            options: {
                accept: "*",
                activeClass: false,
                addClasses: true,
                greedy: false,
                hoverClass: false,
                scope: "default",
                tolerance: "intersect",
                
                // callbacks
                activate: null,
                deactivate: null,
                drop: null,
                out: null,
                over: null
            },
            _create: function() {
                
                var o = this.options,
                    accept = o.accept;
                
                this.isover = false;
                this.isout = true;
                
                this.accept = $.isFunction(accept) ? accept : function(d) {
                    return d.is(accept);
                };
                
                //Store the droppable's proportions
                this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };
                
                // Add the reference and positions to the manager
                $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
                $.ui.ddmanager.droppables[o.scope].push(this);
                
                (o.addClasses && this.element.addClass("ui-droppable"));
                
            },
            
            _destroy: function() {
                var i = 0,
                    drop = $.ui.ddmanager.droppables[this.options.scope];
                
                for ( ; i < drop.length; i++ ) {
                    if ( drop[i] === this ) {
                        drop.splice(i, 1);
                    }
                }
                
                this.element.removeClass("ui-droppable ui-droppable-disabled");
            },
            
            _setOption: function(key, value) {
                
                if(key === "accept") {
                    this.accept = $.isFunction(value) ? value : function(d) {
                        return d.is(value);
                    };
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },
            
            _activate: function(event) {
                var draggable = $.ui.ddmanager.current;
                if(this.options.activeClass) {
                    this.element.addClass(this.options.activeClass);
                }
                if(draggable){
                    this._trigger("activate", event, this.ui(draggable));
                }
            },
            
            _deactivate: function(event) {
                var draggable = $.ui.ddmanager.current;
                if(this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
                if(draggable){
                    this._trigger("deactivate", event, this.ui(draggable));
                }
            },
            
            _over: function(event) {
                
                var draggable = $.ui.ddmanager.current;
                
                // Bail if draggable and droppable are same element
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return;
                }
                
                if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                    if(this.options.hoverClass) {
                        this.element.addClass(this.options.hoverClass);
                    }
                    this._trigger("over", event, this.ui(draggable));
                }
                
            },
            
            _out: function(event) {
                
                var draggable = $.ui.ddmanager.current;
                
                // Bail if draggable and droppable are same element
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return;
                }
                
                if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                    if(this.options.hoverClass) {
                        this.element.removeClass(this.options.hoverClass);
                    }
                    this._trigger("out", event, this.ui(draggable));
                }
                
            },
            
            _drop: function(event,custom) {
                
                var draggable = custom || $.ui.ddmanager.current,
                    childrenIntersection = false;
                
                // Bail if draggable and droppable are same element
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return false;
                }
                
                this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                    var inst = $.data(this, "ui-droppable");
                    if(
                        inst.options.greedy &&
                        !inst.options.disabled &&
                        inst.options.scope === draggable.options.scope &&
                        inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
                        $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
                    ) { childrenIntersection = true; return false; }
                });
                if(childrenIntersection) {
                    return false;
                }
                
                if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                    if(this.options.activeClass) {
                        this.element.removeClass(this.options.activeClass);
                    }
                    if(this.options.hoverClass) {
                        this.element.removeClass(this.options.hoverClass);
                    }
                    this._trigger("drop", event, this.ui(draggable));
                    return this.element;
                }
                
                return false;
                
            },
            
            ui: function(c) {
                return {
                    draggable: (c.currentItem || c.element),
                    helper: c.helper,
                    position: c.position,
                    offset: c.positionAbs
                };
            }
            
        });
        
        $.ui.intersect = function(draggable, droppable, toleranceMode) {
            
            if (!droppable.offset) {
                return false;
            }
            
            var draggableLeft, draggableTop,
                x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
                y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,
                l = droppable.offset.left, r = l + droppable.proportions.width,
                t = droppable.offset.top, b = t + droppable.proportions.height;
            
            switch (toleranceMode) {
                case "fit":
                    return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
                case "intersect":
                    return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
                    x2 - (draggable.helperProportions.width / 2) < r && // Left Half
                    t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
                    y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
                case "pointer":
                    draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
                    draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
                    return isOverAxis( draggableTop, t, droppable.proportions.height ) && isOverAxis( draggableLeft, l, droppable.proportions.width );
                case "touch":
                    return (
                            (y1 >= t && y1 <= b) ||	// Top edge touching
                            (y2 >= t && y2 <= b) ||	// Bottom edge touching
                            (y1 < t && y2 > b)		// Surrounded vertically
                        ) && (
                            (x1 >= l && x1 <= r) ||	// Left edge touching
                            (x2 >= l && x2 <= r) ||	// Right edge touching
                            (x1 < l && x2 > r)		// Surrounded horizontally
                        );
                default:
                    return false;
            }
            
        };
        
        /*
         This manager tracks offsets of draggables and droppables
         */
        $.ui.ddmanager = {
            current: null,
            droppables: { "default": [] },
            prepareOffsets: function(t, event) {
                
                var i, j,
                    m = $.ui.ddmanager.droppables[t.options.scope] || [],
                    type = event ? event.type : null, // workaround for #2317
                    list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
                
                droppablesLoop: for (i = 0; i < m.length; i++) {
                    
                    //No disabled and non-accepted
                    if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
                        continue;
                    }
                    
                    // Filter out elements in the current dragged item
                    for (j=0; j < list.length; j++) {
                        if(list[j] === m[i].element[0]) {
                            m[i].proportions.height = 0;
                            continue droppablesLoop;
                        }
                    }
                    
                    m[i].visible = m[i].element.css("display") !== "none";
                    if(!m[i].visible) {
                        continue;
                    }
                    
                    //Activate the droppable if used directly from draggables
                    if(type === "mousedown") {
                        m[i]._activate.call(m[i], event);
                    }
                    
                    m[i].offset = m[i].element.offset();
                    m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };
                    
                }
                
            },
            drop: function(draggable, event) {
                
                var dropped = false;
                // Create a copy of the droppables in case the list changes during the drop (#9116)
                $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                    
                    if(!this.options) {
                        return;
                    }
                    if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
                        dropped = this._drop.call(this, event) || dropped;
                    }
                    
                    if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                        this.isout = true;
                        this.isover = false;
                        this._deactivate.call(this, event);
                    }
                    
                });
                return dropped;
                
            },
            dragStart: function( draggable, event ) {
                //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
                draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
                    if( !draggable.options.refreshPositions ) {
                        $.ui.ddmanager.prepareOffsets( draggable, event );
                    }
                });
            },
            drag: function(draggable, event) {
                
                //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
                if(draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
                
                //Run through all droppables and check their positions based on specific tolerance options
                $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                    
                    if(this.options.disabled || this.greedyChild || !this.visible) {
                        return;
                    }
                    
                    var parentInstance, scope, parent,
                        intersects = $.ui.intersect(draggable, this, this.options.tolerance),
                        c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
                    if(!c) {
                        return;
                    }
                    
                    if (this.options.greedy) {
                        // find droppable parents with same scope
                        scope = this.options.scope;
                        parent = this.element.parents(":data(ui-droppable)").filter(function () {
                            return $.data(this, "ui-droppable").options.scope === scope;
                        });
                        
                        if (parent.length) {
                            parentInstance = $.data(parent[0], "ui-droppable");
                            parentInstance.greedyChild = (c === "isover");
                        }
                    }
                    
                    // we just moved into a greedy child
                    if (parentInstance && c === "isover") {
                        parentInstance.isover = false;
                        parentInstance.isout = true;
                        parentInstance._out.call(parentInstance, event);
                    }
                    
                    this[c] = true;
                    this[c === "isout" ? "isover" : "isout"] = false;
                    this[c === "isover" ? "_over" : "_out"].call(this, event);
                    
                    // we just moved out of a greedy child
                    if (parentInstance && c === "isout") {
                        parentInstance.isout = false;
                        parentInstance.isover = true;
                        parentInstance._over.call(parentInstance, event);
                    }
                });
                
            },
            dragStop: function( draggable, event ) {
                draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
                //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
                if( !draggable.options.refreshPositions ) {
                    $.ui.ddmanager.prepareOffsets( draggable, event );
                }
            }
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        function num(v) {
            return parseInt(v, 10) || 0;
        }
        
        function isNumber(value) {
            return !isNaN(parseInt(value, 10));
        }
        
        $.widget("ui.resizable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "resize",
            options: {
                alsoResize: false,
                animate: false,
                animateDuration: "slow",
                animateEasing: "swing",
                aspectRatio: false,
                autoHide: false,
                containment: false,
                ghost: false,
                grid: false,
                handles: "e,s,se",
                helper: false,
                maxHeight: null,
                maxWidth: null,
                minHeight: 10,
                minWidth: 10,
                // See #7960
                zIndex: 90,
                
                // callbacks
                resize: null,
                start: null,
                stop: null
            },
            _create: function() {
                
                var n, i, handle, axis, hname,
                    that = this,
                    o = this.options;
                this.element.addClass("ui-resizable");
                
                $.extend(this, {
                    _aspectRatio: !!(o.aspectRatio),
                    aspectRatio: o.aspectRatio,
                    originalElement: this.element,
                    _proportionallyResizeElements: [],
                    _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
                });
                
                //Wrap the element if it cannot hold child nodes
                if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
                    
                    //Create a wrapper element and set the wrapper to the new current internal element
                    this.element.wrap(
                        $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                            position: this.element.css("position"),
                            width: this.element.outerWidth(),
                            height: this.element.outerHeight(),
                            top: this.element.css("top"),
                            left: this.element.css("left")
                        })
                    );
                    
                    //Overwrite the original this.element
                    this.element = this.element.parent().data(
                        "ui-resizable", this.element.data("ui-resizable")
                    );
                    
                    this.elementIsWrapper = true;
                    
                    //Move margins to the wrapper
                    this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
                    this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});
                    
                    //Prevent Safari textarea resize
                    this.originalResizeStyle = this.originalElement.css("resize");
                    this.originalElement.css("resize", "none");
                    
                    //Push the actual element to our proportionallyResize internal array
                    this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));
                    
                    // avoid IE jump (hard set the margin)
                    this.originalElement.css({ margin: this.originalElement.css("margin") });
                    
                    // fix handlers offset
                    this._proportionallyResize();
                    
                }
                
                this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
                if(this.handles.constructor === String) {
                    
                    if ( this.handles === "all") {
                        this.handles = "n,e,s,w,se,sw,ne,nw";
                    }
                    
                    n = this.handles.split(",");
                    this.handles = {};
                    
                    for(i = 0; i < n.length; i++) {
                        
                        handle = $.trim(n[i]);
                        hname = "ui-resizable-"+handle;
                        axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
                        
                        // Apply zIndex to all handles - see #7960
                        axis.css({ zIndex: o.zIndex });
                        
                        //TODO : What's going on here?
                        if ("se" === handle) {
                            axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                        }
                        
                        //Insert into internal handles object and append to element
                        this.handles[handle] = ".ui-resizable-"+handle;
                        this.element.append(axis);
                    }
                    
                }
                
                this._renderAxis = function(target) {
                    
                    var i, axis, padPos, padWrapper;
                    
                    target = target || this.element;
                    
                    for(i in this.handles) {
                        
                        if(this.handles[i].constructor === String) {
                            this.handles[i] = $(this.handles[i], this.element).show();
                        }
                        
                        //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
                        if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
                            
                            axis = $(this.handles[i], this.element);
                            
                            //Checking the correct pad and border
                            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                            
                            //The padding type i have to apply...
                            padPos = [ "padding",
                                /ne|nw|n/.test(i) ? "Top" :
                                    /se|sw|s/.test(i) ? "Bottom" :
                                        /^e$/.test(i) ? "Right" : "Left" ].join("");
                            
                            target.css(padPos, padWrapper);
                            
                            this._proportionallyResize();
                            
                        }
                        
                        //TODO: What's that good for? There's not anything to be executed left
                        if(!$(this.handles[i]).length) {
                            continue;
                        }
                    }
                };
                
                //TODO: make renderAxis a prototype function
                this._renderAxis(this.element);
                
                this._handles = $(".ui-resizable-handle", this.element)
                    .disableSelection();
                
                //Matching axis name
                this._handles.mouseover(function() {
                    if (!that.resizing) {
                        if (this.className) {
                            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                        }
                        //Axis, default = se
                        that.axis = axis && axis[1] ? axis[1] : "se";
                    }
                });
                
                //If we want to auto hide the elements
                if (o.autoHide) {
                    this._handles.hide();
                    $(this.element)
                        .addClass("ui-resizable-autohide")
                        .mouseenter(function() {
                            if (o.disabled) {
                                return;
                            }
                            $(this).removeClass("ui-resizable-autohide");
                            that._handles.show();
                        })
                        .mouseleave(function(){
                            if (o.disabled) {
                                return;
                            }
                            if (!that.resizing) {
                                $(this).addClass("ui-resizable-autohide");
                                that._handles.hide();
                            }
                        });
                }
                
                //Initialize the mouse interaction
                this._mouseInit();
                
            },
            
            _destroy: function() {
                
                this._mouseDestroy();
                
                var wrapper,
                    _destroy = function(exp) {
                        $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
                            .removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
                    };
                
                //TODO: Unwrap at same DOM position
                if (this.elementIsWrapper) {
                    _destroy(this.element);
                    wrapper = this.element;
                    this.originalElement.css({
                        position: wrapper.css("position"),
                        width: wrapper.outerWidth(),
                        height: wrapper.outerHeight(),
                        top: wrapper.css("top"),
                        left: wrapper.css("left")
                    }).insertAfter( wrapper );
                    wrapper.remove();
                }
                
                this.originalElement.css("resize", this.originalResizeStyle);
                _destroy(this.originalElement);
                
                return this;
            },
            
            _mouseCapture: function(event) {
                var i, handle,
                    capture = false;
                
                for (i in this.handles) {
                    handle = $(this.handles[i])[0];
                    if (handle === event.target || $.contains(handle, event.target)) {
                        capture = true;
                    }
                }
                
                return !this.options.disabled && capture;
            },
            
            _mouseStart: function(event) {
                
                var curleft, curtop, cursor,
                    o = this.options,
                    iniPos = this.element.position(),
                    el = this.element;
                
                this.resizing = true;
                
                // bugfix for http://dev.jquery.com/ticket/1749
                if ( (/absolute/).test( el.css("position") ) ) {
                    el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
                } else if (el.is(".ui-draggable")) {
                    el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
                }
                
                this._renderProxy();
                
                curleft = num(this.helper.css("left"));
                curtop = num(this.helper.css("top"));
                
                if (o.containment) {
                    curleft += $(o.containment).scrollLeft() || 0;
                    curtop += $(o.containment).scrollTop() || 0;
                }
                
                //Store needed variables
                this.offset = this.helper.offset();
                this.position = { left: curleft, top: curtop };
                this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
                this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
                this.originalPosition = { left: curleft, top: curtop };
                this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
                this.originalMousePosition = { left: event.pageX, top: event.pageY };
                
                //Aspect Ratio
                this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);
                
                cursor = $(".ui-resizable-" + this.axis).css("cursor");
                $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
                
                el.addClass("ui-resizable-resizing");
                this._propagate("start", event);
                return true;
            },
            
            _mouseDrag: function(event) {
                
                //Increase performance, avoid regex
                var data,
                    el = this.helper, props = {},
                    smp = this.originalMousePosition,
                    a = this.axis,
                    prevTop = this.position.top,
                    prevLeft = this.position.left,
                    prevWidth = this.size.width,
                    prevHeight = this.size.height,
                    dx = (event.pageX-smp.left)||0,
                    dy = (event.pageY-smp.top)||0,
                    trigger = this._change[a];
                
                if (!trigger) {
                    return false;
                }
                
                // Calculate the attrs that will be change
                data = trigger.apply(this, [event, dx, dy]);
                
                // Put this in the mouseDrag handler since the user can start pressing shift while resizing
                this._updateVirtualBoundaries(event.shiftKey);
                if (this._aspectRatio || event.shiftKey) {
                    data = this._updateRatio(data, event);
                }
                
                data = this._respectSize(data, event);
                
                this._updateCache(data);
                
                // plugins callbacks need to be called first
                this._propagate("resize", event);
                
                if (this.position.top !== prevTop) {
                    props.top = this.position.top + "px";
                }
                if (this.position.left !== prevLeft) {
                    props.left = this.position.left + "px";
                }
                if (this.size.width !== prevWidth) {
                    props.width = this.size.width + "px";
                }
                if (this.size.height !== prevHeight) {
                    props.height = this.size.height + "px";
                }
                el.css(props);
                
                if (!this._helper && this._proportionallyResizeElements.length) {
                    this._proportionallyResize();
                }
                
                // Call the user callback if the element was resized
                if ( ! $.isEmptyObject(props) ) {
                    this._trigger("resize", event, this.ui());
                }
                
                return false;
            },
            
            _mouseStop: function(event) {
                
                this.resizing = false;
                var pr, ista, soffseth, soffsetw, s, left, top,
                    o = this.options, that = this;
                
                if(this._helper) {
                    
                    pr = this._proportionallyResizeElements;
                    ista = pr.length && (/textarea/i).test(pr[0].nodeName);
                    soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
                    soffsetw = ista ? 0 : that.sizeDiff.width;
                    
                    s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
                    left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
                    top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
                    
                    if (!o.animate) {
                        this.element.css($.extend(s, { top: top, left: left }));
                    }
                    
                    that.helper.height(that.size.height);
                    that.helper.width(that.size.width);
                    
                    if (this._helper && !o.animate) {
                        this._proportionallyResize();
                    }
                }
                
                $("body").css("cursor", "auto");
                
                this.element.removeClass("ui-resizable-resizing");
                
                this._propagate("stop", event);
                
                if (this._helper) {
                    this.helper.remove();
                }
                
                return false;
                
            },
            
            _updateVirtualBoundaries: function(forceAspectRatio) {
                var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
                    o = this.options;
                
                b = {
                    minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
                    maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                    minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
                    maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
                };
                
                if(this._aspectRatio || forceAspectRatio) {
                    // We want to create an enclosing box whose aspect ration is the requested one
                    // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
                    pMinWidth = b.minHeight * this.aspectRatio;
                    pMinHeight = b.minWidth / this.aspectRatio;
                    pMaxWidth = b.maxHeight * this.aspectRatio;
                    pMaxHeight = b.maxWidth / this.aspectRatio;
                    
                    if(pMinWidth > b.minWidth) {
                        b.minWidth = pMinWidth;
                    }
                    if(pMinHeight > b.minHeight) {
                        b.minHeight = pMinHeight;
                    }
                    if(pMaxWidth < b.maxWidth) {
                        b.maxWidth = pMaxWidth;
                    }
                    if(pMaxHeight < b.maxHeight) {
                        b.maxHeight = pMaxHeight;
                    }
                }
                this._vBoundaries = b;
            },
            
            _updateCache: function(data) {
                this.offset = this.helper.offset();
                if (isNumber(data.left)) {
                    this.position.left = data.left;
                }
                if (isNumber(data.top)) {
                    this.position.top = data.top;
                }
                if (isNumber(data.height)) {
                    this.size.height = data.height;
                }
                if (isNumber(data.width)) {
                    this.size.width = data.width;
                }
            },
            
            _updateRatio: function( data ) {
                
                var cpos = this.position,
                    csize = this.size,
                    a = this.axis;
                
                if (isNumber(data.height)) {
                    data.width = (data.height * this.aspectRatio);
                } else if (isNumber(data.width)) {
                    data.height = (data.width / this.aspectRatio);
                }
                
                if (a === "sw") {
                    data.left = cpos.left + (csize.width - data.width);
                    data.top = null;
                }
                if (a === "nw") {
                    data.top = cpos.top + (csize.height - data.height);
                    data.left = cpos.left + (csize.width - data.width);
                }
                
                return data;
            },
            
            _respectSize: function( data ) {
                
                var o = this._vBoundaries,
                    a = this.axis,
                    ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
                    isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
                    dw = this.originalPosition.left + this.originalSize.width,
                    dh = this.position.top + this.size.height,
                    cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
                if (isminw) {
                    data.width = o.minWidth;
                }
                if (isminh) {
                    data.height = o.minHeight;
                }
                if (ismaxw) {
                    data.width = o.maxWidth;
                }
                if (ismaxh) {
                    data.height = o.maxHeight;
                }
                
                if (isminw && cw) {
                    data.left = dw - o.minWidth;
                }
                if (ismaxw && cw) {
                    data.left = dw - o.maxWidth;
                }
                if (isminh && ch) {
                    data.top = dh - o.minHeight;
                }
                if (ismaxh && ch) {
                    data.top = dh - o.maxHeight;
                }
                
                // fixing jump error on top/left - bug #2330
                if (!data.width && !data.height && !data.left && data.top) {
                    data.top = null;
                } else if (!data.width && !data.height && !data.top && data.left) {
                    data.left = null;
                }
                
                return data;
            },
            
            _proportionallyResize: function() {
                
                if (!this._proportionallyResizeElements.length) {
                    return;
                }
                
                var i, j, borders, paddings, prel,
                    element = this.helper || this.element;
                
                for ( i=0; i < this._proportionallyResizeElements.length; i++) {
                    
                    prel = this._proportionallyResizeElements[i];
                    
                    if (!this.borderDif) {
                        this.borderDif = [];
                        borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
                        paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];
                        
                        for ( j = 0; j < borders.length; j++ ) {
                            this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
                        }
                    }
                    
                    prel.css({
                        height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
                        width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
                    });
                    
                }
                
            },
            
            _renderProxy: function() {
                
                var el = this.element, o = this.options;
                this.elementOffset = el.offset();
                
                if(this._helper) {
                    
                    this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
                    
                    this.helper.addClass(this._helper).css({
                        width: this.element.outerWidth() - 1,
                        height: this.element.outerHeight() - 1,
                        position: "absolute",
                        left: this.elementOffset.left +"px",
                        top: this.elementOffset.top +"px",
                        zIndex: ++o.zIndex //TODO: Don't modify option
                    });
                    
                    this.helper
                        .appendTo("body")
                        .disableSelection();
                    
                } else {
                    this.helper = this.element;
                }
                
            },
            
            _change: {
                e: function(event, dx) {
                    return { width: this.originalSize.width + dx };
                },
                w: function(event, dx) {
                    var cs = this.originalSize, sp = this.originalPosition;
                    return { left: sp.left + dx, width: cs.width - dx };
                },
                n: function(event, dx, dy) {
                    var cs = this.originalSize, sp = this.originalPosition;
                    return { top: sp.top + dy, height: cs.height - dy };
                },
                s: function(event, dx, dy) {
                    return { height: this.originalSize.height + dy };
                },
                se: function(event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
                },
                sw: function(event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
                },
                ne: function(event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
                },
                nw: function(event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
                }
            },
            
            _propagate: function(n, event) {
                $.ui.plugin.call(this, n, [event, this.ui()]);
                (n !== "resize" && this._trigger(n, event, this.ui()));
            },
            
            plugins: {},
            
            ui: function() {
                return {
                    originalElement: this.originalElement,
                    element: this.element,
                    helper: this.helper,
                    position: this.position,
                    size: this.size,
                    originalSize: this.originalSize,
                    originalPosition: this.originalPosition
                };
            }
            
        });
        
        /*
         * Resizable Extensions
         */
        
        $.ui.plugin.add("resizable", "animate", {
            
            stop: function( event ) {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    pr = that._proportionallyResizeElements,
                    ista = pr.length && (/textarea/i).test(pr[0].nodeName),
                    soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
                    soffsetw = ista ? 0 : that.sizeDiff.width,
                    style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
                    left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
                    top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
                
                that.element.animate(
                    $.extend(style, top && left ? { top: top, left: left } : {}), {
                        duration: o.animateDuration,
                        easing: o.animateEasing,
                        step: function() {
                            
                            var data = {
                                width: parseInt(that.element.css("width"), 10),
                                height: parseInt(that.element.css("height"), 10),
                                top: parseInt(that.element.css("top"), 10),
                                left: parseInt(that.element.css("left"), 10)
                            };
                            
                            if (pr && pr.length) {
                                $(pr[0]).css({ width: data.width, height: data.height });
                            }
                            
                            // propagating resize, and updating values for each animation step
                            that._updateCache(data);
                            that._propagate("resize", event);
                            
                        }
                    }
                );
            }
            
        });
        
        $.ui.plugin.add("resizable", "containment", {
            
            start: function() {
                var element, p, co, ch, cw, width, height,
                    that = $(this).data("ui-resizable"),
                    o = that.options,
                    el = that.element,
                    oc = o.containment,
                    ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
                
                if (!ce) {
                    return;
                }
                
                that.containerElement = $(ce);
                
                if (/document/.test(oc) || oc === document) {
                    that.containerOffset = { left: 0, top: 0 };
                    that.containerPosition = { left: 0, top: 0 };
                    
                    that.parentData = {
                        element: $(document), left: 0, top: 0,
                        width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
                    };
                }
                
                // i'm a node, so compute top, left, right, bottom
                else {
                    element = $(ce);
                    p = [];
                    $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });
                    
                    that.containerOffset = element.offset();
                    that.containerPosition = element.position();
                    that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };
                    
                    co = that.containerOffset;
                    ch = that.containerSize.height;
                    cw = that.containerSize.width;
                    width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
                    height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);
                    
                    that.parentData = {
                        element: ce, left: co.left, top: co.top, width: width, height: height
                    };
                }
            },
            
            resize: function( event ) {
                var woset, hoset, isParent, isOffsetRelative,
                    that = $(this).data("ui-resizable"),
                    o = that.options,
                    co = that.containerOffset, cp = that.position,
                    pRatio = that._aspectRatio || event.shiftKey,
                    cop = { top:0, left:0 }, ce = that.containerElement;
                
                if (ce[0] !== document && (/static/).test(ce.css("position"))) {
                    cop = co;
                }
                
                if (cp.left < (that._helper ? co.left : 0)) {
                    that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
                    if (pRatio) {
                        that.size.height = that.size.width / that.aspectRatio;
                    }
                    that.position.left = o.helper ? co.left : 0;
                }
                
                if (cp.top < (that._helper ? co.top : 0)) {
                    that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
                    if (pRatio) {
                        that.size.width = that.size.height * that.aspectRatio;
                    }
                    that.position.top = that._helper ? co.top : 0;
                }
                
                that.offset.left = that.parentData.left+that.position.left;
                that.offset.top = that.parentData.top+that.position.top;
                
                woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
                hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );
                
                isParent = that.containerElement.get(0) === that.element.parent().get(0);
                isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
                
                if(isParent && isOffsetRelative) {
                    woset -= that.parentData.left;
                }
                
                if (woset + that.size.width >= that.parentData.width) {
                    that.size.width = that.parentData.width - woset;
                    if (pRatio) {
                        that.size.height = that.size.width / that.aspectRatio;
                    }
                }
                
                if (hoset + that.size.height >= that.parentData.height) {
                    that.size.height = that.parentData.height - hoset;
                    if (pRatio) {
                        that.size.width = that.size.height * that.aspectRatio;
                    }
                }
            },
            
            stop: function(){
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    co = that.containerOffset,
                    cop = that.containerPosition,
                    ce = that.containerElement,
                    helper = $(that.helper),
                    ho = helper.offset(),
                    w = helper.outerWidth() - that.sizeDiff.width,
                    h = helper.outerHeight() - that.sizeDiff.height;
                
                if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
                    $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
                }
                
                if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
                    $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
                }
                
            }
        });
        
        $.ui.plugin.add("resizable", "alsoResize", {
            
            start: function () {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    _store = function (exp) {
                        $(exp).each(function() {
                            var el = $(this);
                            el.data("ui-resizable-alsoresize", {
                                width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
                                left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
                            });
                        });
                    };
                
                if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
                    if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
                    else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
                }else{
                    _store(o.alsoResize);
                }
            },
            
            resize: function (event, ui) {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    os = that.originalSize,
                    op = that.originalPosition,
                    delta = {
                        height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
                        top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
                    },
                    
                    _alsoResize = function (exp, c) {
                        $(exp).each(function() {
                            var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
                                css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                            
                            $.each(css, function (i, prop) {
                                var sum = (start[prop]||0) + (delta[prop]||0);
                                if (sum && sum >= 0) {
                                    style[prop] = sum || null;
                                }
                            });
                            
                            el.css(style);
                        });
                    };
                
                if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
                    $.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
                }else{
                    _alsoResize(o.alsoResize);
                }
            },
            
            stop: function () {
                $(this).removeData("resizable-alsoresize");
            }
        });
        
        $.ui.plugin.add("resizable", "ghost", {
            
            start: function() {
                
                var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;
                
                that.ghost = that.originalElement.clone();
                that.ghost
                    .css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
                    .addClass("ui-resizable-ghost")
                    .addClass(typeof o.ghost === "string" ? o.ghost : "");
                
                that.ghost.appendTo(that.helper);
                
            },
            
            resize: function(){
                var that = $(this).data("ui-resizable");
                if (that.ghost) {
                    that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
                }
            },
            
            stop: function() {
                var that = $(this).data("ui-resizable");
                if (that.ghost && that.helper) {
                    that.helper.get(0).removeChild(that.ghost.get(0));
                }
            }
            
        });
        
        $.ui.plugin.add("resizable", "grid", {
            
            resize: function() {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    cs = that.size,
                    os = that.originalSize,
                    op = that.originalPosition,
                    a = that.axis,
                    grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
                    gridX = (grid[0]||1),
                    gridY = (grid[1]||1),
                    ox = Math.round((cs.width - os.width) / gridX) * gridX,
                    oy = Math.round((cs.height - os.height) / gridY) * gridY,
                    newWidth = os.width + ox,
                    newHeight = os.height + oy,
                    isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
                    isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
                    isMinWidth = o.minWidth && (o.minWidth > newWidth),
                    isMinHeight = o.minHeight && (o.minHeight > newHeight);
                
                o.grid = grid;
                
                if (isMinWidth) {
                    newWidth = newWidth + gridX;
                }
                if (isMinHeight) {
                    newHeight = newHeight + gridY;
                }
                if (isMaxWidth) {
                    newWidth = newWidth - gridX;
                }
                if (isMaxHeight) {
                    newHeight = newHeight - gridY;
                }
                
                if (/^(se|s|e)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                } else if (/^(ne)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else if (/^(sw)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.left = op.left - ox;
                } else {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                    that.position.left = op.left - ox;
                }
            }
            
        });
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.widget("ui.selectable", $.ui.mouse, {
            version: "1.10.3",
            options: {
                appendTo: "body",
                autoRefresh: true,
                distance: 0,
                filter: "*",
                tolerance: "touch",
                
                // callbacks
                selected: null,
                selecting: null,
                start: null,
                stop: null,
                unselected: null,
                unselecting: null
            },
            _create: function() {
                var selectees,
                    that = this;
                
                this.element.addClass("ui-selectable");
                
                this.dragged = false;
                
                // cache selectee children based on filter
                this.refresh = function() {
                    selectees = $(that.options.filter, that.element[0]);
                    selectees.addClass("ui-selectee");
                    selectees.each(function() {
                        var $this = $(this),
                            pos = $this.offset();
                        $.data(this, "selectable-item", {
                            element: this,
                            $element: $this,
                            left: pos.left,
                            top: pos.top,
                            right: pos.left + $this.outerWidth(),
                            bottom: pos.top + $this.outerHeight(),
                            startselected: false,
                            selected: $this.hasClass("ui-selected"),
                            selecting: $this.hasClass("ui-selecting"),
                            unselecting: $this.hasClass("ui-unselecting")
                        });
                    });
                };
                this.refresh();
                
                this.selectees = selectees.addClass("ui-selectee");
                
                this._mouseInit();
                
                this.helper = $("<div class='ui-selectable-helper'></div>");
            },
            
            _destroy: function() {
                this.selectees
                    .removeClass("ui-selectee")
                    .removeData("selectable-item");
                this.element
                    .removeClass("ui-selectable ui-selectable-disabled");
                this._mouseDestroy();
            },
            
            _mouseStart: function(event) {
                var that = this,
                    options = this.options;
                
                this.opos = [event.pageX, event.pageY];
                
                if (this.options.disabled) {
                    return;
                }
                
                this.selectees = $(options.filter, this.element[0]);
                
                this._trigger("start", event);
                
                $(options.appendTo).append(this.helper);
                // position helper (lasso)
                this.helper.css({
                    "left": event.pageX,
                    "top": event.pageY,
                    "width": 0,
                    "height": 0
                });
                
                if (options.autoRefresh) {
                    this.refresh();
                }
                
                this.selectees.filter(".ui-selected").each(function() {
                    var selectee = $.data(this, "selectable-item");
                    selectee.startselected = true;
                    if (!event.metaKey && !event.ctrlKey) {
                        selectee.$element.removeClass("ui-selected");
                        selectee.selected = false;
                        selectee.$element.addClass("ui-unselecting");
                        selectee.unselecting = true;
                        // selectable UNSELECTING callback
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                });
                
                $(event.target).parents().addBack().each(function() {
                    var doSelect,
                        selectee = $.data(this, "selectable-item");
                    if (selectee) {
                        doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
                        selectee.$element
                            .removeClass(doSelect ? "ui-unselecting" : "ui-selected")
                            .addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                        selectee.unselecting = !doSelect;
                        selectee.selecting = doSelect;
                        selectee.selected = doSelect;
                        // selectable (UN)SELECTING callback
                        if (doSelect) {
                            that._trigger("selecting", event, {
                                selecting: selectee.element
                            });
                        } else {
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                        return false;
                    }
                });
                
            },
            
            _mouseDrag: function(event) {
                
                this.dragged = true;
                
                if (this.options.disabled) {
                    return;
                }
                
                var tmp,
                    that = this,
                    options = this.options,
                    x1 = this.opos[0],
                    y1 = this.opos[1],
                    x2 = event.pageX,
                    y2 = event.pageY;
                
                if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
                if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
                this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
                
                this.selectees.each(function() {
                    var selectee = $.data(this, "selectable-item"),
                        hit = false;
                    
                    //prevent helper from being selected if appendTo: selectable
                    if (!selectee || selectee.element === that.element[0]) {
                        return;
                    }
                    
                    if (options.tolerance === "touch") {
                        hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
                    } else if (options.tolerance === "fit") {
                        hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
                    }
                    
                    if (hit) {
                        // SELECT
                        if (selectee.selected) {
                            selectee.$element.removeClass("ui-selected");
                            selectee.selected = false;
                        }
                        if (selectee.unselecting) {
                            selectee.$element.removeClass("ui-unselecting");
                            selectee.unselecting = false;
                        }
                        if (!selectee.selecting) {
                            selectee.$element.addClass("ui-selecting");
                            selectee.selecting = true;
                            // selectable SELECTING callback
                            that._trigger("selecting", event, {
                                selecting: selectee.element
                            });
                        }
                    } else {
                        // UNSELECT
                        if (selectee.selecting) {
                            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                                selectee.$element.removeClass("ui-selecting");
                                selectee.selecting = false;
                                selectee.$element.addClass("ui-selected");
                                selectee.selected = true;
                            } else {
                                selectee.$element.removeClass("ui-selecting");
                                selectee.selecting = false;
                                if (selectee.startselected) {
                                    selectee.$element.addClass("ui-unselecting");
                                    selectee.unselecting = true;
                                }
                                // selectable UNSELECTING callback
                                that._trigger("unselecting", event, {
                                    unselecting: selectee.element
                                });
                            }
                        }
                        if (selectee.selected) {
                            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                                selectee.$element.removeClass("ui-selected");
                                selectee.selected = false;
                                
                                selectee.$element.addClass("ui-unselecting");
                                selectee.unselecting = true;
                                // selectable UNSELECTING callback
                                that._trigger("unselecting", event, {
                                    unselecting: selectee.element
                                });
                            }
                        }
                    }
                });
                
                return false;
            },
            
            _mouseStop: function(event) {
                var that = this;
                
                this.dragged = false;
                
                $(".ui-unselecting", this.element[0]).each(function() {
                    var selectee = $.data(this, "selectable-item");
                    selectee.$element.removeClass("ui-unselecting");
                    selectee.unselecting = false;
                    selectee.startselected = false;
                    that._trigger("unselected", event, {
                        unselected: selectee.element
                    });
                });
                $(".ui-selecting", this.element[0]).each(function() {
                    var selectee = $.data(this, "selectable-item");
                    selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
                    selectee.selecting = false;
                    selectee.selected = true;
                    selectee.startselected = true;
                    that._trigger("selected", event, {
                        selected: selectee.element
                    });
                });
                this._trigger("stop", event);
                
                this.helper.remove();
                
                return false;
            }
            
        });
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        /*jshint loopfunc: true */
        
        function isOverAxis( x, reference, size ) {
            return ( x > reference ) && ( x < ( reference + size ) );
        }
        
        function isFloating(item) {
            return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
        }
        
        $.widget("ui.sortable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "sort",
            ready: false,
            options: {
                appendTo: "parent",
                axis: false,
                connectWith: false,
                containment: false,
                cursor: "auto",
                cursorAt: false,
                dropOnEmpty: true,
                forcePlaceholderSize: false,
                forceHelperSize: false,
                grid: false,
                handle: false,
                helper: "original",
                items: "> *",
                opacity: false,
                placeholder: false,
                revert: false,
                scroll: true,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                scope: "default",
                tolerance: "intersect",
                zIndex: 1000,
                
                // callbacks
                activate: null,
                beforeStop: null,
                change: null,
                deactivate: null,
                out: null,
                over: null,
                receive: null,
                remove: null,
                sort: null,
                start: null,
                stop: null,
                update: null
            },
            _create: function() {
                
                var o = this.options;
                this.containerCache = {};
                this.element.addClass("ui-sortable");
                
                //Get the items
                this.refresh();
                
                //Let's determine if the items are being displayed horizontally
                this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;
                
                //Let's determine the parent's offset
                this.offset = this.element.offset();
                
                //Initialize mouse events for interaction
                this._mouseInit();
                
                //We're ready to go
                this.ready = true;
                
            },
            
            _destroy: function() {
                this.element
                    .removeClass("ui-sortable ui-sortable-disabled");
                this._mouseDestroy();
                
                for ( var i = this.items.length - 1; i >= 0; i-- ) {
                    this.items[i].item.removeData(this.widgetName + "-item");
                }
                
                return this;
            },
            
            _setOption: function(key, value){
                if ( key === "disabled" ) {
                    this.options[ key ] = value;
                    
                    this.widget().toggleClass( "ui-sortable-disabled", !!value );
                } else {
                    // Don't call widget base _setOption for disable as it adds ui-state-disabled class
                    $.Widget.prototype._setOption.apply(this, arguments);
                }
            },
            
            _mouseCapture: function(event, overrideHandle) {
                var currentItem = null,
                    validHandle = false,
                    that = this;
                
                if (this.reverting) {
                    return false;
                }
                
                if(this.options.disabled || this.options.type === "static") {
                    return false;
                }
                
                //We have to refresh the items data once first
                this._refreshItems(event);
                
                //Find out if the clicked node (or one of its parents) is a actual item in this.items
                $(event.target).parents().each(function() {
                    if($.data(this, that.widgetName + "-item") === that) {
                        currentItem = $(this);
                        return false;
                    }
                });
                if($.data(event.target, that.widgetName + "-item") === that) {
                    currentItem = $(event.target);
                }
                
                if(!currentItem) {
                    return false;
                }
                if(this.options.handle && !overrideHandle) {
                    $(this.options.handle, currentItem).find("*").addBack().each(function() {
                        if(this === event.target) {
                            validHandle = true;
                        }
                    });
                    if(!validHandle) {
                        return false;
                    }
                }
                
                this.currentItem = currentItem;
                this._removeCurrentsFromItems();
                return true;
                
            },
            
            _mouseStart: function(event, overrideHandle, noActivation) {
                
                var i, body,
                    o = this.options;
                
                this.currentContainer = this;
                
                //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
                this.refreshPositions();
                
                //Create and append the visible helper
                this.helper = this._createHelper(event);
                
                //Cache the helper size
                this._cacheHelperProportions();
                
                /*
                 * - Position generation -
                 * This block generates everything position related - it's the core of draggables.
                 */
                
                //Cache the margins of the original element
                this._cacheMargins();
                
                //Get the next scrolling parent
                this.scrollParent = this.helper.scrollParent();
                
                //The element's absolute position on the page minus margins
                this.offset = this.currentItem.offset();
                this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                };
                
                $.extend(this.offset, {
                    click: { //Where the click happened, relative to the element
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
                });
                
                // Only after we got the offset, we can change the helper's position to absolute
                // TODO: Still need to figure out a way to make relative sorting possible
                this.helper.css("position", "absolute");
                this.cssPosition = this.helper.css("position");
                
                //Generate the original position
                this.originalPosition = this._generatePosition(event);
                this.originalPageX = event.pageX;
                this.originalPageY = event.pageY;
                
                //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
                
                //Cache the former DOM position
                this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
                
                //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
                if(this.helper[0] !== this.currentItem[0]) {
                    this.currentItem.hide();
                }
                
                //Create the placeholder
                this._createPlaceholder();
                
                //Set a containment if given in the options
                if(o.containment) {
                    this._setContainment();
                }
                
                if( o.cursor && o.cursor !== "auto" ) { // cursor option
                    body = this.document.find( "body" );
                    
                    // support: IE
                    this.storedCursor = body.css( "cursor" );
                    body.css( "cursor", o.cursor );
                    
                    this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
                }
                
                if(o.opacity) { // opacity option
                    if (this.helper.css("opacity")) {
                        this._storedOpacity = this.helper.css("opacity");
                    }
                    this.helper.css("opacity", o.opacity);
                }
                
                if(o.zIndex) { // zIndex option
                    if (this.helper.css("zIndex")) {
                        this._storedZIndex = this.helper.css("zIndex");
                    }
                    this.helper.css("zIndex", o.zIndex);
                }
                
                //Prepare scrolling
                if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                    this.overflowOffset = this.scrollParent.offset();
                }
                
                //Call callbacks
                this._trigger("start", event, this._uiHash());
                
                //Recache the helper size
                if(!this._preserveHelperProportions) {
                    this._cacheHelperProportions();
                }
                
                
                //Post "activate" events to possible containers
                if( !noActivation ) {
                    for ( i = this.containers.length - 1; i >= 0; i-- ) {
                        this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
                    }
                }
                
                //Prepare possible droppables
                if($.ui.ddmanager) {
                    $.ui.ddmanager.current = this;
                }
                
                if ($.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
                
                this.dragging = true;
                
                this.helper.addClass("ui-sortable-helper");
                this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
                return true;
                
            },
            
            _mouseDrag: function(event) {
                var i, item, itemElement, intersection,
                    o = this.options,
                    scrolled = false;
                
                //Compute the helpers position
                this.position = this._generatePosition(event);
                this.positionAbs = this._convertPositionTo("absolute");
                
                if (!this.lastPositionAbs) {
                    this.lastPositionAbs = this.positionAbs;
                }
                
                //Do scrolling
                if(this.options.scroll) {
                    if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                        
                        if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                        } else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                        }
                        
                        if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                        } else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                        }
                        
                    } else {
                        
                        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                        } else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                        }
                        
                        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                        } else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                        }
                        
                    }
                    
                    if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                        $.ui.ddmanager.prepareOffsets(this, event);
                    }
                }
                
                //Regenerate the absolute position used for position checks
                this.positionAbs = this._convertPositionTo("absolute");
                
                //Set the helper position
                if(!this.options.axis || this.options.axis !== "y") {
                    this.helper[0].style.left = this.position.left+"px";
                }
                if(!this.options.axis || this.options.axis !== "x") {
                    this.helper[0].style.top = this.position.top+"px";
                }
                
                //Rearrange
                for (i = this.items.length - 1; i >= 0; i--) {
                    
                    //Cache variables and intersection, continue if no intersection
                    item = this.items[i];
                    itemElement = item.item[0];
                    intersection = this._intersectsWithPointer(item);
                    if (!intersection) {
                        continue;
                    }
                    
                    // Only put the placeholder inside the current Container, skip all
                    // items form other containers. This works because when moving
                    // an item from one container to another the
                    // currentContainer is switched before the placeholder is moved.
                    //
                    // Without this moving items in "sub-sortables" can cause the placeholder to jitter
                    // beetween the outer and inner container.
                    if (item.instance !== this.currentContainer) {
                        continue;
                    }
                    
                    // cannot intersect with itself
                    // no useless actions that have been done before
                    // no action if the item moved is the parent of the item checked
                    if (itemElement !== this.currentItem[0] &&
                        this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                        !$.contains(this.placeholder[0], itemElement) &&
                        (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
                    ) {
                        
                        this.direction = intersection === 1 ? "down" : "up";
                        
                        if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                            this._rearrange(event, item);
                        } else {
                            break;
                        }
                        
                        this._trigger("change", event, this._uiHash());
                        break;
                    }
                }
                
                //Post events to containers
                this._contactContainers(event);
                
                //Interconnect with droppables
                if($.ui.ddmanager) {
                    $.ui.ddmanager.drag(this, event);
                }
                
                //Call callbacks
                this._trigger("sort", event, this._uiHash());
                
                this.lastPositionAbs = this.positionAbs;
                return false;
                
            },
            
            _mouseStop: function(event, noPropagation) {
                
                if(!event) {
                    return;
                }
                
                //If we are using droppables, inform the manager about the drop
                if ($.ui.ddmanager && !this.options.dropBehaviour) {
                    $.ui.ddmanager.drop(this, event);
                }
                
                if(this.options.revert) {
                    var that = this,
                        cur = this.placeholder.offset(),
                        axis = this.options.axis,
                        animation = {};
                    
                    if ( !axis || axis === "x" ) {
                        animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
                    }
                    if ( !axis || axis === "y" ) {
                        animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
                    }
                    this.reverting = true;
                    $(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
                        that._clear(event);
                    });
                } else {
                    this._clear(event, noPropagation);
                }
                
                return false;
                
            },
            
            cancel: function() {
                
                if(this.dragging) {
                    
                    this._mouseUp({ target: null });
                    
                    if(this.options.helper === "original") {
                        this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                    } else {
                        this.currentItem.show();
                    }
                    
                    //Post deactivating events to containers
                    for (var i = this.containers.length - 1; i >= 0; i--){
                        this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                        if(this.containers[i].containerCache.over) {
                            this.containers[i]._trigger("out", null, this._uiHash(this));
                            this.containers[i].containerCache.over = 0;
                        }
                    }
                    
                }
                
                if (this.placeholder) {
                    //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                    if(this.placeholder[0].parentNode) {
                        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                    }
                    if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                        this.helper.remove();
                    }
                    
                    $.extend(this, {
                        helper: null,
                        dragging: false,
                        reverting: false,
                        _noFinalSort: null
                    });
                    
                    if(this.domPosition.prev) {
                        $(this.domPosition.prev).after(this.currentItem);
                    } else {
                        $(this.domPosition.parent).prepend(this.currentItem);
                    }
                }
                
                return this;
                
            },
            
            serialize: function(o) {
                
                var items = this._getItemsAsjQuery(o && o.connected),
                    str = [];
                o = o || {};
                
                $(items).each(function() {
                    var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
                    if (res) {
                        str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
                    }
                });
                
                if(!str.length && o.key) {
                    str.push(o.key + "=");
                }
                
                return str.join("&");
                
            },
            
            toArray: function(o) {
                
                var items = this._getItemsAsjQuery(o && o.connected),
                    ret = [];
                
                o = o || {};
                
                items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
                return ret;
                
            },
            
            /* Be careful with the following core functions */
            _intersectsWith: function(item) {
                
                var x1 = this.positionAbs.left,
                    x2 = x1 + this.helperProportions.width,
                    y1 = this.positionAbs.top,
                    y2 = y1 + this.helperProportions.height,
                    l = item.left,
                    r = l + item.width,
                    t = item.top,
                    b = t + item.height,
                    dyClick = this.offset.click.top,
                    dxClick = this.offset.click.left,
                    isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
                    isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
                    isOverElement = isOverElementHeight && isOverElementWidth;
                
                if ( this.options.tolerance === "pointer" ||
                    this.options.forcePointerForContainers ||
                    (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
                ) {
                    return isOverElement;
                } else {
                    
                    return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                    x2 - (this.helperProportions.width / 2) < r && // Left Half
                    t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                    y2 - (this.helperProportions.height / 2) < b ); // Top Half
                    
                }
            },
            
            _intersectsWithPointer: function(item) {
                
                var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                    isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                    isOverElement = isOverElementHeight && isOverElementWidth,
                    verticalDirection = this._getDragVerticalDirection(),
                    horizontalDirection = this._getDragHorizontalDirection();
                
                if (!isOverElement) {
                    return false;
                }
                
                return this.floating ?
                    ( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
                    : ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
                
            },
            
            _intersectsWithSides: function(item) {
                
                var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
                    isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
                    verticalDirection = this._getDragVerticalDirection(),
                    horizontalDirection = this._getDragHorizontalDirection();
                
                if (this.floating && horizontalDirection) {
                    return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
                } else {
                    return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
                }
                
            },
            
            _getDragVerticalDirection: function() {
                var delta = this.positionAbs.top - this.lastPositionAbs.top;
                return delta !== 0 && (delta > 0 ? "down" : "up");
            },
            
            _getDragHorizontalDirection: function() {
                var delta = this.positionAbs.left - this.lastPositionAbs.left;
                return delta !== 0 && (delta > 0 ? "right" : "left");
            },
            
            refresh: function(event) {
                this._refreshItems(event);
                this.refreshPositions();
                return this;
            },
            
            _connectWith: function() {
                var options = this.options;
                return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
            },
            
            _getItemsAsjQuery: function(connected) {
                
                var i, j, cur, inst,
                    items = [],
                    queries = [],
                    connectWith = this._connectWith();
                
                if(connectWith && connected) {
                    for (i = connectWith.length - 1; i >= 0; i--){
                        cur = $(connectWith[i]);
                        for ( j = cur.length - 1; j >= 0; j--){
                            inst = $.data(cur[j], this.widgetFullName);
                            if(inst && inst !== this && !inst.options.disabled) {
                                queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                            }
                        }
                    }
                }
                
                queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
                
                for (i = queries.length - 1; i >= 0; i--){
                    queries[i][0].each(function() {
                        items.push(this);
                    });
                }
                
                return $(items);
                
            },
            
            _removeCurrentsFromItems: function() {
                
                var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
                
                this.items = $.grep(this.items, function (item) {
                    for (var j=0; j < list.length; j++) {
                        if(list[j] === item.item[0]) {
                            return false;
                        }
                    }
                    return true;
                });
                
            },
            
            _refreshItems: function(event) {
                
                this.items = [];
                this.containers = [this];
                
                var i, j, cur, inst, targetData, _queries, item, queriesLength,
                    items = this.items,
                    queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
                    connectWith = this._connectWith();
                
                if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
                    for (i = connectWith.length - 1; i >= 0; i--){
                        cur = $(connectWith[i]);
                        for (j = cur.length - 1; j >= 0; j--){
                            inst = $.data(cur[j], this.widgetFullName);
                            if(inst && inst !== this && !inst.options.disabled) {
                                queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
                                this.containers.push(inst);
                            }
                        }
                    }
                }
                
                for (i = queries.length - 1; i >= 0; i--) {
                    targetData = queries[i][1];
                    _queries = queries[i][0];
                    
                    for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
                        item = $(_queries[j]);
                        
                        item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
                        
                        items.push({
                            item: item,
                            instance: targetData,
                            width: 0, height: 0,
                            left: 0, top: 0
                        });
                    }
                }
                
            },
            
            refreshPositions: function(fast) {
                
                //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
                if(this.offsetParent && this.helper) {
                    this.offset.parent = this._getParentOffset();
                }
                
                var i, item, t, p;
                
                for (i = this.items.length - 1; i >= 0; i--){
                    item = this.items[i];
                    
                    //We ignore calculating positions of all connected containers when we're not over them
                    if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                        continue;
                    }
                    
                    t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                    
                    if (!fast) {
                        item.width = t.outerWidth();
                        item.height = t.outerHeight();
                    }
                    
                    p = t.offset();
                    item.left = p.left;
                    item.top = p.top;
                }
                
                if(this.options.custom && this.options.custom.refreshContainers) {
                    this.options.custom.refreshContainers.call(this);
                } else {
                    for (i = this.containers.length - 1; i >= 0; i--){
                        p = this.containers[i].element.offset();
                        this.containers[i].containerCache.left = p.left;
                        this.containers[i].containerCache.top = p.top;
                        this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
                        this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                    }
                }
                
                return this;
            },
            
            _createPlaceholder: function(that) {
                that = that || this;
                var className,
                    o = that.options;
                
                if(!o.placeholder || o.placeholder.constructor === String) {
                    className = o.placeholder;
                    o.placeholder = {
                        element: function() {
                            
                            var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                                element = $( "<" + nodeName + ">", that.document[0] )
                                    .addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
                                    .removeClass("ui-sortable-helper");
                            
                            if ( nodeName === "tr" ) {
                                that.currentItem.children().each(function() {
                                    $( "<td>&#160;</td>", that.document[0] )
                                        .attr( "colspan", $( this ).attr( "colspan" ) || 1 )
                                        .appendTo( element );
                                });
                            } else if ( nodeName === "img" ) {
                                element.attr( "src", that.currentItem.attr( "src" ) );
                            }
                            
                            if ( !className ) {
                                element.css( "visibility", "hidden" );
                            }
                            
                            return element;
                        },
                        update: function(container, p) {
                            
                            // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                            if(className && !o.forcePlaceholderSize) {
                                return;
                            }
                            
                            //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                            if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
                            if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
                        }
                    };
                }
                
                //Create the placeholder
                that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
                
                //Append it after the actual current item
                that.currentItem.after(that.placeholder);
                
                //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
                o.placeholder.update(that, that.placeholder);
                
            },
            
            _contactContainers: function(event) {
                var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
                    innermostContainer = null,
                    innermostIndex = null;
                
                // get innermost container that intersects with item
                for (i = this.containers.length - 1; i >= 0; i--) {
                    
                    // never consider a container that's located within the item itself
                    if($.contains(this.currentItem[0], this.containers[i].element[0])) {
                        continue;
                    }
                    
                    if(this._intersectsWith(this.containers[i].containerCache)) {
                        
                        // if we've already found a container and it's more "inner" than this, then continue
                        if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                            continue;
                        }
                        
                        innermostContainer = this.containers[i];
                        innermostIndex = i;
                        
                    } else {
                        // container doesn't intersect. trigger "out" event if necessary
                        if(this.containers[i].containerCache.over) {
                            this.containers[i]._trigger("out", event, this._uiHash(this));
                            this.containers[i].containerCache.over = 0;
                        }
                    }
                    
                }
                
                // if no intersecting containers found, return
                if(!innermostContainer) {
                    return;
                }
                
                // move the item into the container if it's not there already
                if(this.containers.length === 1) {
                    if (!this.containers[innermostIndex].containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                        this.containers[innermostIndex].containerCache.over = 1;
                    }
                } else {
                    
                    //When entering a new container, we will find the item with the least distance and append our item near it
                    dist = 10000;
                    itemWithLeastDistance = null;
                    floating = innermostContainer.floating || isFloating(this.currentItem);
                    posProperty = floating ? "left" : "top";
                    sizeProperty = floating ? "width" : "height";
                    base = this.positionAbs[posProperty] + this.offset.click[posProperty];
                    for (j = this.items.length - 1; j >= 0; j--) {
                        if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                            continue;
                        }
                        if(this.items[j].item[0] === this.currentItem[0]) {
                            continue;
                        }
                        if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
                            continue;
                        }
                        cur = this.items[j].item.offset()[posProperty];
                        nearBottom = false;
                        if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
                            nearBottom = true;
                            cur += this.items[j][sizeProperty];
                        }
                        
                        if(Math.abs(cur - base) < dist) {
                            dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
                            this.direction = nearBottom ? "up": "down";
                        }
                    }
                    
                    //Check if dropOnEmpty is enabled
                    if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
                        return;
                    }
                    
                    if(this.currentContainer === this.containers[innermostIndex]) {
                        return;
                    }
                    
                    itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                    this._trigger("change", event, this._uiHash());
                    this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                    this.currentContainer = this.containers[innermostIndex];
                    
                    //Update the placeholder
                    this.options.placeholder.update(this.currentContainer, this.placeholder);
                    
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
                
                
            },
            
            _createHelper: function(event) {
                
                var o = this.options,
                    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
                
                //Add the helper to the DOM if that didn't happen already
                if(!helper.parents("body").length) {
                    $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
                }
                
                if(helper[0] === this.currentItem[0]) {
                    this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
                }
                
                if(!helper[0].style.width || o.forceHelperSize) {
                    helper.width(this.currentItem.width());
                }
                if(!helper[0].style.height || o.forceHelperSize) {
                    helper.height(this.currentItem.height());
                }
                
                return helper;
                
            },
            
            _adjustOffsetFromHelper: function(obj) {
                if (typeof obj === "string") {
                    obj = obj.split(" ");
                }
                if ($.isArray(obj)) {
                    obj = {left: +obj[0], top: +obj[1] || 0};
                }
                if ("left" in obj) {
                    this.offset.click.left = obj.left + this.margins.left;
                }
                if ("right" in obj) {
                    this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                }
                if ("top" in obj) {
                    this.offset.click.top = obj.top + this.margins.top;
                }
                if ("bottom" in obj) {
                    this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                }
            },
            
            _getParentOffset: function() {
                
                
                //Get the offsetParent and cache its position
                this.offsetParent = this.helper.offsetParent();
                var po = this.offsetParent.offset();
                
                // This is a special case where we need to modify a offset calculated on start, since the following happened:
                // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                    po.left += this.scrollParent.scrollLeft();
                    po.top += this.scrollParent.scrollTop();
                }
                
                // This needs to be actually done for all browsers, since pageX/pageY includes this information
                // with an ugly IE fix
                if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                    po = { top: 0, left: 0 };
                }
                
                return {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
                };
                
            },
            
            _getRelativeOffset: function() {
                
                if(this.cssPosition === "relative") {
                    var p = this.currentItem.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
                    };
                } else {
                    return { top: 0, left: 0 };
                }
                
            },
            
            _cacheMargins: function() {
                this.margins = {
                    left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
                    top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
                };
            },
            
            _cacheHelperProportions: function() {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                };
            },
            
            _setContainment: function() {
                
                var ce, co, over,
                    o = this.options;
                if(o.containment === "parent") {
                    o.containment = this.helper[0].parentNode;
                }
                if(o.containment === "document" || o.containment === "window") {
                    this.containment = [
                        0 - this.offset.relative.left - this.offset.parent.left,
                        0 - this.offset.relative.top - this.offset.parent.top,
                        $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                        ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                    ];
                }
                
                if(!(/^(document|window|parent)$/).test(o.containment)) {
                    ce = $(o.containment)[0];
                    co = $(o.containment).offset();
                    over = ($(ce).css("overflow") !== "hidden");
                    
                    this.containment = [
                        co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
                        co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
                        co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
                        co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
                    ];
                }
                
            },
            
            _convertPositionTo: function(d, pos) {
                
                if(!pos) {
                    pos = this.position;
                }
                var mod = d === "absolute" ? 1 : -1,
                    scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                    scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
                
                return {
                    top: (
                        pos.top	+																// The absolute mouse position
                        this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
                        ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
                    ),
                    left: (
                        pos.left +																// The absolute mouse position
                        this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
                        ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
                    )
                };
                
            },
            
            _generatePosition: function(event) {
                
                var top, left,
                    o = this.options,
                    pageX = event.pageX,
                    pageY = event.pageY,
                    scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
                
                // This is another very weird special case that only happens for relative elements:
                // 1. If the css position is relative
                // 2. and the scroll parent is the document or similar to the offset parent
                // we have to refresh the relative offset during the scroll so there are no jumps
                if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
                    this.offset.relative = this._getRelativeOffset();
                }
                
                /*
                 * - Position constraining -
                 * Constrain the position to a mix of grid, containment.
                 */
                
                if(this.originalPosition) { //If we are not dragging yet, we won't check for options
                    
                    if(this.containment) {
                        if(event.pageX - this.offset.click.left < this.containment[0]) {
                            pageX = this.containment[0] + this.offset.click.left;
                        }
                        if(event.pageY - this.offset.click.top < this.containment[1]) {
                            pageY = this.containment[1] + this.offset.click.top;
                        }
                        if(event.pageX - this.offset.click.left > this.containment[2]) {
                            pageX = this.containment[2] + this.offset.click.left;
                        }
                        if(event.pageY - this.offset.click.top > this.containment[3]) {
                            pageY = this.containment[3] + this.offset.click.top;
                        }
                    }
                    
                    if(o.grid) {
                        top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                        pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
                        
                        left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                        pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                    }
                    
                }
                
                return {
                    top: (
                        pageY -																// The absolute mouse position
                        this.offset.click.top -													// Click offset (relative to the element)
                        this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                        ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
                    ),
                    left: (
                        pageX -																// The absolute mouse position
                        this.offset.click.left -												// Click offset (relative to the element)
                        this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
                        this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                        ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
                    )
                };
                
            },
            
            _rearrange: function(event, i, a, hardRefresh) {
                
                a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
                
                //Various things done here to improve the performance:
                // 1. we create a setTimeout, that calls refreshPositions
                // 2. on the instance, we have a counter variable, that get's higher after every append
                // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
                // 4. this lets only the last addition to the timeout stack through
                this.counter = this.counter ? ++this.counter : 1;
                var counter = this.counter;
                
                this._delay(function() {
                    if(counter === this.counter) {
                        this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
                    }
                });
                
            },
            
            _clear: function(event, noPropagation) {
                
                this.reverting = false;
                // We delay all events that have to be triggered to after the point where the placeholder has been removed and
                // everything else normalized again
                var i,
                    delayedTriggers = [];
                
                // We first have to update the dom position of the actual currentItem
                // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
                if(!this._noFinalSort && this.currentItem.parent().length) {
                    this.placeholder.before(this.currentItem);
                }
                this._noFinalSort = null;
                
                if(this.helper[0] === this.currentItem[0]) {
                    for(i in this._storedCSS) {
                        if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                            this._storedCSS[i] = "";
                        }
                    }
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }
                
                if(this.fromOutside && !noPropagation) {
                    delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
                }
                if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                    delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
                }
                
                // Check if the items Container has Changed and trigger appropriate
                // events.
                if (this !== this.currentContainer) {
                    if(!noPropagation) {
                        delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
                        delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
                        delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
                    }
                }
                
                
                //Post events to containers
                for (i = this.containers.length - 1; i >= 0; i--){
                    if(!noPropagation) {
                        delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
                    }
                    if(this.containers[i].containerCache.over) {
                        delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
                        this.containers[i].containerCache.over = 0;
                    }
                }
                
                //Do what was originally in plugins
                if ( this.storedCursor ) {
                    this.document.find( "body" ).css( "cursor", this.storedCursor );
                    this.storedStylesheet.remove();
                }
                if(this._storedOpacity) {
                    this.helper.css("opacity", this._storedOpacity);
                }
                if(this._storedZIndex) {
                    this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
                }
                
                this.dragging = false;
                if(this.cancelHelperRemoval) {
                    if(!noPropagation) {
                        this._trigger("beforeStop", event, this._uiHash());
                        for (i=0; i < delayedTriggers.length; i++) {
                            delayedTriggers[i].call(this, event);
                        } //Trigger all delayed events
                        this._trigger("stop", event, this._uiHash());
                    }
                    
                    this.fromOutside = false;
                    return false;
                }
                
                if(!noPropagation) {
                    this._trigger("beforeStop", event, this._uiHash());
                }
                
                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                
                if(this.helper[0] !== this.currentItem[0]) {
                    this.helper.remove();
                }
                this.helper = null;
                
                if(!noPropagation) {
                    for (i=0; i < delayedTriggers.length; i++) {
                        delayedTriggers[i].call(this, event);
                    } //Trigger all delayed events
                    this._trigger("stop", event, this._uiHash());
                }
                
                this.fromOutside = false;
                return true;
                
            },
            
            _trigger: function() {
                if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                    this.cancel();
                }
            },
            
            _uiHash: function(_inst) {
                var inst = _inst || this;
                return {
                    helper: inst.helper,
                    placeholder: inst.placeholder || $([]),
                    position: inst.position,
                    originalPosition: inst.originalPosition,
                    offset: inst.positionAbs,
                    item: inst.currentItem,
                    sender: _inst ? _inst.element : null
                };
            }
            
        });
        
    })(jQuery);
    
    (function($, undefined) {
        
        var dataSpace = "ui-effects-";
        
        $.effects = {
            effect: {}
        };
        
        /*!
         * jQuery Color Animations v2.1.2
         * https://github.com/jquery/jquery-color
         *
         * Copyright 2013 jQuery Foundation and other contributors
         * Released under the MIT license.
         * http://jquery.org/license
         *
         * Date: Wed Jan 16 08:47:09 2013 -0600
         */
        (function( jQuery, undefined ) {
            
            var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
            
            // plusequals test for += 100 -= 100
                rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
            // a set of RE's that can match strings and generate color tuples.
                stringParsers = [{
                    re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                    parse: function( execResult ) {
                        return [
                            execResult[ 1 ],
                            execResult[ 2 ],
                            execResult[ 3 ],
                            execResult[ 4 ]
                        ];
                    }
                }, {
                    re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                    parse: function( execResult ) {
                        return [
                            execResult[ 1 ] * 2.55,
                            execResult[ 2 ] * 2.55,
                            execResult[ 3 ] * 2.55,
                            execResult[ 4 ]
                        ];
                    }
                }, {
                    // this regex ignores A-F because it's compared against an already lowercased string
                    re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                    parse: function( execResult ) {
                        return [
                            parseInt( execResult[ 1 ], 16 ),
                            parseInt( execResult[ 2 ], 16 ),
                            parseInt( execResult[ 3 ], 16 )
                        ];
                    }
                }, {
                    // this regex ignores A-F because it's compared against an already lowercased string
                    re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                    parse: function( execResult ) {
                        return [
                            parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
                            parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
                            parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
                        ];
                    }
                }, {
                    re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                    space: "hsla",
                    parse: function( execResult ) {
                        return [
                            execResult[ 1 ],
                            execResult[ 2 ] / 100,
                            execResult[ 3 ] / 100,
                            execResult[ 4 ]
                        ];
                    }
                }],
            
            // jQuery.Color( )
                color = jQuery.Color = function( color, green, blue, alpha ) {
                    return new jQuery.Color.fn.parse( color, green, blue, alpha );
                },
                spaces = {
                    rgba: {
                        props: {
                            red: {
                                idx: 0,
                                type: "byte"
                            },
                            green: {
                                idx: 1,
                                type: "byte"
                            },
                            blue: {
                                idx: 2,
                                type: "byte"
                            }
                        }
                    },
                    
                    hsla: {
                        props: {
                            hue: {
                                idx: 0,
                                type: "degrees"
                            },
                            saturation: {
                                idx: 1,
                                type: "percent"
                            },
                            lightness: {
                                idx: 2,
                                type: "percent"
                            }
                        }
                    }
                },
                propTypes = {
                    "byte": {
                        floor: true,
                        max: 255
                    },
                    "percent": {
                        max: 1
                    },
                    "degrees": {
                        mod: 360,
                        floor: true
                    }
                },
                support = color.support = {},
            
            // element for support tests
                supportElem = jQuery( "<p>" )[ 0 ],
            
            // colors = jQuery.Color.names
                colors,
            
            // local aliases of functions called often
                each = jQuery.each;
            
            // determine rgba support immediately
            supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
            support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;
            
            // define cache name and alpha properties
            // for rgba and hsla spaces
            each( spaces, function( spaceName, space ) {
                space.cache = "_" + spaceName;
                space.props.alpha = {
                    idx: 3,
                    type: "percent",
                    def: 1
                };
            });
            
            function clamp( value, prop, allowEmpty ) {
                var type = propTypes[ prop.type ] || {};
                
                if ( value == null ) {
                    return (allowEmpty || !prop.def) ? null : prop.def;
                }
                
                // ~~ is an short way of doing floor for positive numbers
                value = type.floor ? ~~value : parseFloat( value );
                
                // IE will pass in empty strings as value for alpha,
                // which will hit this case
                if ( isNaN( value ) ) {
                    return prop.def;
                }
                
                if ( type.mod ) {
                    // we add mod before modding to make sure that negatives values
                    // get converted properly: -10 -> 350
                    return (value + type.mod) % type.mod;
                }
                
                // for now all property types without mod have min and max
                return 0 > value ? 0 : type.max < value ? type.max : value;
            }
            
            function stringParse( string ) {
                var inst = color(),
                    rgba = inst._rgba = [];
                
                string = string.toLowerCase();
                
                each( stringParsers, function( i, parser ) {
                    var parsed,
                        match = parser.re.exec( string ),
                        values = match && parser.parse( match ),
                        spaceName = parser.space || "rgba";
                    
                    if ( values ) {
                        parsed = inst[ spaceName ]( values );
                        
                        // if this was an rgba parse the assignment might happen twice
                        // oh well....
                        inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
                        rgba = inst._rgba = parsed._rgba;
                        
                        // exit each( stringParsers ) here because we matched
                        return false;
                    }
                });
                
                // Found a stringParser that handled it
                if ( rgba.length ) {
                    
                    // if this came from a parsed string, force "transparent" when alpha is 0
                    // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
                    if ( rgba.join() === "0,0,0,0" ) {
                        jQuery.extend( rgba, colors.transparent );
                    }
                    return inst;
                }
                
                // named colors
                return colors[ string ];
            }
            
            color.fn = jQuery.extend( color.prototype, {
                parse: function( red, green, blue, alpha ) {
                    if ( red === undefined ) {
                        this._rgba = [ null, null, null, null ];
                        return this;
                    }
                    if ( red.jquery || red.nodeType ) {
                        red = jQuery( red ).css( green );
                        green = undefined;
                    }
                    
                    var inst = this,
                        type = jQuery.type( red ),
                        rgba = this._rgba = [];
                    
                    // more than 1 argument specified - assume ( red, green, blue, alpha )
                    if ( green !== undefined ) {
                        red = [ red, green, blue, alpha ];
                        type = "array";
                    }
                    
                    if ( type === "string" ) {
                        return this.parse( stringParse( red ) || colors._default );
                    }
                    
                    if ( type === "array" ) {
                        each( spaces.rgba.props, function( key, prop ) {
                            rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
                        });
                        return this;
                    }
                    
                    if ( type === "object" ) {
                        if ( red instanceof color ) {
                            each( spaces, function( spaceName, space ) {
                                if ( red[ space.cache ] ) {
                                    inst[ space.cache ] = red[ space.cache ].slice();
                                }
                            });
                        } else {
                            each( spaces, function( spaceName, space ) {
                                var cache = space.cache;
                                each( space.props, function( key, prop ) {
                                    
                                    // if the cache doesn't exist, and we know how to convert
                                    if ( !inst[ cache ] && space.to ) {
                                        
                                        // if the value was null, we don't need to copy it
                                        // if the key was alpha, we don't need to copy it either
                                        if ( key === "alpha" || red[ key ] == null ) {
                                            return;
                                        }
                                        inst[ cache ] = space.to( inst._rgba );
                                    }
                                    
                                    // this is the only case where we allow nulls for ALL properties.
                                    // call clamp with alwaysAllowEmpty
                                    inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
                                });
                                
                                // everything defined but alpha?
                                if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
                                    // use the default of 1
                                    inst[ cache ][ 3 ] = 1;
                                    if ( space.from ) {
                                        inst._rgba = space.from( inst[ cache ] );
                                    }
                                }
                            });
                        }
                        return this;
                    }
                },
                is: function( compare ) {
                    var is = color( compare ),
                        same = true,
                        inst = this;
                    
                    each( spaces, function( _, space ) {
                        var localCache,
                            isCache = is[ space.cache ];
                        if (isCache) {
                            localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
                            each( space.props, function( _, prop ) {
                                if ( isCache[ prop.idx ] != null ) {
                                    same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
                                    return same;
                                }
                            });
                        }
                        return same;
                    });
                    return same;
                },
                _space: function() {
                    var used = [],
                        inst = this;
                    each( spaces, function( spaceName, space ) {
                        if ( inst[ space.cache ] ) {
                            used.push( spaceName );
                        }
                    });
                    return used.pop();
                },
                transition: function( other, distance ) {
                    var end = color( other ),
                        spaceName = end._space(),
                        space = spaces[ spaceName ],
                        startColor = this.alpha() === 0 ? color( "transparent" ) : this,
                        start = startColor[ space.cache ] || space.to( startColor._rgba ),
                        result = start.slice();
                    
                    end = end[ space.cache ];
                    each( space.props, function( key, prop ) {
                        var index = prop.idx,
                            startValue = start[ index ],
                            endValue = end[ index ],
                            type = propTypes[ prop.type ] || {};
                        
                        // if null, don't override start value
                        if ( endValue === null ) {
                            return;
                        }
                        // if null - use end
                        if ( startValue === null ) {
                            result[ index ] = endValue;
                        } else {
                            if ( type.mod ) {
                                if ( endValue - startValue > type.mod / 2 ) {
                                    startValue += type.mod;
                                } else if ( startValue - endValue > type.mod / 2 ) {
                                    startValue -= type.mod;
                                }
                            }
                            result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
                        }
                    });
                    return this[ spaceName ]( result );
                },
                blend: function( opaque ) {
                    // if we are already opaque - return ourself
                    if ( this._rgba[ 3 ] === 1 ) {
                        return this;
                    }
                    
                    var rgb = this._rgba.slice(),
                        a = rgb.pop(),
                        blend = color( opaque )._rgba;
                    
                    return color( jQuery.map( rgb, function( v, i ) {
                        return ( 1 - a ) * blend[ i ] + a * v;
                    }));
                },
                toRgbaString: function() {
                    var prefix = "rgba(",
                        rgba = jQuery.map( this._rgba, function( v, i ) {
                            return v == null ? ( i > 2 ? 1 : 0 ) : v;
                        });
                    
                    if ( rgba[ 3 ] === 1 ) {
                        rgba.pop();
                        prefix = "rgb(";
                    }
                    
                    return prefix + rgba.join() + ")";
                },
                toHslaString: function() {
                    var prefix = "hsla(",
                        hsla = jQuery.map( this.hsla(), function( v, i ) {
                            if ( v == null ) {
                                v = i > 2 ? 1 : 0;
                            }
                            
                            // catch 1 and 2
                            if ( i && i < 3 ) {
                                v = Math.round( v * 100 ) + "%";
                            }
                            return v;
                        });
                    
                    if ( hsla[ 3 ] === 1 ) {
                        hsla.pop();
                        prefix = "hsl(";
                    }
                    return prefix + hsla.join() + ")";
                },
                toHexString: function( includeAlpha ) {
                    var rgba = this._rgba.slice(),
                        alpha = rgba.pop();
                    
                    if ( includeAlpha ) {
                        rgba.push( ~~( alpha * 255 ) );
                    }
                    
                    return "#" + jQuery.map( rgba, function( v ) {
                            
                            // default to 0 when nulls exist
                            v = ( v || 0 ).toString( 16 );
                            return v.length === 1 ? "0" + v : v;
                        }).join("");
                },
                toString: function() {
                    return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
                }
            });
            color.fn.parse.prototype = color.fn;
            
            // hsla conversions adapted from:
            // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
            
            function hue2rgb( p, q, h ) {
                h = ( h + 1 ) % 1;
                if ( h * 6 < 1 ) {
                    return p + (q - p) * h * 6;
                }
                if ( h * 2 < 1) {
                    return q;
                }
                if ( h * 3 < 2 ) {
                    return p + (q - p) * ((2/3) - h) * 6;
                }
                return p;
            }
            
            spaces.hsla.to = function ( rgba ) {
                if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
                    return [ null, null, null, rgba[ 3 ] ];
                }
                var r = rgba[ 0 ] / 255,
                    g = rgba[ 1 ] / 255,
                    b = rgba[ 2 ] / 255,
                    a = rgba[ 3 ],
                    max = Math.max( r, g, b ),
                    min = Math.min( r, g, b ),
                    diff = max - min,
                    add = max + min,
                    l = add * 0.5,
                    h, s;
                
                if ( min === max ) {
                    h = 0;
                } else if ( r === max ) {
                    h = ( 60 * ( g - b ) / diff ) + 360;
                } else if ( g === max ) {
                    h = ( 60 * ( b - r ) / diff ) + 120;
                } else {
                    h = ( 60 * ( r - g ) / diff ) + 240;
                }
                
                // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
                // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
                if ( diff === 0 ) {
                    s = 0;
                } else if ( l <= 0.5 ) {
                    s = diff / add;
                } else {
                    s = diff / ( 2 - add );
                }
                return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
            };
            
            spaces.hsla.from = function ( hsla ) {
                if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
                    return [ null, null, null, hsla[ 3 ] ];
                }
                var h = hsla[ 0 ] / 360,
                    s = hsla[ 1 ],
                    l = hsla[ 2 ],
                    a = hsla[ 3 ],
                    q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
                    p = 2 * l - q;
                
                return [
                    Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
                    Math.round( hue2rgb( p, q, h ) * 255 ),
                    Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
                    a
                ];
            };
            
            
            each( spaces, function( spaceName, space ) {
                var props = space.props,
                    cache = space.cache,
                    to = space.to,
                    from = space.from;
                
                // makes rgba() and hsla()
                color.fn[ spaceName ] = function( value ) {
                    
                    // generate a cache for this space if it doesn't exist
                    if ( to && !this[ cache ] ) {
                        this[ cache ] = to( this._rgba );
                    }
                    if ( value === undefined ) {
                        return this[ cache ].slice();
                    }
                    
                    var ret,
                        type = jQuery.type( value ),
                        arr = ( type === "array" || type === "object" ) ? value : arguments,
                        local = this[ cache ].slice();
                    
                    each( props, function( key, prop ) {
                        var val = arr[ type === "object" ? key : prop.idx ];
                        if ( val == null ) {
                            val = local[ prop.idx ];
                        }
                        local[ prop.idx ] = clamp( val, prop );
                    });
                    
                    if ( from ) {
                        ret = color( from( local ) );
                        ret[ cache ] = local;
                        return ret;
                    } else {
                        return color( local );
                    }
                };
                
                // makes red() green() blue() alpha() hue() saturation() lightness()
                each( props, function( key, prop ) {
                    // alpha is included in more than one space
                    if ( color.fn[ key ] ) {
                        return;
                    }
                    color.fn[ key ] = function( value ) {
                        var vtype = jQuery.type( value ),
                            fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
                            local = this[ fn ](),
                            cur = local[ prop.idx ],
                            match;
                        
                        if ( vtype === "undefined" ) {
                            return cur;
                        }
                        
                        if ( vtype === "function" ) {
                            value = value.call( this, cur );
                            vtype = jQuery.type( value );
                        }
                        if ( value == null && prop.empty ) {
                            return this;
                        }
                        if ( vtype === "string" ) {
                            match = rplusequals.exec( value );
                            if ( match ) {
                                value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
                            }
                        }
                        local[ prop.idx ] = value;
                        return this[ fn ]( local );
                    };
                });
            });
            
            // add cssHook and .fx.step function for each named hook.
            // accept a space separated string of properties
            color.hook = function( hook ) {
                var hooks = hook.split( " " );
                each( hooks, function( i, hook ) {
                    jQuery.cssHooks[ hook ] = {
                        set: function( elem, value ) {
                            var parsed, curElem,
                                backgroundColor = "";
                            
                            if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
                                value = color( parsed || value );
                                if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
                                    curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                    while (
                                    (backgroundColor === "" || backgroundColor === "transparent") &&
                                    curElem && curElem.style
                                        ) {
                                        try {
                                            backgroundColor = jQuery.css( curElem, "backgroundColor" );
                                            curElem = curElem.parentNode;
                                        } catch ( e ) {
                                        }
                                    }
                                    
                                    value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
                                        backgroundColor :
                                        "_default" );
                                }
                                
                                value = value.toRgbaString();
                            }
                            try {
                                elem.style[ hook ] = value;
                            } catch( e ) {
                                // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
                            }
                        }
                    };
                    jQuery.fx.step[ hook ] = function( fx ) {
                        if ( !fx.colorInit ) {
                            fx.start = color( fx.elem, hook );
                            fx.end = color( fx.end );
                            fx.colorInit = true;
                        }
                        jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
                    };
                });
                
            };
            
            color.hook( stepHooks );
            
            jQuery.cssHooks.borderColor = {
                expand: function( value ) {
                    var expanded = {};
                    
                    each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
                        expanded[ "border" + part + "Color" ] = value;
                    });
                    return expanded;
                }
            };
            
            // Basic color names only.
            // Usage of any of the other color names requires adding yourself or including
            // jquery.color.svg-names.js.
            colors = jQuery.Color.names = {
                // 4.1. Basic color keywords
                aqua: "#00ffff",
                black: "#000000",
                blue: "#0000ff",
                fuchsia: "#ff00ff",
                gray: "#808080",
                green: "#008000",
                lime: "#00ff00",
                maroon: "#800000",
                navy: "#000080",
                olive: "#808000",
                purple: "#800080",
                red: "#ff0000",
                silver: "#c0c0c0",
                teal: "#008080",
                white: "#ffffff",
                yellow: "#ffff00",
                
                // 4.2.3. "transparent" color keyword
                transparent: [ null, null, null, 0 ],
                
                _default: "#ffffff"
            };
            
        })( jQuery );
        
        
        /******************************************************************************/
        /****************************** CLASS ANIMATIONS ******************************/
        /******************************************************************************/
        (function() {
            
            var classAnimationActions = [ "add", "remove", "toggle" ],
                shorthandStyles = {
                    border: 1,
                    borderBottom: 1,
                    borderColor: 1,
                    borderLeft: 1,
                    borderRight: 1,
                    borderTop: 1,
                    borderWidth: 1,
                    margin: 1,
                    padding: 1
                };
            
            $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
                $.fx.step[ prop ] = function( fx ) {
                    if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
                        jQuery.style( fx.elem, prop, fx.end );
                        fx.setAttr = true;
                    }
                };
            });
            
            function getElementStyles( elem ) {
                var key, len,
                    style = elem.ownerDocument.defaultView ?
                        elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
                        elem.currentStyle,
                    styles = {};
                
                if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
                    len = style.length;
                    while ( len-- ) {
                        key = style[ len ];
                        if ( typeof style[ key ] === "string" ) {
                            styles[ $.camelCase( key ) ] = style[ key ];
                        }
                    }
                    // support: Opera, IE <9
                } else {
                    for ( key in style ) {
                        if ( typeof style[ key ] === "string" ) {
                            styles[ key ] = style[ key ];
                        }
                    }
                }
                
                return styles;
            }
            
            
            function styleDifference( oldStyle, newStyle ) {
                var diff = {},
                    name, value;
                
                for ( name in newStyle ) {
                    value = newStyle[ name ];
                    if ( oldStyle[ name ] !== value ) {
                        if ( !shorthandStyles[ name ] ) {
                            if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
                                diff[ name ] = value;
                            }
                        }
                    }
                }
                
                return diff;
            }
            
            // support: jQuery <1.8
            if ( !$.fn.addBack ) {
                $.fn.addBack = function( selector ) {
                    return this.add( selector == null ?
                            this.prevObject : this.prevObject.filter( selector )
                    );
                };
            }
            
            $.effects.animateClass = function( value, duration, easing, callback ) {
                var o = $.speed( duration, easing, callback );
                
                return this.queue( function() {
                    var animated = $( this ),
                        baseClass = animated.attr( "class" ) || "",
                        applyClassChange,
                        allAnimations = o.children ? animated.find( "*" ).addBack() : animated;
                    
                    // map the animated objects to store the original styles.
                    allAnimations = allAnimations.map(function() {
                        var el = $( this );
                        return {
                            el: el,
                            start: getElementStyles( this )
                        };
                    });
                    
                    // apply class change
                    applyClassChange = function() {
                        $.each( classAnimationActions, function(i, action) {
                            if ( value[ action ] ) {
                                animated[ action + "Class" ]( value[ action ] );
                            }
                        });
                    };
                    applyClassChange();
                    
                    // map all animated objects again - calculate new styles and diff
                    allAnimations = allAnimations.map(function() {
                        this.end = getElementStyles( this.el[ 0 ] );
                        this.diff = styleDifference( this.start, this.end );
                        return this;
                    });
                    
                    // apply original class
                    animated.attr( "class", baseClass );
                    
                    // map all animated objects again - this time collecting a promise
                    allAnimations = allAnimations.map(function() {
                        var styleInfo = this,
                            dfd = $.Deferred(),
                            opts = $.extend({}, o, {
                                queue: false,
                                complete: function() {
                                    dfd.resolve( styleInfo );
                                }
                            });
                        
                        this.el.animate( this.diff, opts );
                        return dfd.promise();
                    });
                    
                    // once all animations have completed:
                    $.when.apply( $, allAnimations.get() ).done(function() {
                        
                        // set the final class
                        applyClassChange();
                        
                        // for each animated element,
                        // clear all css properties that were animated
                        $.each( arguments, function() {
                            var el = this.el;
                            $.each( this.diff, function(key) {
                                el.css( key, "" );
                            });
                        });
                        
                        // this is guarnteed to be there if you use jQuery.speed()
                        // it also handles dequeuing the next anim...
                        o.complete.call( animated[ 0 ] );
                    });
                });
            };
            
            $.fn.extend({
                addClass: (function( orig ) {
                    return function( classNames, speed, easing, callback ) {
                        return speed ?
                            $.effects.animateClass.call( this,
                                { add: classNames }, speed, easing, callback ) :
                            orig.apply( this, arguments );
                    };
                })( $.fn.addClass ),
                
                removeClass: (function( orig ) {
                    return function( classNames, speed, easing, callback ) {
                        return arguments.length > 1 ?
                            $.effects.animateClass.call( this,
                                { remove: classNames }, speed, easing, callback ) :
                            orig.apply( this, arguments );
                    };
                })( $.fn.removeClass ),
                
                toggleClass: (function( orig ) {
                    return function( classNames, force, speed, easing, callback ) {
                        if ( typeof force === "boolean" || force === undefined ) {
                            if ( !speed ) {
                                // without speed parameter
                                return orig.apply( this, arguments );
                            } else {
                                return $.effects.animateClass.call( this,
                                    (force ? { add: classNames } : { remove: classNames }),
                                    speed, easing, callback );
                            }
                        } else {
                            // without force parameter
                            return $.effects.animateClass.call( this,
                                { toggle: classNames }, force, speed, easing );
                        }
                    };
                })( $.fn.toggleClass ),
                
                switchClass: function( remove, add, speed, easing, callback) {
                    return $.effects.animateClass.call( this, {
                        add: add,
                        remove: remove
                    }, speed, easing, callback );
                }
            });
            
        })();
        
        /******************************************************************************/
        /*********************************** EFFECTS **********************************/
        /******************************************************************************/
        
        (function() {
            
            $.extend( $.effects, {
                version: "1.10.3",
                
                // Saves a set of properties in a data storage
                save: function( element, set ) {
                    for( var i=0; i < set.length; i++ ) {
                        if ( set[ i ] !== null ) {
                            element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
                        }
                    }
                },
                
                // Restores a set of previously saved properties from a data storage
                restore: function( element, set ) {
                    var val, i;
                    for( i=0; i < set.length; i++ ) {
                        if ( set[ i ] !== null ) {
                            val = element.data( dataSpace + set[ i ] );
                            // support: jQuery 1.6.2
                            // http://bugs.jquery.com/ticket/9917
                            // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
                            // We can't differentiate between "" and 0 here, so we just assume
                            // empty string since it's likely to be a more common value...
                            if ( val === undefined ) {
                                val = "";
                            }
                            element.css( set[ i ], val );
                        }
                    }
                },
                
                setMode: function( el, mode ) {
                    if (mode === "toggle") {
                        mode = el.is( ":hidden" ) ? "show" : "hide";
                    }
                    return mode;
                },
                
                // Translates a [top,left] array into a baseline value
                // this should be a little more flexible in the future to handle a string & hash
                getBaseline: function( origin, original ) {
                    var y, x;
                    switch ( origin[ 0 ] ) {
                        case "top": y = 0; break;
                        case "middle": y = 0.5; break;
                        case "bottom": y = 1; break;
                        default: y = origin[ 0 ] / original.height;
                    }
                    switch ( origin[ 1 ] ) {
                        case "left": x = 0; break;
                        case "center": x = 0.5; break;
                        case "right": x = 1; break;
                        default: x = origin[ 1 ] / original.width;
                    }
                    return {
                        x: x,
                        y: y
                    };
                },
                
                // Wraps the element around a wrapper that copies position properties
                createWrapper: function( element ) {
                    
                    // if the element is already wrapped, return it
                    if ( element.parent().is( ".ui-effects-wrapper" )) {
                        return element.parent();
                    }
                    
                    // wrap the element
                    var props = {
                            width: element.outerWidth(true),
                            height: element.outerHeight(true),
                            "float": element.css( "float" )
                        },
                        wrapper = $( "<div></div>" )
                            .addClass( "ui-effects-wrapper" )
                            .css({
                                fontSize: "100%",
                                background: "transparent",
                                border: "none",
                                margin: 0,
                                padding: 0
                            }),
                    // Store the size in case width/height are defined in % - Fixes #5245
                        size = {
                            width: element.width(),
                            height: element.height()
                        },
                        active = document.activeElement;
                    
                    // support: Firefox
                    // Firefox incorrectly exposes anonymous content
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                    try {
                        active.id;
                    } catch( e ) {
                        active = document.body;
                    }
                    
                    element.wrap( wrapper );
                    
                    // Fixes #7595 - Elements lose focus when wrapped.
                    if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
                        $( active ).focus();
                    }
                    
                    wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
                    
                    // transfer positioning properties to the wrapper
                    if ( element.css( "position" ) === "static" ) {
                        wrapper.css({ position: "relative" });
                        element.css({ position: "relative" });
                    } else {
                        $.extend( props, {
                            position: element.css( "position" ),
                            zIndex: element.css( "z-index" )
                        });
                        $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                            props[ pos ] = element.css( pos );
                            if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
                                props[ pos ] = "auto";
                            }
                        });
                        element.css({
                            position: "relative",
                            top: 0,
                            left: 0,
                            right: "auto",
                            bottom: "auto"
                        });
                    }
                    element.css(size);
                    
                    return wrapper.css( props ).show();
                },
                
                removeWrapper: function( element ) {
                    var active = document.activeElement;
                    
                    if ( element.parent().is( ".ui-effects-wrapper" ) ) {
                        element.parent().replaceWith( element );
                        
                        // Fixes #7595 - Elements lose focus when wrapped.
                        if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
                            $( active ).focus();
                        }
                    }
                    
                    
                    return element;
                },
                
                setTransition: function( element, list, factor, value ) {
                    value = value || {};
                    $.each( list, function( i, x ) {
                        var unit = element.cssUnit( x );
                        if ( unit[ 0 ] > 0 ) {
                            value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
                        }
                    });
                    return value;
                }
            });
            
            // return an effect options object for the given parameters:
            function _normalizeArguments( effect, options, speed, callback ) {
                
                // allow passing all options as the first parameter
                if ( $.isPlainObject( effect ) ) {
                    options = effect;
                    effect = effect.effect;
                }
                
                // convert to an object
                effect = { effect: effect };
                
                // catch (effect, null, ...)
                if ( options == null ) {
                    options = {};
                }
                
                // catch (effect, callback)
                if ( $.isFunction( options ) ) {
                    callback = options;
                    speed = null;
                    options = {};
                }
                
                // catch (effect, speed, ?)
                if ( typeof options === "number" || $.fx.speeds[ options ] ) {
                    callback = speed;
                    speed = options;
                    options = {};
                }
                
                // catch (effect, options, callback)
                if ( $.isFunction( speed ) ) {
                    callback = speed;
                    speed = null;
                }
                
                // add options to effect
                if ( options ) {
                    $.extend( effect, options );
                }
                
                speed = speed || options.duration;
                effect.duration = $.fx.off ? 0 :
                    typeof speed === "number" ? speed :
                        speed in $.fx.speeds ? $.fx.speeds[ speed ] :
                            $.fx.speeds._default;
                
                effect.complete = callback || options.complete;
                
                return effect;
            }
            
            function standardAnimationOption( option ) {
                // Valid standard speeds (nothing, number, named speed)
                if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
                    return true;
                }
                
                // Invalid strings - treat as "normal" speed
                if ( typeof option === "string" && !$.effects.effect[ option ] ) {
                    return true;
                }
                
                // Complete callback
                if ( $.isFunction( option ) ) {
                    return true;
                }
                
                // Options hash (but not naming an effect)
                if ( typeof option === "object" && !option.effect ) {
                    return true;
                }
                
                // Didn't match any standard API
                return false;
            }
            
            $.fn.extend({
                effect: function( /* effect, options, speed, callback */ ) {
                    var args = _normalizeArguments.apply( this, arguments ),
                        mode = args.mode,
                        queue = args.queue,
                        effectMethod = $.effects.effect[ args.effect ];
                    
                    if ( $.fx.off || !effectMethod ) {
                        // delegate to the original method (e.g., .show()) if possible
                        if ( mode ) {
                            return this[ mode ]( args.duration, args.complete );
                        } else {
                            return this.each( function() {
                                if ( args.complete ) {
                                    args.complete.call( this );
                                }
                            });
                        }
                    }
                    
                    function run( next ) {
                        var elem = $( this ),
                            complete = args.complete,
                            mode = args.mode;
                        
                        function done() {
                            if ( $.isFunction( complete ) ) {
                                complete.call( elem[0] );
                            }
                            if ( $.isFunction( next ) ) {
                                next();
                            }
                        }
                        
                        // If the element already has the correct final state, delegate to
                        // the core methods so the internal tracking of "olddisplay" works.
                        if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
                            elem[ mode ]();
                            done();
                        } else {
                            effectMethod.call( elem[0], args, done );
                        }
                    }
                    
                    return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
                },
                
                show: (function( orig ) {
                    return function( option ) {
                        if ( standardAnimationOption( option ) ) {
                            return orig.apply( this, arguments );
                        } else {
                            var args = _normalizeArguments.apply( this, arguments );
                            args.mode = "show";
                            return this.effect.call( this, args );
                        }
                    };
                })( $.fn.show ),
                
                hide: (function( orig ) {
                    return function( option ) {
                        if ( standardAnimationOption( option ) ) {
                            return orig.apply( this, arguments );
                        } else {
                            var args = _normalizeArguments.apply( this, arguments );
                            args.mode = "hide";
                            return this.effect.call( this, args );
                        }
                    };
                })( $.fn.hide ),
                
                toggle: (function( orig ) {
                    return function( option ) {
                        if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
                            return orig.apply( this, arguments );
                        } else {
                            var args = _normalizeArguments.apply( this, arguments );
                            args.mode = "toggle";
                            return this.effect.call( this, args );
                        }
                    };
                })( $.fn.toggle ),
                
                // helper functions
                cssUnit: function(key) {
                    var style = this.css( key ),
                        val = [];
                    
                    $.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
                        if ( style.indexOf( unit ) > 0 ) {
                            val = [ parseFloat( style ), unit ];
                        }
                    });
                    return val;
                }
            });
            
        })();
        
        /******************************************************************************/
        /*********************************** EASING ***********************************/
        /******************************************************************************/
        
        (function() {
            
            // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
            
            var baseEasings = {};
            
            $.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
                baseEasings[ name ] = function( p ) {
                    return Math.pow( p, i + 2 );
                };
            });
            
            $.extend( baseEasings, {
                Sine: function ( p ) {
                    return 1 - Math.cos( p * Math.PI / 2 );
                },
                Circ: function ( p ) {
                    return 1 - Math.sqrt( 1 - p * p );
                },
                Elastic: function( p ) {
                    return p === 0 || p === 1 ? p :
                    -Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
                },
                Back: function( p ) {
                    return p * p * ( 3 * p - 2 );
                },
                Bounce: function ( p ) {
                    var pow2,
                        bounce = 4;
                    
                    while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
                    return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
                }
            });
            
            $.each( baseEasings, function( name, easeIn ) {
                $.easing[ "easeIn" + name ] = easeIn;
                $.easing[ "easeOut" + name ] = function( p ) {
                    return 1 - easeIn( 1 - p );
                };
                $.easing[ "easeInOut" + name ] = function( p ) {
                    return p < 0.5 ?
                    easeIn( p * 2 ) / 2 :
                    1 - easeIn( p * -2 + 2 ) / 2;
                };
            });
            
        })();
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        var uid = 0,
            hideProps = {},
            showProps = {};
        
        hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
            hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
        showProps.height = showProps.paddingTop = showProps.paddingBottom =
            showProps.borderTopWidth = showProps.borderBottomWidth = "show";
        
        $.widget( "ui.accordion", {
            version: "1.10.3",
            options: {
                active: 0,
                animate: {},
                collapsible: false,
                event: "click",
                header: "> li > :first-child,> :not(li):even",
                heightStyle: "auto",
                icons: {
                    activeHeader: "ui-icon-triangle-1-s",
                    header: "ui-icon-triangle-1-e"
                },
                
                // callbacks
                activate: null,
                beforeActivate: null
            },
            
            _create: function() {
                var options = this.options;
                this.prevShow = this.prevHide = $();
                this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
                    // ARIA
                    .attr( "role", "tablist" );
                
                // don't allow collapsible: false and active: false / null
                if ( !options.collapsible && (options.active === false || options.active == null) ) {
                    options.active = 0;
                }
                
                this._processPanels();
                // handle negative values
                if ( options.active < 0 ) {
                    options.active += this.headers.length;
                }
                this._refresh();
            },
            
            _getCreateEventData: function() {
                return {
                    header: this.active,
                    panel: !this.active.length ? $() : this.active.next(),
                    content: !this.active.length ? $() : this.active.next()
                };
            },
            
            _createIcons: function() {
                var icons = this.options.icons;
                if ( icons ) {
                    $( "<span>" )
                        .addClass( "ui-accordion-header-icon ui-icon " + icons.header )
                        .prependTo( this.headers );
                    this.active.children( ".ui-accordion-header-icon" )
                        .removeClass( icons.header )
                        .addClass( icons.activeHeader );
                    this.headers.addClass( "ui-accordion-icons" );
                }
            },
            
            _destroyIcons: function() {
                this.headers
                    .removeClass( "ui-accordion-icons" )
                    .children( ".ui-accordion-header-icon" )
                    .remove();
            },
            
            _destroy: function() {
                var contents;
                
                // clean up main element
                this.element
                    .removeClass( "ui-accordion ui-widget ui-helper-reset" )
                    .removeAttr( "role" );
                
                // clean up headers
                this.headers
                    .removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
                    .removeAttr( "role" )
                    .removeAttr( "aria-selected" )
                    .removeAttr( "aria-controls" )
                    .removeAttr( "tabIndex" )
                    .each(function() {
                        if ( /^ui-accordion/.test( this.id ) ) {
                            this.removeAttribute( "id" );
                        }
                    });
                this._destroyIcons();
                
                // clean up content panels
                contents = this.headers.next()
                    .css( "display", "" )
                    .removeAttr( "role" )
                    .removeAttr( "aria-expanded" )
                    .removeAttr( "aria-hidden" )
                    .removeAttr( "aria-labelledby" )
                    .removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
                    .each(function() {
                        if ( /^ui-accordion/.test( this.id ) ) {
                            this.removeAttribute( "id" );
                        }
                    });
                if ( this.options.heightStyle !== "content" ) {
                    contents.css( "height", "" );
                }
            },
            
            _setOption: function( key, value ) {
                if ( key === "active" ) {
                    // _activate() will handle invalid values and update this.options
                    this._activate( value );
                    return;
                }
                
                if ( key === "event" ) {
                    if ( this.options.event ) {
                        this._off( this.headers, this.options.event );
                    }
                    this._setupEvents( value );
                }
                
                this._super( key, value );
                
                // setting collapsible: false while collapsed; open first panel
                if ( key === "collapsible" && !value && this.options.active === false ) {
                    this._activate( 0 );
                }
                
                if ( key === "icons" ) {
                    this._destroyIcons();
                    if ( value ) {
                        this._createIcons();
                    }
                }
                
                // #5332 - opacity doesn't cascade to positioned elements in IE
                // so we need to add the disabled class to the headers and panels
                if ( key === "disabled" ) {
                    this.headers.add( this.headers.next() )
                        .toggleClass( "ui-state-disabled", !!value );
                }
            },
            
            _keydown: function( event ) {
                /*jshint maxcomplexity:15*/
                if ( event.altKey || event.ctrlKey ) {
                    return;
                }
                
                var keyCode = $.ui.keyCode,
                    length = this.headers.length,
                    currentIndex = this.headers.index( event.target ),
                    toFocus = false;
                
                switch ( event.keyCode ) {
                    case keyCode.RIGHT:
                    case keyCode.DOWN:
                        toFocus = this.headers[ ( currentIndex + 1 ) % length ];
                        break;
                    case keyCode.LEFT:
                    case keyCode.UP:
                        toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
                        break;
                    case keyCode.SPACE:
                    case keyCode.ENTER:
                        this._eventHandler( event );
                        break;
                    case keyCode.HOME:
                        toFocus = this.headers[ 0 ];
                        break;
                    case keyCode.END:
                        toFocus = this.headers[ length - 1 ];
                        break;
                }
                
                if ( toFocus ) {
                    $( event.target ).attr( "tabIndex", -1 );
                    $( toFocus ).attr( "tabIndex", 0 );
                    toFocus.focus();
                    event.preventDefault();
                }
            },
            
            _panelKeyDown : function( event ) {
                if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
                    $( event.currentTarget ).prev().focus();
                }
            },
            
            refresh: function() {
                var options = this.options;
                this._processPanels();
                
                // was collapsed or no panel
                if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
                    options.active = false;
                    this.active = $();
                    // active false only when collapsible is true
                } else if ( options.active === false ) {
                    this._activate( 0 );
                    // was active, but active panel is gone
                } else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
                    // all remaining panel are disabled
                    if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
                        options.active = false;
                        this.active = $();
                        // activate previous panel
                    } else {
                        this._activate( Math.max( 0, options.active - 1 ) );
                    }
                    // was active, active panel still exists
                } else {
                    // make sure active index is correct
                    options.active = this.headers.index( this.active );
                }
                
                this._destroyIcons();
                
                this._refresh();
            },
            
            _processPanels: function() {
                this.headers = this.element.find( this.options.header )
                    .addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );
                
                this.headers.next()
                    .addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
                    .filter(":not(.ui-accordion-content-active)")
                    .hide();
            },
            
            _refresh: function() {
                var maxHeight,
                    options = this.options,
                    heightStyle = options.heightStyle,
                    parent = this.element.parent(),
                    accordionId = this.accordionId = "ui-accordion-" +
                        (this.element.attr( "id" ) || ++uid);
                
                this.active = this._findActive( options.active )
                    .addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
                    .removeClass( "ui-corner-all" );
                this.active.next()
                    .addClass( "ui-accordion-content-active" )
                    .show();
                
                this.headers
                    .attr( "role", "tab" )
                    .each(function( i ) {
                        var header = $( this ),
                            headerId = header.attr( "id" ),
                            panel = header.next(),
                            panelId = panel.attr( "id" );
                        if ( !headerId ) {
                            headerId = accordionId + "-header-" + i;
                            header.attr( "id", headerId );
                        }
                        if ( !panelId ) {
                            panelId = accordionId + "-panel-" + i;
                            panel.attr( "id", panelId );
                        }
                        header.attr( "aria-controls", panelId );
                        panel.attr( "aria-labelledby", headerId );
                    })
                    .next()
                    .attr( "role", "tabpanel" );
                
                this.headers
                    .not( this.active )
                    .attr({
                        "aria-selected": "false",
                        tabIndex: -1
                    })
                    .next()
                    .attr({
                        "aria-expanded": "false",
                        "aria-hidden": "true"
                    })
                    .hide();
                
                // make sure at least one header is in the tab order
                if ( !this.active.length ) {
                    this.headers.eq( 0 ).attr( "tabIndex", 0 );
                } else {
                    this.active.attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    })
                        .next()
                        .attr({
                            "aria-expanded": "true",
                            "aria-hidden": "false"
                        });
                }
                
                this._createIcons();
                
                this._setupEvents( options.event );
                
                if ( heightStyle === "fill" ) {
                    maxHeight = parent.height();
                    this.element.siblings( ":visible" ).each(function() {
                        var elem = $( this ),
                            position = elem.css( "position" );
                        
                        if ( position === "absolute" || position === "fixed" ) {
                            return;
                        }
                        maxHeight -= elem.outerHeight( true );
                    });
                    
                    this.headers.each(function() {
                        maxHeight -= $( this ).outerHeight( true );
                    });
                    
                    this.headers.next()
                        .each(function() {
                            $( this ).height( Math.max( 0, maxHeight -
                                $( this ).innerHeight() + $( this ).height() ) );
                        })
                        .css( "overflow", "auto" );
                } else if ( heightStyle === "auto" ) {
                    maxHeight = 0;
                    this.headers.next()
                        .each(function() {
                            maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
                        })
                        .height( maxHeight );
                }
            },
            
            _activate: function( index ) {
                var active = this._findActive( index )[ 0 ];
                
                // trying to activate the already active panel
                if ( active === this.active[ 0 ] ) {
                    return;
                }
                
                // trying to collapse, simulate a click on the currently active header
                active = active || this.active[ 0 ];
                
                this._eventHandler({
                    target: active,
                    currentTarget: active,
                    preventDefault: $.noop
                });
            },
            
            _findActive: function( selector ) {
                return typeof selector === "number" ? this.headers.eq( selector ) : $();
            },
            
            _setupEvents: function( event ) {
                var events = {
                    keydown: "_keydown"
                };
                if ( event ) {
                    $.each( event.split(" "), function( index, eventName ) {
                        events[ eventName ] = "_eventHandler";
                    });
                }
                
                this._off( this.headers.add( this.headers.next() ) );
                this._on( this.headers, events );
                this._on( this.headers.next(), { keydown: "_panelKeyDown" });
                this._hoverable( this.headers );
                this._focusable( this.headers );
            },
            
            _eventHandler: function( event ) {
                var options = this.options,
                    active = this.active,
                    clicked = $( event.currentTarget ),
                    clickedIsActive = clicked[ 0 ] === active[ 0 ],
                    collapsing = clickedIsActive && options.collapsible,
                    toShow = collapsing ? $() : clicked.next(),
                    toHide = active.next(),
                    eventData = {
                        oldHeader: active,
                        oldPanel: toHide,
                        newHeader: collapsing ? $() : clicked,
                        newPanel: toShow
                    };
                
                event.preventDefault();
                
                if (
                    // click on active header, but not collapsible
                ( clickedIsActive && !options.collapsible ) ||
                    // allow canceling activation
                ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
                    return;
                }
                
                options.active = collapsing ? false : this.headers.index( clicked );
                
                // when the call to ._toggle() comes after the class changes
                // it causes a very odd bug in IE 8 (see #6720)
                this.active = clickedIsActive ? $() : clicked;
                this._toggle( eventData );
                
                // switch classes
                // corner classes on the previously active header stay after the animation
                active.removeClass( "ui-accordion-header-active ui-state-active" );
                if ( options.icons ) {
                    active.children( ".ui-accordion-header-icon" )
                        .removeClass( options.icons.activeHeader )
                        .addClass( options.icons.header );
                }
                
                if ( !clickedIsActive ) {
                    clicked
                        .removeClass( "ui-corner-all" )
                        .addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
                    if ( options.icons ) {
                        clicked.children( ".ui-accordion-header-icon" )
                            .removeClass( options.icons.header )
                            .addClass( options.icons.activeHeader );
                    }
                    
                    clicked
                        .next()
                        .addClass( "ui-accordion-content-active" );
                }
            },
            
            _toggle: function( data ) {
                var toShow = data.newPanel,
                    toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
                
                // handle activating a panel during the animation for another activation
                this.prevShow.add( this.prevHide ).stop( true, true );
                this.prevShow = toShow;
                this.prevHide = toHide;
                
                if ( this.options.animate ) {
                    this._animate( toShow, toHide, data );
                } else {
                    toHide.hide();
                    toShow.show();
                    this._toggleComplete( data );
                }
                
                toHide.attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                });
                toHide.prev().attr( "aria-selected", "false" );
                // if we're switching panels, remove the old header from the tab order
                // if we're opening from collapsed state, remove the previous header from the tab order
                // if we're collapsing, then keep the collapsing header in the tab order
                if ( toShow.length && toHide.length ) {
                    toHide.prev().attr( "tabIndex", -1 );
                } else if ( toShow.length ) {
                    this.headers.filter(function() {
                        return $( this ).attr( "tabIndex" ) === 0;
                    })
                        .attr( "tabIndex", -1 );
                }
                
                toShow
                    .attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    })
                    .prev()
                    .attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    });
            },
            
            _animate: function( toShow, toHide, data ) {
                var total, easing, duration,
                    that = this,
                    adjust = 0,
                    down = toShow.length &&
                        ( !toHide.length || ( toShow.index() < toHide.index() ) ),
                    animate = this.options.animate || {},
                    options = down && animate.down || animate,
                    complete = function() {
                        that._toggleComplete( data );
                    };
                
                if ( typeof options === "number" ) {
                    duration = options;
                }
                if ( typeof options === "string" ) {
                    easing = options;
                }
                // fall back from options to animation in case of partial down settings
                easing = easing || options.easing || animate.easing;
                duration = duration || options.duration || animate.duration;
                
                if ( !toHide.length ) {
                    return toShow.animate( showProps, duration, easing, complete );
                }
                if ( !toShow.length ) {
                    return toHide.animate( hideProps, duration, easing, complete );
                }
                
                total = toShow.show().outerHeight();
                toHide.animate( hideProps, {
                    duration: duration,
                    easing: easing,
                    step: function( now, fx ) {
                        fx.now = Math.round( now );
                    }
                });
                toShow
                    .hide()
                    .animate( showProps, {
                        duration: duration,
                        easing: easing,
                        complete: complete,
                        step: function( now, fx ) {
                            fx.now = Math.round( now );
                            if ( fx.prop !== "height" ) {
                                adjust += fx.now;
                            } else if ( that.options.heightStyle !== "content" ) {
                                fx.now = Math.round( total - toHide.outerHeight() - adjust );
                                adjust = 0;
                            }
                        }
                    });
            },
            
            _toggleComplete: function( data ) {
                var toHide = data.oldPanel;
                
                toHide
                    .removeClass( "ui-accordion-content-active" )
                    .prev()
                    .removeClass( "ui-corner-top" )
                    .addClass( "ui-corner-all" );
                
                // Work around for rendering bug in IE (#5421)
                if ( toHide.length ) {
                    toHide.parent()[0].className = toHide.parent()[0].className;
                }
                
                this._trigger( "activate", null, data );
            }
        });
        
    })( jQuery );
    
    (function( $, undefined ) {
        
        // used to prevent race conditions with remote data sources
        var requestIndex = 0;
        
        $.widget( "ui.autocomplete", {
            version: "1.10.3",
            defaultElement: "<input>",
            options: {
                appendTo: null,
                autoFocus: false,
                delay: 300,
                minLength: 1,
                position: {
                    my: "left top",
                    at: "left bottom",
                    collision: "none"
                },
                source: null,
                
                // callbacks
                change: null,
                close: null,
                focus: null,
                open: null,
                response: null,
                search: null,
                select: null
            },
            
            pending: 0,
            
            _create: function() {
                // Some browsers only repeat keydown events, not keypress events,
                // so we use the suppressKeyPress flag to determine if we've already
                // handled the keydown event. #7269
                // Unfortunately the code for & in keypress is the same as the up arrow,
                // so we use the suppressKeyPressRepeat flag to avoid handling keypress
                // events when we know the keydown event was used to modify the
                // search term. #7799
                var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
                    nodeName = this.element[0].nodeName.toLowerCase(),
                    isTextarea = nodeName === "textarea",
                    isInput = nodeName === "input";
                
                this.isMultiLine =
                    // Textareas are always multi-line
                    isTextarea ? true :
                        // Inputs are always single-line, even if inside a contentEditable element
                        // IE also treats inputs as contentEditable
                        isInput ? false :
                            // All other element types are determined by whether or not they're contentEditable
                            this.element.prop( "isContentEditable" );
                
                this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
                this.isNewMenu = true;
                
                this.element
                    .addClass( "ui-autocomplete-input" )
                    .attr( "autocomplete", "off" );
                
                this._on( this.element, {
                    keydown: function( event ) {
                        /*jshint maxcomplexity:15*/
                        if ( this.element.prop( "readOnly" ) ) {
                            suppressKeyPress = true;
                            suppressInput = true;
                            suppressKeyPressRepeat = true;
                            return;
                        }
                        
                        suppressKeyPress = false;
                        suppressInput = false;
                        suppressKeyPressRepeat = false;
                        var keyCode = $.ui.keyCode;
                        switch( event.keyCode ) {
                            case keyCode.PAGE_UP:
                                suppressKeyPress = true;
                                this._move( "previousPage", event );
                                break;
                            case keyCode.PAGE_DOWN:
                                suppressKeyPress = true;
                                this._move( "nextPage", event );
                                break;
                            case keyCode.UP:
                                suppressKeyPress = true;
                                this._keyEvent( "previous", event );
                                break;
                            case keyCode.DOWN:
                                suppressKeyPress = true;
                                this._keyEvent( "next", event );
                                break;
                            case keyCode.ENTER:
                            case keyCode.NUMPAD_ENTER:
                                // when menu is open and has focus
                                if ( this.menu.active ) {
                                    // #6055 - Opera still allows the keypress to occur
                                    // which causes forms to submit
                                    suppressKeyPress = true;
                                    event.preventDefault();
                                    this.menu.select( event );
                                }
                                break;
                            case keyCode.TAB:
                                if ( this.menu.active ) {
                                    this.menu.select( event );
                                }
                                break;
                            case keyCode.ESCAPE:
                                if ( this.menu.element.is( ":visible" ) ) {
                                    this._value( this.term );
                                    this.close( event );
                                    // Different browsers have different default behavior for escape
                                    // Single press can mean undo or clear
                                    // Double press in IE means clear the whole form
                                    event.preventDefault();
                                }
                                break;
                            default:
                                suppressKeyPressRepeat = true;
                                // search timeout should be triggered before the input value is changed
                                this._searchTimeout( event );
                                break;
                        }
                    },
                    keypress: function( event ) {
                        if ( suppressKeyPress ) {
                            suppressKeyPress = false;
                            if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
                                event.preventDefault();
                            }
                            return;
                        }
                        if ( suppressKeyPressRepeat ) {
                            return;
                        }
                        
                        // replicate some key handlers to allow them to repeat in Firefox and Opera
                        var keyCode = $.ui.keyCode;
                        switch( event.keyCode ) {
                            case keyCode.PAGE_UP:
                                this._move( "previousPage", event );
                                break;
                            case keyCode.PAGE_DOWN:
                                this._move( "nextPage", event );
                                break;
                            case keyCode.UP:
                                this._keyEvent( "previous", event );
                                break;
                            case keyCode.DOWN:
                                this._keyEvent( "next", event );
                                break;
                        }
                    },
                    input: function( event ) {
                        if ( suppressInput ) {
                            suppressInput = false;
                            event.preventDefault();
                            return;
                        }
                        this._searchTimeout( event );
                    },
                    focus: function() {
                        this.selectedItem = null;
                        this.previous = this._value();
                    },
                    blur: function( event ) {
                        if ( this.cancelBlur ) {
                            delete this.cancelBlur;
                            return;
                        }
                        
                        clearTimeout( this.searching );
                        this.close( event );
                        this._change( event );
                    }
                });
                
                this._initSource();
                this.menu = $( "<ul>" )
                    .addClass( "ui-autocomplete ui-front" )
                    .appendTo( this._appendTo() )
                    .menu({
                        // disable ARIA support, the live region takes care of that
                        role: null
                    })
                    .hide()
                    .data( "ui-menu" );
                
                this._on( this.menu.element, {
                    mousedown: function( event ) {
                        // prevent moving focus out of the text field
                        event.preventDefault();
                        
                        // IE doesn't prevent moving focus even with event.preventDefault()
                        // so we set a flag to know when we should ignore the blur event
                        this.cancelBlur = true;
                        this._delay(function() {
                            delete this.cancelBlur;
                        });
                        
                        // clicking on the scrollbar causes focus to shift to the body
                        // but we can't detect a mouseup or a click immediately afterward
                        // so we have to track the next mousedown and close the menu if
                        // the user clicks somewhere outside of the autocomplete
                        var menuElement = this.menu.element[ 0 ];
                        if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
                            this._delay(function() {
                                var that = this;
                                this.document.one( "mousedown", function( event ) {
                                    if ( event.target !== that.element[ 0 ] &&
                                        event.target !== menuElement &&
                                        !$.contains( menuElement, event.target ) ) {
                                        that.close();
                                    }
                                });
                            });
                        }
                    },
                    menufocus: function( event, ui ) {
                        // support: Firefox
                        // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                        if ( this.isNewMenu ) {
                            this.isNewMenu = false;
                            if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
                                this.menu.blur();
                                
                                this.document.one( "mousemove", function() {
                                    $( event.target ).trigger( event.originalEvent );
                                });
                                
                                return;
                            }
                        }
                        
                        var item = ui.item.data( "ui-autocomplete-item" );
                        if ( false !== this._trigger( "focus", event, { item: item } ) ) {
                            // use value to match what will end up in the input, if it was a key event
                            if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
                                this._value( item.value );
                            }
                        } else {
                            // Normally the input is populated with the item's value as the
                            // menu is navigated, causing screen readers to notice a change and
                            // announce the item. Since the focus event was canceled, this doesn't
                            // happen, so we update the live region so that screen readers can
                            // still notice the change and announce it.
                            this.liveRegion.text( item.value );
                        }
                    },
                    menuselect: function( event, ui ) {
                        var item = ui.item.data( "ui-autocomplete-item" ),
                            previous = this.previous;
                        
                        // only trigger when focus was lost (click on menu)
                        if ( this.element[0] !== this.document[0].activeElement ) {
                            this.element.focus();
                            this.previous = previous;
                            // #6109 - IE triggers two focus events and the second
                            // is asynchronous, so we need to reset the previous
                            // term synchronously and asynchronously :-(
                            this._delay(function() {
                                this.previous = previous;
                                this.selectedItem = item;
                            });
                        }
                        
                        if ( false !== this._trigger( "select", event, { item: item } ) ) {
                            this._value( item.value );
                        }
                        // reset the term after the select event
                        // this allows custom select handling to work properly
                        this.term = this._value();
                        
                        this.close( event );
                        this.selectedItem = item;
                    }
                });
                
                this.liveRegion = $( "<span>", {
                    role: "status",
                    "aria-live": "polite"
                })
                    .addClass( "ui-helper-hidden-accessible" )
                    .insertBefore( this.element );
                
                // turning off autocomplete prevents the browser from remembering the
                // value when navigating through history, so we re-enable autocomplete
                // if the page is unloaded before the widget is destroyed. #7790
                this._on( this.window, {
                    beforeunload: function() {
                        this.element.removeAttr( "autocomplete" );
                    }
                });
            },
            
            _destroy: function() {
                clearTimeout( this.searching );
                this.element
                    .removeClass( "ui-autocomplete-input" )
                    .removeAttr( "autocomplete" );
                this.menu.element.remove();
                this.liveRegion.remove();
            },
            
            _setOption: function( key, value ) {
                this._super( key, value );
                if ( key === "source" ) {
                    this._initSource();
                }
                if ( key === "appendTo" ) {
                    this.menu.element.appendTo( this._appendTo() );
                }
                if ( key === "disabled" && value && this.xhr ) {
                    this.xhr.abort();
                }
            },
            
            _appendTo: function() {
                var element = this.options.appendTo;
                
                if ( element ) {
                    element = element.jquery || element.nodeType ?
                        $( element ) :
                        this.document.find( element ).eq( 0 );
                }
                
                if ( !element ) {
                    element = this.element.closest( ".ui-front" );
                }
                
                if ( !element.length ) {
                    element = this.document[0].body;
                }
                
                return element;
            },
            
            _initSource: function() {
                var array, url,
                    that = this;
                if ( $.isArray(this.options.source) ) {
                    array = this.options.source;
                    this.source = function( request, response ) {
                        response( $.ui.autocomplete.filter( array, request.term ) );
                    };
                } else if ( typeof this.options.source === "string" ) {
                    url = this.options.source;
                    this.source = function( request, response ) {
                        if ( that.xhr ) {
                            that.xhr.abort();
                        }
                        that.xhr = $.ajax({
                            url: url,
                            data: request,
                            dataType: "json",
                            success: function( data ) {
                                response( data );
                            },
                            error: function() {
                                response( [] );
                            }
                        });
                    };
                } else {
                    this.source = this.options.source;
                }
            },
            
            _searchTimeout: function( event ) {
                clearTimeout( this.searching );
                this.searching = this._delay(function() {
                    // only search if the value has changed
                    if ( this.term !== this._value() ) {
                        this.selectedItem = null;
                        this.search( null, event );
                    }
                }, this.options.delay );
            },
            
            search: function( value, event ) {
                value = value != null ? value : this._value();
                
                // always save the actual value, not the one passed as an argument
                this.term = this._value();
                
                if ( value.length < this.options.minLength ) {
                    return this.close( event );
                }
                
                if ( this._trigger( "search", event ) === false ) {
                    return;
                }
                
                return this._search( value );
            },
            
            _search: function( value ) {
                this.pending++;
                this.element.addClass( "ui-autocomplete-loading" );
                this.cancelSearch = false;
                
                this.source( { term: value }, this._response() );
            },
            
            _response: function() {
                var that = this,
                    index = ++requestIndex;
                
                return function( content ) {
                    if ( index === requestIndex ) {
                        that.__response( content );
                    }
                    
                    that.pending--;
                    if ( !that.pending ) {
                        that.element.removeClass( "ui-autocomplete-loading" );
                    }
                };
            },
            
            __response: function( content ) {
                if ( content ) {
                    content = this._normalize( content );
                }
                this._trigger( "response", null, { content: content } );
                if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
                    this._suggest( content );
                    this._trigger( "open" );
                } else {
                    // use ._close() instead of .close() so we don't cancel future searches
                    this._close();
                }
            },
            
            close: function( event ) {
                this.cancelSearch = true;
                this._close( event );
            },
            
            _close: function( event ) {
                if ( this.menu.element.is( ":visible" ) ) {
                    this.menu.element.hide();
                    this.menu.blur();
                    this.isNewMenu = true;
                    this._trigger( "close", event );
                }
            },
            
            _change: function( event ) {
                if ( this.previous !== this._value() ) {
                    this._trigger( "change", event, { item: this.selectedItem } );
                }
            },
            
            _normalize: function( items ) {
                // assume all items have the right format when the first item is complete
                if ( items.length && items[0].label && items[0].value ) {
                    return items;
                }
                return $.map( items, function( item ) {
                    if ( typeof item === "string" ) {
                        return {
                            label: item,
                            value: item
                        };
                    }
                    return $.extend({
                        label: item.label || item.value,
                        value: item.value || item.label
                    }, item );
                });
            },
            
            _suggest: function( items ) {
                var ul = this.menu.element.empty();
                this._renderMenu( ul, items );
                this.isNewMenu = true;
                this.menu.refresh();
                
                // size and position menu
                ul.show();
                this._resizeMenu();
                ul.position( $.extend({
                    of: this.element
                }, this.options.position ));
                
                if ( this.options.autoFocus ) {
                    this.menu.next();
                }
            },
            
            _resizeMenu: function() {
                var ul = this.menu.element;
                ul.outerWidth( Math.max(
                    // Firefox wraps long text (possibly a rounding bug)
                    // so we add 1px to avoid the wrapping (#7513)
                    ul.width( "" ).outerWidth() + 1,
                    this.element.outerWidth()
                ) );
            },
            
            _renderMenu: function( ul, items ) {
                var that = this;
                $.each( items, function( index, item ) {
                    that._renderItemData( ul, item );
                });
            },
            
            _renderItemData: function( ul, item ) {
                return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
            },
            
            _renderItem: function( ul, item ) {
                return $( "<li>" )
                    .append( $( "<a>" ).text( item.label ) )
                    .appendTo( ul );
            },
            
            _move: function( direction, event ) {
                if ( !this.menu.element.is( ":visible" ) ) {
                    this.search( null, event );
                    return;
                }
                if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
                    this.menu.isLastItem() && /^next/.test( direction ) ) {
                    this._value( this.term );
                    this.menu.blur();
                    return;
                }
                this.menu[ direction ]( event );
            },
            
            widget: function() {
                return this.menu.element;
            },
            
            _value: function() {
                return this.valueMethod.apply( this.element, arguments );
            },
            
            _keyEvent: function( keyEvent, event ) {
                if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
                    this._move( keyEvent, event );
                    
                    // prevents moving cursor to beginning/end of the text field in some browsers
                    event.preventDefault();
                }
            }
        });
        
        $.extend( $.ui.autocomplete, {
            escapeRegex: function( value ) {
                return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
            },
            filter: function(array, term) {
                var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
                return $.grep( array, function(value) {
                    return matcher.test( value.label || value.value || value );
                });
            }
        });
        
        
        // live region extension, adding a `messages` option
        // NOTE: This is an experimental API. We are still investigating
        // a full solution for string manipulation and internationalization.
        $.widget( "ui.autocomplete", $.ui.autocomplete, {
            options: {
                messages: {
                    noResults: "No search results.",
                    results: function( amount ) {
                        return amount + ( amount > 1 ? " results are" : " result is" ) +
                            " available, use up and down arrow keys to navigate.";
                    }
                }
            },
            
            __response: function( content ) {
                var message;
                this._superApply( arguments );
                if ( this.options.disabled || this.cancelSearch ) {
                    return;
                }
                if ( content && content.length ) {
                    message = this.options.messages.results( content.length );
                } else {
                    message = this.options.messages.noResults;
                }
                this.liveRegion.text( message );
            }
        });
        
    }( jQuery ));
    
    (function( $, undefined ) {
        
        var lastActive, startXPos, startYPos, clickDragged,
            baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
            stateClasses = "ui-state-hover ui-state-active ",
            typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
            formResetHandler = function() {
                var form = $( this );
                setTimeout(function() {
                    form.find( ":ui-button" ).button( "refresh" );
                }, 1 );
            },
            radioGroup = function( radio ) {
                var name = radio.name,
                    form = radio.form,
                    radios = $( [] );
                if ( name ) {
                    name = name.replace( /'/g, "\\'" );
                    if ( form ) {
                        radios = $( form ).find( "[name='" + name + "']" );
                    } else {
                        radios = $( "[name='" + name + "']", radio.ownerDocument )
                            .filter(function() {
                                return !this.form;
                            });
                    }
                }
                return radios;
            };
        
        $.widget( "ui.button", {
            version: "1.10.3",
            defaultElement: "<button>",
            options: {
                disabled: null,
                text: true,
                label: null,
                icons: {
                    primary: null,
                    secondary: null
                }
            },
            _create: function() {
                this.element.closest( "form" )
                    .unbind( "reset" + this.eventNamespace )
                    .bind( "reset" + this.eventNamespace, formResetHandler );
                
                if ( typeof this.options.disabled !== "boolean" ) {
                    this.options.disabled = !!this.element.prop( "disabled" );
                } else {
                    this.element.prop( "disabled", this.options.disabled );
                }
                
                this._determineButtonType();
                this.hasTitle = !!this.buttonElement.attr( "title" );
                
                var that = this,
                    options = this.options,
                    toggleButton = this.type === "checkbox" || this.type === "radio",
                    activeClass = !toggleButton ? "ui-state-active" : "",
                    focusClass = "ui-state-focus";
                
                if ( options.label === null ) {
                    options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
                }
                
                this._hoverable( this.buttonElement );
                
                this.buttonElement
                    .addClass( baseClasses )
                    .attr( "role", "button" )
                    .bind( "mouseenter" + this.eventNamespace, function() {
                        if ( options.disabled ) {
                            return;
                        }
                        if ( this === lastActive ) {
                            $( this ).addClass( "ui-state-active" );
                        }
                    })
                    .bind( "mouseleave" + this.eventNamespace, function() {
                        if ( options.disabled ) {
                            return;
                        }
                        $( this ).removeClass( activeClass );
                    })
                    .bind( "click" + this.eventNamespace, function( event ) {
                        if ( options.disabled ) {
                            event.preventDefault();
                            event.stopImmediatePropagation();
                        }
                    });
                
                this.element
                    .bind( "focus" + this.eventNamespace, function() {
                        // no need to check disabled, focus won't be triggered anyway
                        that.buttonElement.addClass( focusClass );
                    })
                    .bind( "blur" + this.eventNamespace, function() {
                        that.buttonElement.removeClass( focusClass );
                    });
                
                if ( toggleButton ) {
                    this.element.bind( "change" + this.eventNamespace, function() {
                        if ( clickDragged ) {
                            return;
                        }
                        that.refresh();
                    });
                    // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
                    // prevents issue where button state changes but checkbox/radio checked state
                    // does not in Firefox (see ticket #6970)
                    this.buttonElement
                        .bind( "mousedown" + this.eventNamespace, function( event ) {
                            if ( options.disabled ) {
                                return;
                            }
                            clickDragged = false;
                            startXPos = event.pageX;
                            startYPos = event.pageY;
                        })
                        .bind( "mouseup" + this.eventNamespace, function( event ) {
                            if ( options.disabled ) {
                                return;
                            }
                            if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
                                clickDragged = true;
                            }
                        });
                }
                
                if ( this.type === "checkbox" ) {
                    this.buttonElement.bind( "click" + this.eventNamespace, function() {
                        if ( options.disabled || clickDragged ) {
                            return false;
                        }
                    });
                } else if ( this.type === "radio" ) {
                    this.buttonElement.bind( "click" + this.eventNamespace, function() {
                        if ( options.disabled || clickDragged ) {
                            return false;
                        }
                        $( this ).addClass( "ui-state-active" );
                        that.buttonElement.attr( "aria-pressed", "true" );
                        
                        var radio = that.element[ 0 ];
                        radioGroup( radio )
                            .not( radio )
                            .map(function() {
                                return $( this ).button( "widget" )[ 0 ];
                            })
                            .removeClass( "ui-state-active" )
                            .attr( "aria-pressed", "false" );
                    });
                } else {
                    this.buttonElement
                        .bind( "mousedown" + this.eventNamespace, function() {
                            if ( options.disabled ) {
                                return false;
                            }
                            $( this ).addClass( "ui-state-active" );
                            lastActive = this;
                            that.document.one( "mouseup", function() {
                                lastActive = null;
                            });
                        })
                        .bind( "mouseup" + this.eventNamespace, function() {
                            if ( options.disabled ) {
                                return false;
                            }
                            $( this ).removeClass( "ui-state-active" );
                        })
                        .bind( "keydown" + this.eventNamespace, function(event) {
                            if ( options.disabled ) {
                                return false;
                            }
                            if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
                                $( this ).addClass( "ui-state-active" );
                            }
                        })
                        // see #8559, we bind to blur here in case the button element loses
                        // focus between keydown and keyup, it would be left in an "active" state
                        .bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                            $( this ).removeClass( "ui-state-active" );
                        });
                    
                    if ( this.buttonElement.is("a") ) {
                        this.buttonElement.keyup(function(event) {
                            if ( event.keyCode === $.ui.keyCode.SPACE ) {
                                // TODO pass through original event correctly (just as 2nd argument doesn't work)
                                $( this ).click();
                            }
                        });
                    }
                }
                
                // TODO: pull out $.Widget's handling for the disabled option into
                // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
                // be overridden by individual plugins
                this._setOption( "disabled", options.disabled );
                this._resetButton();
            },
            
            _determineButtonType: function() {
                var ancestor, labelSelector, checked;
                
                if ( this.element.is("[type=checkbox]") ) {
                    this.type = "checkbox";
                } else if ( this.element.is("[type=radio]") ) {
                    this.type = "radio";
                } else if ( this.element.is("input") ) {
                    this.type = "input";
                } else {
                    this.type = "button";
                }
                
                if ( this.type === "checkbox" || this.type === "radio" ) {
                    // we don't search against the document in case the element
                    // is disconnected from the DOM
                    ancestor = this.element.parents().last();
                    labelSelector = "label[for='" + this.element.attr("id") + "']";
                    this.buttonElement = ancestor.find( labelSelector );
                    if ( !this.buttonElement.length ) {
                        ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                        this.buttonElement = ancestor.filter( labelSelector );
                        if ( !this.buttonElement.length ) {
                            this.buttonElement = ancestor.find( labelSelector );
                        }
                    }
                    this.element.addClass( "ui-helper-hidden-accessible" );
                    
                    checked = this.element.is( ":checked" );
                    if ( checked ) {
                        this.buttonElement.addClass( "ui-state-active" );
                    }
                    this.buttonElement.prop( "aria-pressed", checked );
                } else {
                    this.buttonElement = this.element;
                }
            },
            
            widget: function() {
                return this.buttonElement;
            },
            
            _destroy: function() {
                this.element
                    .removeClass( "ui-helper-hidden-accessible" );
                this.buttonElement
                    .removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
                    .removeAttr( "role" )
                    .removeAttr( "aria-pressed" )
                    .html( this.buttonElement.find(".ui-button-text").html() );
                
                if ( !this.hasTitle ) {
                    this.buttonElement.removeAttr( "title" );
                }
            },
            
            _setOption: function( key, value ) {
                this._super( key, value );
                if ( key === "disabled" ) {
                    if ( value ) {
                        this.element.prop( "disabled", true );
                    } else {
                        this.element.prop( "disabled", false );
                    }
                    return;
                }
                this._resetButton();
            },
            
            refresh: function() {
                //See #8237 & #8828
                var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );
                
                if ( isDisabled !== this.options.disabled ) {
                    this._setOption( "disabled", isDisabled );
                }
                if ( this.type === "radio" ) {
                    radioGroup( this.element[0] ).each(function() {
                        if ( $( this ).is( ":checked" ) ) {
                            $( this ).button( "widget" )
                                .addClass( "ui-state-active" )
                                .attr( "aria-pressed", "true" );
                        } else {
                            $( this ).button( "widget" )
                                .removeClass( "ui-state-active" )
                                .attr( "aria-pressed", "false" );
                        }
                    });
                } else if ( this.type === "checkbox" ) {
                    if ( this.element.is( ":checked" ) ) {
                        this.buttonElement
                            .addClass( "ui-state-active" )
                            .attr( "aria-pressed", "true" );
                    } else {
                        this.buttonElement
                            .removeClass( "ui-state-active" )
                            .attr( "aria-pressed", "false" );
                    }
                }
            },
            
            _resetButton: function() {
                if ( this.type === "input" ) {
                    if ( this.options.label ) {
                        this.element.val( this.options.label );
                    }
                    return;
                }
                var buttonElement = this.buttonElement.removeClass( typeClasses ),
                    buttonText = $( "<span></span>", this.document[0] )
                        .addClass( "ui-button-text" )
                        .html( this.options.label )
                        .appendTo( buttonElement.empty() )
                        .text(),
                    icons = this.options.icons,
                    multipleIcons = icons.primary && icons.secondary,
                    buttonClasses = [];
                
                if ( icons.primary || icons.secondary ) {
                    if ( this.options.text ) {
                        buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
                    }
                    
                    if ( icons.primary ) {
                        buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
                    }
                    
                    if ( icons.secondary ) {
                        buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
                    }
                    
                    if ( !this.options.text ) {
                        buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );
                        
                        if ( !this.hasTitle ) {
                            buttonElement.attr( "title", $.trim( buttonText ) );
                        }
                    }
                } else {
                    buttonClasses.push( "ui-button-text-only" );
                }
                buttonElement.addClass( buttonClasses.join( " " ) );
            }
        });
        
        $.widget( "ui.buttonset", {
            version: "1.10.3",
            options: {
                items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
            },
            
            _create: function() {
                this.element.addClass( "ui-buttonset" );
            },
            
            _init: function() {
                this.refresh();
            },
            
            _setOption: function( key, value ) {
                if ( key === "disabled" ) {
                    this.buttons.button( "option", key, value );
                }
                
                this._super( key, value );
            },
            
            refresh: function() {
                var rtl = this.element.css( "direction" ) === "rtl";
                
                this.buttons = this.element.find( this.options.items )
                    .filter( ":ui-button" )
                    .button( "refresh" )
                    .end()
                    .not( ":ui-button" )
                    .button()
                    .end()
                    .map(function() {
                        return $( this ).button( "widget" )[ 0 ];
                    })
                    .removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
                    .filter( ":first" )
                    .addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
                    .end()
                    .filter( ":last" )
                    .addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
                    .end()
                    .end();
            },
            
            _destroy: function() {
                this.element.removeClass( "ui-buttonset" );
                this.buttons
                    .map(function() {
                        return $( this ).button( "widget" )[ 0 ];
                    })
                    .removeClass( "ui-corner-left ui-corner-right" )
                    .end()
                    .button( "destroy" );
            }
        });
        
    }( jQuery ) );
    
    (function( $, undefined ) {
        
        $.extend($.ui, { datepicker: { version: "1.10.3" } });
        
        var PROP_NAME = "datepicker",
            instActive;
        
        /* Date picker manager.
         Use the singleton instance of this class, $.datepicker, to interact with the date picker.
         Settings for (groups of) date pickers are maintained in an instance object,
         allowing multiple different settings on the same page. */
        
        function Datepicker() {
            this._curInst = null; // The current instance in use
            this._keyEvent = false; // If the last event was a key event
            this._disabledInputs = []; // List of date picker inputs that have been disabled
            this._datepickerShowing = false; // True if the popup picker is showing , false if not
            this._inDialog = false; // True if showing within a "dialog", false if not
            this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
            this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
            this._appendClass = "ui-datepicker-append"; // The name of the append marker class
            this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
            this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
            this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
            this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
            this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
            this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
            this.regional = []; // Available regional settings, indexed by language code
            this.regional[""] = { // Default regional settings
                closeText: "Done", // Display text for close link
                prevText: "Prev", // Display text for previous month link
                nextText: "Next", // Display text for next month link
                currentText: "Today", // Display text for current month link
                monthNames: ["January","February","March","April","May","June",
                    "July","August","September","October","November","December"], // Names of months for drop-down and formatting
                monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
                dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
                dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
                dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
                weekHeader: "Wk", // Column header for week of the year
                dateFormat: "mm/dd/yy", // See format options on parseDate
                firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
                isRTL: false, // True if right-to-left language, false if left-to-right
                showMonthAfterYear: false, // True if the year select precedes month, false for month then year
                yearSuffix: "" // Additional text to append to the year in the month headers
            };
            this._defaults = { // Global defaults for all the date picker instances
                showOn: "focus", // "focus" for popup on focus,
                // "button" for trigger button, or "both" for either
                showAnim: "fadeIn", // Name of jQuery animation for popup
                showOptions: {}, // Options for enhanced animations
                defaultDate: null, // Used when field is blank: actual date,
                // +/-number for offset from today, null for today
                appendText: "", // Display text following the input box, e.g. showing the format
                buttonText: "...", // Text for trigger button
                buttonImage: "", // URL for trigger button image
                buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
                hideIfNoPrevNext: false, // True to hide next/previous month links
                // if not applicable, false to just disable them
                navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
                gotoCurrent: false, // True if today link goes back to current selection instead
                changeMonth: false, // True if month can be selected directly, false if only prev/next
                changeYear: false, // True if year can be selected directly, false if only prev/next
                yearRange: "c-10:c+10", // Range of years to display in drop-down,
                // either relative to today's year (-nn:+nn), relative to currently displayed year
                // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
                showOtherMonths: false, // True to show dates in other months, false to leave blank
                selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
                showWeek: false, // True to show week of the year, false to not show it
                calculateWeek: this.iso8601Week, // How to calculate the week of the year,
                // takes a Date and returns the number of the week for it
                shortYearCutoff: "+10", // Short year values < this are in the current century,
                // > this are in the previous century,
                // string value starting with "+" for current year + value
                minDate: null, // The earliest selectable date, or null for no limit
                maxDate: null, // The latest selectable date, or null for no limit
                duration: "fast", // Duration of display/closure
                beforeShowDay: null, // Function that takes a date and returns an array with
                // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
                // [2] = cell title (optional), e.g. $.datepicker.noWeekends
                beforeShow: null, // Function that takes an input field and
                // returns a set of custom settings for the date picker
                onSelect: null, // Define a callback function when a date is selected
                onChangeMonthYear: null, // Define a callback function when the month or year is changed
                onClose: null, // Define a callback function when the datepicker is closed
                numberOfMonths: 1, // Number of months to show at a time
                showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
                stepMonths: 1, // Number of months to step back/forward
                stepBigMonths: 12, // Number of months to step back/forward for the big links
                altField: "", // Selector for an alternate field to store selected dates into
                altFormat: "", // The date format to use for the alternate field
                constrainInput: true, // The input is constrained by the current date format
                showButtonPanel: false, // True to show button panel, false to not show it
                autoSize: false, // True to size the input for the date format, false to leave as is
                disabled: false // The initial disabled state
            };
            $.extend(this._defaults, this.regional[""]);
            this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
        }
        
        $.extend(Datepicker.prototype, {
            /* Class name added to elements to indicate already configured with a date picker. */
            markerClassName: "hasDatepicker",
            
            //Keep track of the maximum number of rows displayed (see #7043)
            maxRows: 4,
            
            // TODO rename to "widget" when switching to widget factory
            _widgetDatepicker: function() {
                return this.dpDiv;
            },
            
            /* Override the default settings for all instances of the date picker.
             * @param  settings  object - the new settings to use as defaults (anonymous object)
             * @return the manager object
             */
            setDefaults: function(settings) {
                extendRemove(this._defaults, settings || {});
                return this;
            },
            
            /* Attach the date picker to a jQuery selection.
             * @param  target	element - the target input field or division or span
             * @param  settings  object - the new settings to use for this date picker instance (anonymous)
             */
            _attachDatepicker: function(target, settings) {
                var nodeName, inline, inst;
                nodeName = target.nodeName.toLowerCase();
                inline = (nodeName === "div" || nodeName === "span");
                if (!target.id) {
                    this.uuid += 1;
                    target.id = "dp" + this.uuid;
                }
                inst = this._newInst($(target), inline);
                inst.settings = $.extend({}, settings || {});
                if (nodeName === "input") {
                    this._connectDatepicker(target, inst);
                } else if (inline) {
                    this._inlineDatepicker(target, inst);
                }
            },
            
            /* Create a new instance object. */
            _newInst: function(target, inline) {
                var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
                return {id: id, input: target, // associated target
                    selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
                    drawMonth: 0, drawYear: 0, // month being drawn
                    inline: inline, // is datepicker inline or not
                    dpDiv: (!inline ? this.dpDiv : // presentation div
                        bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
            },
            
            /* Attach the date picker to an input field. */
            _connectDatepicker: function(target, inst) {
                var input = $(target);
                inst.append = $([]);
                inst.trigger = $([]);
                if (input.hasClass(this.markerClassName)) {
                    return;
                }
                this._attachments(input, inst);
                input.addClass(this.markerClassName).keydown(this._doKeyDown).
                    keypress(this._doKeyPress).keyup(this._doKeyUp);
                this._autoSize(inst);
                $.data(target, PROP_NAME, inst);
                //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
                if( inst.settings.disabled ) {
                    this._disableDatepicker( target );
                }
            },
            
            /* Make attachments based on settings. */
            _attachments: function(input, inst) {
                var showOn, buttonText, buttonImage,
                    appendText = this._get(inst, "appendText"),
                    isRTL = this._get(inst, "isRTL");
                
                if (inst.append) {
                    inst.append.remove();
                }
                if (appendText) {
                    inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                    input[isRTL ? "before" : "after"](inst.append);
                }
                
                input.unbind("focus", this._showDatepicker);
                
                if (inst.trigger) {
                    inst.trigger.remove();
                }
                
                showOn = this._get(inst, "showOn");
                if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
                    input.focus(this._showDatepicker);
                }
                if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
                    buttonText = this._get(inst, "buttonText");
                    buttonImage = this._get(inst, "buttonImage");
                    inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                        $("<img/>").addClass(this._triggerClass).
                            attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
                        $("<button type='button'></button>").addClass(this._triggerClass).
                            html(!buttonImage ? buttonText : $("<img/>").attr(
                                { src:buttonImage, alt:buttonText, title:buttonText })));
                    input[isRTL ? "before" : "after"](inst.trigger);
                    inst.trigger.click(function() {
                        if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                            $.datepicker._hideDatepicker();
                        } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                            $.datepicker._hideDatepicker();
                            $.datepicker._showDatepicker(input[0]);
                        } else {
                            $.datepicker._showDatepicker(input[0]);
                        }
                        return false;
                    });
                }
            },
            
            /* Apply the maximum length for the date format. */
            _autoSize: function(inst) {
                if (this._get(inst, "autoSize") && !inst.inline) {
                    var findMax, max, maxI, i,
                        date = new Date(2009, 12 - 1, 20), // Ensure double digits
                        dateFormat = this._get(inst, "dateFormat");
                    
                    if (dateFormat.match(/[DM]/)) {
                        findMax = function(names) {
                            max = 0;
                            maxI = 0;
                            for (i = 0; i < names.length; i++) {
                                if (names[i].length > max) {
                                    max = names[i].length;
                                    maxI = i;
                                }
                            }
                            return maxI;
                        };
                        date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                            "monthNames" : "monthNamesShort"))));
                        date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                                "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
                    }
                    inst.input.attr("size", this._formatDate(inst, date).length);
                }
            },
            
            /* Attach an inline date picker to a div. */
            _inlineDatepicker: function(target, inst) {
                var divSpan = $(target);
                if (divSpan.hasClass(this.markerClassName)) {
                    return;
                }
                divSpan.addClass(this.markerClassName).append(inst.dpDiv);
                $.data(target, PROP_NAME, inst);
                this._setDate(inst, this._getDefaultDate(inst), true);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
                //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
                if( inst.settings.disabled ) {
                    this._disableDatepicker( target );
                }
                // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
                // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
                inst.dpDiv.css( "display", "block" );
            },
            
            /* Pop-up the date picker in a "dialog" box.
             * @param  input element - ignored
             * @param  date	string or Date - the initial date to display
             * @param  onSelect  function - the function to call when a date is selected
             * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
             * @param  pos int[2] - coordinates for the dialog's position within the screen or
             *					event - with x/y coordinates or
             *					leave empty for default (screen centre)
             * @return the manager object
             */
            _dialogDatepicker: function(input, date, onSelect, settings, pos) {
                var id, browserWidth, browserHeight, scrollX, scrollY,
                    inst = this._dialogInst; // internal instance
                
                if (!inst) {
                    this.uuid += 1;
                    id = "dp" + this.uuid;
                    this._dialogInput = $("<input type='text' id='" + id +
                        "' style='position: absolute; top: -100px; width: 0px;'/>");
                    this._dialogInput.keydown(this._doKeyDown);
                    $("body").append(this._dialogInput);
                    inst = this._dialogInst = this._newInst(this._dialogInput, false);
                    inst.settings = {};
                    $.data(this._dialogInput[0], PROP_NAME, inst);
                }
                extendRemove(inst.settings, settings || {});
                date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
                this._dialogInput.val(date);
                
                this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
                if (!this._pos) {
                    browserWidth = document.documentElement.clientWidth;
                    browserHeight = document.documentElement.clientHeight;
                    scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                    scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                    this._pos = // should use actual width/height below
                        [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
                }
                
                // move input on screen for focus, but hidden behind dialog
                this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
                inst.settings.onSelect = onSelect;
                this._inDialog = true;
                this.dpDiv.addClass(this._dialogClass);
                this._showDatepicker(this._dialogInput[0]);
                if ($.blockUI) {
                    $.blockUI(this.dpDiv);
                }
                $.data(this._dialogInput[0], PROP_NAME, inst);
                return this;
            },
            
            /* Detach a datepicker from its control.
             * @param  target	element - the target input field or division or span
             */
            _destroyDatepicker: function(target) {
                var nodeName,
                    $target = $(target),
                    inst = $.data(target, PROP_NAME);
                
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                
                nodeName = target.nodeName.toLowerCase();
                $.removeData(target, PROP_NAME);
                if (nodeName === "input") {
                    inst.append.remove();
                    inst.trigger.remove();
                    $target.removeClass(this.markerClassName).
                        unbind("focus", this._showDatepicker).
                        unbind("keydown", this._doKeyDown).
                        unbind("keypress", this._doKeyPress).
                        unbind("keyup", this._doKeyUp);
                } else if (nodeName === "div" || nodeName === "span") {
                    $target.removeClass(this.markerClassName).empty();
                }
            },
            
            /* Enable the date picker to a jQuery selection.
             * @param  target	element - the target input field or division or span
             */
            _enableDatepicker: function(target) {
                var nodeName, inline,
                    $target = $(target),
                    inst = $.data(target, PROP_NAME);
                
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                
                nodeName = target.nodeName.toLowerCase();
                if (nodeName === "input") {
                    target.disabled = false;
                    inst.trigger.filter("button").
                        each(function() { this.disabled = false; }).end().
                        filter("img").css({opacity: "1.0", cursor: ""});
                } else if (nodeName === "div" || nodeName === "span") {
                    inline = $target.children("." + this._inlineClass);
                    inline.children().removeClass("ui-state-disabled");
                    inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                        prop("disabled", false);
                }
                this._disabledInputs = $.map(this._disabledInputs,
                    function(value) { return (value === target ? null : value); }); // delete entry
            },
            
            /* Disable the date picker to a jQuery selection.
             * @param  target	element - the target input field or division or span
             */
            _disableDatepicker: function(target) {
                var nodeName, inline,
                    $target = $(target),
                    inst = $.data(target, PROP_NAME);
                
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                
                nodeName = target.nodeName.toLowerCase();
                if (nodeName === "input") {
                    target.disabled = true;
                    inst.trigger.filter("button").
                        each(function() { this.disabled = true; }).end().
                        filter("img").css({opacity: "0.5", cursor: "default"});
                } else if (nodeName === "div" || nodeName === "span") {
                    inline = $target.children("." + this._inlineClass);
                    inline.children().addClass("ui-state-disabled");
                    inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                        prop("disabled", true);
                }
                this._disabledInputs = $.map(this._disabledInputs,
                    function(value) { return (value === target ? null : value); }); // delete entry
                this._disabledInputs[this._disabledInputs.length] = target;
            },
            
            /* Is the first field in a jQuery collection disabled as a datepicker?
             * @param  target	element - the target input field or division or span
             * @return boolean - true if disabled, false if enabled
             */
            _isDisabledDatepicker: function(target) {
                if (!target) {
                    return false;
                }
                for (var i = 0; i < this._disabledInputs.length; i++) {
                    if (this._disabledInputs[i] === target) {
                        return true;
                    }
                }
                return false;
            },
            
            /* Retrieve the instance data for the target control.
             * @param  target  element - the target input field or division or span
             * @return  object - the associated instance data
             * @throws  error if a jQuery problem getting data
             */
            _getInst: function(target) {
                try {
                    return $.data(target, PROP_NAME);
                }
                catch (err) {
                    throw "Missing instance data for this datepicker";
                }
            },
            
            /* Update or retrieve the settings for a date picker attached to an input field or division.
             * @param  target  element - the target input field or division or span
             * @param  name	object - the new settings to update or
             *				string - the name of the setting to change or retrieve,
             *				when retrieving also "all" for all instance settings or
             *				"defaults" for all global defaults
             * @param  value   any - the new value for the setting
             *				(omit if above is an object or to retrieve a value)
             */
            _optionDatepicker: function(target, name, value) {
                var settings, date, minDate, maxDate,
                    inst = this._getInst(target);
                
                if (arguments.length === 2 && typeof name === "string") {
                    return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                        (inst ? (name === "all" ? $.extend({}, inst.settings) :
                            this._get(inst, name)) : null));
                }
                
                settings = name || {};
                if (typeof name === "string") {
                    settings = {};
                    settings[name] = value;
                }
                
                if (inst) {
                    if (this._curInst === inst) {
                        this._hideDatepicker();
                    }
                    
                    date = this._getDateDatepicker(target, true);
                    minDate = this._getMinMaxDate(inst, "min");
                    maxDate = this._getMinMaxDate(inst, "max");
                    extendRemove(inst.settings, settings);
                    // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                    if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                        inst.settings.minDate = this._formatDate(inst, minDate);
                    }
                    if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                        inst.settings.maxDate = this._formatDate(inst, maxDate);
                    }
                    if ( "disabled" in settings ) {
                        if ( settings.disabled ) {
                            this._disableDatepicker(target);
                        } else {
                            this._enableDatepicker(target);
                        }
                    }
                    this._attachments($(target), inst);
                    this._autoSize(inst);
                    this._setDate(inst, date);
                    this._updateAlternate(inst);
                    this._updateDatepicker(inst);
                }
            },
            
            // change method deprecated
            _changeDatepicker: function(target, name, value) {
                this._optionDatepicker(target, name, value);
            },
            
            /* Redraw the date picker attached to an input field or division.
             * @param  target  element - the target input field or division or span
             */
            _refreshDatepicker: function(target) {
                var inst = this._getInst(target);
                if (inst) {
                    this._updateDatepicker(inst);
                }
            },
            
            /* Set the dates for a jQuery selection.
             * @param  target element - the target input field or division or span
             * @param  date	Date - the new date
             */
            _setDateDatepicker: function(target, date) {
                var inst = this._getInst(target);
                if (inst) {
                    this._setDate(inst, date);
                    this._updateDatepicker(inst);
                    this._updateAlternate(inst);
                }
            },
            
            /* Get the date(s) for the first entry in a jQuery selection.
             * @param  target element - the target input field or division or span
             * @param  noDefault boolean - true if no default date is to be used
             * @return Date - the current date
             */
            _getDateDatepicker: function(target, noDefault) {
                var inst = this._getInst(target);
                if (inst && !inst.inline) {
                    this._setDateFromField(inst, noDefault);
                }
                return (inst ? this._getDate(inst) : null);
            },
            
            /* Handle keystrokes. */
            _doKeyDown: function(event) {
                var onSelect, dateStr, sel,
                    inst = $.datepicker._getInst(event.target),
                    handled = true,
                    isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
                
                inst._keyEvent = true;
                if ($.datepicker._datepickerShowing) {
                    switch (event.keyCode) {
                        case 9: $.datepicker._hideDatepicker();
                            handled = false;
                            break; // hide on tab out
                        case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                            $.datepicker._currentClass + ")", inst.dpDiv);
                            if (sel[0]) {
                                $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                            }
                            
                            onSelect = $.datepicker._get(inst, "onSelect");
                            if (onSelect) {
                                dateStr = $.datepicker._formatDate(inst);
                                
                                // trigger custom callback
                                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                            } else {
                                $.datepicker._hideDatepicker();
                            }
                            
                            return false; // don't submit the form
                        case 27: $.datepicker._hideDatepicker();
                            break; // hide on escape
                        case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            -$.datepicker._get(inst, "stepBigMonths") :
                            -$.datepicker._get(inst, "stepMonths")), "M");
                            break; // previous month/year on page up/+ ctrl
                        case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            +$.datepicker._get(inst, "stepBigMonths") :
                            +$.datepicker._get(inst, "stepMonths")), "M");
                            break; // next month/year on page down/+ ctrl
                        case 35: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._clearDate(event.target);
                        }
                            handled = event.ctrlKey || event.metaKey;
                            break; // clear on ctrl or command +end
                        case 36: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._gotoToday(event.target);
                        }
                            handled = event.ctrlKey || event.metaKey;
                            break; // current on ctrl or command +home
                        case 37: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                        }
                            handled = event.ctrlKey || event.metaKey;
                            // -1 day on ctrl or command +left
                            if (event.originalEvent.altKey) {
                                $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                    -$.datepicker._get(inst, "stepBigMonths") :
                                    -$.datepicker._get(inst, "stepMonths")), "M");
                            }
                            // next month/year on alt +left on Mac
                            break;
                        case 38: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, -7, "D");
                        }
                            handled = event.ctrlKey || event.metaKey;
                            break; // -1 week on ctrl or command +up
                        case 39: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                        }
                            handled = event.ctrlKey || event.metaKey;
                            // +1 day on ctrl or command +right
                            if (event.originalEvent.altKey) {
                                $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                    +$.datepicker._get(inst, "stepBigMonths") :
                                    +$.datepicker._get(inst, "stepMonths")), "M");
                            }
                            // next month/year on alt +right
                            break;
                        case 40: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, +7, "D");
                        }
                            handled = event.ctrlKey || event.metaKey;
                            break; // +1 week on ctrl or command +down
                        default: handled = false;
                    }
                } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
                    $.datepicker._showDatepicker(this);
                } else {
                    handled = false;
                }
                
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            },
            
            /* Filter entered characters - based on date format. */
            _doKeyPress: function(event) {
                var chars, chr,
                    inst = $.datepicker._getInst(event.target);
                
                if ($.datepicker._get(inst, "constrainInput")) {
                    chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                    chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                    return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
                }
            },
            
            /* Synchronise manual entry and field/alternate field. */
            _doKeyUp: function(event) {
                var date,
                    inst = $.datepicker._getInst(event.target);
                
                if (inst.input.val() !== inst.lastVal) {
                    try {
                        date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                            (inst.input ? inst.input.val() : null),
                            $.datepicker._getFormatConfig(inst));
                        
                        if (date) { // only if valid
                            $.datepicker._setDateFromField(inst);
                            $.datepicker._updateAlternate(inst);
                            $.datepicker._updateDatepicker(inst);
                        }
                    }
                    catch (err) {
                    }
                }
                return true;
            },
            
            /* Pop-up the date picker for a given input field.
             * If false returned from beforeShow event handler do not show.
             * @param  input  element - the input field attached to the date picker or
             *					event - if triggered by focus
             */
            _showDatepicker: function(input) {
                input = input.target || input;
                if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
                    input = $("input", input.parentNode)[0];
                }
                
                if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
                    return;
                }
                
                var inst, beforeShow, beforeShowSettings, isFixed,
                    offset, showAnim, duration;
                
                inst = $.datepicker._getInst(input);
                if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                    $.datepicker._curInst.dpDiv.stop(true, true);
                    if ( inst && $.datepicker._datepickerShowing ) {
                        $.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
                    }
                }
                
                beforeShow = $.datepicker._get(inst, "beforeShow");
                beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
                if(beforeShowSettings === false){
                    return;
                }
                extendRemove(inst.settings, beforeShowSettings);
                
                inst.lastVal = null;
                $.datepicker._lastInput = input;
                $.datepicker._setDateFromField(inst);
                
                if ($.datepicker._inDialog) { // hide cursor
                    input.value = "";
                }
                if (!$.datepicker._pos) { // position below input
                    $.datepicker._pos = $.datepicker._findPos(input);
                    $.datepicker._pos[1] += input.offsetHeight; // add the height
                }
                
                isFixed = false;
                $(input).parents().each(function() {
                    isFixed |= $(this).css("position") === "fixed";
                    return !isFixed;
                });
                
                offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
                $.datepicker._pos = null;
                //to avoid flashes on Firefox
                inst.dpDiv.empty();
                // determine sizing offscreen
                inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
                $.datepicker._updateDatepicker(inst);
                // fix width for dynamic number of date pickers
                // and adjust position before showing
                offset = $.datepicker._checkOffset(inst, offset, isFixed);
                inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
                    "static" : (isFixed ? "fixed" : "absolute")), display: "none",
                    left: offset.left + "px", top: offset.top + "px"});
                
                if (!inst.inline) {
                    showAnim = $.datepicker._get(inst, "showAnim");
                    duration = $.datepicker._get(inst, "duration");
                    inst.dpDiv.zIndex($(input).zIndex()+1);
                    $.datepicker._datepickerShowing = true;
                    
                    if ( $.effects && $.effects.effect[ showAnim ] ) {
                        inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                    } else {
                        inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                    }
                    
                    if ( $.datepicker._shouldFocusInput( inst ) ) {
                        inst.input.focus();
                    }
                    
                    $.datepicker._curInst = inst;
                }
            },
            
            /* Generate the date picker content. */
            _updateDatepicker: function(inst) {
                this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
                instActive = inst; // for delegate hover events
                inst.dpDiv.empty().append(this._generateHTML(inst));
                this._attachHandlers(inst);
                inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();
                
                var origyearshtml,
                    numMonths = this._getNumberOfMonths(inst),
                    cols = numMonths[1],
                    width = 17;
                
                inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
                if (cols > 1) {
                    inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
                }
                inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                "Class"]("ui-datepicker-multi");
                inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
                "Class"]("ui-datepicker-rtl");
                
                if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
                    inst.input.focus();
                }
                
                // deffered render of the years select (to avoid flashes on Firefox)
                if( inst.yearshtml ){
                    origyearshtml = inst.yearshtml;
                    setTimeout(function(){
                        //assure that inst.yearshtml didn't change.
                        if( origyearshtml === inst.yearshtml && inst.yearshtml ){
                            inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                        }
                        origyearshtml = inst.yearshtml = null;
                    }, 0);
                }
            },
            
            // #6694 - don't focus the input if it's already focused
            // this breaks the change event in IE
            // Support: IE and jQuery <1.9
            _shouldFocusInput: function( inst ) {
                return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
            },
            
            /* Check positioning to remain on screen. */
            _checkOffset: function(inst, offset, isFixed) {
                var dpWidth = inst.dpDiv.outerWidth(),
                    dpHeight = inst.dpDiv.outerHeight(),
                    inputWidth = inst.input ? inst.input.outerWidth() : 0,
                    inputHeight = inst.input ? inst.input.outerHeight() : 0,
                    viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                    viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
                
                offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
                offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
                offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;
                
                // now check if datepicker is showing outside window viewport - move to a better place if so.
                offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                    Math.abs(offset.left + dpWidth - viewWidth) : 0);
                offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                    Math.abs(dpHeight + inputHeight) : 0);
                
                return offset;
            },
            
            /* Find an object's position on the screen. */
            _findPos: function(obj) {
                var position,
                    inst = this._getInst(obj),
                    isRTL = this._get(inst, "isRTL");
                
                while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                    obj = obj[isRTL ? "previousSibling" : "nextSibling"];
                }
                
                position = $(obj).offset();
                return [position.left, position.top];
            },
            
            /* Hide the date picker from view.
             * @param  input  element - the input field attached to the date picker
             */
            _hideDatepicker: function(input) {
                var showAnim, duration, postProcess, onClose,
                    inst = this._curInst;
                
                if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
                    return;
                }
                
                if (this._datepickerShowing) {
                    showAnim = this._get(inst, "showAnim");
                    duration = this._get(inst, "duration");
                    postProcess = function() {
                        $.datepicker._tidyDialog(inst);
                    };
                    
                    // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                    if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
                        inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                    } else {
                        inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                            (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
                    }
                    
                    if (!showAnim) {
                        postProcess();
                    }
                    this._datepickerShowing = false;
                    
                    onClose = this._get(inst, "onClose");
                    if (onClose) {
                        onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
                    }
                    
                    this._lastInput = null;
                    if (this._inDialog) {
                        this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
                        if ($.blockUI) {
                            $.unblockUI();
                            $("body").append(this.dpDiv);
                        }
                    }
                    this._inDialog = false;
                }
            },
            
            /* Tidy up after a dialog display. */
            _tidyDialog: function(inst) {
                inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
            },
            
            /* Close date picker if clicked elsewhere. */
            _checkExternalClick: function(event) {
                if (!$.datepicker._curInst) {
                    return;
                }
                
                var $target = $(event.target),
                    inst = $.datepicker._getInst($target[0]);
                
                if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
                    $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                    !$target.hasClass($.datepicker.markerClassName) &&
                    !$target.closest("." + $.datepicker._triggerClass).length &&
                    $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
                    ( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
                    $.datepicker._hideDatepicker();
                }
            },
            
            /* Adjust one of the date sub-fields. */
            _adjustDate: function(id, offset, period) {
                var target = $(id),
                    inst = this._getInst(target[0]);
                
                if (this._isDisabledDatepicker(target[0])) {
                    return;
                }
                this._adjustInstDate(inst, offset +
                    (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                    period);
                this._updateDatepicker(inst);
            },
            
            /* Action for current link. */
            _gotoToday: function(id) {
                var date,
                    target = $(id),
                    inst = this._getInst(target[0]);
                
                if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                    inst.selectedDay = inst.currentDay;
                    inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                    inst.drawYear = inst.selectedYear = inst.currentYear;
                } else {
                    date = new Date();
                    inst.selectedDay = date.getDate();
                    inst.drawMonth = inst.selectedMonth = date.getMonth();
                    inst.drawYear = inst.selectedYear = date.getFullYear();
                }
                this._notifyChange(inst);
                this._adjustDate(target);
            },
            
            /* Action for selecting a new month/year. */
            _selectMonthYear: function(id, select, period) {
                var target = $(id),
                    inst = this._getInst(target[0]);
                
                inst["selected" + (period === "M" ? "Month" : "Year")] =
                    inst["draw" + (period === "M" ? "Month" : "Year")] =
                        parseInt(select.options[select.selectedIndex].value,10);
                
                this._notifyChange(inst);
                this._adjustDate(target);
            },
            
            /* Action for selecting a day. */
            _selectDay: function(id, month, year, td) {
                var inst,
                    target = $(id);
                
                if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                    return;
                }
                
                inst = this._getInst(target[0]);
                inst.selectedDay = inst.currentDay = $("a", td).html();
                inst.selectedMonth = inst.currentMonth = month;
                inst.selectedYear = inst.currentYear = year;
                this._selectDate(id, this._formatDate(inst,
                    inst.currentDay, inst.currentMonth, inst.currentYear));
            },
            
            /* Erase the input field and hide the date picker. */
            _clearDate: function(id) {
                var target = $(id);
                this._selectDate(target, "");
            },
            
            /* Update the input field with the selected date. */
            _selectDate: function(id, dateStr) {
                var onSelect,
                    target = $(id),
                    inst = this._getInst(target[0]);
                
                dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
                if (inst.input) {
                    inst.input.val(dateStr);
                }
                this._updateAlternate(inst);
                
                onSelect = this._get(inst, "onSelect");
                if (onSelect) {
                    onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
                } else if (inst.input) {
                    inst.input.trigger("change"); // fire the change event
                }
                
                if (inst.inline){
                    this._updateDatepicker(inst);
                } else {
                    this._hideDatepicker();
                    this._lastInput = inst.input[0];
                    if (typeof(inst.input[0]) !== "object") {
                        inst.input.focus(); // restore focus
                    }
                    this._lastInput = null;
                }
            },
            
            /* Update any alternate field to synchronise with the main field. */
            _updateAlternate: function(inst) {
                var altFormat, date, dateStr,
                    altField = this._get(inst, "altField");
                
                if (altField) { // update alternate field too
                    altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                    date = this._getDate(inst);
                    dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                    $(altField).each(function() { $(this).val(dateStr); });
                }
            },
            
            /* Set as beforeShowDay function to prevent selection of weekends.
             * @param  date  Date - the date to customise
             * @return [boolean, string] - is this date selectable?, what is its CSS class?
             */
            noWeekends: function(date) {
                var day = date.getDay();
                return [(day > 0 && day < 6), ""];
            },
            
            /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
             * @param  date  Date - the date to get the week for
             * @return  number - the number of the week within the year that contains this date
             */
            iso8601Week: function(date) {
                var time,
                    checkDate = new Date(date.getTime());
                
                // Find Thursday of this week starting on Monday
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                
                time = checkDate.getTime();
                checkDate.setMonth(0); // Compare with Jan 1
                checkDate.setDate(1);
                return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
            },
            
            /* Parse a string value into a date object.
             * See formatDate below for the possible formats.
             *
             * @param  format string - the expected format of the date
             * @param  value string - the date in the above format
             * @param  settings Object - attributes include:
             *					shortYearCutoff  number - the cutoff year for determining the century (optional)
             *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
             *					dayNames		string[7] - names of the days from Sunday (optional)
             *					monthNamesShort string[12] - abbreviated names of the months (optional)
             *					monthNames		string[12] - names of the months (optional)
             * @return  Date - the extracted date value or null if value is blank
             */
            parseDate: function (format, value, settings) {
                if (format == null || value == null) {
                    throw "Invalid arguments";
                }
                
                value = (typeof value === "object" ? value.toString() : value + "");
                if (value === "") {
                    return null;
                }
                
                var iFormat, dim, extra,
                    iValue = 0,
                    shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                    shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                    new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
                    dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                    year = -1,
                    month = -1,
                    day = -1,
                    doy = -1,
                    literal = false,
                    date,
                // Check whether a format character is doubled
                    lookAhead = function(match) {
                        var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                        if (matches) {
                            iFormat++;
                        }
                        return matches;
                    },
                // Extract a number from the string value
                    getNumber = function(match) {
                        var isDoubled = lookAhead(match),
                            size = (match === "@" ? 14 : (match === "!" ? 20 :
                                (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                            digits = new RegExp("^\\d{1," + size + "}"),
                            num = value.substring(iValue).match(digits);
                        if (!num) {
                            throw "Missing number at position " + iValue;
                        }
                        iValue += num[0].length;
                        return parseInt(num[0], 10);
                    },
                // Extract a name from the string value and convert to an index
                    getName = function(match, shortNames, longNames) {
                        var index = -1,
                            names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                                return [ [k, v] ];
                            }).sort(function (a, b) {
                                return -(a[1].length - b[1].length);
                            });
                        
                        $.each(names, function (i, pair) {
                            var name = pair[1];
                            if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                                index = pair[0];
                                iValue += name.length;
                                return false;
                            }
                        });
                        if (index !== -1) {
                            return index + 1;
                        } else {
                            throw "Unknown name at position " + iValue;
                        }
                    },
                // Confirm that a literal character matches the string value
                    checkLiteral = function() {
                        if (value.charAt(iValue) !== format.charAt(iFormat)) {
                            throw "Unexpected literal at position " + iValue;
                        }
                        iValue++;
                    };
                
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            checkLiteral();
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d":
                                day = getNumber("d");
                                break;
                            case "D":
                                getName("D", dayNamesShort, dayNames);
                                break;
                            case "o":
                                doy = getNumber("o");
                                break;
                            case "m":
                                month = getNumber("m");
                                break;
                            case "M":
                                month = getName("M", monthNamesShort, monthNames);
                                break;
                            case "y":
                                year = getNumber("y");
                                break;
                            case "@":
                                date = new Date(getNumber("@"));
                                year = date.getFullYear();
                                month = date.getMonth() + 1;
                                day = date.getDate();
                                break;
                            case "!":
                                date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                                year = date.getFullYear();
                                month = date.getMonth() + 1;
                                day = date.getDate();
                                break;
                            case "'":
                                if (lookAhead("'")){
                                    checkLiteral();
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                checkLiteral();
                        }
                    }
                }
                
                if (iValue < value.length){
                    extra = value.substr(iValue);
                    if (!/^\s+/.test(extra)) {
                        throw "Extra/unparsed characters found in date: " + extra;
                    }
                }
                
                if (year === -1) {
                    year = new Date().getFullYear();
                } else if (year < 100) {
                    year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                        (year <= shortYearCutoff ? 0 : -100);
                }
                
                if (doy > -1) {
                    month = 1;
                    day = doy;
                    do {
                        dim = this._getDaysInMonth(year, month - 1);
                        if (day <= dim) {
                            break;
                        }
                        month++;
                        day -= dim;
                    } while (true);
                }
                
                date = this._daylightSavingAdjust(new Date(year, month - 1, day));
                if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                    throw "Invalid date"; // E.g. 31/02/00
                }
                return date;
            },
            
            /* Standard date formats. */
            ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
            COOKIE: "D, dd M yy",
            ISO_8601: "yy-mm-dd",
            RFC_822: "D, d M y",
            RFC_850: "DD, dd-M-y",
            RFC_1036: "D, d M y",
            RFC_1123: "D, d M yy",
            RFC_2822: "D, d M yy",
            RSS: "D, d M y", // RFC 822
            TICKS: "!",
            TIMESTAMP: "@",
            W3C: "yy-mm-dd", // ISO 8601
            
            _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
            Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
            
            /* Format a date object into a string value.
             * The format can be combinations of the following:
             * d  - day of month (no leading zero)
             * dd - day of month (two digit)
             * o  - day of year (no leading zeros)
             * oo - day of year (three digit)
             * D  - day name short
             * DD - day name long
             * m  - month of year (no leading zero)
             * mm - month of year (two digit)
             * M  - month name short
             * MM - month name long
             * y  - year (two digit)
             * yy - year (four digit)
             * @ - Unix timestamp (ms since 01/01/1970)
             * ! - Windows ticks (100ns since 01/01/0001)
             * "..." - literal text
             * '' - single quote
             *
             * @param  format string - the desired format of the date
             * @param  date Date - the date value to format
             * @param  settings Object - attributes include:
             *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
             *					dayNames		string[7] - names of the days from Sunday (optional)
             *					monthNamesShort string[12] - abbreviated names of the months (optional)
             *					monthNames		string[12] - names of the months (optional)
             * @return  string - the date in the above format
             */
            formatDate: function (format, date, settings) {
                if (!date) {
                    return "";
                }
                
                var iFormat,
                    dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                // Check whether a format character is doubled
                    lookAhead = function(match) {
                        var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                        if (matches) {
                            iFormat++;
                        }
                        return matches;
                    },
                // Format a number, with leading zero if necessary
                    formatNumber = function(match, value, len) {
                        var num = "" + value;
                        if (lookAhead(match)) {
                            while (num.length < len) {
                                num = "0" + num;
                            }
                        }
                        return num;
                    },
                // Format a name, short or long as requested
                    formatName = function(match, value, shortNames, longNames) {
                        return (lookAhead(match) ? longNames[value] : shortNames[value]);
                    },
                    output = "",
                    literal = false;
                
                if (date) {
                    for (iFormat = 0; iFormat < format.length; iFormat++) {
                        if (literal) {
                            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                                literal = false;
                            } else {
                                output += format.charAt(iFormat);
                            }
                        } else {
                            switch (format.charAt(iFormat)) {
                                case "d":
                                    output += formatNumber("d", date.getDate(), 2);
                                    break;
                                case "D":
                                    output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                    break;
                                case "o":
                                    output += formatNumber("o",
                                        Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                                    break;
                                case "m":
                                    output += formatNumber("m", date.getMonth() + 1, 2);
                                    break;
                                case "M":
                                    output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                    break;
                                case "y":
                                    output += (lookAhead("y") ? date.getFullYear() :
                                    (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                                    break;
                                case "@":
                                    output += date.getTime();
                                    break;
                                case "!":
                                    output += date.getTime() * 10000 + this._ticksTo1970;
                                    break;
                                case "'":
                                    if (lookAhead("'")) {
                                        output += "'";
                                    } else {
                                        literal = true;
                                    }
                                    break;
                                default:
                                    output += format.charAt(iFormat);
                            }
                        }
                    }
                }
                return output;
            },
            
            /* Extract all possible characters from the date format. */
            _possibleChars: function (format) {
                var iFormat,
                    chars = "",
                    literal = false,
                // Check whether a format character is doubled
                    lookAhead = function(match) {
                        var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                        if (matches) {
                            iFormat++;
                        }
                        return matches;
                    };
                
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            chars += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d": case "m": case "y": case "@":
                            chars += "0123456789";
                            break;
                            case "D": case "M":
                            return null; // Accept anything
                            case "'":
                                if (lookAhead("'")) {
                                    chars += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                chars += format.charAt(iFormat);
                        }
                    }
                }
                return chars;
            },
            
            /* Get a setting value, defaulting if necessary. */
            _get: function(inst, name) {
                return inst.settings[name] !== undefined ?
                    inst.settings[name] : this._defaults[name];
            },
            
            /* Parse existing date and initialise date picker. */
            _setDateFromField: function(inst, noDefault) {
                if (inst.input.val() === inst.lastVal) {
                    return;
                }
                
                var dateFormat = this._get(inst, "dateFormat"),
                    dates = inst.lastVal = inst.input ? inst.input.val() : null,
                    defaultDate = this._getDefaultDate(inst),
                    date = defaultDate,
                    settings = this._getFormatConfig(inst);
                
                try {
                    date = this.parseDate(dateFormat, dates, settings) || defaultDate;
                } catch (event) {
                    dates = (noDefault ? "" : dates);
                }
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
                inst.currentDay = (dates ? date.getDate() : 0);
                inst.currentMonth = (dates ? date.getMonth() : 0);
                inst.currentYear = (dates ? date.getFullYear() : 0);
                this._adjustInstDate(inst);
            },
            
            /* Retrieve the default date shown on opening. */
            _getDefaultDate: function(inst) {
                return this._restrictMinMax(inst,
                    this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
            },
            
            /* A date may be specified as an exact value or a relative one. */
            _determineDate: function(inst, date, defaultDate) {
                var offsetNumeric = function(offset) {
                        var date = new Date();
                        date.setDate(date.getDate() + offset);
                        return date;
                    },
                    offsetString = function(offset) {
                        try {
                            return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                                offset, $.datepicker._getFormatConfig(inst));
                        }
                        catch (e) {
                            // Ignore
                        }
                        
                        var date = (offset.toLowerCase().match(/^c/) ?
                                    $.datepicker._getDate(inst) : null) || new Date(),
                            year = date.getFullYear(),
                            month = date.getMonth(),
                            day = date.getDate(),
                            pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                            matches = pattern.exec(offset);
                        
                        while (matches) {
                            switch (matches[2] || "d") {
                                case "d" : case "D" :
                                day += parseInt(matches[1],10); break;
                                case "w" : case "W" :
                                day += parseInt(matches[1],10) * 7; break;
                                case "m" : case "M" :
                                month += parseInt(matches[1],10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                                case "y": case "Y" :
                                year += parseInt(matches[1],10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                            }
                            matches = pattern.exec(offset);
                        }
                        return new Date(year, month, day);
                    },
                    newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                        (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
                
                newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
                if (newDate) {
                    newDate.setHours(0);
                    newDate.setMinutes(0);
                    newDate.setSeconds(0);
                    newDate.setMilliseconds(0);
                }
                return this._daylightSavingAdjust(newDate);
            },
            
            /* Handle switch to/from daylight saving.
             * Hours may be non-zero on daylight saving cut-over:
             * > 12 when midnight changeover, but then cannot generate
             * midnight datetime, so jump to 1AM, otherwise reset.
             * @param  date  (Date) the date to check
             * @return  (Date) the corrected date
             */
            _daylightSavingAdjust: function(date) {
                if (!date) {
                    return null;
                }
                date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
                return date;
            },
            
            /* Set the date(s) directly. */
            _setDate: function(inst, date, noChange) {
                var clear = !date,
                    origMonth = inst.selectedMonth,
                    origYear = inst.selectedYear,
                    newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
                
                inst.selectedDay = inst.currentDay = newDate.getDate();
                inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
                inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
                if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                    this._notifyChange(inst);
                }
                this._adjustInstDate(inst);
                if (inst.input) {
                    inst.input.val(clear ? "" : this._formatDate(inst));
                }
            },
            
            /* Retrieve the date(s) directly. */
            _getDate: function(inst) {
                var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
                    this._daylightSavingAdjust(new Date(
                        inst.currentYear, inst.currentMonth, inst.currentDay)));
                return startDate;
            },
            
            /* Attach the onxxx handlers.  These are declared statically so
             * they work with static code transformers like Caja.
             */
            _attachHandlers: function(inst) {
                var stepMonths = this._get(inst, "stepMonths"),
                    id = "#" + inst.id.replace( /\\\\/g, "\\" );
                inst.dpDiv.find("[data-handler]").map(function () {
                    var handler = {
                        prev: function () {
                            $.datepicker._adjustDate(id, -stepMonths, "M");
                        },
                        next: function () {
                            $.datepicker._adjustDate(id, +stepMonths, "M");
                        },
                        hide: function () {
                            $.datepicker._hideDatepicker();
                        },
                        today: function () {
                            $.datepicker._gotoToday(id);
                        },
                        selectDay: function () {
                            $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                            return false;
                        },
                        selectMonth: function () {
                            $.datepicker._selectMonthYear(id, this, "M");
                            return false;
                        },
                        selectYear: function () {
                            $.datepicker._selectMonthYear(id, this, "Y");
                            return false;
                        }
                    };
                    $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
                });
            },
            
            /* Generate the HTML for the current state of the date picker. */
            _generateHTML: function(inst) {
                var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                    controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                    monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                    selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                    cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                    printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                    tempDate = new Date(),
                    today = this._daylightSavingAdjust(
                        new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                    isRTL = this._get(inst, "isRTL"),
                    showButtonPanel = this._get(inst, "showButtonPanel"),
                    hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                    navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                    numMonths = this._getNumberOfMonths(inst),
                    showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                    stepMonths = this._get(inst, "stepMonths"),
                    isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
                    currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                        new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
                    minDate = this._getMinMaxDate(inst, "min"),
                    maxDate = this._getMinMaxDate(inst, "max"),
                    drawMonth = inst.drawMonth - showCurrentAtPos,
                    drawYear = inst.drawYear;
                
                if (drawMonth < 0) {
                    drawMonth += 12;
                    drawYear--;
                }
                if (maxDate) {
                    maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                        maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                    maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                    while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                        drawMonth--;
                        if (drawMonth < 0) {
                            drawMonth = 11;
                            drawYear--;
                        }
                    }
                }
                inst.drawMonth = drawMonth;
                inst.drawYear = drawYear;
                
                prevText = this._get(inst, "prevText");
                prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                    this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                    this._getFormatConfig(inst)));
                
                prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
                    (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));
                
                nextText = this._get(inst, "nextText");
                nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                    this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                    this._getFormatConfig(inst)));
                
                next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
                    (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));
                
                currentText = this._get(inst, "currentText");
                gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
                currentText = (!navigationAsDateFormat ? currentText :
                    this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
                
                controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                this._get(inst, "closeText") + "</button>" : "");
                
                buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
                (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
                
                firstDay = parseInt(this._get(inst, "firstDay"),10);
                firstDay = (isNaN(firstDay) ? 0 : firstDay);
                
                showWeek = this._get(inst, "showWeek");
                dayNames = this._get(inst, "dayNames");
                dayNamesMin = this._get(inst, "dayNamesMin");
                monthNames = this._get(inst, "monthNames");
                monthNamesShort = this._get(inst, "monthNamesShort");
                beforeShowDay = this._get(inst, "beforeShowDay");
                showOtherMonths = this._get(inst, "showOtherMonths");
                selectOtherMonths = this._get(inst, "selectOtherMonths");
                defaultDate = this._getDefaultDate(inst);
                html = "";
                dow;
                for (row = 0; row < numMonths[0]; row++) {
                    group = "";
                    this.maxRows = 4;
                    for (col = 0; col < numMonths[1]; col++) {
                        selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                        cornerClass = " ui-corner-all";
                        calender = "";
                        if (isMultiMonth) {
                            calender += "<div class='ui-datepicker-group";
                            if (numMonths[1] > 1) {
                                switch (col) {
                                    case 0: calender += " ui-datepicker-group-first";
                                        cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
                                    case numMonths[1]-1: calender += " ui-datepicker-group-last";
                                        cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
                                    default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
                                }
                            }
                            calender += "'>";
                        }
                        calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                            (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                            (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                            this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                                row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                            "</div><table class='ui-datepicker-calendar'><thead>" +
                            "<tr>";
                        thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                        for (dow = 0; dow < 7; dow++) { // days of the week
                            day = (dow + firstDay) % 7;
                            thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                                "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                        }
                        calender += thead + "</tr></thead><tbody>";
                        daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                        if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                        }
                        leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                        curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                        numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                        this.maxRows = numRows;
                        printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                        for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                            calender += "<tr>";
                            tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                            this._get(inst, "calculateWeek")(printDate) + "</td>");
                            for (dow = 0; dow < 7; dow++) { // create date picker days
                                daySettings = (beforeShowDay ?
                                    beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                                otherMonth = (printDate.getMonth() !== drawMonth);
                                unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                                    (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                                tbody += "<td class='" +
                                    ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                                    (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                                    ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                                    (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                                        // or defaultDate is current printedDate and defaultDate is selectedDate
                                    " " + this._dayOverClass : "") + // highlight selected day
                                    (unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
                                    (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                                    (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                                    (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                                    ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                                    (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                                    (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                        (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                        (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                                        (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                                        (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                                        "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                                printDate.setDate(printDate.getDate() + 1);
                                printDate = this._daylightSavingAdjust(printDate);
                            }
                            calender += tbody + "</tr>";
                        }
                        drawMonth++;
                        if (drawMonth > 11) {
                            drawMonth = 0;
                            drawYear++;
                        }
                        calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                            ((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                        group += calender;
                    }
                    html += group;
                }
                html += buttonPanel;
                inst._keyEvent = false;
                return html;
            },
            
            /* Generate the month and year header. */
            _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
                                               secondary, monthNames, monthNamesShort) {
                
                var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                    changeMonth = this._get(inst, "changeMonth"),
                    changeYear = this._get(inst, "changeYear"),
                    showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                    html = "<div class='ui-datepicker-title'>",
                    monthHtml = "";
                
                // month selection
                if (secondary || !changeMonth) {
                    monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
                } else {
                    inMinYear = (minDate && minDate.getFullYear() === drawYear);
                    inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
                    monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                    for ( month = 0; month < 12; month++) {
                        if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                            monthHtml += "<option value='" + month + "'" +
                                (month === drawMonth ? " selected='selected'" : "") +
                                ">" + monthNamesShort[month] + "</option>";
                        }
                    }
                    monthHtml += "</select>";
                }
                
                if (!showMonthAfterYear) {
                    html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
                }
                
                // year selection
                if ( !inst.yearshtml ) {
                    inst.yearshtml = "";
                    if (secondary || !changeYear) {
                        html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                    } else {
                        // determine range of years to display
                        years = this._get(inst, "yearRange").split(":");
                        thisYear = new Date().getFullYear();
                        determineYear = function(value) {
                            var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                                (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                                    parseInt(value, 10)));
                            return (isNaN(year) ? thisYear : year);
                        };
                        year = determineYear(years[0]);
                        endYear = Math.max(year, determineYear(years[1] || ""));
                        year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                        endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                        inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                        for (; year <= endYear; year++) {
                            inst.yearshtml += "<option value='" + year + "'" +
                                (year === drawYear ? " selected='selected'" : "") +
                                ">" + year + "</option>";
                        }
                        inst.yearshtml += "</select>";
                        
                        html += inst.yearshtml;
                        inst.yearshtml = null;
                    }
                }
                
                html += this._get(inst, "yearSuffix");
                if (showMonthAfterYear) {
                    html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
                }
                html += "</div>"; // Close datepicker_header
                return html;
            },
            
            /* Adjust one of the date sub-fields. */
            _adjustInstDate: function(inst, offset, period) {
                var year = inst.drawYear + (period === "Y" ? offset : 0),
                    month = inst.drawMonth + (period === "M" ? offset : 0),
                    day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
                    date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
                
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
                if (period === "M" || period === "Y") {
                    this._notifyChange(inst);
                }
            },
            
            /* Ensure a date is within any min/max bounds. */
            _restrictMinMax: function(inst, date) {
                var minDate = this._getMinMaxDate(inst, "min"),
                    maxDate = this._getMinMaxDate(inst, "max"),
                    newDate = (minDate && date < minDate ? minDate : date);
                return (maxDate && newDate > maxDate ? maxDate : newDate);
            },
            
            /* Notify change of month/year. */
            _notifyChange: function(inst) {
                var onChange = this._get(inst, "onChangeMonthYear");
                if (onChange) {
                    onChange.apply((inst.input ? inst.input[0] : null),
                        [inst.selectedYear, inst.selectedMonth + 1, inst]);
                }
            },
            
            /* Determine the number of months to show. */
            _getNumberOfMonths: function(inst) {
                var numMonths = this._get(inst, "numberOfMonths");
                return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
            },
            
            /* Determine the current maximum date - ensure no time components are set. */
            _getMinMaxDate: function(inst, minMax) {
                return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
            },
            
            /* Find the number of days in a given month. */
            _getDaysInMonth: function(year, month) {
                return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
            },
            
            /* Find the day of the week of the first of a month. */
            _getFirstDayOfMonth: function(year, month) {
                return new Date(year, month, 1).getDay();
            },
            
            /* Determines if we should allow a "next/prev" month display change. */
            _canAdjustMonth: function(inst, offset, curYear, curMonth) {
                var numMonths = this._getNumberOfMonths(inst),
                    date = this._daylightSavingAdjust(new Date(curYear,
                        curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
                
                if (offset < 0) {
                    date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
                }
                return this._isInRange(inst, date);
            },
            
            /* Is the given date in the accepted range? */
            _isInRange: function(inst, date) {
                var yearSplit, currentYear,
                    minDate = this._getMinMaxDate(inst, "min"),
                    maxDate = this._getMinMaxDate(inst, "max"),
                    minYear = null,
                    maxYear = null,
                    years = this._get(inst, "yearRange");
                if (years){
                    yearSplit = years.split(":");
                    currentYear = new Date().getFullYear();
                    minYear = parseInt(yearSplit[0], 10);
                    maxYear = parseInt(yearSplit[1], 10);
                    if ( yearSplit[0].match(/[+\-].*/) ) {
                        minYear += currentYear;
                    }
                    if ( yearSplit[1].match(/[+\-].*/) ) {
                        maxYear += currentYear;
                    }
                }
                
                return ((!minDate || date.getTime() >= minDate.getTime()) &&
                (!maxDate || date.getTime() <= maxDate.getTime()) &&
                (!minYear || date.getFullYear() >= minYear) &&
                (!maxYear || date.getFullYear() <= maxYear));
            },
            
            /* Provide the configuration settings for formatting/parsing. */
            _getFormatConfig: function(inst) {
                var shortYearCutoff = this._get(inst, "shortYearCutoff");
                shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
                return {shortYearCutoff: shortYearCutoff,
                    dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
                    monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
            },
            
            /* Format the given date for display. */
            _formatDate: function(inst, day, month, year) {
                if (!day) {
                    inst.currentDay = inst.selectedDay;
                    inst.currentMonth = inst.selectedMonth;
                    inst.currentYear = inst.selectedYear;
                }
                var date = (day ? (typeof day === "object" ? day :
                    this._daylightSavingAdjust(new Date(year, month, day))) :
                    this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
                return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
            }
        });
        
        /*
         * Bind hover events for datepicker elements.
         * Done via delegate so the binding only occurs once in the lifetime of the parent div.
         * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
         */
        function bindHover(dpDiv) {
            var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
            return dpDiv.delegate(selector, "mouseout", function() {
                $(this).removeClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).removeClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).removeClass("ui-datepicker-next-hover");
                }
            })
                .delegate(selector, "mouseover", function(){
                    if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
                        $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                        $(this).addClass("ui-state-hover");
                        if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                            $(this).addClass("ui-datepicker-prev-hover");
                        }
                        if (this.className.indexOf("ui-datepicker-next") !== -1) {
                            $(this).addClass("ui-datepicker-next-hover");
                        }
                    }
                });
        }
        
        /* jQuery extend now ignores nulls! */
        function extendRemove(target, props) {
            $.extend(target, props);
            for (var name in props) {
                if (props[name] == null) {
                    target[name] = props[name];
                }
            }
            return target;
        }
        
        /* Invoke the datepicker functionality.
         @param  options  string - a command, optionally followed by additional parameters or
         Object - settings for attaching new datepicker functionality
         @return  jQuery object */
        $.fn.datepicker = function(options){
            
            /* Verify an empty collection wasn't passed - Fixes #6976 */
            if ( !this.length ) {
                return this;
            }
            
            /* Initialise the date picker. */
            if (!$.datepicker.initialized) {
                $(document).mousedown($.datepicker._checkExternalClick);
                $.datepicker.initialized = true;
            }
            
            /* Append datepicker main container to body if not exist. */
            if ($("#"+$.datepicker._mainDivId).length === 0) {
                $("body").append($.datepicker.dpDiv);
            }
            
            var otherArgs = Array.prototype.slice.call(arguments, 1);
            if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
                return $.datepicker["_" + options + "Datepicker"].
                    apply($.datepicker, [this[0]].concat(otherArgs));
            }
            if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
                return $.datepicker["_" + options + "Datepicker"].
                    apply($.datepicker, [this[0]].concat(otherArgs));
            }
            return this.each(function() {
                typeof options === "string" ?
                    $.datepicker["_" + options + "Datepicker"].
                        apply($.datepicker, [this].concat(otherArgs)) :
                    $.datepicker._attachDatepicker(this, options);
            });
        };
        
        $.datepicker = new Datepicker(); // singleton instance
        $.datepicker.initialized = false;
        $.datepicker.uuid = new Date().getTime();
        $.datepicker.version = "1.10.3";
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        var sizeRelatedOptions = {
                buttons: true,
                height: true,
                maxHeight: true,
                maxWidth: true,
                minHeight: true,
                minWidth: true,
                width: true
            },
            resizableRelatedOptions = {
                maxHeight: true,
                maxWidth: true,
                minHeight: true,
                minWidth: true
            };
        
        $.widget( "ui.dialog", {
            version: "1.10.3",
            options: {
                appendTo: "body",
                autoOpen: true,
                buttons: [],
                closeOnEscape: true,
                closeText: "close",
                dialogClass: "",
                draggable: true,
                hide: null,
                height: "auto",
                maxHeight: null,
                maxWidth: null,
                minHeight: 150,
                minWidth: 150,
                modal: false,
                position: {
                    my: "center",
                    at: "center",
                    of: window,
                    collision: "fit",
                    // Ensure the titlebar is always visible
                    using: function( pos ) {
                        var topOffset = $( this ).css( pos ).offset().top;
                        if ( topOffset < 0 ) {
                            $( this ).css( "top", pos.top - topOffset );
                        }
                    }
                },
                resizable: true,
                show: null,
                title: null,
                width: 300,
                
                // callbacks
                beforeClose: null,
                close: null,
                drag: null,
                dragStart: null,
                dragStop: null,
                focus: null,
                open: null,
                resize: null,
                resizeStart: null,
                resizeStop: null
            },
            
            _create: function() {
                this.originalCss = {
                    display: this.element[0].style.display,
                    width: this.element[0].style.width,
                    minHeight: this.element[0].style.minHeight,
                    maxHeight: this.element[0].style.maxHeight,
                    height: this.element[0].style.height
                };
                this.originalPosition = {
                    parent: this.element.parent(),
                    index: this.element.parent().children().index( this.element )
                };
                this.originalTitle = this.element.attr("title");
                this.options.title = this.options.title || this.originalTitle;
                
                this._createWrapper();
                
                this.element
                    .show()
                    .removeAttr("title")
                    .addClass("ui-dialog-content ui-widget-content")
                    .appendTo( this.uiDialog );
                
                this._createTitlebar();
                this._createButtonPane();
                
                if ( this.options.draggable && $.fn.draggable ) {
                    this._makeDraggable();
                }
                if ( this.options.resizable && $.fn.resizable ) {
                    this._makeResizable();
                }
                
                this._isOpen = false;
            },
            
            _init: function() {
                if ( this.options.autoOpen ) {
                    this.open();
                }
            },
            
            _appendTo: function() {
                var element = this.options.appendTo;
                if ( element && (element.jquery || element.nodeType) ) {
                    return $( element );
                }
                return this.document.find( element || "body" ).eq( 0 );
            },
            
            _destroy: function() {
                var next,
                    originalPosition = this.originalPosition;
                
                this._destroyOverlay();
                
                this.element
                    .removeUniqueId()
                    .removeClass("ui-dialog-content ui-widget-content")
                    .css( this.originalCss )
                    // Without detaching first, the following becomes really slow
                    .detach();
                
                this.uiDialog.stop( true, true ).remove();
                
                if ( this.originalTitle ) {
                    this.element.attr( "title", this.originalTitle );
                }
                
                next = originalPosition.parent.children().eq( originalPosition.index );
                // Don't try to place the dialog next to itself (#8613)
                if ( next.length && next[0] !== this.element[0] ) {
                    next.before( this.element );
                } else {
                    originalPosition.parent.append( this.element );
                }
            },
            
            widget: function() {
                return this.uiDialog;
            },
            
            disable: $.noop,
            enable: $.noop,
            
            close: function( event ) {
                var that = this;
                
                if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
                    return;
                }
                
                this._isOpen = false;
                this._destroyOverlay();
                
                if ( !this.opener.filter(":focusable").focus().length ) {
                    // Hiding a focused element doesn't trigger blur in WebKit
                    // so in case we have nothing to focus on, explicitly blur the active element
                    // https://bugs.webkit.org/show_bug.cgi?id=47182
                    $( this.document[0].activeElement ).blur();
                }
                
                this._hide( this.uiDialog, this.options.hide, function() {
                    that._trigger( "close", event );
                });
            },
            
            isOpen: function() {
                return this._isOpen;
            },
            
            moveToTop: function() {
                this._moveToTop();
            },
            
            _moveToTop: function( event, silent ) {
                var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
                if ( moved && !silent ) {
                    this._trigger( "focus", event );
                }
                return moved;
            },
            
            open: function() {
                var that = this;
                if ( this._isOpen ) {
                    if ( this._moveToTop() ) {
                        this._focusTabbable();
                    }
                    return;
                }
                
                this._isOpen = true;
                this.opener = $( this.document[0].activeElement );
                
                this._size();
                this._position();
                this._createOverlay();
                this._moveToTop( null, true );
                this._show( this.uiDialog, this.options.show, function() {
                    that._focusTabbable();
                    that._trigger("focus");
                });
                
                this._trigger("open");
            },
            
            _focusTabbable: function() {
                // Set focus to the first match:
                // 1. First element inside the dialog matching [autofocus]
                // 2. Tabbable element inside the content element
                // 3. Tabbable element inside the buttonpane
                // 4. The close button
                // 5. The dialog itself
                var hasFocus = this.element.find("[autofocus]");
                if ( !hasFocus.length ) {
                    hasFocus = this.element.find(":tabbable");
                }
                if ( !hasFocus.length ) {
                    hasFocus = this.uiDialogButtonPane.find(":tabbable");
                }
                if ( !hasFocus.length ) {
                    hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
                }
                if ( !hasFocus.length ) {
                    hasFocus = this.uiDialog;
                }
                hasFocus.eq( 0 ).focus();
            },
            
            _keepFocus: function( event ) {
                function checkFocus() {
                    var activeElement = this.document[0].activeElement,
                        isActive = this.uiDialog[0] === activeElement ||
                            $.contains( this.uiDialog[0], activeElement );
                    if ( !isActive ) {
                        this._focusTabbable();
                    }
                }
                event.preventDefault();
                checkFocus.call( this );
                // support: IE
                // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
                // so we check again later
                this._delay( checkFocus );
            },
            
            _createWrapper: function() {
                this.uiDialog = $("<div>")
                    .addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
                    this.options.dialogClass )
                    .hide()
                    .attr({
                        // Setting tabIndex makes the div focusable
                        tabIndex: -1,
                        role: "dialog"
                    })
                    .appendTo( this._appendTo() );
                
                this._on( this.uiDialog, {
                    keydown: function( event ) {
                        if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                            event.keyCode === $.ui.keyCode.ESCAPE ) {
                            event.preventDefault();
                            this.close( event );
                            return;
                        }
                        
                        // prevent tabbing out of dialogs
                        if ( event.keyCode !== $.ui.keyCode.TAB ) {
                            return;
                        }
                        var tabbables = this.uiDialog.find(":tabbable"),
                            first = tabbables.filter(":first"),
                            last  = tabbables.filter(":last");
                        
                        if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
                            first.focus( 1 );
                            event.preventDefault();
                        } else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
                            last.focus( 1 );
                            event.preventDefault();
                        }
                    },
                    mousedown: function( event ) {
                        if ( this._moveToTop( event ) ) {
                            this._focusTabbable();
                        }
                    }
                });
                
                // We assume that any existing aria-describedby attribute means
                // that the dialog content is marked up properly
                // otherwise we brute force the content as the description
                if ( !this.element.find("[aria-describedby]").length ) {
                    this.uiDialog.attr({
                        "aria-describedby": this.element.uniqueId().attr("id")
                    });
                }
            },
            
            _createTitlebar: function() {
                var uiDialogTitle;
                
                this.uiDialogTitlebar = $("<div>")
                    .addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
                    .prependTo( this.uiDialog );
                this._on( this.uiDialogTitlebar, {
                    mousedown: function( event ) {
                        // Don't prevent click on close button (#8838)
                        // Focusing a dialog that is partially scrolled out of view
                        // causes the browser to scroll it into view, preventing the click event
                        if ( !$( event.target ).closest(".ui-dialog-titlebar-close") ) {
                            // Dialog isn't getting focus when dragging (#8063)
                            this.uiDialog.focus();
                        }
                    }
                });
                
                this.uiDialogTitlebarClose = $("<button></button>")
                    .button({
                        label: this.options.closeText,
                        icons: {
                            primary: "ui-icon-closethick"
                        },
                        text: false
                    })
                    .addClass("ui-dialog-titlebar-close")
                    .appendTo( this.uiDialogTitlebar );
                this._on( this.uiDialogTitlebarClose, {
                    click: function( event ) {
                        event.preventDefault();
                        this.close( event );
                    }
                });
                
                uiDialogTitle = $("<span>")
                    .uniqueId()
                    .addClass("ui-dialog-title")
                    .prependTo( this.uiDialogTitlebar );
                this._title( uiDialogTitle );
                
                this.uiDialog.attr({
                    "aria-labelledby": uiDialogTitle.attr("id")
                });
            },
            
            _title: function( title ) {
                if ( !this.options.title ) {
                    title.html("&#160;");
                }
                title.text( this.options.title );
            },
            
            _createButtonPane: function() {
                this.uiDialogButtonPane = $("<div>")
                    .addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");
                
                this.uiButtonSet = $("<div>")
                    .addClass("ui-dialog-buttonset")
                    .appendTo( this.uiDialogButtonPane );
                
                this._createButtons();
            },
            
            _createButtons: function() {
                var that = this,
                    buttons = this.options.buttons;
                
                // if we already have a button pane, remove it
                this.uiDialogButtonPane.remove();
                this.uiButtonSet.empty();
                
                if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
                    this.uiDialog.removeClass("ui-dialog-buttons");
                    return;
                }
                
                $.each( buttons, function( name, props ) {
                    var click, buttonOptions;
                    props = $.isFunction( props ) ?
                    { click: props, text: name } :
                        props;
                    // Default to a non-submitting button
                    props = $.extend( { type: "button" }, props );
                    // Change the context for the click callback to be the main element
                    click = props.click;
                    props.click = function() {
                        click.apply( that.element[0], arguments );
                    };
                    buttonOptions = {
                        icons: props.icons,
                        text: props.showText
                    };
                    delete props.icons;
                    delete props.showText;
                    $( "<button></button>", props )
                        .button( buttonOptions )
                        .appendTo( that.uiButtonSet );
                });
                this.uiDialog.addClass("ui-dialog-buttons");
                this.uiDialogButtonPane.appendTo( this.uiDialog );
            },
            
            _makeDraggable: function() {
                var that = this,
                    options = this.options;
                
                function filteredUi( ui ) {
                    return {
                        position: ui.position,
                        offset: ui.offset
                    };
                }
                
                this.uiDialog.draggable({
                    cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                    handle: ".ui-dialog-titlebar",
                    containment: "document",
                    start: function( event, ui ) {
                        $( this ).addClass("ui-dialog-dragging");
                        that._blockFrames();
                        that._trigger( "dragStart", event, filteredUi( ui ) );
                    },
                    drag: function( event, ui ) {
                        that._trigger( "drag", event, filteredUi( ui ) );
                    },
                    stop: function( event, ui ) {
                        options.position = [
                            ui.position.left - that.document.scrollLeft(),
                            ui.position.top - that.document.scrollTop()
                        ];
                        $( this ).removeClass("ui-dialog-dragging");
                        that._unblockFrames();
                        that._trigger( "dragStop", event, filteredUi( ui ) );
                    }
                });
            },
            
            _makeResizable: function() {
                var that = this,
                    options = this.options,
                    handles = options.resizable,
                // .ui-resizable has position: relative defined in the stylesheet
                // but dialogs have to use absolute or fixed positioning
                    position = this.uiDialog.css("position"),
                    resizeHandles = typeof handles === "string" ?
                        handles	:
                        "n,e,s,w,se,sw,ne,nw";
                
                function filteredUi( ui ) {
                    return {
                        originalPosition: ui.originalPosition,
                        originalSize: ui.originalSize,
                        position: ui.position,
                        size: ui.size
                    };
                }
                
                this.uiDialog.resizable({
                    cancel: ".ui-dialog-content",
                    containment: "document",
                    alsoResize: this.element,
                    maxWidth: options.maxWidth,
                    maxHeight: options.maxHeight,
                    minWidth: options.minWidth,
                    minHeight: this._minHeight(),
                    handles: resizeHandles,
                    start: function( event, ui ) {
                        $( this ).addClass("ui-dialog-resizing");
                        that._blockFrames();
                        that._trigger( "resizeStart", event, filteredUi( ui ) );
                    },
                    resize: function( event, ui ) {
                        that._trigger( "resize", event, filteredUi( ui ) );
                    },
                    stop: function( event, ui ) {
                        options.height = $( this ).height();
                        options.width = $( this ).width();
                        $( this ).removeClass("ui-dialog-resizing");
                        that._unblockFrames();
                        that._trigger( "resizeStop", event, filteredUi( ui ) );
                    }
                })
                    .css( "position", position );
            },
            
            _minHeight: function() {
                var options = this.options;
                
                return options.height === "auto" ?
                    options.minHeight :
                    Math.min( options.minHeight, options.height );
            },
            
            _position: function() {
                // Need to show the dialog to get the actual offset in the position plugin
                var isVisible = this.uiDialog.is(":visible");
                if ( !isVisible ) {
                    this.uiDialog.show();
                }
                this.uiDialog.position( this.options.position );
                if ( !isVisible ) {
                    this.uiDialog.hide();
                }
            },
            
            _setOptions: function( options ) {
                var that = this,
                    resize = false,
                    resizableOptions = {};
                
                $.each( options, function( key, value ) {
                    that._setOption( key, value );
                    
                    if ( key in sizeRelatedOptions ) {
                        resize = true;
                    }
                    if ( key in resizableRelatedOptions ) {
                        resizableOptions[ key ] = value;
                    }
                });
                
                if ( resize ) {
                    this._size();
                    this._position();
                }
                if ( this.uiDialog.is(":data(ui-resizable)") ) {
                    this.uiDialog.resizable( "option", resizableOptions );
                }
            },
            
            _setOption: function( key, value ) {
                /*jshint maxcomplexity:15*/
                var isDraggable, isResizable,
                    uiDialog = this.uiDialog;
                
                if ( key === "dialogClass" ) {
                    uiDialog
                        .removeClass( this.options.dialogClass )
                        .addClass( value );
                }
                
                if ( key === "disabled" ) {
                    return;
                }
                
                this._super( key, value );
                
                if ( key === "appendTo" ) {
                    this.uiDialog.appendTo( this._appendTo() );
                }
                
                if ( key === "buttons" ) {
                    this._createButtons();
                }
                
                if ( key === "closeText" ) {
                    this.uiDialogTitlebarClose.button({
                        // Ensure that we always pass a string
                        label: "" + value
                    });
                }
                
                if ( key === "draggable" ) {
                    isDraggable = uiDialog.is(":data(ui-draggable)");
                    if ( isDraggable && !value ) {
                        uiDialog.draggable("destroy");
                    }
                    
                    if ( !isDraggable && value ) {
                        this._makeDraggable();
                    }
                }
                
                if ( key === "position" ) {
                    this._position();
                }
                
                if ( key === "resizable" ) {
                    // currently resizable, becoming non-resizable
                    isResizable = uiDialog.is(":data(ui-resizable)");
                    if ( isResizable && !value ) {
                        uiDialog.resizable("destroy");
                    }
                    
                    // currently resizable, changing handles
                    if ( isResizable && typeof value === "string" ) {
                        uiDialog.resizable( "option", "handles", value );
                    }
                    
                    // currently non-resizable, becoming resizable
                    if ( !isResizable && value !== false ) {
                        this._makeResizable();
                    }
                }
                
                if ( key === "title" ) {
                    this._title( this.uiDialogTitlebar.find(".ui-dialog-title") );
                }
            },
            
            _size: function() {
                // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
                // divs will both have width and height set, so we need to reset them
                var nonContentHeight, minContentHeight, maxContentHeight,
                    options = this.options;
                
                // Reset content sizing
                this.element.show().css({
                    width: "auto",
                    minHeight: 0,
                    maxHeight: "none",
                    height: 0
                });
                
                if ( options.minWidth > options.width ) {
                    options.width = options.minWidth;
                }
                
                // reset wrapper sizing
                // determine the height of all the non-content elements
                nonContentHeight = this.uiDialog.css({
                    height: "auto",
                    width: options.width
                })
                    .outerHeight();
                minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
                maxContentHeight = typeof options.maxHeight === "number" ?
                    Math.max( 0, options.maxHeight - nonContentHeight ) :
                    "none";
                
                if ( options.height === "auto" ) {
                    this.element.css({
                        minHeight: minContentHeight,
                        maxHeight: maxContentHeight,
                        height: "auto"
                    });
                } else {
                    this.element.height( Math.max( 0, options.height - nonContentHeight ) );
                }
                
                if (this.uiDialog.is(":data(ui-resizable)") ) {
                    this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
                }
            },
            
            _blockFrames: function() {
                this.iframeBlocks = this.document.find( "iframe" ).map(function() {
                    var iframe = $( this );
                    
                    return $( "<div>" )
                        .css({
                            position: "absolute",
                            width: iframe.outerWidth(),
                            height: iframe.outerHeight()
                        })
                        .appendTo( iframe.parent() )
                        .offset( iframe.offset() )[0];
                });
            },
            
            _unblockFrames: function() {
                if ( this.iframeBlocks ) {
                    this.iframeBlocks.remove();
                    delete this.iframeBlocks;
                }
            },
            
            _allowInteraction: function( event ) {
                if ( $( event.target ).closest(".ui-dialog").length ) {
                    return true;
                }
                
                // TODO: Remove hack when datepicker implements
                // the .ui-front logic (#8989)
                return !!$( event.target ).closest(".ui-datepicker").length;
            },
            
            _createOverlay: function() {
                if ( !this.options.modal ) {
                    return;
                }
                
                var that = this,
                    widgetFullName = this.widgetFullName;
                if ( !$.ui.dialog.overlayInstances ) {
                    // Prevent use of anchors and inputs.
                    // We use a delay in case the overlay is created from an
                    // event that we're going to be cancelling. (#2804)
                    this._delay(function() {
                        // Handle .dialog().dialog("close") (#4065)
                        if ( $.ui.dialog.overlayInstances ) {
                            this.document.bind( "focusin.dialog", function( event ) {
                                if ( !that._allowInteraction( event ) ) {
                                    event.preventDefault();
                                    $(".ui-dialog:visible:last .ui-dialog-content")
                                        .data( widgetFullName )._focusTabbable();
                                }
                            });
                        }
                    });
                }
                
                this.overlay = $("<div>")
                    .addClass("ui-widget-overlay ui-front")
                    .appendTo( this._appendTo() );
                this._on( this.overlay, {
                    mousedown: "_keepFocus"
                });
                $.ui.dialog.overlayInstances++;
            },
            
            _destroyOverlay: function() {
                if ( !this.options.modal ) {
                    return;
                }
                
                if ( this.overlay ) {
                    $.ui.dialog.overlayInstances--;
                    
                    if ( !$.ui.dialog.overlayInstances ) {
                        this.document.unbind( "focusin.dialog" );
                    }
                    this.overlay.remove();
                    this.overlay = null;
                }
            }
        });
        
        $.ui.dialog.overlayInstances = 0;
        
        // DEPRECATED
        if ( $.uiBackCompat !== false ) {
            // position option with array notation
            // just override with old implementation
            $.widget( "ui.dialog", $.ui.dialog, {
                _position: function() {
                    var position = this.options.position,
                        myAt = [],
                        offset = [ 0, 0 ],
                        isVisible;
                    
                    if ( position ) {
                        if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
                            myAt = position.split ? position.split(" ") : [ position[0], position[1] ];
                            if ( myAt.length === 1 ) {
                                myAt[1] = myAt[0];
                            }
                            
                            $.each( [ "left", "top" ], function( i, offsetPosition ) {
                                if ( +myAt[ i ] === myAt[ i ] ) {
                                    offset[ i ] = myAt[ i ];
                                    myAt[ i ] = offsetPosition;
                                }
                            });
                            
                            position = {
                                my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
                                myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
                                at: myAt.join(" ")
                            };
                        }
                        
                        position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
                    } else {
                        position = $.ui.dialog.prototype.options.position;
                    }
                    
                    // need to show the dialog to get the actual offset in the position plugin
                    isVisible = this.uiDialog.is(":visible");
                    if ( !isVisible ) {
                        this.uiDialog.show();
                    }
                    this.uiDialog.position( position );
                    if ( !isVisible ) {
                        this.uiDialog.hide();
                    }
                }
            });
        }
        
    }( jQuery ) );
    
    (function( $, undefined ) {
        
        var rvertical = /up|down|vertical/,
            rpositivemotion = /up|left|vertical|horizontal/;
        
        $.effects.effect.blind = function( o, done ) {
            // Create element
            var el = $( this ),
                props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
                mode = $.effects.setMode( el, o.mode || "hide" ),
                direction = o.direction || "up",
                vertical = rvertical.test( direction ),
                ref = vertical ? "height" : "width",
                ref2 = vertical ? "top" : "left",
                motion = rpositivemotion.test( direction ),
                animation = {},
                show = mode === "show",
                wrapper, distance, margin;
            
            // if already wrapped, the wrapper's properties are my property. #6245
            if ( el.parent().is( ".ui-effects-wrapper" ) ) {
                $.effects.save( el.parent(), props );
            } else {
                $.effects.save( el, props );
            }
            el.show();
            wrapper = $.effects.createWrapper( el ).css({
                overflow: "hidden"
            });
            
            distance = wrapper[ ref ]();
            margin = parseFloat( wrapper.css( ref2 ) ) || 0;
            
            animation[ ref ] = show ? distance : 0;
            if ( !motion ) {
                el
                    .css( vertical ? "bottom" : "right", 0 )
                    .css( vertical ? "top" : "left", "auto" )
                    .css({ position: "absolute" });
                
                animation[ ref2 ] = show ? margin : distance + margin;
            }
            
            // start at 0 if we are showing
            if ( show ) {
                wrapper.css( ref, 0 );
                if ( ! motion ) {
                    wrapper.css( ref2, margin + distance );
                }
            }
            
            // Animate
            wrapper.animate( animation, {
                duration: o.duration,
                easing: o.easing,
                queue: false,
                complete: function() {
                    if ( mode === "hide" ) {
                        el.hide();
                    }
                    $.effects.restore( el, props );
                    $.effects.removeWrapper( el );
                    done();
                }
            });
            
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.bounce = function( o, done ) {
            var el = $( this ),
                props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
            
            // defaults:
                mode = $.effects.setMode( el, o.mode || "effect" ),
                hide = mode === "hide",
                show = mode === "show",
                direction = o.direction || "up",
                distance = o.distance,
                times = o.times || 5,
            
            // number of internal animations
                anims = times * 2 + ( show || hide ? 1 : 0 ),
                speed = o.duration / anims,
                easing = o.easing,
            
            // utility:
                ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
                motion = ( direction === "up" || direction === "left" ),
                i,
                upAnim,
                downAnim,
            
            // we will need to re-assemble the queue to stack our animations in place
                queue = el.queue(),
                queuelen = queue.length;
            
            // Avoid touching opacity to prevent clearType and PNG issues in IE
            if ( show || hide ) {
                props.push( "opacity" );
            }
            
            $.effects.save( el, props );
            el.show();
            $.effects.createWrapper( el ); // Create Wrapper
            
            // default distance for the BIGGEST bounce is the outer Distance / 3
            if ( !distance ) {
                distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
            }
            
            if ( show ) {
                downAnim = { opacity: 1 };
                downAnim[ ref ] = 0;
                
                // if we are showing, force opacity 0 and set the initial position
                // then do the "first" animation
                el.css( "opacity", 0 )
                    .css( ref, motion ? -distance * 2 : distance * 2 )
                    .animate( downAnim, speed, easing );
            }
            
            // start at the smallest distance if we are hiding
            if ( hide ) {
                distance = distance / Math.pow( 2, times - 1 );
            }
            
            downAnim = {};
            downAnim[ ref ] = 0;
            // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
            for ( i = 0; i < times; i++ ) {
                upAnim = {};
                upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
                
                el.animate( upAnim, speed, easing )
                    .animate( downAnim, speed, easing );
                
                distance = hide ? distance * 2 : distance / 2;
            }
            
            // Last Bounce when Hiding
            if ( hide ) {
                upAnim = { opacity: 0 };
                upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
                
                el.animate( upAnim, speed, easing );
            }
            
            el.queue(function() {
                if ( hide ) {
                    el.hide();
                }
                $.effects.restore( el, props );
                $.effects.removeWrapper( el );
                done();
            });
            
            // inject all the animations we just queued to be first in line (after "inprogress")
            if ( queuelen > 1) {
                queue.splice.apply( queue,
                    [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
            }
            el.dequeue();
            
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.clip = function( o, done ) {
            // Create element
            var el = $( this ),
                props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
                mode = $.effects.setMode( el, o.mode || "hide" ),
                show = mode === "show",
                direction = o.direction || "vertical",
                vert = direction === "vertical",
                size = vert ? "height" : "width",
                position = vert ? "top" : "left",
                animation = {},
                wrapper, animate, distance;
            
            // Save & Show
            $.effects.save( el, props );
            el.show();
            
            // Create Wrapper
            wrapper = $.effects.createWrapper( el ).css({
                overflow: "hidden"
            });
            animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
            distance = animate[ size ]();
            
            // Shift
            if ( show ) {
                animate.css( size, 0 );
                animate.css( position, distance / 2 );
            }
            
            // Create Animation Object:
            animation[ size ] = show ? distance : 0;
            animation[ position ] = show ? 0 : distance / 2;
            
            // Animate
            animate.animate( animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if ( !show ) {
                        el.hide();
                    }
                    $.effects.restore( el, props );
                    $.effects.removeWrapper( el );
                    done();
                }
            });
            
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.drop = function( o, done ) {
            
            var el = $( this ),
                props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
                mode = $.effects.setMode( el, o.mode || "hide" ),
                show = mode === "show",
                direction = o.direction || "left",
                ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
                motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
                animation = {
                    opacity: show ? 1 : 0
                },
                distance;
            
            // Adjust
            $.effects.save( el, props );
            el.show();
            $.effects.createWrapper( el );
            
            distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;
            
            if ( show ) {
                el
                    .css( "opacity", 0 )
                    .css( ref, motion === "pos" ? -distance : distance );
            }
            
            // Animation
            animation[ ref ] = ( show ?
                    ( motion === "pos" ? "+=" : "-=" ) :
                    ( motion === "pos" ? "-=" : "+=" ) ) +
                distance;
            
            // Animate
            el.animate( animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if ( mode === "hide" ) {
                        el.hide();
                    }
                    $.effects.restore( el, props );
                    $.effects.removeWrapper( el );
                    done();
                }
            });
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.explode = function( o, done ) {
            
            var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
                cells = rows,
                el = $( this ),
                mode = $.effects.setMode( el, o.mode || "hide" ),
                show = mode === "show",
            
            // show and then visibility:hidden the element before calculating offset
                offset = el.show().css( "visibility", "hidden" ).offset(),
            
            // width and height of a piece
                width = Math.ceil( el.outerWidth() / cells ),
                height = Math.ceil( el.outerHeight() / rows ),
                pieces = [],
            
            // loop
                i, j, left, top, mx, my;
            
            // children animate complete:
            function childComplete() {
                pieces.push( this );
                if ( pieces.length === rows * cells ) {
                    animComplete();
                }
            }
            
            // clone the element for each row and cell.
            for( i = 0; i < rows ; i++ ) { // ===>
                top = offset.top + i * height;
                my = i - ( rows - 1 ) / 2 ;
                
                for( j = 0; j < cells ; j++ ) { // |||
                    left = offset.left + j * width;
                    mx = j - ( cells - 1 ) / 2 ;
                    
                    // Create a clone of the now hidden main element that will be absolute positioned
                    // within a wrapper div off the -left and -top equal to size of our pieces
                    el
                        .clone()
                        .appendTo( "body" )
                        .wrap( "<div></div>" )
                        .css({
                            position: "absolute",
                            visibility: "visible",
                            left: -j * width,
                            top: -i * height
                        })
                        
                        // select the wrapper - make it overflow: hidden and absolute positioned based on
                        // where the original was located +left and +top equal to the size of pieces
                        .parent()
                        .addClass( "ui-effects-explode" )
                        .css({
                            position: "absolute",
                            overflow: "hidden",
                            width: width,
                            height: height,
                            left: left + ( show ? mx * width : 0 ),
                            top: top + ( show ? my * height : 0 ),
                            opacity: show ? 0 : 1
                        }).animate({
                            left: left + ( show ? 0 : mx * width ),
                            top: top + ( show ? 0 : my * height ),
                            opacity: show ? 1 : 0
                        }, o.duration || 500, o.easing, childComplete );
                }
            }
            
            function animComplete() {
                el.css({
                    visibility: "visible"
                });
                $( pieces ).remove();
                if ( !show ) {
                    el.hide();
                }
                done();
            }
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.fade = function( o, done ) {
            var el = $( this ),
                mode = $.effects.setMode( el, o.mode || "toggle" );
            
            el.animate({
                opacity: mode
            }, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: done
            });
        };
        
    })( jQuery );
    
    (function( $, undefined ) {
        
        $.effects.effect.fold = function( o, done ) {
            
            // Create element
            var el = $( this ),
                props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
                mode = $.effects.setMode( el, o.mode || "hide" ),
                show = mode === "show",
                hide = mode === "hide",
                size = o.size || 15,
                percent = /([0-9]+)%/.exec( size ),
                horizFirst = !!o.horizFirst,
                widthFirst = show !== horizFirst,
                ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
                duration = o.duration / 2,
                wrapper, distance,
                animation1 = {},
                animation2 = {};
            
            $.effects.save( el, props );
            el.show();
            
            // Create Wrapper
            wrapper = $.effects.createWrapper( el ).css({
                overflow: "hidden"
            });
            distance = widthFirst ?
                [ wrapper.width(), wrapper.height() ] :
                [ wrapper.height(), wrapper.width() ];
            
            if ( percent ) {
                size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
            }
            if ( show ) {
                wrapper.css( horizFirst ? {
                    height: 0,
                    width: size
                } : {
                    height: size,
                    width: 0
                });
            }
            
            // Animation
            animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
            animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;
            
            // Animate
            wrapper
                .animate( animation1, duration, o.easing )
                .animate( animation2, duration, o.easing, function() {
                    if ( hide ) {
                        el.hide();
                    }
                    $.effects.restore( el, props );
                    $.effects.removeWrapper( el );
                    done();
                });
            
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.highlight = function( o, done ) {
            var elem = $( this ),
                props = [ "backgroundImage", "backgroundColor", "opacity" ],
                mode = $.effects.setMode( elem, o.mode || "show" ),
                animation = {
                    backgroundColor: elem.css( "backgroundColor" )
                };
            
            if (mode === "hide") {
                animation.opacity = 0;
            }
            
            $.effects.save( elem, props );
            
            elem
                .show()
                .css({
                    backgroundImage: "none",
                    backgroundColor: o.color || "#ffff99"
                })
                .animate( animation, {
                    queue: false,
                    duration: o.duration,
                    easing: o.easing,
                    complete: function() {
                        if ( mode === "hide" ) {
                            elem.hide();
                        }
                        $.effects.restore( elem, props );
                        done();
                    }
                });
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.pulsate = function( o, done ) {
            var elem = $( this ),
                mode = $.effects.setMode( elem, o.mode || "show" ),
                show = mode === "show",
                hide = mode === "hide",
                showhide = ( show || mode === "hide" ),
            
            // showing or hiding leaves of the "last" animation
                anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
                duration = o.duration / anims,
                animateTo = 0,
                queue = elem.queue(),
                queuelen = queue.length,
                i;
            
            if ( show || !elem.is(":visible")) {
                elem.css( "opacity", 0 ).show();
                animateTo = 1;
            }
            
            // anims - 1 opacity "toggles"
            for ( i = 1; i < anims; i++ ) {
                elem.animate({
                    opacity: animateTo
                }, duration, o.easing );
                animateTo = 1 - animateTo;
            }
            
            elem.animate({
                opacity: animateTo
            }, duration, o.easing);
            
            elem.queue(function() {
                if ( hide ) {
                    elem.hide();
                }
                done();
            });
            
            // We just queued up "anims" animations, we need to put them next in the queue
            if ( queuelen > 1 ) {
                queue.splice.apply( queue,
                    [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
            }
            elem.dequeue();
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.puff = function( o, done ) {
            var elem = $( this ),
                mode = $.effects.setMode( elem, o.mode || "hide" ),
                hide = mode === "hide",
                percent = parseInt( o.percent, 10 ) || 150,
                factor = percent / 100,
                original = {
                    height: elem.height(),
                    width: elem.width(),
                    outerHeight: elem.outerHeight(),
                    outerWidth: elem.outerWidth()
                };
            
            $.extend( o, {
                effect: "scale",
                queue: false,
                fade: true,
                mode: mode,
                complete: done,
                percent: hide ? percent : 100,
                from: hide ?
                    original :
                {
                    height: original.height * factor,
                    width: original.width * factor,
                    outerHeight: original.outerHeight * factor,
                    outerWidth: original.outerWidth * factor
                }
            });
            
            elem.effect( o );
        };
        
        $.effects.effect.scale = function( o, done ) {
            
            // Create element
            var el = $( this ),
                options = $.extend( true, {}, o ),
                mode = $.effects.setMode( el, o.mode || "effect" ),
                percent = parseInt( o.percent, 10 ) ||
                    ( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
                direction = o.direction || "both",
                origin = o.origin,
                original = {
                    height: el.height(),
                    width: el.width(),
                    outerHeight: el.outerHeight(),
                    outerWidth: el.outerWidth()
                },
                factor = {
                    y: direction !== "horizontal" ? (percent / 100) : 1,
                    x: direction !== "vertical" ? (percent / 100) : 1
                };
            
            // We are going to pass this effect to the size effect:
            options.effect = "size";
            options.queue = false;
            options.complete = done;
            
            // Set default origin and restore for show/hide
            if ( mode !== "effect" ) {
                options.origin = origin || ["middle","center"];
                options.restore = true;
            }
            
            options.from = o.from || ( mode === "show" ? {
                    height: 0,
                    width: 0,
                    outerHeight: 0,
                    outerWidth: 0
                } : original );
            options.to = {
                height: original.height * factor.y,
                width: original.width * factor.x,
                outerHeight: original.outerHeight * factor.y,
                outerWidth: original.outerWidth * factor.x
            };
            
            // Fade option to support puff
            if ( options.fade ) {
                if ( mode === "show" ) {
                    options.from.opacity = 0;
                    options.to.opacity = 1;
                }
                if ( mode === "hide" ) {
                    options.from.opacity = 1;
                    options.to.opacity = 0;
                }
            }
            
            // Animate
            el.effect( options );
            
        };
        
        $.effects.effect.size = function( o, done ) {
            
            // Create element
            var original, baseline, factor,
                el = $( this ),
                props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],
            
            // Always restore
                props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],
            
            // Copy for children
                props2 = [ "width", "height", "overflow" ],
                cProps = [ "fontSize" ],
                vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
                hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],
            
            // Set options
                mode = $.effects.setMode( el, o.mode || "effect" ),
                restore = o.restore || mode !== "effect",
                scale = o.scale || "both",
                origin = o.origin || [ "middle", "center" ],
                position = el.css( "position" ),
                props = restore ? props0 : props1,
                zero = {
                    height: 0,
                    width: 0,
                    outerHeight: 0,
                    outerWidth: 0
                };
            
            if ( mode === "show" ) {
                el.show();
            }
            original = {
                height: el.height(),
                width: el.width(),
                outerHeight: el.outerHeight(),
                outerWidth: el.outerWidth()
            };
            
            if ( o.mode === "toggle" && mode === "show" ) {
                el.from = o.to || zero;
                el.to = o.from || original;
            } else {
                el.from = o.from || ( mode === "show" ? zero : original );
                el.to = o.to || ( mode === "hide" ? zero : original );
            }
            
            // Set scaling factor
            factor = {
                from: {
                    y: el.from.height / original.height,
                    x: el.from.width / original.width
                },
                to: {
                    y: el.to.height / original.height,
                    x: el.to.width / original.width
                }
            };
            
            // Scale the css box
            if ( scale === "box" || scale === "both" ) {
                
                // Vertical props scaling
                if ( factor.from.y !== factor.to.y ) {
                    props = props.concat( vProps );
                    el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
                    el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
                }
                
                // Horizontal props scaling
                if ( factor.from.x !== factor.to.x ) {
                    props = props.concat( hProps );
                    el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
                    el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
                }
            }
            
            // Scale the content
            if ( scale === "content" || scale === "both" ) {
                
                // Vertical props scaling
                if ( factor.from.y !== factor.to.y ) {
                    props = props.concat( cProps ).concat( props2 );
                    el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
                    el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
                }
            }
            
            $.effects.save( el, props );
            el.show();
            $.effects.createWrapper( el );
            el.css( "overflow", "hidden" ).css( el.from );
            
            // Adjust
            if (origin) { // Calculate baseline shifts
                baseline = $.effects.getBaseline( origin, original );
                el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
                el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
                el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
                el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
            }
            el.css( el.from ); // set top & left
            
            // Animate
            if ( scale === "content" || scale === "both" ) { // Scale the children
                
                // Add margins/font-size
                vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
                hProps = hProps.concat([ "marginLeft", "marginRight" ]);
                props2 = props0.concat(vProps).concat(hProps);
                
                el.find( "*[width]" ).each( function(){
                    var child = $( this ),
                        c_original = {
                            height: child.height(),
                            width: child.width(),
                            outerHeight: child.outerHeight(),
                            outerWidth: child.outerWidth()
                        };
                    if (restore) {
                        $.effects.save(child, props2);
                    }
                    
                    child.from = {
                        height: c_original.height * factor.from.y,
                        width: c_original.width * factor.from.x,
                        outerHeight: c_original.outerHeight * factor.from.y,
                        outerWidth: c_original.outerWidth * factor.from.x
                    };
                    child.to = {
                        height: c_original.height * factor.to.y,
                        width: c_original.width * factor.to.x,
                        outerHeight: c_original.height * factor.to.y,
                        outerWidth: c_original.width * factor.to.x
                    };
                    
                    // Vertical props scaling
                    if ( factor.from.y !== factor.to.y ) {
                        child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
                        child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
                    }
                    
                    // Horizontal props scaling
                    if ( factor.from.x !== factor.to.x ) {
                        child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
                        child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
                    }
                    
                    // Animate children
                    child.css( child.from );
                    child.animate( child.to, o.duration, o.easing, function() {
                        
                        // Restore children
                        if ( restore ) {
                            $.effects.restore( child, props2 );
                        }
                    });
                });
            }
            
            // Animate
            el.animate( el.to, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if ( el.to.opacity === 0 ) {
                        el.css( "opacity", el.from.opacity );
                    }
                    if( mode === "hide" ) {
                        el.hide();
                    }
                    $.effects.restore( el, props );
                    if ( !restore ) {
                        
                        // we need to calculate our new positioning based on the scaling
                        if ( position === "static" ) {
                            el.css({
                                position: "relative",
                                top: el.to.top,
                                left: el.to.left
                            });
                        } else {
                            $.each([ "top", "left" ], function( idx, pos ) {
                                el.css( pos, function( _, str ) {
                                    var val = parseInt( str, 10 ),
                                        toRef = idx ? el.to.left : el.to.top;
                                    
                                    // if original was "auto", recalculate the new value from wrapper
                                    if ( str === "auto" ) {
                                        return toRef + "px";
                                    }
                                    
                                    return val + toRef + "px";
                                });
                            });
                        }
                    }
                    
                    $.effects.removeWrapper( el );
                    done();
                }
            });
            
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.shake = function( o, done ) {
            
            var el = $( this ),
                props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
                mode = $.effects.setMode( el, o.mode || "effect" ),
                direction = o.direction || "left",
                distance = o.distance || 20,
                times = o.times || 3,
                anims = times * 2 + 1,
                speed = Math.round(o.duration/anims),
                ref = (direction === "up" || direction === "down") ? "top" : "left",
                positiveMotion = (direction === "up" || direction === "left"),
                animation = {},
                animation1 = {},
                animation2 = {},
                i,
            
            // we will need to re-assemble the queue to stack our animations in place
                queue = el.queue(),
                queuelen = queue.length;
            
            $.effects.save( el, props );
            el.show();
            $.effects.createWrapper( el );
            
            // Animation
            animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
            animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
            animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;
            
            // Animate
            el.animate( animation, speed, o.easing );
            
            // Shakes
            for ( i = 1; i < times; i++ ) {
                el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
            }
            el
                .animate( animation1, speed, o.easing )
                .animate( animation, speed / 2, o.easing )
                .queue(function() {
                    if ( mode === "hide" ) {
                        el.hide();
                    }
                    $.effects.restore( el, props );
                    $.effects.removeWrapper( el );
                    done();
                });
            
            // inject all the animations we just queued to be first in line (after "inprogress")
            if ( queuelen > 1) {
                queue.splice.apply( queue,
                    [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
            }
            el.dequeue();
            
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.slide = function( o, done ) {
            
            // Create element
            var el = $( this ),
                props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
                mode = $.effects.setMode( el, o.mode || "show" ),
                show = mode === "show",
                direction = o.direction || "left",
                ref = (direction === "up" || direction === "down") ? "top" : "left",
                positiveMotion = (direction === "up" || direction === "left"),
                distance,
                animation = {};
            
            // Adjust
            $.effects.save( el, props );
            el.show();
            distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );
            
            $.effects.createWrapper( el ).css({
                overflow: "hidden"
            });
            
            if ( show ) {
                el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
            }
            
            // Animation
            animation[ ref ] = ( show ?
                    ( positiveMotion ? "+=" : "-=") :
                    ( positiveMotion ? "-=" : "+=")) +
                distance;
            
            // Animate
            el.animate( animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function() {
                    if ( mode === "hide" ) {
                        el.hide();
                    }
                    $.effects.restore( el, props );
                    $.effects.removeWrapper( el );
                    done();
                }
            });
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.effects.effect.transfer = function( o, done ) {
            var elem = $( this ),
                target = $( o.to ),
                targetFixed = target.css( "position" ) === "fixed",
                body = $("body"),
                fixTop = targetFixed ? body.scrollTop() : 0,
                fixLeft = targetFixed ? body.scrollLeft() : 0,
                endPosition = target.offset(),
                animation = {
                    top: endPosition.top - fixTop ,
                    left: endPosition.left - fixLeft ,
                    height: target.innerHeight(),
                    width: target.innerWidth()
                },
                startPosition = elem.offset(),
                transfer = $( "<div class='ui-effects-transfer'></div>" )
                    .appendTo( document.body )
                    .addClass( o.className )
                    .css({
                        top: startPosition.top - fixTop ,
                        left: startPosition.left - fixLeft ,
                        height: elem.innerHeight(),
                        width: elem.innerWidth(),
                        position: targetFixed ? "fixed" : "absolute"
                    })
                    .animate( animation, o.duration, o.easing, function() {
                        transfer.remove();
                        done();
                    });
        };
        
    })(jQuery);
    
    (function( $, undefined ) {
        
        $.widget( "ui.menu", {
            version: "1.10.3",
            defaultElement: "<ul>",
            delay: 300,
            options: {
                icons: {
                    submenu: "ui-icon-carat-1-e"
                },
                menus: "ul",
                position: {
                    my: "left top",
                    at: "right top"
                },
                role: "menu",
                
                // callbacks
                blur: null,
                focus: null,
                select: null
            },
            
            _create: function() {
                this.activeMenu = this.element;
                // flag used to prevent firing of the click handler
                // as the event bubbles up through nested menus
                this.mouseHandled = false;
                this.element
                    .uniqueId()
                    .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
                    .toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
                    .attr({
                        role: this.options.role,
                        tabIndex: 0
                    })
                    // need to catch all clicks on disabled menu
                    // not possible through _on
                    .bind( "click" + this.eventNamespace, $.proxy(function( event ) {
                        if ( this.options.disabled ) {
                            event.preventDefault();
                        }
                    }, this ));
                
                if ( this.options.disabled ) {
                    this.element
                        .addClass( "ui-state-disabled" )
                        .attr( "aria-disabled", "true" );
                }
                
                this._on({
                    // Prevent focus from sticking to links inside menu after clicking
                    // them (focus should always stay on UL during navigation).
                    "mousedown .ui-menu-item > a": function( event ) {
                        event.preventDefault();
                    },
                    "click .ui-state-disabled > a": function( event ) {
                        event.preventDefault();
                    },
                    "click .ui-menu-item:has(a)": function( event ) {
                        var target = $( event.target ).closest( ".ui-menu-item" );
                        if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
                            this.mouseHandled = true;
                            
                            this.select( event );
                            // Open submenu on click
                            if ( target.has( ".ui-menu" ).length ) {
                                this.expand( event );
                            } else if ( !this.element.is( ":focus" ) ) {
                                // Redirect focus to the menu
                                this.element.trigger( "focus", [ true ] );
                                
                                // If the active item is on the top level, let it stay active.
                                // Otherwise, blur the active item since it is no longer visible.
                                if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
                                    clearTimeout( this.timer );
                                }
                            }
                        }
                    },
                    "mouseenter .ui-menu-item": function( event ) {
                        var target = $( event.currentTarget );
                        // Remove ui-state-active class from siblings of the newly focused menu item
                        // to avoid a jump caused by adjacent elements both having a class with a border
                        target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
                        this.focus( event, target );
                    },
                    mouseleave: "collapseAll",
                    "mouseleave .ui-menu": "collapseAll",
                    focus: function( event, keepActiveItem ) {
                        // If there's already an active item, keep it active
                        // If not, activate the first item
                        var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );
                        
                        if ( !keepActiveItem ) {
                            this.focus( event, item );
                        }
                    },
                    blur: function( event ) {
                        this._delay(function() {
                            if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
                                this.collapseAll( event );
                            }
                        });
                    },
                    keydown: "_keydown"
                });
                
                this.refresh();
                
                // Clicks outside of a menu collapse any open menus
                this._on( this.document, {
                    click: function( event ) {
                        if ( !$( event.target ).closest( ".ui-menu" ).length ) {
                            this.collapseAll( event );
                        }
                        
                        // Reset the mouseHandled flag
                        this.mouseHandled = false;
                    }
                });
            },
            
            _destroy: function() {
                // Destroy (sub)menus
                this.element
                    .removeAttr( "aria-activedescendant" )
                    .find( ".ui-menu" ).addBack()
                    .removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
                    .removeAttr( "role" )
                    .removeAttr( "tabIndex" )
                    .removeAttr( "aria-labelledby" )
                    .removeAttr( "aria-expanded" )
                    .removeAttr( "aria-hidden" )
                    .removeAttr( "aria-disabled" )
                    .removeUniqueId()
                    .show();
                
                // Destroy menu items
                this.element.find( ".ui-menu-item" )
                    .removeClass( "ui-menu-item" )
                    .removeAttr( "role" )
                    .removeAttr( "aria-disabled" )
                    .children( "a" )
                    .removeUniqueId()
                    .removeClass( "ui-corner-all ui-state-hover" )
                    .removeAttr( "tabIndex" )
                    .removeAttr( "role" )
                    .removeAttr( "aria-haspopup" )
                    .children().each( function() {
                        var elem = $( this );
                        if ( elem.data( "ui-menu-submenu-carat" ) ) {
                            elem.remove();
                        }
                    });
                
                // Destroy menu dividers
                this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
            },
            
            _keydown: function( event ) {
                /*jshint maxcomplexity:20*/
                var match, prev, character, skip, regex,
                    preventDefault = true;
                
                function escape( value ) {
                    return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
                }
                
                switch ( event.keyCode ) {
                    case $.ui.keyCode.PAGE_UP:
                        this.previousPage( event );
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        this.nextPage( event );
                        break;
                    case $.ui.keyCode.HOME:
                        this._move( "first", "first", event );
                        break;
                    case $.ui.keyCode.END:
                        this._move( "last", "last", event );
                        break;
                    case $.ui.keyCode.UP:
                        this.previous( event );
                        break;
                    case $.ui.keyCode.DOWN:
                        this.next( event );
                        break;
                    case $.ui.keyCode.LEFT:
                        this.collapse( event );
                        break;
                    case $.ui.keyCode.RIGHT:
                        if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
                            this.expand( event );
                        }
                        break;
                    case $.ui.keyCode.ENTER:
                    case $.ui.keyCode.SPACE:
                        this._activate( event );
                        break;
                    case $.ui.keyCode.ESCAPE:
                        this.collapse( event );
                        break;
                    default:
                        preventDefault = false;
                        prev = this.previousFilter || "";
                        character = String.fromCharCode( event.keyCode );
                        skip = false;
                        
                        clearTimeout( this.filterTimer );
                        
                        if ( character === prev ) {
                            skip = true;
                        } else {
                            character = prev + character;
                        }
                        
                        regex = new RegExp( "^" + escape( character ), "i" );
                        match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
                            return regex.test( $( this ).children( "a" ).text() );
                        });
                        match = skip && match.index( this.active.next() ) !== -1 ?
                            this.active.nextAll( ".ui-menu-item" ) :
                            match;
                        
                        // If no matches on the current filter, reset to the last character pressed
                        // to move down the menu to the first item that starts with that character
                        if ( !match.length ) {
                            character = String.fromCharCode( event.keyCode );
                            regex = new RegExp( "^" + escape( character ), "i" );
                            match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
                                return regex.test( $( this ).children( "a" ).text() );
                            });
                        }
                        
                        if ( match.length ) {
                            this.focus( event, match );
                            if ( match.length > 1 ) {
                                this.previousFilter = character;
                                this.filterTimer = this._delay(function() {
                                    delete this.previousFilter;
                                }, 1000 );
                            } else {
                                delete this.previousFilter;
                            }
                        } else {
                            delete this.previousFilter;
                        }
                }
                
                if ( preventDefault ) {
                    event.preventDefault();
                }
            },
            
            _activate: function( event ) {
                if ( !this.active.is( ".ui-state-disabled" ) ) {
                    if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
                        this.expand( event );
                    } else {
                        this.select( event );
                    }
                }
            },
            
            refresh: function() {
                var menus,
                    icon = this.options.icons.submenu,
                    submenus = this.element.find( this.options.menus );
                
                // Initialize nested menus
                submenus.filter( ":not(.ui-menu)" )
                    .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
                    .hide()
                    .attr({
                        role: this.options.role,
                        "aria-hidden": "true",
                        "aria-expanded": "false"
                    })
                    .each(function() {
                        var menu = $( this ),
                            item = menu.prev( "a" ),
                            submenuCarat = $( "<span>" )
                                .addClass( "ui-menu-icon ui-icon " + icon )
                                .data( "ui-menu-submenu-carat", true );
                        
                        item
                            .attr( "aria-haspopup", "true" )
                            .prepend( submenuCarat );
                        menu.attr( "aria-labelledby", item.attr( "id" ) );
                    });
                
                menus = submenus.add( this.element );
                
                // Don't refresh list items that are already adapted
                menus.children( ":not(.ui-menu-item):has(a)" )
                    .addClass( "ui-menu-item" )
                    .attr( "role", "presentation" )
                    .children( "a" )
                    .uniqueId()
                    .addClass( "ui-corner-all" )
                    .attr({
                        tabIndex: -1,
                        role: this._itemRole()
                    });
                
                // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
                menus.children( ":not(.ui-menu-item)" ).each(function() {
                    var item = $( this );
                    // hyphen, em dash, en dash
                    if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
                        item.addClass( "ui-widget-content ui-menu-divider" );
                    }
                });
                
                // Add aria-disabled attribute to any disabled menu item
                menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );
                
                // If the active item has been removed, blur the menu
                if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
                    this.blur();
                }
            },
            
            _itemRole: function() {
                return {
                    menu: "menuitem",
                    listbox: "option"
                }[ this.options.role ];
            },
            
            _setOption: function( key, value ) {
                if ( key === "icons" ) {
                    this.element.find( ".ui-menu-icon" )
                        .removeClass( this.options.icons.submenu )
                        .addClass( value.submenu );
                }
                this._super( key, value );
            },
            
            focus: function( event, item ) {
                var nested, focused;
                this.blur( event, event && event.type === "focus" );
                
                this._scrollIntoView( item );
                
                this.active = item.first();
                focused = this.active.children( "a" ).addClass( "ui-state-focus" );
                // Only update aria-activedescendant if there's a role
                // otherwise we assume focus is managed elsewhere
                if ( this.options.role ) {
                    this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
                }
                
                // Highlight active parent menu item, if any
                this.active
                    .parent()
                    .closest( ".ui-menu-item" )
                    .children( "a:first" )
                    .addClass( "ui-state-active" );
                
                if ( event && event.type === "keydown" ) {
                    this._close();
                } else {
                    this.timer = this._delay(function() {
                        this._close();
                    }, this.delay );
                }
                
                nested = item.children( ".ui-menu" );
                if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
                    this._startOpening(nested);
                }
                this.activeMenu = item.parent();
                
                this._trigger( "focus", event, { item: item } );
            },
            
            _scrollIntoView: function( item ) {
                var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
                if ( this._hasScroll() ) {
                    borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
                    paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
                    offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                    scroll = this.activeMenu.scrollTop();
                    elementHeight = this.activeMenu.height();
                    itemHeight = item.height();
                    
                    if ( offset < 0 ) {
                        this.activeMenu.scrollTop( scroll + offset );
                    } else if ( offset + itemHeight > elementHeight ) {
                        this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
                    }
                }
            },
            
            blur: function( event, fromFocus ) {
                if ( !fromFocus ) {
                    clearTimeout( this.timer );
                }
                
                if ( !this.active ) {
                    return;
                }
                
                this.active.children( "a" ).removeClass( "ui-state-focus" );
                this.active = null;
                
                this._trigger( "blur", event, { item: this.active } );
            },
            
            _startOpening: function( submenu ) {
                clearTimeout( this.timer );
                
                // Don't open if already open fixes a Firefox bug that caused a .5 pixel
                // shift in the submenu position when mousing over the carat icon
                if ( submenu.attr( "aria-hidden" ) !== "true" ) {
                    return;
                }
                
                this.timer = this._delay(function() {
                    this._close();
                    this._open( submenu );
                }, this.delay );
            },
            
            _open: function( submenu ) {
                var position = $.extend({
                    of: this.active
                }, this.options.position );
                
                clearTimeout( this.timer );
                this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
                    .hide()
                    .attr( "aria-hidden", "true" );
                
                submenu
                    .show()
                    .removeAttr( "aria-hidden" )
                    .attr( "aria-expanded", "true" )
                    .position( position );
            },
            
            collapseAll: function( event, all ) {
                clearTimeout( this.timer );
                this.timer = this._delay(function() {
                    // If we were passed an event, look for the submenu that contains the event
                    var currentMenu = all ? this.element :
                        $( event && event.target ).closest( this.element.find( ".ui-menu" ) );
                    
                    // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                    if ( !currentMenu.length ) {
                        currentMenu = this.element;
                    }
                    
                    this._close( currentMenu );
                    
                    this.blur( event );
                    this.activeMenu = currentMenu;
                }, this.delay );
            },
            
            // With no arguments, closes the currently active menu - if nothing is active
            // it closes all menus.  If passed an argument, it will search for menus BELOW
            _close: function( startMenu ) {
                if ( !startMenu ) {
                    startMenu = this.active ? this.active.parent() : this.element;
                }
                
                startMenu
                    .find( ".ui-menu" )
                    .hide()
                    .attr( "aria-hidden", "true" )
                    .attr( "aria-expanded", "false" )
                    .end()
                    .find( "a.ui-state-active" )
                    .removeClass( "ui-state-active" );
            },
            
            collapse: function( event ) {
                var newItem = this.active &&
                    this.active.parent().closest( ".ui-menu-item", this.element );
                if ( newItem && newItem.length ) {
                    this._close();
                    this.focus( event, newItem );
                }
            },
            
            expand: function( event ) {
                var newItem = this.active &&
                    this.active
                        .children( ".ui-menu " )
                        .children( ".ui-menu-item" )
                        .first();
                
                if ( newItem && newItem.length ) {
                    this._open( newItem.parent() );
                    
                    // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                    this._delay(function() {
                        this.focus( event, newItem );
                    });
                }
            },
            
            next: function( event ) {
                this._move( "next", "first", event );
            },
            
            previous: function( event ) {
                this._move( "prev", "last", event );
            },
            
            isFirstItem: function() {
                return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
            },
            
            isLastItem: function() {
                return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
            },
            
            _move: function( direction, filter, event ) {
                var next;
                if ( this.active ) {
                    if ( direction === "first" || direction === "last" ) {
                        next = this.active
                            [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
                            .eq( -1 );
                    } else {
                        next = this.active
                            [ direction + "All" ]( ".ui-menu-item" )
                            .eq( 0 );
                    }
                }
                if ( !next || !next.length || !this.active ) {
                    next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
                }
                
                this.focus( event, next );
            },
            
            nextPage: function( event ) {
                var item, base, height;
                
                if ( !this.active ) {
                    this.next( event );
                    return;
                }
                if ( this.isLastItem() ) {
                    return;
                }
                if ( this._hasScroll() ) {
                    base = this.active.offset().top;
                    height = this.element.height();
                    this.active.nextAll( ".ui-menu-item" ).each(function() {
                        item = $( this );
                        return item.offset().top - base - height < 0;
                    });
                    
                    this.focus( event, item );
                } else {
                    this.focus( event, this.activeMenu.children( ".ui-menu-item" )
                        [ !this.active ? "first" : "last" ]() );
                }
            },
            
            previousPage: function( event ) {
                var item, base, height;
                if ( !this.active ) {
                    this.next( event );
                    return;
                }
                if ( this.isFirstItem() ) {
                    return;
                }
                if ( this._hasScroll() ) {
                    base = this.active.offset().top;
                    height = this.element.height();
                    this.active.prevAll( ".ui-menu-item" ).each(function() {
                        item = $( this );
                        return item.offset().top - base + height > 0;
                    });
                    
                    this.focus( event, item );
                } else {
                    this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
                }
            },
            
            _hasScroll: function() {
                return this.element.outerHeight() < this.element.prop( "scrollHeight" );
            },
            
            select: function( event ) {
                // TODO: It should never be possible to not have an active item at this
                // point, but the tests don't trigger mouseenter before click.
                this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
                var ui = { item: this.active };
                if ( !this.active.has( ".ui-menu" ).length ) {
                    this.collapseAll( event, true );
                }
                this._trigger( "select", event, ui );
            }
        });
        
    }( jQuery ));
    
    (function( $, undefined ) {
        
        $.ui = $.ui || {};
        
        var cachedScrollbarWidth,
            max = Math.max,
            abs = Math.abs,
            round = Math.round,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;
        
        function getOffsets( offsets, width, height ) {
            return [
                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
            ];
        }
        
        function parseCss( element, property ) {
            return parseInt( $.css( element, property ), 10 ) || 0;
        }
        
        function getDimensions( elem ) {
            var raw = elem[0];
            if ( raw.nodeType === 9 ) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: 0, left: 0 }
                };
            }
            if ( $.isWindow( raw ) ) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
                };
            }
            if ( raw.preventDefault ) {
                return {
                    width: 0,
                    height: 0,
                    offset: { top: raw.pageY, left: raw.pageX }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }
        
        $.position = {
            scrollbarWidth: function() {
                if ( cachedScrollbarWidth !== undefined ) {
                    return cachedScrollbarWidth;
                }
                var w1, w2,
                    div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
                    innerDiv = div.children()[0];
                
                $( "body" ).append( div );
                w1 = innerDiv.offsetWidth;
                div.css( "overflow", "scroll" );
                
                w2 = innerDiv.offsetWidth;
                
                if ( w1 === w2 ) {
                    w2 = div[0].clientWidth;
                }
                
                div.remove();
                
                return (cachedScrollbarWidth = w1 - w2);
            },
            getScrollInfo: function( within ) {
                var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
                    overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
                    hasOverflowX = overflowX === "scroll" ||
                        ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
                    hasOverflowY = overflowY === "scroll" ||
                        ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function( element ) {
                var withinElement = $( element || window ),
                    isWindow = $.isWindow( withinElement[0] );
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    offset: withinElement.offset() || { left: 0, top: 0 },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: isWindow ? withinElement.width() : withinElement.outerWidth(),
                    height: isWindow ? withinElement.height() : withinElement.outerHeight()
                };
            }
        };
        
        $.fn.position = function( options ) {
            if ( !options || !options.of ) {
                return _position.apply( this, arguments );
            }
            
            // make a copy, we don't want to modify arguments
            options = $.extend( {}, options );
            
            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                target = $( options.of ),
                within = $.position.getWithinInfo( options.within ),
                scrollInfo = $.position.getScrollInfo( within ),
                collision = ( options.collision || "flip" ).split( " " ),
                offsets = {};
            
            dimensions = getDimensions( target );
            if ( target[0].preventDefault ) {
                // force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;
            // clone to reuse original targetOffset later
            basePosition = $.extend( {}, targetOffset );
            
            // force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each( [ "my", "at" ], function() {
                var pos = ( options[ this ] || "" ).split( " " ),
                    horizontalOffset,
                    verticalOffset;
                
                if ( pos.length === 1) {
                    pos = rhorizontal.test( pos[ 0 ] ) ?
                        pos.concat( [ "center" ] ) :
                        rvertical.test( pos[ 0 ] ) ?
                            [ "center" ].concat( pos ) :
                            [ "center", "center" ];
                }
                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
                
                // calculate offsets
                horizontalOffset = roffset.exec( pos[ 0 ] );
                verticalOffset = roffset.exec( pos[ 1 ] );
                offsets[ this ] = [
                    horizontalOffset ? horizontalOffset[ 0 ] : 0,
                    verticalOffset ? verticalOffset[ 0 ] : 0
                ];
                
                // reduce to just the positions without the offsets
                options[ this ] = [
                    rposition.exec( pos[ 0 ] )[ 0 ],
                    rposition.exec( pos[ 1 ] )[ 0 ]
                ];
            });
            
            // normalize collision option
            if ( collision.length === 1 ) {
                collision[ 1 ] = collision[ 0 ];
            }
            
            if ( options.at[ 0 ] === "right" ) {
                basePosition.left += targetWidth;
            } else if ( options.at[ 0 ] === "center" ) {
                basePosition.left += targetWidth / 2;
            }
            
            if ( options.at[ 1 ] === "bottom" ) {
                basePosition.top += targetHeight;
            } else if ( options.at[ 1 ] === "center" ) {
                basePosition.top += targetHeight / 2;
            }
            
            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
            basePosition.left += atOffset[ 0 ];
            basePosition.top += atOffset[ 1 ];
            
            return this.each(function() {
                var collisionPosition, using,
                    elem = $( this ),
                    elemWidth = elem.outerWidth(),
                    elemHeight = elem.outerHeight(),
                    marginLeft = parseCss( this, "marginLeft" ),
                    marginTop = parseCss( this, "marginTop" ),
                    collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
                    collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
                    position = $.extend( {}, basePosition ),
                    myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
                
                if ( options.my[ 0 ] === "right" ) {
                    position.left -= elemWidth;
                } else if ( options.my[ 0 ] === "center" ) {
                    position.left -= elemWidth / 2;
                }
                
                if ( options.my[ 1 ] === "bottom" ) {
                    position.top -= elemHeight;
                } else if ( options.my[ 1 ] === "center" ) {
                    position.top -= elemHeight / 2;
                }
                
                position.left += myOffset[ 0 ];
                position.top += myOffset[ 1 ];
                
                // if the browser doesn't support fractions, then round for consistent results
                if ( !$.support.offsetFractions ) {
                    position.left = round( position.left );
                    position.top = round( position.top );
                }
                
                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };
                
                $.each( [ "left", "top" ], function( i, dir ) {
                    if ( $.ui.position[ collision[ i ] ] ) {
                        $.ui.position[ collision[ i ] ][ dir ]( position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem : elem
                        });
                    }
                });
                
                if ( options.using ) {
                    // adds feedback as second argument to using callback, if present
                    using = function( props ) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                            feedback.horizontal = "center";
                        }
                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                            feedback.vertical = "middle";
                        }
                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call( this, props, feedback );
                    };
                }
                
                elem.offset( $.extend( position, { using: using } ) );
            });
        };
        
        $.ui.position = {
            fit: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;
                    
                    // element is wider than within
                    if ( data.collisionWidth > outerWidth ) {
                        // element is initially over the left side of within
                        if ( overLeft > 0 && overRight <= 0 ) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                            position.left += overLeft - newOverRight;
                            // element is initially over right side of within
                        } else if ( overRight > 0 && overLeft <= 0 ) {
                            position.left = withinOffset;
                            // element is initially over both left and right sides of within
                        } else {
                            if ( overLeft > overRight ) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }
                        // too far left -> align with left edge
                    } else if ( overLeft > 0 ) {
                        position.left += overLeft;
                        // too far right -> align with right edge
                    } else if ( overRight > 0 ) {
                        position.left -= overRight;
                        // adjust based on position and margin
                    } else {
                        position.left = max( position.left - collisionPosLeft, position.left );
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;
                    
                    // element is taller than within
                    if ( data.collisionHeight > outerHeight ) {
                        // element is initially over the top of within
                        if ( overTop > 0 && overBottom <= 0 ) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                            position.top += overTop - newOverBottom;
                            // element is initially over bottom of within
                        } else if ( overBottom > 0 && overTop <= 0 ) {
                            position.top = withinOffset;
                            // element is initially over both top and bottom of within
                        } else {
                            if ( overTop > overBottom ) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }
                        // too far up -> align with top
                    } else if ( overTop > 0 ) {
                        position.top += overTop;
                        // too far down -> align with bottom edge
                    } else if ( overBottom > 0 ) {
                        position.top -= overBottom;
                        // adjust based on position and margin
                    } else {
                        position.top = max( position.top - collisionPosTop, position.top );
                    }
                }
            },
            flip: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[ 0 ] === "left" ?
                            -data.elemWidth :
                            data.my[ 0 ] === "right" ?
                                data.elemWidth :
                                0,
                        atOffset = data.at[ 0 ] === "left" ?
                            data.targetWidth :
                            data.at[ 0 ] === "right" ?
                                -data.targetWidth :
                                0,
                        offset = -2 * data.offset[ 0 ],
                        newOverRight,
                        newOverLeft;
                    
                    if ( overLeft < 0 ) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                    else if ( overRight > 0 ) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[ 1 ] === "top",
                        myOffset = top ?
                            -data.elemHeight :
                            data.my[ 1 ] === "bottom" ?
                                data.elemHeight :
                                0,
                        atOffset = data.at[ 1 ] === "top" ?
                            data.targetHeight :
                            data.at[ 1 ] === "bottom" ?
                                -data.targetHeight :
                                0,
                        offset = -2 * data.offset[ 1 ],
                        newOverTop,
                        newOverBottom;
                    if ( overTop < 0 ) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                        if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                    else if ( overBottom > 0 ) {
                        newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                        if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply( this, arguments );
                    $.ui.position.fit.left.apply( this, arguments );
                },
                top: function() {
                    $.ui.position.flip.top.apply( this, arguments );
                    $.ui.position.fit.top.apply( this, arguments );
                }
            }
        };
        
        // fraction support test
        (function () {
            var testElement, testElementParent, testElementStyle, offsetLeft, i,
                body = document.getElementsByTagName( "body" )[ 0 ],
                div = document.createElement( "div" );
            
            //Create a "fake body" for testing based on method used in jQuery.support
            testElement = document.createElement( body ? "div" : "body" );
            testElementStyle = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            };
            if ( body ) {
                $.extend( testElementStyle, {
                    position: "absolute",
                    left: "-1000px",
                    top: "-1000px"
                });
            }
            for ( i in testElementStyle ) {
                testElement.style[ i ] = testElementStyle[ i ];
            }
            testElement.appendChild( div );
            testElementParent = body || document.documentElement;
            testElementParent.insertBefore( testElement, testElementParent.firstChild );
            
            div.style.cssText = "position: absolute; left: 10.7432222px;";
            
            offsetLeft = $( div ).offset().left;
            $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
            
            testElement.innerHTML = "";
            testElementParent.removeChild( testElement );
        })();
        
    }( jQuery ) );
    
    (function( $, undefined ) {
        
        $.widget( "ui.progressbar", {
            version: "1.10.3",
            options: {
                max: 100,
                value: 0,
                
                change: null,
                complete: null
            },
            
            min: 0,
            
            _create: function() {
                // Constrain initial value
                this.oldValue = this.options.value = this._constrainedValue();
                
                this.element
                    .addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
                    .attr({
                        // Only set static values, aria-valuenow and aria-valuemax are
                        // set inside _refreshValue()
                        role: "progressbar",
                        "aria-valuemin": this.min
                    });
                
                this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
                    .appendTo( this.element );
                
                this._refreshValue();
            },
            
            _destroy: function() {
                this.element
                    .removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
                    .removeAttr( "role" )
                    .removeAttr( "aria-valuemin" )
                    .removeAttr( "aria-valuemax" )
                    .removeAttr( "aria-valuenow" );
                
                this.valueDiv.remove();
            },
            
            value: function( newValue ) {
                if ( newValue === undefined ) {
                    return this.options.value;
                }
                
                this.options.value = this._constrainedValue( newValue );
                this._refreshValue();
            },
            
            _constrainedValue: function( newValue ) {
                if ( newValue === undefined ) {
                    newValue = this.options.value;
                }
                
                this.indeterminate = newValue === false;
                
                // sanitize value
                if ( typeof newValue !== "number" ) {
                    newValue = 0;
                }
                
                return this.indeterminate ? false :
                    Math.min( this.options.max, Math.max( this.min, newValue ) );
            },
            
            _setOptions: function( options ) {
                // Ensure "value" option is set after other values (like max)
                var value = options.value;
                delete options.value;
                
                this._super( options );
                
                this.options.value = this._constrainedValue( value );
                this._refreshValue();
            },
            
            _setOption: function( key, value ) {
                if ( key === "max" ) {
                    // Don't allow a max less than min
                    value = Math.max( this.min, value );
                }
                
                this._super( key, value );
            },
            
            _percentage: function() {
                return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
            },
            
            _refreshValue: function() {
                var value = this.options.value,
                    percentage = this._percentage();
                
                this.valueDiv
                    .toggle( this.indeterminate || value > this.min )
                    .toggleClass( "ui-corner-right", value === this.options.max )
                    .width( percentage.toFixed(0) + "%" );
                
                this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );
                
                if ( this.indeterminate ) {
                    this.element.removeAttr( "aria-valuenow" );
                    if ( !this.overlayDiv ) {
                        this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
                    }
                } else {
                    this.element.attr({
                        "aria-valuemax": this.options.max,
                        "aria-valuenow": value
                    });
                    if ( this.overlayDiv ) {
                        this.overlayDiv.remove();
                        this.overlayDiv = null;
                    }
                }
                
                if ( this.oldValue !== value ) {
                    this.oldValue = value;
                    this._trigger( "change" );
                }
                if ( value === this.options.max ) {
                    this._trigger( "complete" );
                }
            }
        });
        
    })( jQuery );
    
    (function( $, undefined ) {
        
        // number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        var numPages = 5;
        
        $.widget( "ui.slider", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "slide",
            
            options: {
                animate: false,
                distance: 0,
                max: 100,
                min: 0,
                orientation: "horizontal",
                range: false,
                step: 1,
                value: 0,
                values: null,
                
                // callbacks
                change: null,
                slide: null,
                start: null,
                stop: null
            },
            
            _create: function() {
                this._keySliding = false;
                this._mouseSliding = false;
                this._animateOff = true;
                this._handleIndex = null;
                this._detectOrientation();
                this._mouseInit();
                
                this.element
                    .addClass( "ui-slider" +
                    " ui-slider-" + this.orientation +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all");
                
                this._refresh();
                this._setOption( "disabled", this.options.disabled );
                
                this._animateOff = false;
            },
            
            _refresh: function() {
                this._createRange();
                this._createHandles();
                this._setupEvents();
                this._refreshValue();
            },
            
            _createHandles: function() {
                var i, handleCount,
                    options = this.options,
                    existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
                    handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
                    handles = [];
                
                handleCount = ( options.values && options.values.length ) || 1;
                
                if ( existingHandles.length > handleCount ) {
                    existingHandles.slice( handleCount ).remove();
                    existingHandles = existingHandles.slice( 0, handleCount );
                }
                
                for ( i = existingHandles.length; i < handleCount; i++ ) {
                    handles.push( handle );
                }
                
                this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );
                
                this.handle = this.handles.eq( 0 );
                
                this.handles.each(function( i ) {
                    $( this ).data( "ui-slider-handle-index", i );
                });
            },
            
            _createRange: function() {
                var options = this.options,
                    classes = "";
                
                if ( options.range ) {
                    if ( options.range === true ) {
                        if ( !options.values ) {
                            options.values = [ this._valueMin(), this._valueMin() ];
                        } else if ( options.values.length && options.values.length !== 2 ) {
                            options.values = [ options.values[0], options.values[0] ];
                        } else if ( $.isArray( options.values ) ) {
                            options.values = options.values.slice(0);
                        }
                    }
                    
                    if ( !this.range || !this.range.length ) {
                        this.range = $( "<div></div>" )
                            .appendTo( this.element );
                        
                        classes = "ui-slider-range" +
                                // note: this isn't the most fittingly semantic framework class for this element,
                                // but worked best visually with a variety of themes
                            " ui-widget-header ui-corner-all";
                    } else {
                        this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
                            // Handle range switching from true to min/max
                            .css({
                                "left": "",
                                "bottom": ""
                            });
                    }
                    
                    this.range.addClass( classes +
                        ( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
                } else {
                    this.range = $([]);
                }
            },
            
            _setupEvents: function() {
                var elements = this.handles.add( this.range ).filter( "a" );
                this._off( elements );
                this._on( elements, this._handleEvents );
                this._hoverable( elements );
                this._focusable( elements );
            },
            
            _destroy: function() {
                this.handles.remove();
                this.range.remove();
                
                this.element
                    .removeClass( "ui-slider" +
                    " ui-slider-horizontal" +
                    " ui-slider-vertical" +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all" );
                
                this._mouseDestroy();
            },
            
            _mouseCapture: function( event ) {
                var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                    that = this,
                    o = this.options;
                
                if ( o.disabled ) {
                    return false;
                }
                
                this.elementSize = {
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight()
                };
                this.elementOffset = this.element.offset();
                
                position = { x: event.pageX, y: event.pageY };
                normValue = this._normValueFromMouse( position );
                distance = this._valueMax() - this._valueMin() + 1;
                this.handles.each(function( i ) {
                    var thisDistance = Math.abs( normValue - that.values(i) );
                    if (( distance > thisDistance ) ||
                        ( distance === thisDistance &&
                        (i === that._lastChangedValue || that.values(i) === o.min ))) {
                        distance = thisDistance;
                        closestHandle = $( this );
                        index = i;
                    }
                });
                
                allowed = this._start( event, index );
                if ( allowed === false ) {
                    return false;
                }
                this._mouseSliding = true;
                
                this._handleIndex = index;
                
                closestHandle
                    .addClass( "ui-state-active" )
                    .focus();
                
                offset = closestHandle.offset();
                mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
                this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
                    left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
                    top: event.pageY - offset.top -
                    ( closestHandle.height() / 2 ) -
                    ( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
                    ( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
                    ( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
                };
                
                if ( !this.handles.hasClass( "ui-state-hover" ) ) {
                    this._slide( event, index, normValue );
                }
                this._animateOff = true;
                return true;
            },
            
            _mouseStart: function() {
                return true;
            },
            
            _mouseDrag: function( event ) {
                var position = { x: event.pageX, y: event.pageY },
                    normValue = this._normValueFromMouse( position );
                
                this._slide( event, this._handleIndex, normValue );
                
                return false;
            },
            
            _mouseStop: function( event ) {
                this.handles.removeClass( "ui-state-active" );
                this._mouseSliding = false;
                
                this._stop( event, this._handleIndex );
                this._change( event, this._handleIndex );
                
                this._handleIndex = null;
                this._clickOffset = null;
                this._animateOff = false;
                
                return false;
            },
            
            _detectOrientation: function() {
                this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
            },
            
            _normValueFromMouse: function( position ) {
                var pixelTotal,
                    pixelMouse,
                    percentMouse,
                    valueTotal,
                    valueMouse;
                
                if ( this.orientation === "horizontal" ) {
                    pixelTotal = this.elementSize.width;
                    pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
                } else {
                    pixelTotal = this.elementSize.height;
                    pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
                }
                
                percentMouse = ( pixelMouse / pixelTotal );
                if ( percentMouse > 1 ) {
                    percentMouse = 1;
                }
                if ( percentMouse < 0 ) {
                    percentMouse = 0;
                }
                if ( this.orientation === "vertical" ) {
                    percentMouse = 1 - percentMouse;
                }
                
                valueTotal = this._valueMax() - this._valueMin();
                valueMouse = this._valueMin() + percentMouse * valueTotal;
                
                return this._trimAlignValue( valueMouse );
            },
            
            _start: function( event, index ) {
                var uiHash = {
                    handle: this.handles[ index ],
                    value: this.value()
                };
                if ( this.options.values && this.options.values.length ) {
                    uiHash.value = this.values( index );
                    uiHash.values = this.values();
                }
                return this._trigger( "start", event, uiHash );
            },
            
            _slide: function( event, index, newVal ) {
                var otherVal,
                    newValues,
                    allowed;
                
                if ( this.options.values && this.options.values.length ) {
                    otherVal = this.values( index ? 0 : 1 );
                    
                    if ( ( this.options.values.length === 2 && this.options.range === true ) &&
                        ( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
                    ) {
                        newVal = otherVal;
                    }
                    
                    if ( newVal !== this.values( index ) ) {
                        newValues = this.values();
                        newValues[ index ] = newVal;
                        // A slide can be canceled by returning false from the slide callback
                        allowed = this._trigger( "slide", event, {
                            handle: this.handles[ index ],
                            value: newVal,
                            values: newValues
                        } );
                        otherVal = this.values( index ? 0 : 1 );
                        if ( allowed !== false ) {
                            this.values( index, newVal, true );
                        }
                    }
                } else {
                    if ( newVal !== this.value() ) {
                        // A slide can be canceled by returning false from the slide callback
                        allowed = this._trigger( "slide", event, {
                            handle: this.handles[ index ],
                            value: newVal
                        } );
                        if ( allowed !== false ) {
                            this.value( newVal );
                        }
                    }
                }
            },
            
            _stop: function( event, index ) {
                var uiHash = {
                    handle: this.handles[ index ],
                    value: this.value()
                };
                if ( this.options.values && this.options.values.length ) {
                    uiHash.value = this.values( index );
                    uiHash.values = this.values();
                }
                
                this._trigger( "stop", event, uiHash );
            },
            
            _change: function( event, index ) {
                if ( !this._keySliding && !this._mouseSliding ) {
                    var uiHash = {
                        handle: this.handles[ index ],
                        value: this.value()
                    };
                    if ( this.options.values && this.options.values.length ) {
                        uiHash.value = this.values( index );
                        uiHash.values = this.values();
                    }
                    
                    //store the last changed value index for reference when handles overlap
                    this._lastChangedValue = index;
                    
                    this._trigger( "change", event, uiHash );
                }
            },
            
            value: function( newValue ) {
                if ( arguments.length ) {
                    this.options.value = this._trimAlignValue( newValue );
                    this._refreshValue();
                    this._change( null, 0 );
                    return;
                }
                
                return this._value();
            },
            
            values: function( index, newValue ) {
                var vals,
                    newValues,
                    i;
                
                if ( arguments.length > 1 ) {
                    this.options.values[ index ] = this._trimAlignValue( newValue );
                    this._refreshValue();
                    this._change( null, index );
                    return;
                }
                
                if ( arguments.length ) {
                    if ( $.isArray( arguments[ 0 ] ) ) {
                        vals = this.options.values;
                        newValues = arguments[ 0 ];
                        for ( i = 0; i < vals.length; i += 1 ) {
                            vals[ i ] = this._trimAlignValue( newValues[ i ] );
                            this._change( null, i );
                        }
                        this._refreshValue();
                    } else {
                        if ( this.options.values && this.options.values.length ) {
                            return this._values( index );
                        } else {
                            return this.value();
                        }
                    }
                } else {
                    return this._values();
                }
            },
            
            _setOption: function( key, value ) {
                var i,
                    valsLength = 0;
                
                if ( key === "range" && this.options.range === true ) {
                    if ( value === "min" ) {
                        this.options.value = this._values( 0 );
                        this.options.values = null;
                    } else if ( value === "max" ) {
                        this.options.value = this._values( this.options.values.length-1 );
                        this.options.values = null;
                    }
                }
                
                if ( $.isArray( this.options.values ) ) {
                    valsLength = this.options.values.length;
                }
                
                $.Widget.prototype._setOption.apply( this, arguments );
                
                switch ( key ) {
                    case "orientation":
                        this._detectOrientation();
                        this.element
                            .removeClass( "ui-slider-horizontal ui-slider-vertical" )
                            .addClass( "ui-slider-" + this.orientation );
                        this._refreshValue();
                        break;
                    case "value":
                        this._animateOff = true;
                        this._refreshValue();
                        this._change( null, 0 );
                        this._animateOff = false;
                        break;
                    case "values":
                        this._animateOff = true;
                        this._refreshValue();
                        for ( i = 0; i < valsLength; i += 1 ) {
                            this._change( null, i );
                        }
                        this._animateOff = false;
                        break;
                    case "min":
                    case "max":
                        this._animateOff = true;
                        this._refreshValue();
                        this._animateOff = false;
                        break;
                    case "range":
                        this._animateOff = true;
                        this._refresh();
                        this._animateOff = false;
                        break;
                }
            },
            
            //internal value getter
            // _value() returns value trimmed by min and max, aligned by step
            _value: function() {
                var val = this.options.value;
                val = this._trimAlignValue( val );
                
                return val;
            },
            
            //internal values getter
            // _values() returns array of values trimmed by min and max, aligned by step
            // _values( index ) returns single value trimmed by min and max, aligned by step
            _values: function( index ) {
                var val,
                    vals,
                    i;
                
                if ( arguments.length ) {
                    val = this.options.values[ index ];
                    val = this._trimAlignValue( val );
                    
                    return val;
                } else if ( this.options.values && this.options.values.length ) {
                    // .slice() creates a copy of the array
                    // this copy gets trimmed by min and max and then returned
                    vals = this.options.values.slice();
                    for ( i = 0; i < vals.length; i+= 1) {
                        vals[ i ] = this._trimAlignValue( vals[ i ] );
                    }
                    
                    return vals;
                } else {
                    return [];
                }
            },
            
            // returns the step-aligned value that val is closest to, between (inclusive) min and max
            _trimAlignValue: function( val ) {
                if ( val <= this._valueMin() ) {
                    return this._valueMin();
                }
                if ( val >= this._valueMax() ) {
                    return this._valueMax();
                }
                var step = ( this.options.step > 0 ) ? this.options.step : 1,
                    valModStep = (val - this._valueMin()) % step,
                    alignValue = val - valModStep;
                
                if ( Math.abs(valModStep) * 2 >= step ) {
                    alignValue += ( valModStep > 0 ) ? step : ( -step );
                }
                
                // Since JavaScript has problems with large floats, round
                // the final value to 5 digits after the decimal point (see #4124)
                return parseFloat( alignValue.toFixed(5) );
            },
            
            _valueMin: function() {
                return this.options.min;
            },
            
            _valueMax: function() {
                return this.options.max;
            },
            
            _refreshValue: function() {
                var lastValPercent, valPercent, value, valueMin, valueMax,
                    oRange = this.options.range,
                    o = this.options,
                    that = this,
                    animate = ( !this._animateOff ) ? o.animate : false,
                    _set = {};
                
                if ( this.options.values && this.options.values.length ) {
                    this.handles.each(function( i ) {
                        valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
                        _set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                        $( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
                        if ( that.options.range === true ) {
                            if ( that.orientation === "horizontal" ) {
                                if ( i === 0 ) {
                                    that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
                                }
                                if ( i === 1 ) {
                                    that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                                }
                            } else {
                                if ( i === 0 ) {
                                    that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
                                }
                                if ( i === 1 ) {
                                    that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                                }
                            }
                        }
                        lastValPercent = valPercent;
                    });
                } else {
                    value = this.value();
                    valueMin = this._valueMin();
                    valueMax = this._valueMax();
                    valPercent = ( valueMax !== valueMin ) ?
                    ( value - valueMin ) / ( valueMax - valueMin ) * 100 :
                        0;
                    _set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                    this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
                    
                    if ( oRange === "min" && this.orientation === "horizontal" ) {
                        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
                    }
                    if ( oRange === "max" && this.orientation === "horizontal" ) {
                        this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
                    }
                    if ( oRange === "min" && this.orientation === "vertical" ) {
                        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
                    }
                    if ( oRange === "max" && this.orientation === "vertical" ) {
                        this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
                    }
                }
            },
            
            _handleEvents: {
                keydown: function( event ) {
                    /*jshint maxcomplexity:25*/
                    var allowed, curVal, newVal, step,
                        index = $( event.target ).data( "ui-slider-handle-index" );
                    
                    switch ( event.keyCode ) {
                        case $.ui.keyCode.HOME:
                        case $.ui.keyCode.END:
                        case $.ui.keyCode.PAGE_UP:
                        case $.ui.keyCode.PAGE_DOWN:
                        case $.ui.keyCode.UP:
                        case $.ui.keyCode.RIGHT:
                        case $.ui.keyCode.DOWN:
                        case $.ui.keyCode.LEFT:
                            event.preventDefault();
                            if ( !this._keySliding ) {
                                this._keySliding = true;
                                $( event.target ).addClass( "ui-state-active" );
                                allowed = this._start( event, index );
                                if ( allowed === false ) {
                                    return;
                                }
                            }
                            break;
                    }
                    
                    step = this.options.step;
                    if ( this.options.values && this.options.values.length ) {
                        curVal = newVal = this.values( index );
                    } else {
                        curVal = newVal = this.value();
                    }
                    
                    switch ( event.keyCode ) {
                        case $.ui.keyCode.HOME:
                            newVal = this._valueMin();
                            break;
                        case $.ui.keyCode.END:
                            newVal = this._valueMax();
                            break;
                        case $.ui.keyCode.PAGE_UP:
                            newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
                            break;
                        case $.ui.keyCode.PAGE_DOWN:
                            newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
                            break;
                        case $.ui.keyCode.UP:
                        case $.ui.keyCode.RIGHT:
                            if ( curVal === this._valueMax() ) {
                                return;
                            }
                            newVal = this._trimAlignValue( curVal + step );
                            break;
                        case $.ui.keyCode.DOWN:
                        case $.ui.keyCode.LEFT:
                            if ( curVal === this._valueMin() ) {
                                return;
                            }
                            newVal = this._trimAlignValue( curVal - step );
                            break;
                    }
                    
                    this._slide( event, index, newVal );
                },
                click: function( event ) {
                    event.preventDefault();
                },
                keyup: function( event ) {
                    var index = $( event.target ).data( "ui-slider-handle-index" );
                    
                    if ( this._keySliding ) {
                        this._keySliding = false;
                        this._stop( event, index );
                        this._change( event, index );
                        $( event.target ).removeClass( "ui-state-active" );
                    }
                }
            }
            
        });
        
    }(jQuery));
    
    (function( $ ) {
        
        function modifier( fn ) {
            return function() {
                var previous = this.element.val();
                fn.apply( this, arguments );
                this._refresh();
                if ( previous !== this.element.val() ) {
                    this._trigger( "change" );
                }
            };
        }
        
        $.widget( "ui.spinner", {
            version: "1.10.3",
            defaultElement: "<input>",
            widgetEventPrefix: "spin",
            options: {
                culture: null,
                icons: {
                    down: "ui-icon-triangle-1-s",
                    up: "ui-icon-triangle-1-n"
                },
                incremental: true,
                max: null,
                min: null,
                numberFormat: null,
                page: 10,
                step: 1,
                
                change: null,
                spin: null,
                start: null,
                stop: null
            },
            
            _create: function() {
                // handle string values that need to be parsed
                this._setOption( "max", this.options.max );
                this._setOption( "min", this.options.min );
                this._setOption( "step", this.options.step );
                
                // format the value, but don't constrain
                this._value( this.element.val(), true );
                
                this._draw();
                this._on( this._events );
                this._refresh();
                
                // turning off autocomplete prevents the browser from remembering the
                // value when navigating through history, so we re-enable autocomplete
                // if the page is unloaded before the widget is destroyed. #7790
                this._on( this.window, {
                    beforeunload: function() {
                        this.element.removeAttr( "autocomplete" );
                    }
                });
            },
            
            _getCreateOptions: function() {
                var options = {},
                    element = this.element;
                
                $.each( [ "min", "max", "step" ], function( i, option ) {
                    var value = element.attr( option );
                    if ( value !== undefined && value.length ) {
                        options[ option ] = value;
                    }
                });
                
                return options;
            },
            
            _events: {
                keydown: function( event ) {
                    if ( this._start( event ) && this._keydown( event ) ) {
                        event.preventDefault();
                    }
                },
                keyup: "_stop",
                focus: function() {
                    this.previous = this.element.val();
                },
                blur: function( event ) {
                    if ( this.cancelBlur ) {
                        delete this.cancelBlur;
                        return;
                    }
                    
                    this._stop();
                    this._refresh();
                    if ( this.previous !== this.element.val() ) {
                        this._trigger( "change", event );
                    }
                },
                mousewheel: function( event, delta ) {
                    if ( !delta ) {
                        return;
                    }
                    if ( !this.spinning && !this._start( event ) ) {
                        return false;
                    }
                    
                    this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
                    clearTimeout( this.mousewheelTimer );
                    this.mousewheelTimer = this._delay(function() {
                        if ( this.spinning ) {
                            this._stop( event );
                        }
                    }, 100 );
                    event.preventDefault();
                },
                "mousedown .ui-spinner-button": function( event ) {
                    var previous;
                    
                    // We never want the buttons to have focus; whenever the user is
                    // interacting with the spinner, the focus should be on the input.
                    // If the input is focused then this.previous is properly set from
                    // when the input first received focus. If the input is not focused
                    // then we need to set this.previous based on the value before spinning.
                    previous = this.element[0] === this.document[0].activeElement ?
                        this.previous : this.element.val();
                    function checkFocus() {
                        var isActive = this.element[0] === this.document[0].activeElement;
                        if ( !isActive ) {
                            this.element.focus();
                            this.previous = previous;
                            // support: IE
                            // IE sets focus asynchronously, so we need to check if focus
                            // moved off of the input because the user clicked on the button.
                            this._delay(function() {
                                this.previous = previous;
                            });
                        }
                    }
                    
                    // ensure focus is on (or stays on) the text field
                    event.preventDefault();
                    checkFocus.call( this );
                    
                    // support: IE
                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    // and check (again) if focus moved off of the input.
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;
                        checkFocus.call( this );
                    });
                    
                    if ( this._start( event ) === false ) {
                        return;
                    }
                    
                    this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
                },
                "mouseup .ui-spinner-button": "_stop",
                "mouseenter .ui-spinner-button": function( event ) {
                    // button will add ui-state-active if mouse was down while mouseleave and kept down
                    if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
                        return;
                    }
                    
                    if ( this._start( event ) === false ) {
                        return false;
                    }
                    this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
                },
                // TODO: do we really want to consider this a stop?
                // shouldn't we just stop the repeater and wait until mouseup before
                // we trigger the stop event?
                "mouseleave .ui-spinner-button": "_stop"
            },
            
            _draw: function() {
                var uiSpinner = this.uiSpinner = this.element
                    .addClass( "ui-spinner-input" )
                    .attr( "autocomplete", "off" )
                    .wrap( this._uiSpinnerHtml() )
                    .parent()
                    // add buttons
                    .append( this._buttonHtml() );
                
                this.element.attr( "role", "spinbutton" );
                
                // button bindings
                this.buttons = uiSpinner.find( ".ui-spinner-button" )
                    .attr( "tabIndex", -1 )
                    .button()
                    .removeClass( "ui-corner-all" );
                
                // IE 6 doesn't understand height: 50% for the buttons
                // unless the wrapper has an explicit height
                if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
                    uiSpinner.height() > 0 ) {
                    uiSpinner.height( uiSpinner.height() );
                }
                
                // disable spinner if element was already disabled
                if ( this.options.disabled ) {
                    this.disable();
                }
            },
            
            _keydown: function( event ) {
                var options = this.options,
                    keyCode = $.ui.keyCode;
                
                switch ( event.keyCode ) {
                    case keyCode.UP:
                        this._repeat( null, 1, event );
                        return true;
                    case keyCode.DOWN:
                        this._repeat( null, -1, event );
                        return true;
                    case keyCode.PAGE_UP:
                        this._repeat( null, options.page, event );
                        return true;
                    case keyCode.PAGE_DOWN:
                        this._repeat( null, -options.page, event );
                        return true;
                }
                
                return false;
            },
            
            _uiSpinnerHtml: function() {
                return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
            },
            
            _buttonHtml: function() {
                return "" +
                    "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
                    "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
                    "</a>" +
                    "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
                    "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
                    "</a>";
            },
            
            _start: function( event ) {
                if ( !this.spinning && this._trigger( "start", event ) === false ) {
                    return false;
                }
                
                if ( !this.counter ) {
                    this.counter = 1;
                }
                this.spinning = true;
                return true;
            },
            
            _repeat: function( i, steps, event ) {
                i = i || 500;
                
                clearTimeout( this.timer );
                this.timer = this._delay(function() {
                    this._repeat( 40, steps, event );
                }, i );
                
                this._spin( steps * this.options.step, event );
            },
            
            _spin: function( step, event ) {
                var value = this.value() || 0;
                
                if ( !this.counter ) {
                    this.counter = 1;
                }
                
                value = this._adjustValue( value + step * this._increment( this.counter ) );
                
                if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
                    this._value( value );
                    this.counter++;
                }
            },
            
            _increment: function( i ) {
                var incremental = this.options.incremental;
                
                if ( incremental ) {
                    return $.isFunction( incremental ) ?
                        incremental( i ) :
                        Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
                }
                
                return 1;
            },
            
            _precision: function() {
                var precision = this._precisionOf( this.options.step );
                if ( this.options.min !== null ) {
                    precision = Math.max( precision, this._precisionOf( this.options.min ) );
                }
                return precision;
            },
            
            _precisionOf: function( num ) {
                var str = num.toString(),
                    decimal = str.indexOf( "." );
                return decimal === -1 ? 0 : str.length - decimal - 1;
            },
            
            _adjustValue: function( value ) {
                var base, aboveMin,
                    options = this.options;
                
                // make sure we're at a valid step
                // - find out where we are relative to the base (min or 0)
                base = options.min !== null ? options.min : 0;
                aboveMin = value - base;
                // - round to the nearest step
                aboveMin = Math.round(aboveMin / options.step) * options.step;
                // - rounding is based on 0, so adjust back to our base
                value = base + aboveMin;
                
                // fix precision from bad JS floating point math
                value = parseFloat( value.toFixed( this._precision() ) );
                
                // clamp the value
                if ( options.max !== null && value > options.max) {
                    return options.max;
                }
                if ( options.min !== null && value < options.min ) {
                    return options.min;
                }
                
                return value;
            },
            
            _stop: function( event ) {
                if ( !this.spinning ) {
                    return;
                }
                
                clearTimeout( this.timer );
                clearTimeout( this.mousewheelTimer );
                this.counter = 0;
                this.spinning = false;
                this._trigger( "stop", event );
            },
            
            _setOption: function( key, value ) {
                if ( key === "culture" || key === "numberFormat" ) {
                    var prevValue = this._parse( this.element.val() );
                    this.options[ key ] = value;
                    this.element.val( this._format( prevValue ) );
                    return;
                }
                
                if ( key === "max" || key === "min" || key === "step" ) {
                    if ( typeof value === "string" ) {
                        value = this._parse( value );
                    }
                }
                if ( key === "icons" ) {
                    this.buttons.first().find( ".ui-icon" )
                        .removeClass( this.options.icons.up )
                        .addClass( value.up );
                    this.buttons.last().find( ".ui-icon" )
                        .removeClass( this.options.icons.down )
                        .addClass( value.down );
                }
                
                this._super( key, value );
                
                if ( key === "disabled" ) {
                    if ( value ) {
                        this.element.prop( "disabled", true );
                        this.buttons.button( "disable" );
                    } else {
                        this.element.prop( "disabled", false );
                        this.buttons.button( "enable" );
                    }
                }
            },
            
            _setOptions: modifier(function( options ) {
                this._super( options );
                this._value( this.element.val() );
            }),
            
            _parse: function( val ) {
                if ( typeof val === "string" && val !== "" ) {
                    val = window.Globalize && this.options.numberFormat ?
                        Globalize.parseFloat( val, 10, this.options.culture ) : +val;
                }
                return val === "" || isNaN( val ) ? null : val;
            },
            
            _format: function( value ) {
                if ( value === "" ) {
                    return "";
                }
                return window.Globalize && this.options.numberFormat ?
                    Globalize.format( value, this.options.numberFormat, this.options.culture ) :
                    value;
            },
            
            _refresh: function() {
                this.element.attr({
                    "aria-valuemin": this.options.min,
                    "aria-valuemax": this.options.max,
                    // TODO: what should we do with values that can't be parsed?
                    "aria-valuenow": this._parse( this.element.val() )
                });
            },
            
            // update the value without triggering change
            _value: function( value, allowAny ) {
                var parsed;
                if ( value !== "" ) {
                    parsed = this._parse( value );
                    if ( parsed !== null ) {
                        if ( !allowAny ) {
                            parsed = this._adjustValue( parsed );
                        }
                        value = this._format( parsed );
                    }
                }
                this.element.val( value );
                this._refresh();
            },
            
            _destroy: function() {
                this.element
                    .removeClass( "ui-spinner-input" )
                    .prop( "disabled", false )
                    .removeAttr( "autocomplete" )
                    .removeAttr( "role" )
                    .removeAttr( "aria-valuemin" )
                    .removeAttr( "aria-valuemax" )
                    .removeAttr( "aria-valuenow" );
                this.uiSpinner.replaceWith( this.element );
            },
            
            stepUp: modifier(function( steps ) {
                this._stepUp( steps );
            }),
            _stepUp: function( steps ) {
                if ( this._start() ) {
                    this._spin( (steps || 1) * this.options.step );
                    this._stop();
                }
            },
            
            stepDown: modifier(function( steps ) {
                this._stepDown( steps );
            }),
            _stepDown: function( steps ) {
                if ( this._start() ) {
                    this._spin( (steps || 1) * -this.options.step );
                    this._stop();
                }
            },
            
            pageUp: modifier(function( pages ) {
                this._stepUp( (pages || 1) * this.options.page );
            }),
            
            pageDown: modifier(function( pages ) {
                this._stepDown( (pages || 1) * this.options.page );
            }),
            
            value: function( newVal ) {
                if ( !arguments.length ) {
                    return this._parse( this.element.val() );
                }
                modifier( this._value ).call( this, newVal );
            },
            
            widget: function() {
                return this.uiSpinner;
            }
        });
        
    }( jQuery ) );
    
    (function( $, undefined ) {
        
        var tabId = 0,
            rhash = /#.*$/;
        
        function getNextTabId() {
            return ++tabId;
        }
        
        function isLocal( anchor ) {
            return anchor.hash.length > 1 &&
                decodeURIComponent( anchor.href.replace( rhash, "" ) ) ===
                decodeURIComponent( location.href.replace( rhash, "" ) );
        }
        
        $.widget( "ui.tabs", {
            version: "1.10.3",
            delay: 300,
            options: {
                active: null,
                collapsible: false,
                event: "click",
                heightStyle: "content",
                hide: null,
                show: null,
                
                // callbacks
                activate: null,
                beforeActivate: null,
                beforeLoad: null,
                load: null
            },
            
            _create: function() {
                var that = this,
                    options = this.options;
                
                this.running = false;
                
                this.element
                    .addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
                    .toggleClass( "ui-tabs-collapsible", options.collapsible )
                    // Prevent users from focusing disabled tabs via click
                    .delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
                        if ( $( this ).is( ".ui-state-disabled" ) ) {
                            event.preventDefault();
                        }
                    })
                    // support: IE <9
                    // Preventing the default action in mousedown doesn't prevent IE
                    // from focusing the element, so if the anchor gets focused, blur.
                    // We don't have to worry about focusing the previously focused
                    // element since clicking on a non-focusable element should focus
                    // the body anyway.
                    .delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                        if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
                            this.blur();
                        }
                    });
                
                this._processTabs();
                options.active = this._initialActive();
                
                // Take disabling tabs via class attribute from HTML
                // into account and update option properly.
                if ( $.isArray( options.disabled ) ) {
                    options.disabled = $.unique( options.disabled.concat(
                        $.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
                            return that.tabs.index( li );
                        })
                    ) ).sort();
                }
                
                // check for length avoids error when initializing empty list
                if ( this.options.active !== false && this.anchors.length ) {
                    this.active = this._findActive( options.active );
                } else {
                    this.active = $();
                }
                
                this._refresh();
                
                if ( this.active.length ) {
                    this.load( options.active );
                }
            },
            
            _initialActive: function() {
                var active = this.options.active,
                    collapsible = this.options.collapsible,
                    locationHash = location.hash.substring( 1 );
                
                if ( active === null ) {
                    // check the fragment identifier in the URL
                    if ( locationHash ) {
                        this.tabs.each(function( i, tab ) {
                            if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
                                active = i;
                                return false;
                            }
                        });
                    }
                    
                    // check for a tab marked active via a class
                    if ( active === null ) {
                        active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
                    }
                    
                    // no active tab, set to false
                    if ( active === null || active === -1 ) {
                        active = this.tabs.length ? 0 : false;
                    }
                }
                
                // handle numbers: negative, out of range
                if ( active !== false ) {
                    active = this.tabs.index( this.tabs.eq( active ) );
                    if ( active === -1 ) {
                        active = collapsible ? false : 0;
                    }
                }
                
                // don't allow collapsible: false and active: false
                if ( !collapsible && active === false && this.anchors.length ) {
                    active = 0;
                }
                
                return active;
            },
            
            _getCreateEventData: function() {
                return {
                    tab: this.active,
                    panel: !this.active.length ? $() : this._getPanelForTab( this.active )
                };
            },
            
            _tabKeydown: function( event ) {
                /*jshint maxcomplexity:15*/
                var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
                    selectedIndex = this.tabs.index( focusedTab ),
                    goingForward = true;
                
                if ( this._handlePageNav( event ) ) {
                    return;
                }
                
                switch ( event.keyCode ) {
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                        selectedIndex++;
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.LEFT:
                        goingForward = false;
                        selectedIndex--;
                        break;
                    case $.ui.keyCode.END:
                        selectedIndex = this.anchors.length - 1;
                        break;
                    case $.ui.keyCode.HOME:
                        selectedIndex = 0;
                        break;
                    case $.ui.keyCode.SPACE:
                        // Activate only, no collapsing
                        event.preventDefault();
                        clearTimeout( this.activating );
                        this._activate( selectedIndex );
                        return;
                    case $.ui.keyCode.ENTER:
                        // Toggle (cancel delayed activation, allow collapsing)
                        event.preventDefault();
                        clearTimeout( this.activating );
                        // Determine if we should collapse or activate
                        this._activate( selectedIndex === this.options.active ? false : selectedIndex );
                        return;
                    default:
                        return;
                }
                
                // Focus the appropriate tab, based on which key was pressed
                event.preventDefault();
                clearTimeout( this.activating );
                selectedIndex = this._focusNextTab( selectedIndex, goingForward );
                
                // Navigating with control key will prevent automatic activation
                if ( !event.ctrlKey ) {
                    // Update aria-selected immediately so that AT think the tab is already selected.
                    // Otherwise AT may confuse the user by stating that they need to activate the tab,
                    // but the tab will already be activated by the time the announcement finishes.
                    focusedTab.attr( "aria-selected", "false" );
                    this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );
                    
                    this.activating = this._delay(function() {
                        this.option( "active", selectedIndex );
                    }, this.delay );
                }
            },
            
            _panelKeydown: function( event ) {
                if ( this._handlePageNav( event ) ) {
                    return;
                }
                
                // Ctrl+up moves focus to the current tab
                if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
                    event.preventDefault();
                    this.active.focus();
                }
            },
            
            // Alt+page up/down moves focus to the previous/next tab (and activates)
            _handlePageNav: function( event ) {
                if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
                    this._activate( this._focusNextTab( this.options.active - 1, false ) );
                    return true;
                }
                if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
                    this._activate( this._focusNextTab( this.options.active + 1, true ) );
                    return true;
                }
            },
            
            _findNextTab: function( index, goingForward ) {
                var lastTabIndex = this.tabs.length - 1;
                
                function constrain() {
                    if ( index > lastTabIndex ) {
                        index = 0;
                    }
                    if ( index < 0 ) {
                        index = lastTabIndex;
                    }
                    return index;
                }
                
                while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
                    index = goingForward ? index + 1 : index - 1;
                }
                
                return index;
            },
            
            _focusNextTab: function( index, goingForward ) {
                index = this._findNextTab( index, goingForward );
                this.tabs.eq( index ).focus();
                return index;
            },
            
            _setOption: function( key, value ) {
                if ( key === "active" ) {
                    // _activate() will handle invalid values and update this.options
                    this._activate( value );
                    return;
                }
                
                if ( key === "disabled" ) {
                    // don't use the widget factory's disabled handling
                    this._setupDisabled( value );
                    return;
                }
                
                this._super( key, value);
                
                if ( key === "collapsible" ) {
                    this.element.toggleClass( "ui-tabs-collapsible", value );
                    // Setting collapsible: false while collapsed; open first panel
                    if ( !value && this.options.active === false ) {
                        this._activate( 0 );
                    }
                }
                
                if ( key === "event" ) {
                    this._setupEvents( value );
                }
                
                if ( key === "heightStyle" ) {
                    this._setupHeightStyle( value );
                }
            },
            
            _tabId: function( tab ) {
                return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
            },
            
            _sanitizeSelector: function( hash ) {
                return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
            },
            
            refresh: function() {
                var options = this.options,
                    lis = this.tablist.children( ":has(a[href])" );
                
                // get disabled tabs from class attribute from HTML
                // this will get converted to a boolean if needed in _refresh()
                options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
                    return lis.index( tab );
                });
                
                this._processTabs();
                
                // was collapsed or no tabs
                if ( options.active === false || !this.anchors.length ) {
                    options.active = false;
                    this.active = $();
                    // was active, but active tab is gone
                } else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
                    // all remaining tabs are disabled
                    if ( this.tabs.length === options.disabled.length ) {
                        options.active = false;
                        this.active = $();
                        // activate previous tab
                    } else {
                        this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
                    }
                    // was active, active tab still exists
                } else {
                    // make sure active index is correct
                    options.active = this.tabs.index( this.active );
                }
                
                this._refresh();
            },
            
            _refresh: function() {
                this._setupDisabled( this.options.disabled );
                this._setupEvents( this.options.event );
                this._setupHeightStyle( this.options.heightStyle );
                
                this.tabs.not( this.active ).attr({
                    "aria-selected": "false",
                    tabIndex: -1
                });
                this.panels.not( this._getPanelForTab( this.active ) )
                    .hide()
                    .attr({
                        "aria-expanded": "false",
                        "aria-hidden": "true"
                    });
                
                // Make sure one tab is in the tab order
                if ( !this.active.length ) {
                    this.tabs.eq( 0 ).attr( "tabIndex", 0 );
                } else {
                    this.active
                        .addClass( "ui-tabs-active ui-state-active" )
                        .attr({
                            "aria-selected": "true",
                            tabIndex: 0
                        });
                    this._getPanelForTab( this.active )
                        .show()
                        .attr({
                            "aria-expanded": "true",
                            "aria-hidden": "false"
                        });
                }
            },
            
            _processTabs: function() {
                var that = this;
                
                this.tablist = this._getList()
                    .addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
                    .attr( "role", "tablist" );
                
                this.tabs = this.tablist.find( "> li:has(a[href])" )
                    .addClass( "ui-state-default ui-corner-top" )
                    .attr({
                        role: "tab",
                        tabIndex: -1
                    });
                
                this.anchors = this.tabs.map(function() {
                    return $( "a", this )[ 0 ];
                })
                    .addClass( "ui-tabs-anchor" )
                    .attr({
                        role: "presentation",
                        tabIndex: -1
                    });
                
                this.panels = $();
                
                this.anchors.each(function( i, anchor ) {
                    var selector, panel, panelId,
                        anchorId = $( anchor ).uniqueId().attr( "id" ),
                        tab = $( anchor ).closest( "li" ),
                        originalAriaControls = tab.attr( "aria-controls" );
                    
                    // inline tab
                    if ( isLocal( anchor ) ) {
                        selector = anchor.hash;
                        panel = that.element.find( that._sanitizeSelector( selector ) );
                        // remote tab
                    } else {
                        panelId = that._tabId( tab );
                        selector = "#" + panelId;
                        panel = that.element.find( selector );
                        if ( !panel.length ) {
                            panel = that._createPanel( panelId );
                            panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
                        }
                        panel.attr( "aria-live", "polite" );
                    }
                    
                    if ( panel.length) {
                        that.panels = that.panels.add( panel );
                    }
                    if ( originalAriaControls ) {
                        tab.data( "ui-tabs-aria-controls", originalAriaControls );
                    }
                    tab.attr({
                        "aria-controls": selector.substring( 1 ),
                        "aria-labelledby": anchorId
                    });
                    panel.attr( "aria-labelledby", anchorId );
                });
                
                this.panels
                    .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
                    .attr( "role", "tabpanel" );
            },
            
            // allow overriding how to find the list for rare usage scenarios (#7715)
            _getList: function() {
                return this.element.find( "ol,ul" ).eq( 0 );
            },
            
            _createPanel: function( id ) {
                return $( "<div>" )
                    .attr( "id", id )
                    .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
                    .data( "ui-tabs-destroy", true );
            },
            
            _setupDisabled: function( disabled ) {
                if ( $.isArray( disabled ) ) {
                    if ( !disabled.length ) {
                        disabled = false;
                    } else if ( disabled.length === this.anchors.length ) {
                        disabled = true;
                    }
                }
                
                // disable tabs
                for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
                    if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
                        $( li )
                            .addClass( "ui-state-disabled" )
                            .attr( "aria-disabled", "true" );
                    } else {
                        $( li )
                            .removeClass( "ui-state-disabled" )
                            .removeAttr( "aria-disabled" );
                    }
                }
                
                this.options.disabled = disabled;
            },
            
            _setupEvents: function( event ) {
                var events = {
                    click: function( event ) {
                        event.preventDefault();
                    }
                };
                if ( event ) {
                    $.each( event.split(" "), function( index, eventName ) {
                        events[ eventName ] = "_eventHandler";
                    });
                }
                
                this._off( this.anchors.add( this.tabs ).add( this.panels ) );
                this._on( this.anchors, events );
                this._on( this.tabs, { keydown: "_tabKeydown" } );
                this._on( this.panels, { keydown: "_panelKeydown" } );
                
                this._focusable( this.tabs );
                this._hoverable( this.tabs );
            },
            
            _setupHeightStyle: function( heightStyle ) {
                var maxHeight,
                    parent = this.element.parent();
                
                if ( heightStyle === "fill" ) {
                    maxHeight = parent.height();
                    maxHeight -= this.element.outerHeight() - this.element.height();
                    
                    this.element.siblings( ":visible" ).each(function() {
                        var elem = $( this ),
                            position = elem.css( "position" );
                        
                        if ( position === "absolute" || position === "fixed" ) {
                            return;
                        }
                        maxHeight -= elem.outerHeight( true );
                    });
                    
                    this.element.children().not( this.panels ).each(function() {
                        maxHeight -= $( this ).outerHeight( true );
                    });
                    
                    this.panels.each(function() {
                        $( this ).height( Math.max( 0, maxHeight -
                            $( this ).innerHeight() + $( this ).height() ) );
                    })
                        .css( "overflow", "auto" );
                } else if ( heightStyle === "auto" ) {
                    maxHeight = 0;
                    this.panels.each(function() {
                        maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
                    }).height( maxHeight );
                }
            },
            
            _eventHandler: function( event ) {
                var options = this.options,
                    active = this.active,
                    anchor = $( event.currentTarget ),
                    tab = anchor.closest( "li" ),
                    clickedIsActive = tab[ 0 ] === active[ 0 ],
                    collapsing = clickedIsActive && options.collapsible,
                    toShow = collapsing ? $() : this._getPanelForTab( tab ),
                    toHide = !active.length ? $() : this._getPanelForTab( active ),
                    eventData = {
                        oldTab: active,
                        oldPanel: toHide,
                        newTab: collapsing ? $() : tab,
                        newPanel: toShow
                    };
                
                event.preventDefault();
                
                if ( tab.hasClass( "ui-state-disabled" ) ||
                        // tab is already loading
                    tab.hasClass( "ui-tabs-loading" ) ||
                        // can't switch durning an animation
                    this.running ||
                        // click on active header, but not collapsible
                    ( clickedIsActive && !options.collapsible ) ||
                        // allow canceling activation
                    ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
                    return;
                }
                
                options.active = collapsing ? false : this.tabs.index( tab );
                
                this.active = clickedIsActive ? $() : tab;
                if ( this.xhr ) {
                    this.xhr.abort();
                }
                
                if ( !toHide.length && !toShow.length ) {
                    $.error( "jQuery UI Tabs: Mismatching fragment identifier." );
                }
                
                if ( toShow.length ) {
                    this.load( this.tabs.index( tab ), event );
                }
                this._toggle( event, eventData );
            },
            
            // handles show/hide for selecting tabs
            _toggle: function( event, eventData ) {
                var that = this,
                    toShow = eventData.newPanel,
                    toHide = eventData.oldPanel;
                
                this.running = true;
                
                function complete() {
                    that.running = false;
                    that._trigger( "activate", event, eventData );
                }
                
                function show() {
                    eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );
                    
                    if ( toShow.length && that.options.show ) {
                        that._show( toShow, that.options.show, complete );
                    } else {
                        toShow.show();
                        complete();
                    }
                }
                
                // start out by hiding, then showing, then completing
                if ( toHide.length && this.options.hide ) {
                    this._hide( toHide, this.options.hide, function() {
                        eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
                        show();
                    });
                } else {
                    eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
                    toHide.hide();
                    show();
                }
                
                toHide.attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                });
                eventData.oldTab.attr( "aria-selected", "false" );
                // If we're switching tabs, remove the old tab from the tab order.
                // If we're opening from collapsed state, remove the previous tab from the tab order.
                // If we're collapsing, then keep the collapsing tab in the tab order.
                if ( toShow.length && toHide.length ) {
                    eventData.oldTab.attr( "tabIndex", -1 );
                } else if ( toShow.length ) {
                    this.tabs.filter(function() {
                        return $( this ).attr( "tabIndex" ) === 0;
                    })
                        .attr( "tabIndex", -1 );
                }
                
                toShow.attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                });
                eventData.newTab.attr({
                    "aria-selected": "true",
                    tabIndex: 0
                });
            },
            
            _activate: function( index ) {
                var anchor,
                    active = this._findActive( index );
                
                // trying to activate the already active panel
                if ( active[ 0 ] === this.active[ 0 ] ) {
                    return;
                }
                
                // trying to collapse, simulate a click on the current active header
                if ( !active.length ) {
                    active = this.active;
                }
                
                anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
                this._eventHandler({
                    target: anchor,
                    currentTarget: anchor,
                    preventDefault: $.noop
                });
            },
            
            _findActive: function( index ) {
                return index === false ? $() : this.tabs.eq( index );
            },
            
            _getIndex: function( index ) {
                // meta-function to give users option to provide a href string instead of a numerical index.
                if ( typeof index === "string" ) {
                    index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
                }
                
                return index;
            },
            
            _destroy: function() {
                if ( this.xhr ) {
                    this.xhr.abort();
                }
                
                this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );
                
                this.tablist
                    .removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
                    .removeAttr( "role" );
                
                this.anchors
                    .removeClass( "ui-tabs-anchor" )
                    .removeAttr( "role" )
                    .removeAttr( "tabIndex" )
                    .removeUniqueId();
                
                this.tabs.add( this.panels ).each(function() {
                    if ( $.data( this, "ui-tabs-destroy" ) ) {
                        $( this ).remove();
                    } else {
                        $( this )
                            .removeClass( "ui-state-default ui-state-active ui-state-disabled " +
                            "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
                            .removeAttr( "tabIndex" )
                            .removeAttr( "aria-live" )
                            .removeAttr( "aria-busy" )
                            .removeAttr( "aria-selected" )
                            .removeAttr( "aria-labelledby" )
                            .removeAttr( "aria-hidden" )
                            .removeAttr( "aria-expanded" )
                            .removeAttr( "role" );
                    }
                });
                
                this.tabs.each(function() {
                    var li = $( this ),
                        prev = li.data( "ui-tabs-aria-controls" );
                    if ( prev ) {
                        li
                            .attr( "aria-controls", prev )
                            .removeData( "ui-tabs-aria-controls" );
                    } else {
                        li.removeAttr( "aria-controls" );
                    }
                });
                
                this.panels.show();
                
                if ( this.options.heightStyle !== "content" ) {
                    this.panels.css( "height", "" );
                }
            },
            
            enable: function( index ) {
                var disabled = this.options.disabled;
                if ( disabled === false ) {
                    return;
                }
                
                if ( index === undefined ) {
                    disabled = false;
                } else {
                    index = this._getIndex( index );
                    if ( $.isArray( disabled ) ) {
                        disabled = $.map( disabled, function( num ) {
                            return num !== index ? num : null;
                        });
                    } else {
                        disabled = $.map( this.tabs, function( li, num ) {
                            return num !== index ? num : null;
                        });
                    }
                }
                this._setupDisabled( disabled );
            },
            
            disable: function( index ) {
                var disabled = this.options.disabled;
                if ( disabled === true ) {
                    return;
                }
                
                if ( index === undefined ) {
                    disabled = true;
                } else {
                    index = this._getIndex( index );
                    if ( $.inArray( index, disabled ) !== -1 ) {
                        return;
                    }
                    if ( $.isArray( disabled ) ) {
                        disabled = $.merge( [ index ], disabled ).sort();
                    } else {
                        disabled = [ index ];
                    }
                }
                this._setupDisabled( disabled );
            },
            
            load: function( index, event ) {
                index = this._getIndex( index );
                var that = this,
                    tab = this.tabs.eq( index ),
                    anchor = tab.find( ".ui-tabs-anchor" ),
                    panel = this._getPanelForTab( tab ),
                    eventData = {
                        tab: tab,
                        panel: panel
                    };
                
                // not remote
                if ( isLocal( anchor[ 0 ] ) ) {
                    return;
                }
                
                this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );
                
                // support: jQuery <1.8
                // jQuery <1.8 returns false if the request is canceled in beforeSend,
                // but as of 1.8, $.ajax() always returns a jqXHR object.
                if ( this.xhr && this.xhr.statusText !== "canceled" ) {
                    tab.addClass( "ui-tabs-loading" );
                    panel.attr( "aria-busy", "true" );
                    
                    this.xhr
                        .success(function( response ) {
                            // support: jQuery <1.8
                            // http://bugs.jquery.com/ticket/11778
                            setTimeout(function() {
                                panel.html( response );
                                that._trigger( "load", event, eventData );
                            }, 1 );
                        })
                        .complete(function( jqXHR, status ) {
                            // support: jQuery <1.8
                            // http://bugs.jquery.com/ticket/11778
                            setTimeout(function() {
                                if ( status === "abort" ) {
                                    that.panels.stop( false, true );
                                }
                                
                                tab.removeClass( "ui-tabs-loading" );
                                panel.removeAttr( "aria-busy" );
                                
                                if ( jqXHR === that.xhr ) {
                                    delete that.xhr;
                                }
                            }, 1 );
                        });
                }
            },
            
            _ajaxSettings: function( anchor, event, eventData ) {
                var that = this;
                return {
                    url: anchor.attr( "href" ),
                    beforeSend: function( jqXHR, settings ) {
                        return that._trigger( "beforeLoad", event,
                            $.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
                    }
                };
            },
            
            _getPanelForTab: function( tab ) {
                var id = $( tab ).attr( "aria-controls" );
                return this.element.find( this._sanitizeSelector( "#" + id ) );
            }
        });
        
    })( jQuery );
    
    (function( $ ) {
        
        var increments = 0;
        
        function addDescribedBy( elem, id ) {
            var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
            describedby.push( id );
            elem
                .data( "ui-tooltip-id", id )
                .attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
        }
        
        function removeDescribedBy( elem ) {
            var id = elem.data( "ui-tooltip-id" ),
                describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
                index = $.inArray( id, describedby );
            if ( index !== -1 ) {
                describedby.splice( index, 1 );
            }
            
            elem.removeData( "ui-tooltip-id" );
            describedby = $.trim( describedby.join( " " ) );
            if ( describedby ) {
                elem.attr( "aria-describedby", describedby );
            } else {
                elem.removeAttr( "aria-describedby" );
            }
        }
        
        $.widget( "ui.tooltip", {
            version: "1.10.3",
            options: {
                content: function() {
                    // support: IE<9, Opera in jQuery <1.7
                    // .text() can't accept undefined, so coerce to a string
                    var title = $( this ).attr( "title" ) || "";
                    // Escape title, since we're going from an attribute to raw HTML
                    return $( "<a>" ).text( title ).html();
                },
                hide: true,
                // Disabled elements have inconsistent behavior across browsers (#8661)
                items: "[title]:not([disabled])",
                position: {
                    my: "left top+15",
                    at: "left bottom",
                    collision: "flipfit flip"
                },
                show: true,
                tooltipClass: null,
                track: false,
                
                // callbacks
                close: null,
                open: null
            },
            
            _create: function() {
                this._on({
                    mouseover: "open",
                    focusin: "open"
                });
                
                // IDs of generated tooltips, needed for destroy
                this.tooltips = {};
                // IDs of parent tooltips where we removed the title attribute
                this.parents = {};
                
                if ( this.options.disabled ) {
                    this._disable();
                }
            },
            
            _setOption: function( key, value ) {
                var that = this;
                
                if ( key === "disabled" ) {
                    this[ value ? "_disable" : "_enable" ]();
                    this.options[ key ] = value;
                    // disable element style changes
                    return;
                }
                
                this._super( key, value );
                
                if ( key === "content" ) {
                    $.each( this.tooltips, function( id, element ) {
                        that._updateContent( element );
                    });
                }
            },
            
            _disable: function() {
                var that = this;
                
                // close open tooltips
                $.each( this.tooltips, function( id, element ) {
                    var event = $.Event( "blur" );
                    event.target = event.currentTarget = element[0];
                    that.close( event, true );
                });
                
                // remove title attributes to prevent native tooltips
                this.element.find( this.options.items ).addBack().each(function() {
                    var element = $( this );
                    if ( element.is( "[title]" ) ) {
                        element
                            .data( "ui-tooltip-title", element.attr( "title" ) )
                            .attr( "title", "" );
                    }
                });
            },
            
            _enable: function() {
                // restore title attributes
                this.element.find( this.options.items ).addBack().each(function() {
                    var element = $( this );
                    if ( element.data( "ui-tooltip-title" ) ) {
                        element.attr( "title", element.data( "ui-tooltip-title" ) );
                    }
                });
            },
            
            open: function( event ) {
                var that = this,
                    target = $( event ? event.target : this.element )
                        // we need closest here due to mouseover bubbling,
                        // but always pointing at the same event target
                        .closest( this.options.items );
                
                // No element to show a tooltip for or the tooltip is already open
                if ( !target.length || target.data( "ui-tooltip-id" ) ) {
                    return;
                }
                
                if ( target.attr( "title" ) ) {
                    target.data( "ui-tooltip-title", target.attr( "title" ) );
                }
                
                target.data( "ui-tooltip-open", true );
                
                // kill parent tooltips, custom or native, for hover
                if ( event && event.type === "mouseover" ) {
                    target.parents().each(function() {
                        var parent = $( this ),
                            blurEvent;
                        if ( parent.data( "ui-tooltip-open" ) ) {
                            blurEvent = $.Event( "blur" );
                            blurEvent.target = blurEvent.currentTarget = this;
                            that.close( blurEvent, true );
                        }
                        if ( parent.attr( "title" ) ) {
                            parent.uniqueId();
                            that.parents[ this.id ] = {
                                element: this,
                                title: parent.attr( "title" )
                            };
                            parent.attr( "title", "" );
                        }
                    });
                }
                
                this._updateContent( target, event );
            },
            
            _updateContent: function( target, event ) {
                var content,
                    contentOption = this.options.content,
                    that = this,
                    eventType = event ? event.type : null;
                
                if ( typeof contentOption === "string" ) {
                    return this._open( event, target, contentOption );
                }
                
                content = contentOption.call( target[0], function( response ) {
                    // ignore async response if tooltip was closed already
                    if ( !target.data( "ui-tooltip-open" ) ) {
                        return;
                    }
                    // IE may instantly serve a cached response for ajax requests
                    // delay this call to _open so the other call to _open runs first
                    that._delay(function() {
                        // jQuery creates a special event for focusin when it doesn't
                        // exist natively. To improve performance, the native event
                        // object is reused and the type is changed. Therefore, we can't
                        // rely on the type being correct after the event finished
                        // bubbling, so we set it back to the previous value. (#8740)
                        if ( event ) {
                            event.type = eventType;
                        }
                        this._open( event, target, response );
                    });
                });
                if ( content ) {
                    this._open( event, target, content );
                }
            },
            
            _open: function( event, target, content ) {
                var tooltip, events, delayedShow,
                    positionOption = $.extend( {}, this.options.position );
                
                if ( !content ) {
                    return;
                }
                
                // Content can be updated multiple times. If the tooltip already
                // exists, then just update the content and bail.
                tooltip = this._find( target );
                if ( tooltip.length ) {
                    tooltip.find( ".ui-tooltip-content" ).html( content );
                    return;
                }
                
                // if we have a title, clear it to prevent the native tooltip
                // we have to check first to avoid defining a title if none exists
                // (we don't want to cause an element to start matching [title])
                //
                // We use removeAttr only for key events, to allow IE to export the correct
                // accessible attributes. For mouse events, set to empty string to avoid
                // native tooltip showing up (happens only when removing inside mouseover).
                if ( target.is( "[title]" ) ) {
                    if ( event && event.type === "mouseover" ) {
                        target.attr( "title", "" );
                    } else {
                        target.removeAttr( "title" );
                    }
                }
                
                tooltip = this._tooltip( target );
                addDescribedBy( target, tooltip.attr( "id" ) );
                tooltip.find( ".ui-tooltip-content" ).html( content );
                
                function position( event ) {
                    positionOption.of = event;
                    if ( tooltip.is( ":hidden" ) ) {
                        return;
                    }
                    tooltip.position( positionOption );
                }
                if ( this.options.track && event && /^mouse/.test( event.type ) ) {
                    this._on( this.document, {
                        mousemove: position
                    });
                    // trigger once to override element-relative positioning
                    position( event );
                } else {
                    tooltip.position( $.extend({
                        of: target
                    }, this.options.position ) );
                }
                
                tooltip.hide();
                
                this._show( tooltip, this.options.show );
                // Handle tracking tooltips that are shown with a delay (#8644). As soon
                // as the tooltip is visible, position the tooltip using the most recent
                // event.
                if ( this.options.show && this.options.show.delay ) {
                    delayedShow = this.delayedShow = setInterval(function() {
                        if ( tooltip.is( ":visible" ) ) {
                            position( positionOption.of );
                            clearInterval( delayedShow );
                        }
                    }, $.fx.interval );
                }
                
                this._trigger( "open", event, { tooltip: tooltip } );
                
                events = {
                    keyup: function( event ) {
                        if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
                            var fakeEvent = $.Event(event);
                            fakeEvent.currentTarget = target[0];
                            this.close( fakeEvent, true );
                        }
                    },
                    remove: function() {
                        this._removeTooltip( tooltip );
                    }
                };
                if ( !event || event.type === "mouseover" ) {
                    events.mouseleave = "close";
                }
                if ( !event || event.type === "focusin" ) {
                    events.focusout = "close";
                }
                this._on( true, target, events );
            },
            
            close: function( event ) {
                var that = this,
                    target = $( event ? event.currentTarget : this.element ),
                    tooltip = this._find( target );
                
                // disabling closes the tooltip, so we need to track when we're closing
                // to avoid an infinite loop in case the tooltip becomes disabled on close
                if ( this.closing ) {
                    return;
                }
                
                // Clear the interval for delayed tracking tooltips
                clearInterval( this.delayedShow );
                
                // only set title if we had one before (see comment in _open())
                if ( target.data( "ui-tooltip-title" ) ) {
                    target.attr( "title", target.data( "ui-tooltip-title" ) );
                }
                
                removeDescribedBy( target );
                
                tooltip.stop( true );
                this._hide( tooltip, this.options.hide, function() {
                    that._removeTooltip( $( this ) );
                });
                
                target.removeData( "ui-tooltip-open" );
                this._off( target, "mouseleave focusout keyup" );
                // Remove 'remove' binding only on delegated targets
                if ( target[0] !== this.element[0] ) {
                    this._off( target, "remove" );
                }
                this._off( this.document, "mousemove" );
                
                if ( event && event.type === "mouseleave" ) {
                    $.each( this.parents, function( id, parent ) {
                        $( parent.element ).attr( "title", parent.title );
                        delete that.parents[ id ];
                    });
                }
                
                this.closing = true;
                this._trigger( "close", event, { tooltip: tooltip } );
                this.closing = false;
            },
            
            _tooltip: function( element ) {
                var id = "ui-tooltip-" + increments++,
                    tooltip = $( "<div>" )
                        .attr({
                            id: id,
                            role: "tooltip"
                        })
                        .addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
                        ( this.options.tooltipClass || "" ) );
                $( "<div>" )
                    .addClass( "ui-tooltip-content" )
                    .appendTo( tooltip );
                tooltip.appendTo( this.document[0].body );
                this.tooltips[ id ] = element;
                return tooltip;
            },
            
            _find: function( target ) {
                var id = target.data( "ui-tooltip-id" );
                return id ? $( "#" + id ) : $();
            },
            
            _removeTooltip: function( tooltip ) {
                tooltip.remove();
                delete this.tooltips[ tooltip.attr( "id" ) ];
            },
            
            _destroy: function() {
                var that = this;
                
                // close open tooltips
                $.each( this.tooltips, function( id, element ) {
                    // Delegate to close method to handle common cleanup
                    var event = $.Event( "blur" );
                    event.target = event.currentTarget = element[0];
                    that.close( event, true );
                    
                    // Remove immediately; destroying an open tooltip doesn't use the
                    // hide animation
                    $( "#" + id ).remove();
                    
                    // Restore the title
                    if ( element.data( "ui-tooltip-title" ) ) {
                        element.attr( "title", element.data( "ui-tooltip-title" ) );
                        element.removeData( "ui-tooltip-title" );
                    }
                });
            }
        });
        
    }( jQuery ) );
    
},{"jquery":84}],84:[function(require,module,exports){
    (function (global){
        ; var __browserify_shim_require__=require;(function browserifyShim(module, define, require) {
            /*!
             * jQuery JavaScript Library v2.1.4
             * http://jquery.com/
             *
             * Includes Sizzle.js
             * http://sizzlejs.com/
             *
             * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
             * Released under the MIT license
             * http://jquery.org/license
             *
             * Date: 2015-04-28T16:01Z
             */
            
            (function( global, factory ) {
                
                if ( typeof module === "object" && typeof module.exports === "object" ) {
                    // For CommonJS and CommonJS-like environments where a proper `window`
                    // is present, execute the factory and get jQuery.
                    // For environments that do not have a `window` with a `document`
                    // (such as Node.js), expose a factory as module.exports.
                    // This accentuates the need for the creation of a real `window`.
                    // e.g. var jQuery = require("jquery")(window);
                    // See ticket #14549 for more info.
                    module.exports = global.document ?
                        factory( global, true ) :
                        function( w ) {
                            if ( !w.document ) {
                                throw new Error( "jQuery requires a window with a document" );
                            }
                            return factory( w );
                        };
                } else {
                    factory( global );
                }
                
                // Pass this if window is not defined yet
            }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
                
                // Support: Firefox 18+
                // Can't be in strict mode, several libs including ASP.NET trace
                // the stack via arguments.caller.callee and Firefox dies if
                // you try to trace through "use strict" call chains. (#13335)
                //
                
                var arr = [];
                
                var slice = arr.slice;
                
                var concat = arr.concat;
                
                var push = arr.push;
                
                var indexOf = arr.indexOf;
                
                var class2type = {};
                
                var toString = class2type.toString;
                
                var hasOwn = class2type.hasOwnProperty;
                
                var support = {};
                
                
                
                var
                // Use the correct document accordingly with window argument (sandbox)
                    document = window.document,
                    
                    version = "2.1.4",
                
                // Define a local copy of jQuery
                    jQuery = function( selector, context ) {
                        // The jQuery object is actually just the init constructor 'enhanced'
                        // Need init if jQuery is called (just allow error to be thrown if not included)
                        return new jQuery.fn.init( selector, context );
                    },
                
                // Support: Android<4.1
                // Make sure we trim BOM and NBSP
                    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
                
                // Matches dashed string for camelizing
                    rmsPrefix = /^-ms-/,
                    rdashAlpha = /-([\da-z])/gi,
                
                // Used by jQuery.camelCase as callback to replace()
                    fcamelCase = function( all, letter ) {
                        return letter.toUpperCase();
                    };
                
                jQuery.fn = jQuery.prototype = {
                    // The current version of jQuery being used
                    jquery: version,
                    
                    constructor: jQuery,
                    
                    // Start with an empty selector
                    selector: "",
                    
                    // The default length of a jQuery object is 0
                    length: 0,
                    
                    toArray: function() {
                        return slice.call( this );
                    },
                    
                    // Get the Nth element in the matched element set OR
                    // Get the whole matched element set as a clean array
                    get: function( num ) {
                        return num != null ?
                            
                            // Return just the one element from the set
                            ( num < 0 ? this[ num + this.length ] : this[ num ] ) :
                            
                            // Return all the elements in a clean array
                            slice.call( this );
                    },
                    
                    // Take an array of elements and push it onto the stack
                    // (returning the new matched element set)
                    pushStack: function( elems ) {
                        
                        // Build a new jQuery matched element set
                        var ret = jQuery.merge( this.constructor(), elems );
                        
                        // Add the old object onto the stack (as a reference)
                        ret.prevObject = this;
                        ret.context = this.context;
                        
                        // Return the newly-formed element set
                        return ret;
                    },
                    
                    // Execute a callback for every element in the matched set.
                    // (You can seed the arguments with an array of args, but this is
                    // only used internally.)
                    each: function( callback, args ) {
                        return jQuery.each( this, callback, args );
                    },
                    
                    map: function( callback ) {
                        return this.pushStack( jQuery.map(this, function( elem, i ) {
                            return callback.call( elem, i, elem );
                        }));
                    },
                    
                    slice: function() {
                        return this.pushStack( slice.apply( this, arguments ) );
                    },
                    
                    first: function() {
                        return this.eq( 0 );
                    },
                    
                    last: function() {
                        return this.eq( -1 );
                    },
                    
                    eq: function( i ) {
                        var len = this.length,
                            j = +i + ( i < 0 ? len : 0 );
                        return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
                    },
                    
                    end: function() {
                        return this.prevObject || this.constructor(null);
                    },
                    
                    // For internal use only.
                    // Behaves like an Array's method, not like a jQuery method.
                    push: push,
                    sort: arr.sort,
                    splice: arr.splice
                };
                
                jQuery.extend = jQuery.fn.extend = function() {
                    var options, name, src, copy, copyIsArray, clone,
                        target = arguments[0] || {},
                        i = 1,
                        length = arguments.length,
                        deep = false;
                    
                    // Handle a deep copy situation
                    if ( typeof target === "boolean" ) {
                        deep = target;
                        
                        // Skip the boolean and the target
                        target = arguments[ i ] || {};
                        i++;
                    }
                    
                    // Handle case when target is a string or something (possible in deep copy)
                    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
                        target = {};
                    }
                    
                    // Extend jQuery itself if only one argument is passed
                    if ( i === length ) {
                        target = this;
                        i--;
                    }
                    
                    for ( ; i < length; i++ ) {
                        // Only deal with non-null/undefined values
                        if ( (options = arguments[ i ]) != null ) {
                            // Extend the base object
                            for ( name in options ) {
                                src = target[ name ];
                                copy = options[ name ];
                                
                                // Prevent never-ending loop
                                if ( target === copy ) {
                                    continue;
                                }
                                
                                // Recurse if we're merging plain objects or arrays
                                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                                    if ( copyIsArray ) {
                                        copyIsArray = false;
                                        clone = src && jQuery.isArray(src) ? src : [];
                                        
                                    } else {
                                        clone = src && jQuery.isPlainObject(src) ? src : {};
                                    }
                                    
                                    // Never move original objects, clone them
                                    target[ name ] = jQuery.extend( deep, clone, copy );
                                    
                                    // Don't bring in undefined values
                                } else if ( copy !== undefined ) {
                                    target[ name ] = copy;
                                }
                            }
                        }
                    }
                    
                    // Return the modified object
                    return target;
                };
                
                jQuery.extend({
                    // Unique for each copy of jQuery on the page
                    expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
                    
                    // Assume jQuery is ready without the ready module
                    isReady: true,
                    
                    error: function( msg ) {
                        throw new Error( msg );
                    },
                    
                    noop: function() {},
                    
                    isFunction: function( obj ) {
                        return jQuery.type(obj) === "function";
                    },
                    
                    isArray: Array.isArray,
                    
                    isWindow: function( obj ) {
                        return obj != null && obj === obj.window;
                    },
                    
                    isNumeric: function( obj ) {
                        // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                        // subtraction forces infinities to NaN
                        // adding 1 corrects loss of precision from parseFloat (#15100)
                        return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
                    },
                    
                    isPlainObject: function( obj ) {
                        // Not plain objects:
                        // - Any object or value whose internal [[Class]] property is not "[object Object]"
                        // - DOM nodes
                        // - window
                        if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                            return false;
                        }
                        
                        if ( obj.constructor &&
                            !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
                            return false;
                        }
                        
                        // If the function hasn't returned already, we're confident that
                        // |obj| is a plain object, created by {} or constructed with new Object
                        return true;
                    },
                    
                    isEmptyObject: function( obj ) {
                        var name;
                        for ( name in obj ) {
                            return false;
                        }
                        return true;
                    },
                    
                    type: function( obj ) {
                        if ( obj == null ) {
                            return obj + "";
                        }
                        // Support: Android<4.0, iOS<6 (functionish RegExp)
                        return typeof obj === "object" || typeof obj === "function" ?
                        class2type[ toString.call(obj) ] || "object" :
                            typeof obj;
                    },
                    
                    // Evaluates a script in a global context
                    globalEval: function( code ) {
                        var script,
                            indirect = eval;
                        
                        code = jQuery.trim( code );
                        
                        if ( code ) {
                            // If the code includes a valid, prologue position
                            // strict mode pragma, execute code by injecting a
                            // script tag into the document.
                            if ( code.indexOf("use strict") === 1 ) {
                                script = document.createElement("script");
                                script.text = code;
                                document.head.appendChild( script ).parentNode.removeChild( script );
                            } else {
                                // Otherwise, avoid the DOM node creation, insertion
                                // and removal by using an indirect global eval
                                indirect( code );
                            }
                        }
                    },
                    
                    // Convert dashed to camelCase; used by the css and data modules
                    // Support: IE9-11+
                    // Microsoft forgot to hump their vendor prefix (#9572)
                    camelCase: function( string ) {
                        return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
                    },
                    
                    nodeName: function( elem, name ) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                    },
                    
                    // args is for internal usage only
                    each: function( obj, callback, args ) {
                        var value,
                            i = 0,
                            length = obj.length,
                            isArray = isArraylike( obj );
                        
                        if ( args ) {
                            if ( isArray ) {
                                for ( ; i < length; i++ ) {
                                    value = callback.apply( obj[ i ], args );
                                    
                                    if ( value === false ) {
                                        break;
                                    }
                                }
                            } else {
                                for ( i in obj ) {
                                    value = callback.apply( obj[ i ], args );
                                    
                                    if ( value === false ) {
                                        break;
                                    }
                                }
                            }
                            
                            // A special, fast, case for the most common use of each
                        } else {
                            if ( isArray ) {
                                for ( ; i < length; i++ ) {
                                    value = callback.call( obj[ i ], i, obj[ i ] );
                                    
                                    if ( value === false ) {
                                        break;
                                    }
                                }
                            } else {
                                for ( i in obj ) {
                                    value = callback.call( obj[ i ], i, obj[ i ] );
                                    
                                    if ( value === false ) {
                                        break;
                                    }
                                }
                            }
                        }
                        
                        return obj;
                    },
                    
                    // Support: Android<4.1
                    trim: function( text ) {
                        return text == null ?
                            "" :
                            ( text + "" ).replace( rtrim, "" );
                    },
                    
                    // results is for internal usage only
                    makeArray: function( arr, results ) {
                        var ret = results || [];
                        
                        if ( arr != null ) {
                            if ( isArraylike( Object(arr) ) ) {
                                jQuery.merge( ret,
                                    typeof arr === "string" ?
                                        [ arr ] : arr
                                );
                            } else {
                                push.call( ret, arr );
                            }
                        }
                        
                        return ret;
                    },
                    
                    inArray: function( elem, arr, i ) {
                        return arr == null ? -1 : indexOf.call( arr, elem, i );
                    },
                    
                    merge: function( first, second ) {
                        var len = +second.length,
                            j = 0,
                            i = first.length;
                        
                        for ( ; j < len; j++ ) {
                            first[ i++ ] = second[ j ];
                        }
                        
                        first.length = i;
                        
                        return first;
                    },
                    
                    grep: function( elems, callback, invert ) {
                        var callbackInverse,
                            matches = [],
                            i = 0,
                            length = elems.length,
                            callbackExpect = !invert;
                        
                        // Go through the array, only saving the items
                        // that pass the validator function
                        for ( ; i < length; i++ ) {
                            callbackInverse = !callback( elems[ i ], i );
                            if ( callbackInverse !== callbackExpect ) {
                                matches.push( elems[ i ] );
                            }
                        }
                        
                        return matches;
                    },
                    
                    // arg is for internal usage only
                    map: function( elems, callback, arg ) {
                        var value,
                            i = 0,
                            length = elems.length,
                            isArray = isArraylike( elems ),
                            ret = [];
                        
                        // Go through the array, translating each of the items to their new values
                        if ( isArray ) {
                            for ( ; i < length; i++ ) {
                                value = callback( elems[ i ], i, arg );
                                
                                if ( value != null ) {
                                    ret.push( value );
                                }
                            }
                            
                            // Go through every key on the object,
                        } else {
                            for ( i in elems ) {
                                value = callback( elems[ i ], i, arg );
                                
                                if ( value != null ) {
                                    ret.push( value );
                                }
                            }
                        }
                        
                        // Flatten any nested arrays
                        return concat.apply( [], ret );
                    },
                    
                    // A global GUID counter for objects
                    guid: 1,
                    
                    // Bind a function to a context, optionally partially applying any
                    // arguments.
                    proxy: function( fn, context ) {
                        var tmp, args, proxy;
                        
                        if ( typeof context === "string" ) {
                            tmp = fn[ context ];
                            context = fn;
                            fn = tmp;
                        }
                        
                        // Quick check to determine if target is callable, in the spec
                        // this throws a TypeError, but we will just return undefined.
                        if ( !jQuery.isFunction( fn ) ) {
                            return undefined;
                        }
                        
                        // Simulated bind
                        args = slice.call( arguments, 2 );
                        proxy = function() {
                            return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
                        };
                        
                        // Set the guid of unique handler to the same of original handler, so it can be removed
                        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                        
                        return proxy;
                    },
                    
                    now: Date.now,
                    
                    // jQuery.support is not used in Core but other projects attach their
                    // properties to it so it needs to exist.
                    support: support
                });
                
                // Populate the class2type map
                jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
                    class2type[ "[object " + name + "]" ] = name.toLowerCase();
                });
                
                function isArraylike( obj ) {
                    
                    // Support: iOS 8.2 (not reproducible in simulator)
                    // `in` check used to prevent JIT error (gh-2145)
                    // hasOwn isn't used here due to false negatives
                    // regarding Nodelist length in IE
                    var length = "length" in obj && obj.length,
                        type = jQuery.type( obj );
                    
                    if ( type === "function" || jQuery.isWindow( obj ) ) {
                        return false;
                    }
                    
                    if ( obj.nodeType === 1 && length ) {
                        return true;
                    }
                    
                    return type === "array" || length === 0 ||
                        typeof length === "number" && length > 0 && ( length - 1 ) in obj;
                }
                var Sizzle =
                    /*!
                     * Sizzle CSS Selector Engine v2.2.0-pre
                     * http://sizzlejs.com/
                     *
                     * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
                     * Released under the MIT license
                     * http://jquery.org/license
                     *
                     * Date: 2014-12-16
                     */
                    (function( window ) {
                        
                        var i,
                            support,
                            Expr,
                            getText,
                            isXML,
                            tokenize,
                            compile,
                            select,
                            outermostContext,
                            sortInput,
                            hasDuplicate,
                        
                        // Local document vars
                            setDocument,
                            document,
                            docElem,
                            documentIsHTML,
                            rbuggyQSA,
                            rbuggyMatches,
                            matches,
                            contains,
                        
                        // Instance-specific data
                            expando = "sizzle" + 1 * new Date(),
                            preferredDoc = window.document,
                            dirruns = 0,
                            done = 0,
                            classCache = createCache(),
                            tokenCache = createCache(),
                            compilerCache = createCache(),
                            sortOrder = function( a, b ) {
                                if ( a === b ) {
                                    hasDuplicate = true;
                                }
                                return 0;
                            },
                        
                        // General-purpose constants
                            MAX_NEGATIVE = 1 << 31,
                        
                        // Instance methods
                            hasOwn = ({}).hasOwnProperty,
                            arr = [],
                            pop = arr.pop,
                            push_native = arr.push,
                            push = arr.push,
                            slice = arr.slice,
                        // Use a stripped-down indexOf as it's faster than native
                        // http://jsperf.com/thor-indexof-vs-for/5
                            indexOf = function( list, elem ) {
                                var i = 0,
                                    len = list.length;
                                for ( ; i < len; i++ ) {
                                    if ( list[i] === elem ) {
                                        return i;
                                    }
                                }
                                return -1;
                            },
                            
                            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                        
                        // Regular expressions
                        
                        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                            whitespace = "[\\x20\\t\\r\\n\\f]",
                        // http://www.w3.org/TR/css3-syntax/#characters
                            characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                        
                        // Loosely modeled on CSS identifier characters
                        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                            identifier = characterEncoding.replace( "w", "w#" ),
                        
                        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
                                    // Operator (capture 2)
                                "*([*^$|!~]?=)" + whitespace +
                                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                                "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                                "*\\]",
                            
                            pseudos = ":(" + characterEncoding + ")(?:\\((" +
                                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                                    // 1. quoted (capture 3; capture 4 or capture 5)
                                "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                                    // 2. simple (capture 6)
                                "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                                    // 3. anything else (capture 2)
                                ".*" +
                                ")\\)|)",
                        
                        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                            rwhitespace = new RegExp( whitespace + "+", "g" ),
                            rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
                            
                            rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                            rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
                            
                            rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
                            
                            rpseudo = new RegExp( pseudos ),
                            ridentifier = new RegExp( "^" + identifier + "$" ),
                            
                            matchExpr = {
                                "ID": new RegExp( "^#(" + characterEncoding + ")" ),
                                "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
                                "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
                                "ATTR": new RegExp( "^" + attributes ),
                                "PSEUDO": new RegExp( "^" + pseudos ),
                                "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                                    "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                                    "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                                "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                                // For use in libraries implementing .is()
                                // We use this for POS matching in `select`
                                "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                                    whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                            },
                            
                            rinputs = /^(?:input|select|textarea|button)$/i,
                            rheader = /^h\d$/i,
                            
                            rnative = /^[^{]+\{\s*\[native \w/,
                        
                        // Easily-parseable/retrievable ID or TAG or CLASS selectors
                            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                            
                            rsibling = /[+~]/,
                            rescape = /'|\\/g,
                        
                        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                            runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                            funescape = function( _, escaped, escapedWhitespace ) {
                                var high = "0x" + escaped - 0x10000;
                                // NaN means non-codepoint
                                // Support: Firefox<24
                                // Workaround erroneous numeric interpretation of +"0x"
                                return high !== high || escapedWhitespace ?
                                    escaped :
                                    high < 0 ?
                                        // BMP codepoint
                                        String.fromCharCode( high + 0x10000 ) :
                                        // Supplemental Plane codepoint (surrogate pair)
                                        String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                            },
                        
                        // Used for iframes
                        // See setDocument()
                        // Removing the function wrapper causes a "Permission Denied"
                        // error in IE
                            unloadHandler = function() {
                                setDocument();
                            };
                        
                        // Optimize for push.apply( _, NodeList )
                        try {
                            push.apply(
                                (arr = slice.call( preferredDoc.childNodes )),
                                preferredDoc.childNodes
                            );
                            // Support: Android<4.0
                            // Detect silently failing push.apply
                            arr[ preferredDoc.childNodes.length ].nodeType;
                        } catch ( e ) {
                            push = { apply: arr.length ?
                                
                                // Leverage slice if possible
                                function( target, els ) {
                                    push_native.apply( target, slice.call(els) );
                                } :
                                
                                // Support: IE<9
                                // Otherwise append directly
                                function( target, els ) {
                                    var j = target.length,
                                        i = 0;
                                    // Can't trust NodeList.length
                                    while ( (target[j++] = els[i++]) ) {}
                                    target.length = j - 1;
                                }
                            };
                        }
                        
                        function Sizzle( selector, context, results, seed ) {
                            var match, elem, m, nodeType,
                            // QSA vars
                                i, groups, old, nid, newContext, newSelector;
                            
                            if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                                setDocument( context );
                            }
                            
                            context = context || document;
                            results = results || [];
                            nodeType = context.nodeType;
                            
                            if ( typeof selector !== "string" || !selector ||
                                nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
                                
                                return results;
                            }
                            
                            if ( !seed && documentIsHTML ) {
                                
                                // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                                if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
                                    // Speed-up: Sizzle("#ID")
                                    if ( (m = match[1]) ) {
                                        if ( nodeType === 9 ) {
                                            elem = context.getElementById( m );
                                            // Check parentNode to catch when Blackberry 4.6 returns
                                            // nodes that are no longer in the document (jQuery #6963)
                                            if ( elem && elem.parentNode ) {
                                                // Handle the case where IE, Opera, and Webkit return items
                                                // by name instead of ID
                                                if ( elem.id === m ) {
                                                    results.push( elem );
                                                    return results;
                                                }
                                            } else {
                                                return results;
                                            }
                                        } else {
                                            // Context is not a document
                                            if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                                                contains( context, elem ) && elem.id === m ) {
                                                results.push( elem );
                                                return results;
                                            }
                                        }
                                        
                                        // Speed-up: Sizzle("TAG")
                                    } else if ( match[2] ) {
                                        push.apply( results, context.getElementsByTagName( selector ) );
                                        return results;
                                        
                                        // Speed-up: Sizzle(".CLASS")
                                    } else if ( (m = match[3]) && support.getElementsByClassName ) {
                                        push.apply( results, context.getElementsByClassName( m ) );
                                        return results;
                                    }
                                }
                                
                                // QSA path
                                if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                                    nid = old = expando;
                                    newContext = context;
                                    newSelector = nodeType !== 1 && selector;
                                    
                                    // qSA works strangely on Element-rooted queries
                                    // We can work around this by specifying an extra ID on the root
                                    // and working up from there (Thanks to Andrew Dupont for the technique)
                                    // IE 8 doesn't work on object elements
                                    if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                                        groups = tokenize( selector );
                                        
                                        if ( (old = context.getAttribute("id")) ) {
                                            nid = old.replace( rescape, "\\$&" );
                                        } else {
                                            context.setAttribute( "id", nid );
                                        }
                                        nid = "[id='" + nid + "'] ";
                                        
                                        i = groups.length;
                                        while ( i-- ) {
                                            groups[i] = nid + toSelector( groups[i] );
                                        }
                                        newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                                        newSelector = groups.join(",");
                                    }
                                    
                                    if ( newSelector ) {
                                        try {
                                            push.apply( results,
                                                newContext.querySelectorAll( newSelector )
                                            );
                                            return results;
                                        } catch(qsaError) {
                                        } finally {
                                            if ( !old ) {
                                                context.removeAttribute("id");
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // All others
                            return select( selector.replace( rtrim, "$1" ), context, results, seed );
                        }
                        
                        /**
                         * Create key-value caches of limited size
                         * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
                         *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                         *	deleting the oldest entry
                         */
                        function createCache() {
                            var keys = [];
                            
                            function cache( key, value ) {
                                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                                if ( keys.push( key + " " ) > Expr.cacheLength ) {
                                    // Only keep the most recent entries
                                    delete cache[ keys.shift() ];
                                }
                                return (cache[ key + " " ] = value);
                            }
                            return cache;
                        }
                        
                        /**
                         * Mark a function for special use by Sizzle
                         * @param {Function} fn The function to mark
                         */
                        function markFunction( fn ) {
                            fn[ expando ] = true;
                            return fn;
                        }
                        
                        /**
                         * Support testing using an element
                         * @param {Function} fn Passed the created div and expects a boolean result
                         */
                        function assert( fn ) {
                            var div = document.createElement("div");
                            
                            try {
                                return !!fn( div );
                            } catch (e) {
                                return false;
                            } finally {
                                // Remove from its parent by default
                                if ( div.parentNode ) {
                                    div.parentNode.removeChild( div );
                                }
                                // release memory in IE
                                div = null;
                            }
                        }
                        
                        /**
                         * Adds the same handler for all of the specified attrs
                         * @param {String} attrs Pipe-separated list of attributes
                         * @param {Function} handler The method that will be applied
                         */
                        function addHandle( attrs, handler ) {
                            var arr = attrs.split("|"),
                                i = attrs.length;
                            
                            while ( i-- ) {
                                Expr.attrHandle[ arr[i] ] = handler;
                            }
                        }
                        
                        /**
                         * Checks document order of two siblings
                         * @param {Element} a
                         * @param {Element} b
                         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                         */
                        function siblingCheck( a, b ) {
                            var cur = b && a,
                                diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                    ( ~b.sourceIndex || MAX_NEGATIVE ) -
                                    ( ~a.sourceIndex || MAX_NEGATIVE );
                            
                            // Use IE sourceIndex if available on both nodes
                            if ( diff ) {
                                return diff;
                            }
                            
                            // Check if b follows a
                            if ( cur ) {
                                while ( (cur = cur.nextSibling) ) {
                                    if ( cur === b ) {
                                        return -1;
                                    }
                                }
                            }
                            
                            return a ? 1 : -1;
                        }
                        
                        /**
                         * Returns a function to use in pseudos for input types
                         * @param {String} type
                         */
                        function createInputPseudo( type ) {
                            return function( elem ) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === type;
                            };
                        }
                        
                        /**
                         * Returns a function to use in pseudos for buttons
                         * @param {String} type
                         */
                        function createButtonPseudo( type ) {
                            return function( elem ) {
                                var name = elem.nodeName.toLowerCase();
                                return (name === "input" || name === "button") && elem.type === type;
                            };
                        }
                        
                        /**
                         * Returns a function to use in pseudos for positionals
                         * @param {Function} fn
                         */
                        function createPositionalPseudo( fn ) {
                            return markFunction(function( argument ) {
                                argument = +argument;
                                return markFunction(function( seed, matches ) {
                                    var j,
                                        matchIndexes = fn( [], seed.length, argument ),
                                        i = matchIndexes.length;
                                    
                                    // Match elements found at the specified indexes
                                    while ( i-- ) {
                                        if ( seed[ (j = matchIndexes[i]) ] ) {
                                            seed[j] = !(matches[j] = seed[j]);
                                        }
                                    }
                                });
                            });
                        }
                        
                        /**
                         * Checks a node for validity as a Sizzle context
                         * @param {Element|Object=} context
                         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                         */
                        function testContext( context ) {
                            return context && typeof context.getElementsByTagName !== "undefined" && context;
                        }
                        
                        // Expose support vars for convenience
                        support = Sizzle.support = {};
                        
                        /**
                         * Detects XML nodes
                         * @param {Element|Object} elem An element or a document
                         * @returns {Boolean} True iff elem is a non-HTML XML node
                         */
                        isXML = Sizzle.isXML = function( elem ) {
                            // documentElement is verified for cases where it doesn't yet exist
                            // (such as loading iframes in IE - #4833)
                            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                            return documentElement ? documentElement.nodeName !== "HTML" : false;
                        };
                        
                        /**
                         * Sets document-related variables once based on the current document
                         * @param {Element|Object} [doc] An element or document object to use to set the document
                         * @returns {Object} Returns the current document
                         */
                        setDocument = Sizzle.setDocument = function( node ) {
                            var hasCompare, parent,
                                doc = node ? node.ownerDocument || node : preferredDoc;
                            
                            // If no document and documentElement is available, return
                            if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                                return document;
                            }
                            
                            // Set our document
                            document = doc;
                            docElem = doc.documentElement;
                            parent = doc.defaultView;
                            
                            // Support: IE>8
                            // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                            // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                            // IE6-8 do not support the defaultView property so parent will be undefined
                            if ( parent && parent !== parent.top ) {
                                // IE11 does not have attachEvent, so all must suffer
                                if ( parent.addEventListener ) {
                                    parent.addEventListener( "unload", unloadHandler, false );
                                } else if ( parent.attachEvent ) {
                                    parent.attachEvent( "onunload", unloadHandler );
                                }
                            }
                            
                            /* Support tests
                             ---------------------------------------------------------------------- */
                            documentIsHTML = !isXML( doc );
                            
                            /* Attributes
                             ---------------------------------------------------------------------- */
                            
                            // Support: IE<8
                            // Verify that getAttribute really returns attributes and not properties
                            // (excepting IE8 booleans)
                            support.attributes = assert(function( div ) {
                                div.className = "i";
                                return !div.getAttribute("className");
                            });
                            
                            /* getElement(s)By*
                             ---------------------------------------------------------------------- */
                            
                            // Check if getElementsByTagName("*") returns only elements
                            support.getElementsByTagName = assert(function( div ) {
                                div.appendChild( doc.createComment("") );
                                return !div.getElementsByTagName("*").length;
                            });
                            
                            // Support: IE<9
                            support.getElementsByClassName = rnative.test( doc.getElementsByClassName );
                            
                            // Support: IE<10
                            // Check if getElementById returns elements by name
                            // The broken getElementById methods don't pick up programatically-set names,
                            // so use a roundabout getElementsByName test
                            support.getById = assert(function( div ) {
                                docElem.appendChild( div ).id = expando;
                                return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
                            });
                            
                            // ID find and filter
                            if ( support.getById ) {
                                Expr.find["ID"] = function( id, context ) {
                                    if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                                        var m = context.getElementById( id );
                                        // Check parentNode to catch when Blackberry 4.6 returns
                                        // nodes that are no longer in the document #6963
                                        return m && m.parentNode ? [ m ] : [];
                                    }
                                };
                                Expr.filter["ID"] = function( id ) {
                                    var attrId = id.replace( runescape, funescape );
                                    return function( elem ) {
                                        return elem.getAttribute("id") === attrId;
                                    };
                                };
                            } else {
                                // Support: IE6/7
                                // getElementById is not reliable as a find shortcut
                                delete Expr.find["ID"];
                                
                                Expr.filter["ID"] =  function( id ) {
                                    var attrId = id.replace( runescape, funescape );
                                    return function( elem ) {
                                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                                        return node && node.value === attrId;
                                    };
                                };
                            }
                            
                            // Tag
                            Expr.find["TAG"] = support.getElementsByTagName ?
                                function( tag, context ) {
                                    if ( typeof context.getElementsByTagName !== "undefined" ) {
                                        return context.getElementsByTagName( tag );
                                        
                                        // DocumentFragment nodes don't have gEBTN
                                    } else if ( support.qsa ) {
                                        return context.querySelectorAll( tag );
                                    }
                                } :
                                
                                function( tag, context ) {
                                    var elem,
                                        tmp = [],
                                        i = 0,
                                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                        results = context.getElementsByTagName( tag );
                                    
                                    // Filter out possible comments
                                    if ( tag === "*" ) {
                                        while ( (elem = results[i++]) ) {
                                            if ( elem.nodeType === 1 ) {
                                                tmp.push( elem );
                                            }
                                        }
                                        
                                        return tmp;
                                    }
                                    return results;
                                };
                            
                            // Class
                            Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                                    if ( documentIsHTML ) {
                                        return context.getElementsByClassName( className );
                                    }
                                };
                            
                            /* QSA/matchesSelector
                             ---------------------------------------------------------------------- */
                            
                            // QSA and matchesSelector support
                            
                            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                            rbuggyMatches = [];
                            
                            // qSa(:focus) reports false when true (Chrome 21)
                            // We allow this because of a bug in IE8/9 that throws an error
                            // whenever `document.activeElement` is accessed on an iframe
                            // So, we allow :focus to pass through QSA all the time to avoid the IE error
                            // See http://bugs.jquery.com/ticket/13378
                            rbuggyQSA = [];
                            
                            if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
                                // Build QSA regex
                                // Regex strategy adopted from Diego Perini
                                assert(function( div ) {
                                    // Select is set to empty string on purpose
                                    // This is to test IE's treatment of not explicitly
                                    // setting a boolean content attribute,
                                    // since its presence should be enough
                                    // http://bugs.jquery.com/ticket/12359
                                    docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                                        "<select id='" + expando + "-\f]' msallowcapture=''>" +
                                        "<option selected=''></option></select>";
                                    
                                    // Support: IE8, Opera 11-12.16
                                    // Nothing should be selected when empty strings follow ^= or $= or *=
                                    // The test attribute must be unknown in Opera but "safe" for WinRT
                                    // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                    if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                                        rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                                    }
                                    
                                    // Support: IE8
                                    // Boolean attributes and "value" are not treated correctly
                                    if ( !div.querySelectorAll("[selected]").length ) {
                                        rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                                    }
                                    
                                    // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
                                    if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                                        rbuggyQSA.push("~=");
                                    }
                                    
                                    // Webkit/Opera - :checked should return selected option elements
                                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                    // IE8 throws error here and will not see later tests
                                    if ( !div.querySelectorAll(":checked").length ) {
                                        rbuggyQSA.push(":checked");
                                    }
                                    
                                    // Support: Safari 8+, iOS 8+
                                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                                    // In-page `selector#id sibing-combinator selector` fails
                                    if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                                        rbuggyQSA.push(".#.+[+~]");
                                    }
                                });
                                
                                assert(function( div ) {
                                    // Support: Windows 8 Native Apps
                                    // The type and name attributes are restricted during .innerHTML assignment
                                    var input = doc.createElement("input");
                                    input.setAttribute( "type", "hidden" );
                                    div.appendChild( input ).setAttribute( "name", "D" );
                                    
                                    // Support: IE8
                                    // Enforce case-sensitivity of name attribute
                                    if ( div.querySelectorAll("[name=d]").length ) {
                                        rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                                    }
                                    
                                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                    // IE8 throws error here and will not see later tests
                                    if ( !div.querySelectorAll(":enabled").length ) {
                                        rbuggyQSA.push( ":enabled", ":disabled" );
                                    }
                                    
                                    // Opera 10-11 does not throw on post-comma invalid pseudos
                                    div.querySelectorAll("*,:x");
                                    rbuggyQSA.push(",.*:");
                                });
                            }
                            
                            if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                                    docElem.webkitMatchesSelector ||
                                    docElem.mozMatchesSelector ||
                                    docElem.oMatchesSelector ||
                                    docElem.msMatchesSelector) )) ) {
                                
                                assert(function( div ) {
                                    // Check to see if it's possible to do matchesSelector
                                    // on a disconnected node (IE 9)
                                    support.disconnectedMatch = matches.call( div, "div" );
                                    
                                    // This should fail with an exception
                                    // Gecko does not error, returns false instead
                                    matches.call( div, "[s!='']:x" );
                                    rbuggyMatches.push( "!=", pseudos );
                                });
                            }
                            
                            rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                            rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
                            
                            /* Contains
                             ---------------------------------------------------------------------- */
                            hasCompare = rnative.test( docElem.compareDocumentPosition );
                            
                            // Element contains another
                            // Purposefully does not implement inclusive descendent
                            // As in, an element does not contain itself
                            contains = hasCompare || rnative.test( docElem.contains ) ?
                                function( a, b ) {
                                    var adown = a.nodeType === 9 ? a.documentElement : a,
                                        bup = b && b.parentNode;
                                    return a === bup || !!( bup && bup.nodeType === 1 && (
                                            adown.contains ?
                                                adown.contains( bup ) :
                                            a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                                        ));
                                } :
                                function( a, b ) {
                                    if ( b ) {
                                        while ( (b = b.parentNode) ) {
                                            if ( b === a ) {
                                                return true;
                                            }
                                        }
                                    }
                                    return false;
                                };
                            
                            /* Sorting
                             ---------------------------------------------------------------------- */
                            
                            // Document order sorting
                            sortOrder = hasCompare ?
                                function( a, b ) {
                                    
                                    // Flag for duplicate removal
                                    if ( a === b ) {
                                        hasDuplicate = true;
                                        return 0;
                                    }
                                    
                                    // Sort on method existence if only one input has compareDocumentPosition
                                    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                    if ( compare ) {
                                        return compare;
                                    }
                                    
                                    // Calculate position if both inputs belong to the same document
                                    compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                                        a.compareDocumentPosition( b ) :
                                        
                                        // Otherwise we know they are disconnected
                                        1;
                                    
                                    // Disconnected nodes
                                    if ( compare & 1 ||
                                        (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
                                        
                                        // Choose the first element that is related to our preferred document
                                        if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                            return -1;
                                        }
                                        if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                            return 1;
                                        }
                                        
                                        // Maintain original order
                                        return sortInput ?
                                            ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                            0;
                                    }
                                    
                                    return compare & 4 ? -1 : 1;
                                } :
                                function( a, b ) {
                                    // Exit early if the nodes are identical
                                    if ( a === b ) {
                                        hasDuplicate = true;
                                        return 0;
                                    }
                                    
                                    var cur,
                                        i = 0,
                                        aup = a.parentNode,
                                        bup = b.parentNode,
                                        ap = [ a ],
                                        bp = [ b ];
                                    
                                    // Parentless nodes are either documents or disconnected
                                    if ( !aup || !bup ) {
                                        return a === doc ? -1 :
                                            b === doc ? 1 :
                                                aup ? -1 :
                                                    bup ? 1 :
                                                        sortInput ?
                                                            ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                                            0;
                                        
                                        // If the nodes are siblings, we can do a quick check
                                    } else if ( aup === bup ) {
                                        return siblingCheck( a, b );
                                    }
                                    
                                    // Otherwise we need full lists of their ancestors for comparison
                                    cur = a;
                                    while ( (cur = cur.parentNode) ) {
                                        ap.unshift( cur );
                                    }
                                    cur = b;
                                    while ( (cur = cur.parentNode) ) {
                                        bp.unshift( cur );
                                    }
                                    
                                    // Walk down the tree looking for a discrepancy
                                    while ( ap[i] === bp[i] ) {
                                        i++;
                                    }
                                    
                                    return i ?
                                        // Do a sibling check if the nodes have a common ancestor
                                        siblingCheck( ap[i], bp[i] ) :
                                        
                                        // Otherwise nodes in our document sort first
                                        ap[i] === preferredDoc ? -1 :
                                            bp[i] === preferredDoc ? 1 :
                                                0;
                                };
                            
                            return doc;
                        };
                        
                        Sizzle.matches = function( expr, elements ) {
                            return Sizzle( expr, null, null, elements );
                        };
                        
                        Sizzle.matchesSelector = function( elem, expr ) {
                            // Set document vars if needed
                            if ( ( elem.ownerDocument || elem ) !== document ) {
                                setDocument( elem );
                            }
                            
                            // Make sure that attribute selectors are quoted
                            expr = expr.replace( rattributeQuotes, "='$1']" );
                            
                            if ( support.matchesSelector && documentIsHTML &&
                                ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                                ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
                                
                                try {
                                    var ret = matches.call( elem, expr );
                                    
                                    // IE 9's matchesSelector returns false on disconnected nodes
                                    if ( ret || support.disconnectedMatch ||
                                            // As well, disconnected nodes are said to be in a document
                                            // fragment in IE 9
                                        elem.document && elem.document.nodeType !== 11 ) {
                                        return ret;
                                    }
                                } catch (e) {}
                            }
                            
                            return Sizzle( expr, document, null, [ elem ] ).length > 0;
                        };
                        
                        Sizzle.contains = function( context, elem ) {
                            // Set document vars if needed
                            if ( ( context.ownerDocument || context ) !== document ) {
                                setDocument( context );
                            }
                            return contains( context, elem );
                        };
                        
                        Sizzle.attr = function( elem, name ) {
                            // Set document vars if needed
                            if ( ( elem.ownerDocument || elem ) !== document ) {
                                setDocument( elem );
                            }
                            
                            var fn = Expr.attrHandle[ name.toLowerCase() ],
                            // Don't get fooled by Object.prototype properties (jQuery #13807)
                                val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                                    fn( elem, name, !documentIsHTML ) :
                                    undefined;
                            
                            return val !== undefined ?
                                val :
                                support.attributes || !documentIsHTML ?
                                    elem.getAttribute( name ) :
                                    (val = elem.getAttributeNode(name)) && val.specified ?
                                        val.value :
                                        null;
                        };
                        
                        Sizzle.error = function( msg ) {
                            throw new Error( "Syntax error, unrecognized expression: " + msg );
                        };
                        
                        /**
                         * Document sorting and removing duplicates
                         * @param {ArrayLike} results
                         */
                        Sizzle.uniqueSort = function( results ) {
                            var elem,
                                duplicates = [],
                                j = 0,
                                i = 0;
                            
                            // Unless we *know* we can detect duplicates, assume their presence
                            hasDuplicate = !support.detectDuplicates;
                            sortInput = !support.sortStable && results.slice( 0 );
                            results.sort( sortOrder );
                            
                            if ( hasDuplicate ) {
                                while ( (elem = results[i++]) ) {
                                    if ( elem === results[ i ] ) {
                                        j = duplicates.push( i );
                                    }
                                }
                                while ( j-- ) {
                                    results.splice( duplicates[ j ], 1 );
                                }
                            }
                            
                            // Clear input after sorting to release objects
                            // See https://github.com/jquery/sizzle/pull/225
                            sortInput = null;
                            
                            return results;
                        };
                        
                        /**
                         * Utility function for retrieving the text value of an array of DOM nodes
                         * @param {Array|Element} elem
                         */
                        getText = Sizzle.getText = function( elem ) {
                            var node,
                                ret = "",
                                i = 0,
                                nodeType = elem.nodeType;
                            
                            if ( !nodeType ) {
                                // If no nodeType, this is expected to be an array
                                while ( (node = elem[i++]) ) {
                                    // Do not traverse comment nodes
                                    ret += getText( node );
                                }
                            } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                                // Use textContent for elements
                                // innerText usage removed for consistency of new lines (jQuery #11153)
                                if ( typeof elem.textContent === "string" ) {
                                    return elem.textContent;
                                } else {
                                    // Traverse its children
                                    for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                        ret += getText( elem );
                                    }
                                }
                            } else if ( nodeType === 3 || nodeType === 4 ) {
                                return elem.nodeValue;
                            }
                            // Do not include comment or processing instruction nodes
                            
                            return ret;
                        };
                        
                        Expr = Sizzle.selectors = {
                            
                            // Can be adjusted by the user
                            cacheLength: 50,
                            
                            createPseudo: markFunction,
                            
                            match: matchExpr,
                            
                            attrHandle: {},
                            
                            find: {},
                            
                            relative: {
                                ">": { dir: "parentNode", first: true },
                                " ": { dir: "parentNode" },
                                "+": { dir: "previousSibling", first: true },
                                "~": { dir: "previousSibling" }
                            },
                            
                            preFilter: {
                                "ATTR": function( match ) {
                                    match[1] = match[1].replace( runescape, funescape );
                                    
                                    // Move the given value to match[3] whether quoted or unquoted
                                    match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
                                    
                                    if ( match[2] === "~=" ) {
                                        match[3] = " " + match[3] + " ";
                                    }
                                    
                                    return match.slice( 0, 4 );
                                },
                                
                                "CHILD": function( match ) {
                                    /* matches from matchExpr["CHILD"]
                                     1 type (only|nth|...)
                                     2 what (child|of-type)
                                     3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                                     4 xn-component of xn+y argument ([+-]?\d*n|)
                                     5 sign of xn-component
                                     6 x of xn-component
                                     7 sign of y-component
                                     8 y of y-component
                                     */
                                    match[1] = match[1].toLowerCase();
                                    
                                    if ( match[1].slice( 0, 3 ) === "nth" ) {
                                        // nth-* requires argument
                                        if ( !match[3] ) {
                                            Sizzle.error( match[0] );
                                        }
                                        
                                        // numeric x and y parameters for Expr.filter.CHILD
                                        // remember that false/true cast respectively to 0/1
                                        match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                                        match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
                                        
                                        // other types prohibit arguments
                                    } else if ( match[3] ) {
                                        Sizzle.error( match[0] );
                                    }
                                    
                                    return match;
                                },
                                
                                "PSEUDO": function( match ) {
                                    var excess,
                                        unquoted = !match[6] && match[2];
                                    
                                    if ( matchExpr["CHILD"].test( match[0] ) ) {
                                        return null;
                                    }
                                    
                                    // Accept quoted arguments as-is
                                    if ( match[3] ) {
                                        match[2] = match[4] || match[5] || "";
                                        
                                        // Strip excess characters from unquoted arguments
                                    } else if ( unquoted && rpseudo.test( unquoted ) &&
                                            // Get excess from tokenize (recursively)
                                        (excess = tokenize( unquoted, true )) &&
                                            // advance to the next closing parenthesis
                                        (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
                                        
                                        // excess is a negative index
                                        match[0] = match[0].slice( 0, excess );
                                        match[2] = unquoted.slice( 0, excess );
                                    }
                                    
                                    // Return only captures needed by the pseudo filter method (type and argument)
                                    return match.slice( 0, 3 );
                                }
                            },
                            
                            filter: {
                                
                                "TAG": function( nodeNameSelector ) {
                                    var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                                    return nodeNameSelector === "*" ?
                                        function() { return true; } :
                                        function( elem ) {
                                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                        };
                                },
                                
                                "CLASS": function( className ) {
                                    var pattern = classCache[ className + " " ];
                                    
                                    return pattern ||
                                        (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                                        classCache( className, function( elem ) {
                                            return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                                        });
                                },
                                
                                "ATTR": function( name, operator, check ) {
                                    return function( elem ) {
                                        var result = Sizzle.attr( elem, name );
                                        
                                        if ( result == null ) {
                                            return operator === "!=";
                                        }
                                        if ( !operator ) {
                                            return true;
                                        }
                                        
                                        result += "";
                                        
                                        return operator === "=" ? result === check :
                                            operator === "!=" ? result !== check :
                                                operator === "^=" ? check && result.indexOf( check ) === 0 :
                                                    operator === "*=" ? check && result.indexOf( check ) > -1 :
                                                        operator === "$=" ? check && result.slice( -check.length ) === check :
                                                            operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                                                operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                                    false;
                                    };
                                },
                                
                                "CHILD": function( type, what, argument, first, last ) {
                                    var simple = type.slice( 0, 3 ) !== "nth",
                                        forward = type.slice( -4 ) !== "last",
                                        ofType = what === "of-type";
                                    
                                    return first === 1 && last === 0 ?
                                        
                                        // Shortcut for :nth-*(n)
                                        function( elem ) {
                                            return !!elem.parentNode;
                                        } :
                                        
                                        function( elem, context, xml ) {
                                            var cache, outerCache, node, diff, nodeIndex, start,
                                                dir = simple !== forward ? "nextSibling" : "previousSibling",
                                                parent = elem.parentNode,
                                                name = ofType && elem.nodeName.toLowerCase(),
                                                useCache = !xml && !ofType;
                                            
                                            if ( parent ) {
                                                
                                                // :(first|last|only)-(child|of-type)
                                                if ( simple ) {
                                                    while ( dir ) {
                                                        node = elem;
                                                        while ( (node = node[ dir ]) ) {
                                                            if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                                                return false;
                                                            }
                                                        }
                                                        // Reverse direction for :only-* (if we haven't yet done so)
                                                        start = dir = type === "only" && !start && "nextSibling";
                                                    }
                                                    return true;
                                                }
                                                
                                                start = [ forward ? parent.firstChild : parent.lastChild ];
                                                
                                                // non-xml :nth-child(...) stores cache data on `parent`
                                                if ( forward && useCache ) {
                                                    // Seek `elem` from a previously-cached index
                                                    outerCache = parent[ expando ] || (parent[ expando ] = {});
                                                    cache = outerCache[ type ] || [];
                                                    nodeIndex = cache[0] === dirruns && cache[1];
                                                    diff = cache[0] === dirruns && cache[2];
                                                    node = nodeIndex && parent.childNodes[ nodeIndex ];
                                                    
                                                    while ( (node = ++nodeIndex && node && node[ dir ] ||
                                                            
                                                            // Fallback to seeking `elem` from the start
                                                        (diff = nodeIndex = 0) || start.pop()) ) {
                                                        
                                                        // When found, cache indexes on `parent` and break
                                                        if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                            outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                            break;
                                                        }
                                                    }
                                                    
                                                    // Use previously-cached element index if available
                                                } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                                                    diff = cache[1];
                                                    
                                                    // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                } else {
                                                    // Use the same loop as above to seek `elem` from the start
                                                    while ( (node = ++nodeIndex && node && node[ dir ] ||
                                                        (diff = nodeIndex = 0) || start.pop()) ) {
                                                        
                                                        if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                                            // Cache the index of each encountered element
                                                            if ( useCache ) {
                                                                (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                                            }
                                                            
                                                            if ( node === elem ) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                
                                                // Incorporate the offset, then check against cycle size
                                                diff -= last;
                                                return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                            }
                                        };
                                },
                                
                                "PSEUDO": function( pseudo, argument ) {
                                    // pseudo-class names are case-insensitive
                                    // http://www.w3.org/TR/selectors/#pseudo-classes
                                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                    // Remember that setFilters inherits from pseudos
                                    var args,
                                        fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                            Sizzle.error( "unsupported pseudo: " + pseudo );
                                    
                                    // The user may use createPseudo to indicate that
                                    // arguments are needed to create the filter function
                                    // just as Sizzle does
                                    if ( fn[ expando ] ) {
                                        return fn( argument );
                                    }
                                    
                                    // But maintain support for old signatures
                                    if ( fn.length > 1 ) {
                                        args = [ pseudo, pseudo, "", argument ];
                                        return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                            markFunction(function( seed, matches ) {
                                                var idx,
                                                    matched = fn( seed, argument ),
                                                    i = matched.length;
                                                while ( i-- ) {
                                                    idx = indexOf( seed, matched[i] );
                                                    seed[ idx ] = !( matches[ idx ] = matched[i] );
                                                }
                                            }) :
                                            function( elem ) {
                                                return fn( elem, 0, args );
                                            };
                                    }
                                    
                                    return fn;
                                }
                            },
                            
                            pseudos: {
                                // Potentially complex pseudos
                                "not": markFunction(function( selector ) {
                                    // Trim the selector passed to compile
                                    // to avoid treating leading and trailing
                                    // spaces as combinators
                                    var input = [],
                                        results = [],
                                        matcher = compile( selector.replace( rtrim, "$1" ) );
                                    
                                    return matcher[ expando ] ?
                                        markFunction(function( seed, matches, context, xml ) {
                                            var elem,
                                                unmatched = matcher( seed, null, xml, [] ),
                                                i = seed.length;
                                            
                                            // Match elements unmatched by `matcher`
                                            while ( i-- ) {
                                                if ( (elem = unmatched[i]) ) {
                                                    seed[i] = !(matches[i] = elem);
                                                }
                                            }
                                        }) :
                                        function( elem, context, xml ) {
                                            input[0] = elem;
                                            matcher( input, null, xml, results );
                                            // Don't keep the element (issue #299)
                                            input[0] = null;
                                            return !results.pop();
                                        };
                                }),
                                
                                "has": markFunction(function( selector ) {
                                    return function( elem ) {
                                        return Sizzle( selector, elem ).length > 0;
                                    };
                                }),
                                
                                "contains": markFunction(function( text ) {
                                    text = text.replace( runescape, funescape );
                                    return function( elem ) {
                                        return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                                    };
                                }),
                                
                                // "Whether an element is represented by a :lang() selector
                                // is based solely on the element's language value
                                // being equal to the identifier C,
                                // or beginning with the identifier C immediately followed by "-".
                                // The matching of C against the element's language value is performed case-insensitively.
                                // The identifier C does not have to be a valid language name."
                                // http://www.w3.org/TR/selectors/#lang-pseudo
                                "lang": markFunction( function( lang ) {
                                    // lang value must be a valid identifier
                                    if ( !ridentifier.test(lang || "") ) {
                                        Sizzle.error( "unsupported lang: " + lang );
                                    }
                                    lang = lang.replace( runescape, funescape ).toLowerCase();
                                    return function( elem ) {
                                        var elemLang;
                                        do {
                                            if ( (elemLang = documentIsHTML ?
                                                    elem.lang :
                                                elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
                                                
                                                elemLang = elemLang.toLowerCase();
                                                return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                            }
                                        } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                                        return false;
                                    };
                                }),
                                
                                // Miscellaneous
                                "target": function( elem ) {
                                    var hash = window.location && window.location.hash;
                                    return hash && hash.slice( 1 ) === elem.id;
                                },
                                
                                "root": function( elem ) {
                                    return elem === docElem;
                                },
                                
                                "focus": function( elem ) {
                                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                                },
                                
                                // Boolean properties
                                "enabled": function( elem ) {
                                    return elem.disabled === false;
                                },
                                
                                "disabled": function( elem ) {
                                    return elem.disabled === true;
                                },
                                
                                "checked": function( elem ) {
                                    // In CSS3, :checked should return both checked and selected elements
                                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                    var nodeName = elem.nodeName.toLowerCase();
                                    return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                                },
                                
                                "selected": function( elem ) {
                                    // Accessing this property makes selected-by-default
                                    // options in Safari work properly
                                    if ( elem.parentNode ) {
                                        elem.parentNode.selectedIndex;
                                    }
                                    
                                    return elem.selected === true;
                                },
                                
                                // Contents
                                "empty": function( elem ) {
                                    // http://www.w3.org/TR/selectors/#empty-pseudo
                                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                                    // nodeType < 6 works because attributes (2) do not appear as children
                                    for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                        if ( elem.nodeType < 6 ) {
                                            return false;
                                        }
                                    }
                                    return true;
                                },
                                
                                "parent": function( elem ) {
                                    return !Expr.pseudos["empty"]( elem );
                                },
                                
                                // Element/input types
                                "header": function( elem ) {
                                    return rheader.test( elem.nodeName );
                                },
                                
                                "input": function( elem ) {
                                    return rinputs.test( elem.nodeName );
                                },
                                
                                "button": function( elem ) {
                                    var name = elem.nodeName.toLowerCase();
                                    return name === "input" && elem.type === "button" || name === "button";
                                },
                                
                                "text": function( elem ) {
                                    var attr;
                                    return elem.nodeName.toLowerCase() === "input" &&
                                        elem.type === "text" &&
                                            
                                            // Support: IE<8
                                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                        ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                                },
                                
                                // Position-in-collection
                                "first": createPositionalPseudo(function() {
                                    return [ 0 ];
                                }),
                                
                                "last": createPositionalPseudo(function( matchIndexes, length ) {
                                    return [ length - 1 ];
                                }),
                                
                                "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                    return [ argument < 0 ? argument + length : argument ];
                                }),
                                
                                "even": createPositionalPseudo(function( matchIndexes, length ) {
                                    var i = 0;
                                    for ( ; i < length; i += 2 ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                }),
                                
                                "odd": createPositionalPseudo(function( matchIndexes, length ) {
                                    var i = 1;
                                    for ( ; i < length; i += 2 ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                }),
                                
                                "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                    var i = argument < 0 ? argument + length : argument;
                                    for ( ; --i >= 0; ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                }),
                                
                                "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                    var i = argument < 0 ? argument + length : argument;
                                    for ( ; ++i < length; ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                })
                            }
                        };
                        
                        Expr.pseudos["nth"] = Expr.pseudos["eq"];
                        
                        // Add button/input type pseudos
                        for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                            Expr.pseudos[ i ] = createInputPseudo( i );
                        }
                        for ( i in { submit: true, reset: true } ) {
                            Expr.pseudos[ i ] = createButtonPseudo( i );
                        }
                        
                        // Easy API for creating new setFilters
                        function setFilters() {}
                        setFilters.prototype = Expr.filters = Expr.pseudos;
                        Expr.setFilters = new setFilters();
                        
                        tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                            var matched, match, tokens, type,
                                soFar, groups, preFilters,
                                cached = tokenCache[ selector + " " ];
                            
                            if ( cached ) {
                                return parseOnly ? 0 : cached.slice( 0 );
                            }
                            
                            soFar = selector;
                            groups = [];
                            preFilters = Expr.preFilter;
                            
                            while ( soFar ) {
                                
                                // Comma and first run
                                if ( !matched || (match = rcomma.exec( soFar )) ) {
                                    if ( match ) {
                                        // Don't consume trailing commas as valid
                                        soFar = soFar.slice( match[0].length ) || soFar;
                                    }
                                    groups.push( (tokens = []) );
                                }
                                
                                matched = false;
                                
                                // Combinators
                                if ( (match = rcombinators.exec( soFar )) ) {
                                    matched = match.shift();
                                    tokens.push({
                                        value: matched,
                                        // Cast descendant combinators to space
                                        type: match[0].replace( rtrim, " " )
                                    });
                                    soFar = soFar.slice( matched.length );
                                }
                                
                                // Filters
                                for ( type in Expr.filter ) {
                                    if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                                        (match = preFilters[ type ]( match ))) ) {
                                        matched = match.shift();
                                        tokens.push({
                                            value: matched,
                                            type: type,
                                            matches: match
                                        });
                                        soFar = soFar.slice( matched.length );
                                    }
                                }
                                
                                if ( !matched ) {
                                    break;
                                }
                            }
                            
                            // Return the length of the invalid excess
                            // if we're just parsing
                            // Otherwise, throw an error or return tokens
                            return parseOnly ?
                                soFar.length :
                                soFar ?
                                    Sizzle.error( selector ) :
                                    // Cache the tokens
                                    tokenCache( selector, groups ).slice( 0 );
                        };
                        
                        function toSelector( tokens ) {
                            var i = 0,
                                len = tokens.length,
                                selector = "";
                            for ( ; i < len; i++ ) {
                                selector += tokens[i].value;
                            }
                            return selector;
                        }
                        
                        function addCombinator( matcher, combinator, base ) {
                            var dir = combinator.dir,
                                checkNonElements = base && dir === "parentNode",
                                doneName = done++;
                            
                            return combinator.first ?
                                // Check against closest ancestor/preceding element
                                function( elem, context, xml ) {
                                    while ( (elem = elem[ dir ]) ) {
                                        if ( elem.nodeType === 1 || checkNonElements ) {
                                            return matcher( elem, context, xml );
                                        }
                                    }
                                } :
                                
                                // Check against all ancestor/preceding elements
                                function( elem, context, xml ) {
                                    var oldCache, outerCache,
                                        newCache = [ dirruns, doneName ];
                                    
                                    // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                                    if ( xml ) {
                                        while ( (elem = elem[ dir ]) ) {
                                            if ( elem.nodeType === 1 || checkNonElements ) {
                                                if ( matcher( elem, context, xml ) ) {
                                                    return true;
                                                }
                                            }
                                        }
                                    } else {
                                        while ( (elem = elem[ dir ]) ) {
                                            if ( elem.nodeType === 1 || checkNonElements ) {
                                                outerCache = elem[ expando ] || (elem[ expando ] = {});
                                                if ( (oldCache = outerCache[ dir ]) &&
                                                    oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
                                                    
                                                    // Assign to newCache so results back-propagate to previous elements
                                                    return (newCache[ 2 ] = oldCache[ 2 ]);
                                                } else {
                                                    // Reuse newcache so results back-propagate to previous elements
                                                    outerCache[ dir ] = newCache;
                                                    
                                                    // A match means we're done; a fail means we have to keep checking
                                                    if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                                        return true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                };
                        }
                        
                        function elementMatcher( matchers ) {
                            return matchers.length > 1 ?
                                function( elem, context, xml ) {
                                    var i = matchers.length;
                                    while ( i-- ) {
                                        if ( !matchers[i]( elem, context, xml ) ) {
                                            return false;
                                        }
                                    }
                                    return true;
                                } :
                                matchers[0];
                        }
                        
                        function multipleContexts( selector, contexts, results ) {
                            var i = 0,
                                len = contexts.length;
                            for ( ; i < len; i++ ) {
                                Sizzle( selector, contexts[i], results );
                            }
                            return results;
                        }
                        
                        function condense( unmatched, map, filter, context, xml ) {
                            var elem,
                                newUnmatched = [],
                                i = 0,
                                len = unmatched.length,
                                mapped = map != null;
                            
                            for ( ; i < len; i++ ) {
                                if ( (elem = unmatched[i]) ) {
                                    if ( !filter || filter( elem, context, xml ) ) {
                                        newUnmatched.push( elem );
                                        if ( mapped ) {
                                            map.push( i );
                                        }
                                    }
                                }
                            }
                            
                            return newUnmatched;
                        }
                        
                        function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                            if ( postFilter && !postFilter[ expando ] ) {
                                postFilter = setMatcher( postFilter );
                            }
                            if ( postFinder && !postFinder[ expando ] ) {
                                postFinder = setMatcher( postFinder, postSelector );
                            }
                            return markFunction(function( seed, results, context, xml ) {
                                var temp, i, elem,
                                    preMap = [],
                                    postMap = [],
                                    preexisting = results.length,
                                
                                // Get initial elements from seed or context
                                    elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
                                
                                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                    matcherIn = preFilter && ( seed || !selector ) ?
                                        condense( elems, preMap, preFilter, context, xml ) :
                                        elems,
                                    
                                    matcherOut = matcher ?
                                        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
                                            
                                            // ...intermediate processing is necessary
                                            [] :
                                            
                                            // ...otherwise use results directly
                                            results :
                                        matcherIn;
                                
                                // Find primary matches
                                if ( matcher ) {
                                    matcher( matcherIn, matcherOut, context, xml );
                                }
                                
                                // Apply postFilter
                                if ( postFilter ) {
                                    temp = condense( matcherOut, postMap );
                                    postFilter( temp, [], context, xml );
                                    
                                    // Un-match failing elements by moving them back to matcherIn
                                    i = temp.length;
                                    while ( i-- ) {
                                        if ( (elem = temp[i]) ) {
                                            matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                                        }
                                    }
                                }
                                
                                if ( seed ) {
                                    if ( postFinder || preFilter ) {
                                        if ( postFinder ) {
                                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                            temp = [];
                                            i = matcherOut.length;
                                            while ( i-- ) {
                                                if ( (elem = matcherOut[i]) ) {
                                                    // Restore matcherIn since elem is not yet a final match
                                                    temp.push( (matcherIn[i] = elem) );
                                                }
                                            }
                                            postFinder( null, (matcherOut = []), temp, xml );
                                        }
                                        
                                        // Move matched elements from seed to results to keep them synchronized
                                        i = matcherOut.length;
                                        while ( i-- ) {
                                            if ( (elem = matcherOut[i]) &&
                                                (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
                                                
                                                seed[temp] = !(results[temp] = elem);
                                            }
                                        }
                                    }
                                    
                                    // Add elements to results, through postFinder if defined
                                } else {
                                    matcherOut = condense(
                                        matcherOut === results ?
                                            matcherOut.splice( preexisting, matcherOut.length ) :
                                            matcherOut
                                    );
                                    if ( postFinder ) {
                                        postFinder( null, results, matcherOut, xml );
                                    } else {
                                        push.apply( results, matcherOut );
                                    }
                                }
                            });
                        }
                        
                        function matcherFromTokens( tokens ) {
                            var checkContext, matcher, j,
                                len = tokens.length,
                                leadingRelative = Expr.relative[ tokens[0].type ],
                                implicitRelative = leadingRelative || Expr.relative[" "],
                                i = leadingRelative ? 1 : 0,
                            
                            // The foundational matcher ensures that elements are reachable from top-level context(s)
                                matchContext = addCombinator( function( elem ) {
                                    return elem === checkContext;
                                }, implicitRelative, true ),
                                matchAnyContext = addCombinator( function( elem ) {
                                    return indexOf( checkContext, elem ) > -1;
                                }, implicitRelative, true ),
                                matchers = [ function( elem, context, xml ) {
                                    var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                                            (checkContext = context).nodeType ?
                                                matchContext( elem, context, xml ) :
                                                matchAnyContext( elem, context, xml ) );
                                    // Avoid hanging onto element (issue #299)
                                    checkContext = null;
                                    return ret;
                                } ];
                            
                            for ( ; i < len; i++ ) {
                                if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                                    matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                                } else {
                                    matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
                                    
                                    // Return special upon seeing a positional matcher
                                    if ( matcher[ expando ] ) {
                                        // Find the next relative operator (if any) for proper handling
                                        j = ++i;
                                        for ( ; j < len; j++ ) {
                                            if ( Expr.relative[ tokens[j].type ] ) {
                                                break;
                                            }
                                        }
                                        return setMatcher(
                                            i > 1 && elementMatcher( matchers ),
                                            i > 1 && toSelector(
                                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                                tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                                            ).replace( rtrim, "$1" ),
                                            matcher,
                                            i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                            j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                            j < len && toSelector( tokens )
                                        );
                                    }
                                    matchers.push( matcher );
                                }
                            }
                            
                            return elementMatcher( matchers );
                        }
                        
                        function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                            var bySet = setMatchers.length > 0,
                                byElement = elementMatchers.length > 0,
                                superMatcher = function( seed, context, xml, results, outermost ) {
                                    var elem, j, matcher,
                                        matchedCount = 0,
                                        i = "0",
                                        unmatched = seed && [],
                                        setMatched = [],
                                        contextBackup = outermostContext,
                                    // We must always have either seed elements or outermost context
                                        elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                                    // Use integer dirruns iff this is the outermost matcher
                                        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                        len = elems.length;
                                    
                                    if ( outermost ) {
                                        outermostContext = context !== document && context;
                                    }
                                    
                                    // Add elements passing elementMatchers directly to results
                                    // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                                    // Support: IE<9, Safari
                                    // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                    for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                                        if ( byElement && elem ) {
                                            j = 0;
                                            while ( (matcher = elementMatchers[j++]) ) {
                                                if ( matcher( elem, context, xml ) ) {
                                                    results.push( elem );
                                                    break;
                                                }
                                            }
                                            if ( outermost ) {
                                                dirruns = dirrunsUnique;
                                            }
                                        }
                                        
                                        // Track unmatched elements for set filters
                                        if ( bySet ) {
                                            // They will have gone through all possible matchers
                                            if ( (elem = !matcher && elem) ) {
                                                matchedCount--;
                                            }
                                            
                                            // Lengthen the array for every element, matched or not
                                            if ( seed ) {
                                                unmatched.push( elem );
                                            }
                                        }
                                    }
                                    
                                    // Apply set filters to unmatched elements
                                    matchedCount += i;
                                    if ( bySet && i !== matchedCount ) {
                                        j = 0;
                                        while ( (matcher = setMatchers[j++]) ) {
                                            matcher( unmatched, setMatched, context, xml );
                                        }
                                        
                                        if ( seed ) {
                                            // Reintegrate element matches to eliminate the need for sorting
                                            if ( matchedCount > 0 ) {
                                                while ( i-- ) {
                                                    if ( !(unmatched[i] || setMatched[i]) ) {
                                                        setMatched[i] = pop.call( results );
                                                    }
                                                }
                                            }
                                            
                                            // Discard index placeholder values to get only actual matches
                                            setMatched = condense( setMatched );
                                        }
                                        
                                        // Add matches to results
                                        push.apply( results, setMatched );
                                        
                                        // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                        if ( outermost && !seed && setMatched.length > 0 &&
                                            ( matchedCount + setMatchers.length ) > 1 ) {
                                            
                                            Sizzle.uniqueSort( results );
                                        }
                                    }
                                    
                                    // Override manipulation of globals by nested matchers
                                    if ( outermost ) {
                                        dirruns = dirrunsUnique;
                                        outermostContext = contextBackup;
                                    }
                                    
                                    return unmatched;
                                };
                            
                            return bySet ?
                                markFunction( superMatcher ) :
                                superMatcher;
                        }
                        
                        compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                            var i,
                                setMatchers = [],
                                elementMatchers = [],
                                cached = compilerCache[ selector + " " ];
                            
                            if ( !cached ) {
                                // Generate a function of recursive functions that can be used to check each element
                                if ( !match ) {
                                    match = tokenize( selector );
                                }
                                i = match.length;
                                while ( i-- ) {
                                    cached = matcherFromTokens( match[i] );
                                    if ( cached[ expando ] ) {
                                        setMatchers.push( cached );
                                    } else {
                                        elementMatchers.push( cached );
                                    }
                                }
                                
                                // Cache the compiled function
                                cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
                                
                                // Save selector and tokenization
                                cached.selector = selector;
                            }
                            return cached;
                        };
                        
                        /**
                         * A low-level selection function that works with Sizzle's compiled
                         *  selector functions
                         * @param {String|Function} selector A selector or a pre-compiled
                         *  selector function built with Sizzle.compile
                         * @param {Element} context
                         * @param {Array} [results]
                         * @param {Array} [seed] A set of elements to match against
                         */
                        select = Sizzle.select = function( selector, context, results, seed ) {
                            var i, tokens, token, type, find,
                                compiled = typeof selector === "function" && selector,
                                match = !seed && tokenize( (selector = compiled.selector || selector) );
                            
                            results = results || [];
                            
                            // Try to minimize operations if there is no seed and only one group
                            if ( match.length === 1 ) {
                                
                                // Take a shortcut and set the context if the root selector is an ID
                                tokens = match[0] = match[0].slice( 0 );
                                if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                    support.getById && context.nodeType === 9 && documentIsHTML &&
                                    Expr.relative[ tokens[1].type ] ) {
                                    
                                    context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                                    if ( !context ) {
                                        return results;
                                        
                                        // Precompiled matchers will still verify ancestry, so step up a level
                                    } else if ( compiled ) {
                                        context = context.parentNode;
                                    }
                                    
                                    selector = selector.slice( tokens.shift().value.length );
                                }
                                
                                // Fetch a seed set for right-to-left matching
                                i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                                while ( i-- ) {
                                    token = tokens[i];
                                    
                                    // Abort if we hit a combinator
                                    if ( Expr.relative[ (type = token.type) ] ) {
                                        break;
                                    }
                                    if ( (find = Expr.find[ type ]) ) {
                                        // Search, expanding context for leading sibling combinators
                                        if ( (seed = find(
                                                token.matches[0].replace( runescape, funescape ),
                                                rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                                            )) ) {
                                            
                                            // If seed is empty or no tokens remain, we can return early
                                            tokens.splice( i, 1 );
                                            selector = seed.length && toSelector( tokens );
                                            if ( !selector ) {
                                                push.apply( results, seed );
                                                return results;
                                            }
                                            
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            // Compile and execute a filtering function if one is not provided
                            // Provide `match` to avoid retokenization if we modified the selector above
                            ( compiled || compile( selector, match ) )(
                                seed,
                                context,
                                !documentIsHTML,
                                results,
                                rsibling.test( selector ) && testContext( context.parentNode ) || context
                            );
                            return results;
                        };
                        
                        // One-time assignments
                        
                        // Sort stability
                        support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
                        
                        // Support: Chrome 14-35+
                        // Always assume duplicates if they aren't passed to the comparison function
                        support.detectDuplicates = !!hasDuplicate;
                        
                        // Initialize against the default document
                        setDocument();
                        
                        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                        // Detached nodes confoundingly follow *each other*
                        support.sortDetached = assert(function( div1 ) {
                            // Should return 1, but returns 4 (following)
                            return div1.compareDocumentPosition( document.createElement("div") ) & 1;
                        });
                        
                        // Support: IE<8
                        // Prevent attribute/property "interpolation"
                        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                        if ( !assert(function( div ) {
                                div.innerHTML = "<a href='#'></a>";
                                return div.firstChild.getAttribute("href") === "#" ;
                            }) ) {
                            addHandle( "type|href|height|width", function( elem, name, isXML ) {
                                if ( !isXML ) {
                                    return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                                }
                            });
                        }
                        
                        // Support: IE<9
                        // Use defaultValue in place of getAttribute("value")
                        if ( !support.attributes || !assert(function( div ) {
                                div.innerHTML = "<input/>";
                                div.firstChild.setAttribute( "value", "" );
                                return div.firstChild.getAttribute( "value" ) === "";
                            }) ) {
                            addHandle( "value", function( elem, name, isXML ) {
                                if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                                    return elem.defaultValue;
                                }
                            });
                        }
                        
                        // Support: IE<9
                        // Use getAttributeNode to fetch booleans when getAttribute lies
                        if ( !assert(function( div ) {
                                return div.getAttribute("disabled") == null;
                            }) ) {
                            addHandle( booleans, function( elem, name, isXML ) {
                                var val;
                                if ( !isXML ) {
                                    return elem[ name ] === true ? name.toLowerCase() :
                                        (val = elem.getAttributeNode( name )) && val.specified ?
                                            val.value :
                                            null;
                                }
                            });
                        }
                        
                        return Sizzle;
                        
                    })( window );
                
                
                
                jQuery.find = Sizzle;
                jQuery.expr = Sizzle.selectors;
                jQuery.expr[":"] = jQuery.expr.pseudos;
                jQuery.unique = Sizzle.uniqueSort;
                jQuery.text = Sizzle.getText;
                jQuery.isXMLDoc = Sizzle.isXML;
                jQuery.contains = Sizzle.contains;
                
                
                
                var rneedsContext = jQuery.expr.match.needsContext;
                
                var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
                
                
                
                var risSimple = /^.[^:#\[\.,]*$/;
                
                // Implement the identical functionality for filter and not
                function winnow( elements, qualifier, not ) {
                    if ( jQuery.isFunction( qualifier ) ) {
                        return jQuery.grep( elements, function( elem, i ) {
                            /* jshint -W018 */
                            return !!qualifier.call( elem, i, elem ) !== not;
                        });
                        
                    }
                    
                    if ( qualifier.nodeType ) {
                        return jQuery.grep( elements, function( elem ) {
                            return ( elem === qualifier ) !== not;
                        });
                        
                    }
                    
                    if ( typeof qualifier === "string" ) {
                        if ( risSimple.test( qualifier ) ) {
                            return jQuery.filter( qualifier, elements, not );
                        }
                        
                        qualifier = jQuery.filter( qualifier, elements );
                    }
                    
                    return jQuery.grep( elements, function( elem ) {
                        return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
                    });
                }
                
                jQuery.filter = function( expr, elems, not ) {
                    var elem = elems[ 0 ];
                    
                    if ( not ) {
                        expr = ":not(" + expr + ")";
                    }
                    
                    return elems.length === 1 && elem.nodeType === 1 ?
                        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
                        jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                            return elem.nodeType === 1;
                        }));
                };
                
                jQuery.fn.extend({
                    find: function( selector ) {
                        var i,
                            len = this.length,
                            ret = [],
                            self = this;
                        
                        if ( typeof selector !== "string" ) {
                            return this.pushStack( jQuery( selector ).filter(function() {
                                for ( i = 0; i < len; i++ ) {
                                    if ( jQuery.contains( self[ i ], this ) ) {
                                        return true;
                                    }
                                }
                            }) );
                        }
                        
                        for ( i = 0; i < len; i++ ) {
                            jQuery.find( selector, self[ i ], ret );
                        }
                        
                        // Needed because $( selector, context ) becomes $( context ).find( selector )
                        ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
                        ret.selector = this.selector ? this.selector + " " + selector : selector;
                        return ret;
                    },
                    filter: function( selector ) {
                        return this.pushStack( winnow(this, selector || [], false) );
                    },
                    not: function( selector ) {
                        return this.pushStack( winnow(this, selector || [], true) );
                    },
                    is: function( selector ) {
                        return !!winnow(
                            this,
                            
                            // If this is a positional/relative selector, check membership in the returned set
                            // so $("p:first").is("p:last") won't return true for a doc with two "p".
                            typeof selector === "string" && rneedsContext.test( selector ) ?
                                jQuery( selector ) :
                            selector || [],
                            false
                        ).length;
                    }
                });
                
                
                // Initialize a jQuery object
                
                
                // A central reference to the root jQuery(document)
                var rootjQuery,
                
                // A simple way to check for HTML strings
                // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                // Strict HTML recognition (#11290: must start with <)
                    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
                    
                    init = jQuery.fn.init = function( selector, context ) {
                        var match, elem;
                        
                        // HANDLE: $(""), $(null), $(undefined), $(false)
                        if ( !selector ) {
                            return this;
                        }
                        
                        // Handle HTML strings
                        if ( typeof selector === "string" ) {
                            if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
                                // Assume that strings that start and end with <> are HTML and skip the regex check
                                match = [ null, selector, null ];
                                
                            } else {
                                match = rquickExpr.exec( selector );
                            }
                            
                            // Match html or make sure no context is specified for #id
                            if ( match && (match[1] || !context) ) {
                                
                                // HANDLE: $(html) -> $(array)
                                if ( match[1] ) {
                                    context = context instanceof jQuery ? context[0] : context;
                                    
                                    // Option to run scripts is true for back-compat
                                    // Intentionally let the error be thrown if parseHTML is not present
                                    jQuery.merge( this, jQuery.parseHTML(
                                        match[1],
                                        context && context.nodeType ? context.ownerDocument || context : document,
                                        true
                                    ) );
                                    
                                    // HANDLE: $(html, props)
                                    if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                                        for ( match in context ) {
                                            // Properties of context are called as methods if possible
                                            if ( jQuery.isFunction( this[ match ] ) ) {
                                                this[ match ]( context[ match ] );
                                                
                                                // ...and otherwise set as attributes
                                            } else {
                                                this.attr( match, context[ match ] );
                                            }
                                        }
                                    }
                                    
                                    return this;
                                    
                                    // HANDLE: $(#id)
                                } else {
                                    elem = document.getElementById( match[2] );
                                    
                                    // Support: Blackberry 4.6
                                    // gEBID returns nodes no longer in the document (#6963)
                                    if ( elem && elem.parentNode ) {
                                        // Inject the element directly into the jQuery object
                                        this.length = 1;
                                        this[0] = elem;
                                    }
                                    
                                    this.context = document;
                                    this.selector = selector;
                                    return this;
                                }
                                
                                // HANDLE: $(expr, $(...))
                            } else if ( !context || context.jquery ) {
                                return ( context || rootjQuery ).find( selector );
                                
                                // HANDLE: $(expr, context)
                                // (which is just equivalent to: $(context).find(expr)
                            } else {
                                return this.constructor( context ).find( selector );
                            }
                            
                            // HANDLE: $(DOMElement)
                        } else if ( selector.nodeType ) {
                            this.context = this[0] = selector;
                            this.length = 1;
                            return this;
                            
                            // HANDLE: $(function)
                            // Shortcut for document ready
                        } else if ( jQuery.isFunction( selector ) ) {
                            return typeof rootjQuery.ready !== "undefined" ?
                                rootjQuery.ready( selector ) :
                                // Execute immediately if ready is not present
                                selector( jQuery );
                        }
                        
                        if ( selector.selector !== undefined ) {
                            this.selector = selector.selector;
                            this.context = selector.context;
                        }
                        
                        return jQuery.makeArray( selector, this );
                    };
                
                // Give the init function the jQuery prototype for later instantiation
                init.prototype = jQuery.fn;
                
                // Initialize central reference
                rootjQuery = jQuery( document );
                
                
                var rparentsprev = /^(?:parents|prev(?:Until|All))/,
                // Methods guaranteed to produce a unique set when starting from a unique set
                    guaranteedUnique = {
                        children: true,
                        contents: true,
                        next: true,
                        prev: true
                    };
                
                jQuery.extend({
                    dir: function( elem, dir, until ) {
                        var matched = [],
                            truncate = until !== undefined;
                        
                        while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
                            if ( elem.nodeType === 1 ) {
                                if ( truncate && jQuery( elem ).is( until ) ) {
                                    break;
                                }
                                matched.push( elem );
                            }
                        }
                        return matched;
                    },
                    
                    sibling: function( n, elem ) {
                        var matched = [];
                        
                        for ( ; n; n = n.nextSibling ) {
                            if ( n.nodeType === 1 && n !== elem ) {
                                matched.push( n );
                            }
                        }
                        
                        return matched;
                    }
                });
                
                jQuery.fn.extend({
                    has: function( target ) {
                        var targets = jQuery( target, this ),
                            l = targets.length;
                        
                        return this.filter(function() {
                            var i = 0;
                            for ( ; i < l; i++ ) {
                                if ( jQuery.contains( this, targets[i] ) ) {
                                    return true;
                                }
                            }
                        });
                    },
                    
                    closest: function( selectors, context ) {
                        var cur,
                            i = 0,
                            l = this.length,
                            matched = [],
                            pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                                jQuery( selectors, context || this.context ) :
                                0;
                        
                        for ( ; i < l; i++ ) {
                            for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                                // Always skip document fragments
                                if ( cur.nodeType < 11 && (pos ?
                                    pos.index(cur) > -1 :
                                        
                                        // Don't pass non-elements to Sizzle
                                    cur.nodeType === 1 &&
                                    jQuery.find.matchesSelector(cur, selectors)) ) {
                                    
                                    matched.push( cur );
                                    break;
                                }
                            }
                        }
                        
                        return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
                    },
                    
                    // Determine the position of an element within the set
                    index: function( elem ) {
                        
                        // No argument, return index in parent
                        if ( !elem ) {
                            return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
                        }
                        
                        // Index in selector
                        if ( typeof elem === "string" ) {
                            return indexOf.call( jQuery( elem ), this[ 0 ] );
                        }
                        
                        // Locate the position of the desired element
                        return indexOf.call( this,
                            
                            // If it receives a jQuery object, the first element is used
                            elem.jquery ? elem[ 0 ] : elem
                        );
                    },
                    
                    add: function( selector, context ) {
                        return this.pushStack(
                            jQuery.unique(
                                jQuery.merge( this.get(), jQuery( selector, context ) )
                            )
                        );
                    },
                    
                    addBack: function( selector ) {
                        return this.add( selector == null ?
                                this.prevObject : this.prevObject.filter(selector)
                        );
                    }
                });
                
                function sibling( cur, dir ) {
                    while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
                    return cur;
                }
                
                jQuery.each({
                    parent: function( elem ) {
                        var parent = elem.parentNode;
                        return parent && parent.nodeType !== 11 ? parent : null;
                    },
                    parents: function( elem ) {
                        return jQuery.dir( elem, "parentNode" );
                    },
                    parentsUntil: function( elem, i, until ) {
                        return jQuery.dir( elem, "parentNode", until );
                    },
                    next: function( elem ) {
                        return sibling( elem, "nextSibling" );
                    },
                    prev: function( elem ) {
                        return sibling( elem, "previousSibling" );
                    },
                    nextAll: function( elem ) {
                        return jQuery.dir( elem, "nextSibling" );
                    },
                    prevAll: function( elem ) {
                        return jQuery.dir( elem, "previousSibling" );
                    },
                    nextUntil: function( elem, i, until ) {
                        return jQuery.dir( elem, "nextSibling", until );
                    },
                    prevUntil: function( elem, i, until ) {
                        return jQuery.dir( elem, "previousSibling", until );
                    },
                    siblings: function( elem ) {
                        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
                    },
                    children: function( elem ) {
                        return jQuery.sibling( elem.firstChild );
                    },
                    contents: function( elem ) {
                        return elem.contentDocument || jQuery.merge( [], elem.childNodes );
                    }
                }, function( name, fn ) {
                    jQuery.fn[ name ] = function( until, selector ) {
                        var matched = jQuery.map( this, fn, until );
                        
                        if ( name.slice( -5 ) !== "Until" ) {
                            selector = until;
                        }
                        
                        if ( selector && typeof selector === "string" ) {
                            matched = jQuery.filter( selector, matched );
                        }
                        
                        if ( this.length > 1 ) {
                            // Remove duplicates
                            if ( !guaranteedUnique[ name ] ) {
                                jQuery.unique( matched );
                            }
                            
                            // Reverse order for parents* and prev-derivatives
                            if ( rparentsprev.test( name ) ) {
                                matched.reverse();
                            }
                        }
                        
                        return this.pushStack( matched );
                    };
                });
                var rnotwhite = (/\S+/g);
                
                
                
                // String to Object options format cache
                var optionsCache = {};
                
                // Convert String-formatted options into Object-formatted ones and store in cache
                function createOptions( options ) {
                    var object = optionsCache[ options ] = {};
                    jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
                        object[ flag ] = true;
                    });
                    return object;
                }
                
                /*
                 * Create a callback list using the following parameters:
                 *
                 *	options: an optional list of space-separated options that will change how
                 *			the callback list behaves or a more traditional option object
                 *
                 * By default a callback list will act like an event callback list and can be
                 * "fired" multiple times.
                 *
                 * Possible options:
                 *
                 *	once:			will ensure the callback list can only be fired once (like a Deferred)
                 *
                 *	memory:			will keep track of previous values and will call any callback added
                 *					after the list has been fired right away with the latest "memorized"
                 *					values (like a Deferred)
                 *
                 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
                 *
                 *	stopOnFalse:	interrupt callings when a callback returns false
                 *
                 */
                jQuery.Callbacks = function( options ) {
                    
                    // Convert options from String-formatted to Object-formatted if needed
                    // (we check in cache first)
                    options = typeof options === "string" ?
                        ( optionsCache[ options ] || createOptions( options ) ) :
                        jQuery.extend( {}, options );
                    
                    var // Last fire value (for non-forgettable lists)
                        memory,
                    // Flag to know if list was already fired
                        fired,
                    // Flag to know if list is currently firing
                        firing,
                    // First callback to fire (used internally by add and fireWith)
                        firingStart,
                    // End of the loop when firing
                        firingLength,
                    // Index of currently firing callback (modified by remove if needed)
                        firingIndex,
                    // Actual callback list
                        list = [],
                    // Stack of fire calls for repeatable lists
                        stack = !options.once && [],
                    // Fire callbacks
                        fire = function( data ) {
                            memory = options.memory && data;
                            fired = true;
                            firingIndex = firingStart || 0;
                            firingStart = 0;
                            firingLength = list.length;
                            firing = true;
                            for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                                    memory = false; // To prevent further calls using add
                                    break;
                                }
                            }
                            firing = false;
                            if ( list ) {
                                if ( stack ) {
                                    if ( stack.length ) {
                                        fire( stack.shift() );
                                    }
                                } else if ( memory ) {
                                    list = [];
                                } else {
                                    self.disable();
                                }
                            }
                        },
                    // Actual Callbacks object
                        self = {
                            // Add a callback or a collection of callbacks to the list
                            add: function() {
                                if ( list ) {
                                    // First, we save the current length
                                    var start = list.length;
                                    (function add( args ) {
                                        jQuery.each( args, function( _, arg ) {
                                            var type = jQuery.type( arg );
                                            if ( type === "function" ) {
                                                if ( !options.unique || !self.has( arg ) ) {
                                                    list.push( arg );
                                                }
                                            } else if ( arg && arg.length && type !== "string" ) {
                                                // Inspect recursively
                                                add( arg );
                                            }
                                        });
                                    })( arguments );
                                    // Do we need to add the callbacks to the
                                    // current firing batch?
                                    if ( firing ) {
                                        firingLength = list.length;
                                        // With memory, if we're not firing then
                                        // we should call right away
                                    } else if ( memory ) {
                                        firingStart = start;
                                        fire( memory );
                                    }
                                }
                                return this;
                            },
                            // Remove a callback from the list
                            remove: function() {
                                if ( list ) {
                                    jQuery.each( arguments, function( _, arg ) {
                                        var index;
                                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                                            list.splice( index, 1 );
                                            // Handle firing indexes
                                            if ( firing ) {
                                                if ( index <= firingLength ) {
                                                    firingLength--;
                                                }
                                                if ( index <= firingIndex ) {
                                                    firingIndex--;
                                                }
                                            }
                                        }
                                    });
                                }
                                return this;
                            },
                            // Check if a given callback is in the list.
                            // If no argument is given, return whether or not list has callbacks attached.
                            has: function( fn ) {
                                return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
                            },
                            // Remove all callbacks from the list
                            empty: function() {
                                list = [];
                                firingLength = 0;
                                return this;
                            },
                            // Have the list do nothing anymore
                            disable: function() {
                                list = stack = memory = undefined;
                                return this;
                            },
                            // Is it disabled?
                            disabled: function() {
                                return !list;
                            },
                            // Lock the list in its current state
                            lock: function() {
                                stack = undefined;
                                if ( !memory ) {
                                    self.disable();
                                }
                                return this;
                            },
                            // Is it locked?
                            locked: function() {
                                return !stack;
                            },
                            // Call all callbacks with the given context and arguments
                            fireWith: function( context, args ) {
                                if ( list && ( !fired || stack ) ) {
                                    args = args || [];
                                    args = [ context, args.slice ? args.slice() : args ];
                                    if ( firing ) {
                                        stack.push( args );
                                    } else {
                                        fire( args );
                                    }
                                }
                                return this;
                            },
                            // Call all the callbacks with the given arguments
                            fire: function() {
                                self.fireWith( this, arguments );
                                return this;
                            },
                            // To know if the callbacks have already been called at least once
                            fired: function() {
                                return !!fired;
                            }
                        };
                    
                    return self;
                };
                
                
                jQuery.extend({
                    
                    Deferred: function( func ) {
                        var tuples = [
                                // action, add listener, listener list, final state
                                [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                                [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                                [ "notify", "progress", jQuery.Callbacks("memory") ]
                            ],
                            state = "pending",
                            promise = {
                                state: function() {
                                    return state;
                                },
                                always: function() {
                                    deferred.done( arguments ).fail( arguments );
                                    return this;
                                },
                                then: function( /* fnDone, fnFail, fnProgress */ ) {
                                    var fns = arguments;
                                    return jQuery.Deferred(function( newDefer ) {
                                        jQuery.each( tuples, function( i, tuple ) {
                                            var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                            deferred[ tuple[1] ](function() {
                                                var returned = fn && fn.apply( this, arguments );
                                                if ( returned && jQuery.isFunction( returned.promise ) ) {
                                                    returned.promise()
                                                        .done( newDefer.resolve )
                                                        .fail( newDefer.reject )
                                                        .progress( newDefer.notify );
                                                } else {
                                                    newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                                }
                                            });
                                        });
                                        fns = null;
                                    }).promise();
                                },
                                // Get a promise for this deferred
                                // If obj is provided, the promise aspect is added to the object
                                promise: function( obj ) {
                                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                                }
                            },
                            deferred = {};
                        
                        // Keep pipe for back-compat
                        promise.pipe = promise.then;
                        
                        // Add list-specific methods
                        jQuery.each( tuples, function( i, tuple ) {
                            var list = tuple[ 2 ],
                                stateString = tuple[ 3 ];
                            
                            // promise[ done | fail | progress ] = list.add
                            promise[ tuple[1] ] = list.add;
                            
                            // Handle state
                            if ( stateString ) {
                                list.add(function() {
                                    // state = [ resolved | rejected ]
                                    state = stateString;
                                    
                                    // [ reject_list | resolve_list ].disable; progress_list.lock
                                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                            }
                            
                            // deferred[ resolve | reject | notify ]
                            deferred[ tuple[0] ] = function() {
                                deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                                return this;
                            };
                            deferred[ tuple[0] + "With" ] = list.fireWith;
                        });
                        
                        // Make the deferred a promise
                        promise.promise( deferred );
                        
                        // Call given func if any
                        if ( func ) {
                            func.call( deferred, deferred );
                        }
                        
                        // All done!
                        return deferred;
                    },
                    
                    // Deferred helper
                    when: function( subordinate /* , ..., subordinateN */ ) {
                        var i = 0,
                            resolveValues = slice.call( arguments ),
                            length = resolveValues.length,
                        
                        // the count of uncompleted subordinates
                            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
                        
                        // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                        
                        // Update function for both resolve and progress values
                            updateFunc = function( i, contexts, values ) {
                                return function( value ) {
                                    contexts[ i ] = this;
                                    values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                                    if ( values === progressValues ) {
                                        deferred.notifyWith( contexts, values );
                                    } else if ( !( --remaining ) ) {
                                        deferred.resolveWith( contexts, values );
                                    }
                                };
                            },
                            
                            progressValues, progressContexts, resolveContexts;
                        
                        // Add listeners to Deferred subordinates; treat others as resolved
                        if ( length > 1 ) {
                            progressValues = new Array( length );
                            progressContexts = new Array( length );
                            resolveContexts = new Array( length );
                            for ( ; i < length; i++ ) {
                                if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                                    resolveValues[ i ].promise()
                                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                                        .fail( deferred.reject )
                                        .progress( updateFunc( i, progressContexts, progressValues ) );
                                } else {
                                    --remaining;
                                }
                            }
                        }
                        
                        // If we're not waiting on anything, resolve the master
                        if ( !remaining ) {
                            deferred.resolveWith( resolveContexts, resolveValues );
                        }
                        
                        return deferred.promise();
                    }
                });
                
                
                // The deferred used on DOM ready
                var readyList;
                
                jQuery.fn.ready = function( fn ) {
                    // Add the callback
                    jQuery.ready.promise().done( fn );
                    
                    return this;
                };
                
                jQuery.extend({
                    // Is the DOM ready to be used? Set to true once it occurs.
                    isReady: false,
                    
                    // A counter to track how many items to wait for before
                    // the ready event fires. See #6781
                    readyWait: 1,
                    
                    // Hold (or release) the ready event
                    holdReady: function( hold ) {
                        if ( hold ) {
                            jQuery.readyWait++;
                        } else {
                            jQuery.ready( true );
                        }
                    },
                    
                    // Handle when the DOM is ready
                    ready: function( wait ) {
                        
                        // Abort if there are pending holds or we're already ready
                        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                            return;
                        }
                        
                        // Remember that the DOM is ready
                        jQuery.isReady = true;
                        
                        // If a normal DOM Ready event fired, decrement, and wait if need be
                        if ( wait !== true && --jQuery.readyWait > 0 ) {
                            return;
                        }
                        
                        // If there are functions bound, to execute
                        readyList.resolveWith( document, [ jQuery ] );
                        
                        // Trigger any bound ready events
                        if ( jQuery.fn.triggerHandler ) {
                            jQuery( document ).triggerHandler( "ready" );
                            jQuery( document ).off( "ready" );
                        }
                    }
                });
                
                /**
                 * The ready event handler and self cleanup method
                 */
                function completed() {
                    document.removeEventListener( "DOMContentLoaded", completed, false );
                    window.removeEventListener( "load", completed, false );
                    jQuery.ready();
                }
                
                jQuery.ready.promise = function( obj ) {
                    if ( !readyList ) {
                        
                        readyList = jQuery.Deferred();
                        
                        // Catch cases where $(document).ready() is called after the browser event has already occurred.
                        // We once tried to use readyState "interactive" here, but it caused issues like the one
                        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
                        if ( document.readyState === "complete" ) {
                            // Handle it asynchronously to allow scripts the opportunity to delay ready
                            setTimeout( jQuery.ready );
                            
                        } else {
                            
                            // Use the handy event callback
                            document.addEventListener( "DOMContentLoaded", completed, false );
                            
                            // A fallback to window.onload, that will always work
                            window.addEventListener( "load", completed, false );
                        }
                    }
                    return readyList.promise( obj );
                };
                
                // Kick off the DOM ready check even if the user does not
                jQuery.ready.promise();
                
                
                
                
                // Multifunctional method to get and set values of a collection
                // The value/s can optionally be executed if it's a function
                var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
                    var i = 0,
                        len = elems.length,
                        bulk = key == null;
                    
                    // Sets many values
                    if ( jQuery.type( key ) === "object" ) {
                        chainable = true;
                        for ( i in key ) {
                            jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
                        }
                        
                        // Sets one value
                    } else if ( value !== undefined ) {
                        chainable = true;
                        
                        if ( !jQuery.isFunction( value ) ) {
                            raw = true;
                        }
                        
                        if ( bulk ) {
                            // Bulk operations run against the entire set
                            if ( raw ) {
                                fn.call( elems, value );
                                fn = null;
                                
                                // ...except when executing function values
                            } else {
                                bulk = fn;
                                fn = function( elem, key, value ) {
                                    return bulk.call( jQuery( elem ), value );
                                };
                            }
                        }
                        
                        if ( fn ) {
                            for ( ; i < len; i++ ) {
                                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
                            }
                        }
                    }
                    
                    return chainable ?
                        elems :
                        
                        // Gets
                        bulk ?
                            fn.call( elems ) :
                            len ? fn( elems[0], key ) : emptyGet;
                };
                
                
                /**
                 * Determines whether an object can have data
                 */
                jQuery.acceptData = function( owner ) {
                    // Accepts only:
                    //  - Node
                    //    - Node.ELEMENT_NODE
                    //    - Node.DOCUMENT_NODE
                    //  - Object
                    //    - Any
                    /* jshint -W018 */
                    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
                };
                
                
                function Data() {
                    // Support: Android<4,
                    // Old WebKit does not have Object.preventExtensions/freeze method,
                    // return new empty object instead with no [[set]] accessor
                    Object.defineProperty( this.cache = {}, 0, {
                        get: function() {
                            return {};
                        }
                    });
                    
                    this.expando = jQuery.expando + Data.uid++;
                }
                
                Data.uid = 1;
                Data.accepts = jQuery.acceptData;
                
                Data.prototype = {
                    key: function( owner ) {
                        // We can accept data for non-element nodes in modern browsers,
                        // but we should not, see #8335.
                        // Always return the key for a frozen object.
                        if ( !Data.accepts( owner ) ) {
                            return 0;
                        }
                        
                        var descriptor = {},
                        // Check if the owner object already has a cache key
                            unlock = owner[ this.expando ];
                        
                        // If not, create one
                        if ( !unlock ) {
                            unlock = Data.uid++;
                            
                            // Secure it in a non-enumerable, non-writable property
                            try {
                                descriptor[ this.expando ] = { value: unlock };
                                Object.defineProperties( owner, descriptor );
                                
                                // Support: Android<4
                                // Fallback to a less secure definition
                            } catch ( e ) {
                                descriptor[ this.expando ] = unlock;
                                jQuery.extend( owner, descriptor );
                            }
                        }
                        
                        // Ensure the cache object
                        if ( !this.cache[ unlock ] ) {
                            this.cache[ unlock ] = {};
                        }
                        
                        return unlock;
                    },
                    set: function( owner, data, value ) {
                        var prop,
                        // There may be an unlock assigned to this node,
                        // if there is no entry for this "owner", create one inline
                        // and set the unlock as though an owner entry had always existed
                            unlock = this.key( owner ),
                            cache = this.cache[ unlock ];
                        
                        // Handle: [ owner, key, value ] args
                        if ( typeof data === "string" ) {
                            cache[ data ] = value;
                            
                            // Handle: [ owner, { properties } ] args
                        } else {
                            // Fresh assignments by object are shallow copied
                            if ( jQuery.isEmptyObject( cache ) ) {
                                jQuery.extend( this.cache[ unlock ], data );
                                // Otherwise, copy the properties one-by-one to the cache object
                            } else {
                                for ( prop in data ) {
                                    cache[ prop ] = data[ prop ];
                                }
                            }
                        }
                        return cache;
                    },
                    get: function( owner, key ) {
                        // Either a valid cache is found, or will be created.
                        // New caches will be created and the unlock returned,
                        // allowing direct access to the newly created
                        // empty data object. A valid owner object must be provided.
                        var cache = this.cache[ this.key( owner ) ];
                        
                        return key === undefined ?
                            cache : cache[ key ];
                    },
                    access: function( owner, key, value ) {
                        var stored;
                        // In cases where either:
                        //
                        //   1. No key was specified
                        //   2. A string key was specified, but no value provided
                        //
                        // Take the "read" path and allow the get method to determine
                        // which value to return, respectively either:
                        //
                        //   1. The entire cache object
                        //   2. The data stored at the key
                        //
                        if ( key === undefined ||
                            ((key && typeof key === "string") && value === undefined) ) {
                            
                            stored = this.get( owner, key );
                            
                            return stored !== undefined ?
                                stored : this.get( owner, jQuery.camelCase(key) );
                        }
                        
                        // [*]When the key is not a string, or both a key and value
                        // are specified, set or extend (existing objects) with either:
                        //
                        //   1. An object of properties
                        //   2. A key and value
                        //
                        this.set( owner, key, value );
                        
                        // Since the "set" path can have two possible entry points
                        // return the expected data based on which path was taken[*]
                        return value !== undefined ? value : key;
                    },
                    remove: function( owner, key ) {
                        var i, name, camel,
                            unlock = this.key( owner ),
                            cache = this.cache[ unlock ];
                        
                        if ( key === undefined ) {
                            this.cache[ unlock ] = {};
                            
                        } else {
                            // Support array or space separated string of keys
                            if ( jQuery.isArray( key ) ) {
                                // If "name" is an array of keys...
                                // When data is initially created, via ("key", "val") signature,
                                // keys will be converted to camelCase.
                                // Since there is no way to tell _how_ a key was added, remove
                                // both plain key and camelCase key. #12786
                                // This will only penalize the array argument path.
                                name = key.concat( key.map( jQuery.camelCase ) );
                            } else {
                                camel = jQuery.camelCase( key );
                                // Try the string as a key before any manipulation
                                if ( key in cache ) {
                                    name = [ key, camel ];
                                } else {
                                    // If a key with the spaces exists, use it.
                                    // Otherwise, create an array by matching non-whitespace
                                    name = camel;
                                    name = name in cache ?
                                        [ name ] : ( name.match( rnotwhite ) || [] );
                                }
                            }
                            
                            i = name.length;
                            while ( i-- ) {
                                delete cache[ name[ i ] ];
                            }
                        }
                    },
                    hasData: function( owner ) {
                        return !jQuery.isEmptyObject(
                            this.cache[ owner[ this.expando ] ] || {}
                        );
                    },
                    discard: function( owner ) {
                        if ( owner[ this.expando ] ) {
                            delete this.cache[ owner[ this.expando ] ];
                        }
                    }
                };
                var data_priv = new Data();
                
                var data_user = new Data();
                
                
                
                //	Implementation Summary
                //
                //	1. Enforce API surface and semantic compatibility with 1.9.x branch
                //	2. Improve the module's maintainability by reducing the storage
                //		paths to a single mechanism.
                //	3. Use the same single mechanism to support "private" and "user" data.
                //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
                //	5. Avoid exposing implementation details on user objects (eg. expando properties)
                //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
                
                var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                    rmultiDash = /([A-Z])/g;
                
                function dataAttr( elem, key, data ) {
                    var name;
                    
                    // If nothing was found internally, try to fetch any
                    // data from the HTML5 data-* attribute
                    if ( data === undefined && elem.nodeType === 1 ) {
                        name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
                        data = elem.getAttribute( name );
                        
                        if ( typeof data === "string" ) {
                            try {
                                data = data === "true" ? true :
                                    data === "false" ? false :
                                        data === "null" ? null :
                                            // Only convert to a number if it doesn't change the string
                                            +data + "" === data ? +data :
                                                rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                                    data;
                            } catch( e ) {}
                            
                            // Make sure we set the data so it isn't changed later
                            data_user.set( elem, key, data );
                        } else {
                            data = undefined;
                        }
                    }
                    return data;
                }
                
                jQuery.extend({
                    hasData: function( elem ) {
                        return data_user.hasData( elem ) || data_priv.hasData( elem );
                    },
                    
                    data: function( elem, name, data ) {
                        return data_user.access( elem, name, data );
                    },
                    
                    removeData: function( elem, name ) {
                        data_user.remove( elem, name );
                    },
                    
                    // TODO: Now that all calls to _data and _removeData have been replaced
                    // with direct calls to data_priv methods, these can be deprecated.
                    _data: function( elem, name, data ) {
                        return data_priv.access( elem, name, data );
                    },
                    
                    _removeData: function( elem, name ) {
                        data_priv.remove( elem, name );
                    }
                });
                
                jQuery.fn.extend({
                    data: function( key, value ) {
                        var i, name, data,
                            elem = this[ 0 ],
                            attrs = elem && elem.attributes;
                        
                        // Gets all values
                        if ( key === undefined ) {
                            if ( this.length ) {
                                data = data_user.get( elem );
                                
                                if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
                                    i = attrs.length;
                                    while ( i-- ) {
                                        
                                        // Support: IE11+
                                        // The attrs elements can be null (#14894)
                                        if ( attrs[ i ] ) {
                                            name = attrs[ i ].name;
                                            if ( name.indexOf( "data-" ) === 0 ) {
                                                name = jQuery.camelCase( name.slice(5) );
                                                dataAttr( elem, name, data[ name ] );
                                            }
                                        }
                                    }
                                    data_priv.set( elem, "hasDataAttrs", true );
                                }
                            }
                            
                            return data;
                        }
                        
                        // Sets multiple values
                        if ( typeof key === "object" ) {
                            return this.each(function() {
                                data_user.set( this, key );
                            });
                        }
                        
                        return access( this, function( value ) {
                            var data,
                                camelKey = jQuery.camelCase( key );
                            
                            // The calling jQuery object (element matches) is not empty
                            // (and therefore has an element appears at this[ 0 ]) and the
                            // `value` parameter was not undefined. An empty jQuery object
                            // will result in `undefined` for elem = this[ 0 ] which will
                            // throw an exception if an attempt to read a data cache is made.
                            if ( elem && value === undefined ) {
                                // Attempt to get data from the cache
                                // with the key as-is
                                data = data_user.get( elem, key );
                                if ( data !== undefined ) {
                                    return data;
                                }
                                
                                // Attempt to get data from the cache
                                // with the key camelized
                                data = data_user.get( elem, camelKey );
                                if ( data !== undefined ) {
                                    return data;
                                }
                                
                                // Attempt to "discover" the data in
                                // HTML5 custom data-* attrs
                                data = dataAttr( elem, camelKey, undefined );
                                if ( data !== undefined ) {
                                    return data;
                                }
                                
                                // We tried really hard, but the data doesn't exist.
                                return;
                            }
                            
                            // Set the data...
                            this.each(function() {
                                // First, attempt to store a copy or reference of any
                                // data that might've been store with a camelCased key.
                                var data = data_user.get( this, camelKey );
                                
                                // For HTML5 data-* attribute interop, we have to
                                // store property names with dashes in a camelCase form.
                                // This might not apply to all properties...*
                                data_user.set( this, camelKey, value );
                                
                                // *... In the case of properties that might _actually_
                                // have dashes, we need to also store a copy of that
                                // unchanged property.
                                if ( key.indexOf("-") !== -1 && data !== undefined ) {
                                    data_user.set( this, key, value );
                                }
                            });
                        }, null, value, arguments.length > 1, null, true );
                    },
                    
                    removeData: function( key ) {
                        return this.each(function() {
                            data_user.remove( this, key );
                        });
                    }
                });
                
                
                jQuery.extend({
                    queue: function( elem, type, data ) {
                        var queue;
                        
                        if ( elem ) {
                            type = ( type || "fx" ) + "queue";
                            queue = data_priv.get( elem, type );
                            
                            // Speed up dequeue by getting out quickly if this is just a lookup
                            if ( data ) {
                                if ( !queue || jQuery.isArray( data ) ) {
                                    queue = data_priv.access( elem, type, jQuery.makeArray(data) );
                                } else {
                                    queue.push( data );
                                }
                            }
                            return queue || [];
                        }
                    },
                    
                    dequeue: function( elem, type ) {
                        type = type || "fx";
                        
                        var queue = jQuery.queue( elem, type ),
                            startLength = queue.length,
                            fn = queue.shift(),
                            hooks = jQuery._queueHooks( elem, type ),
                            next = function() {
                                jQuery.dequeue( elem, type );
                            };
                        
                        // If the fx queue is dequeued, always remove the progress sentinel
                        if ( fn === "inprogress" ) {
                            fn = queue.shift();
                            startLength--;
                        }
                        
                        if ( fn ) {
                            
                            // Add a progress sentinel to prevent the fx queue from being
                            // automatically dequeued
                            if ( type === "fx" ) {
                                queue.unshift( "inprogress" );
                            }
                            
                            // Clear up the last queue stop function
                            delete hooks.stop;
                            fn.call( elem, next, hooks );
                        }
                        
                        if ( !startLength && hooks ) {
                            hooks.empty.fire();
                        }
                    },
                    
                    // Not public - generate a queueHooks object, or return the current one
                    _queueHooks: function( elem, type ) {
                        var key = type + "queueHooks";
                        return data_priv.get( elem, key ) || data_priv.access( elem, key, {
                                empty: jQuery.Callbacks("once memory").add(function() {
                                    data_priv.remove( elem, [ type + "queue", key ] );
                                })
                            });
                    }
                });
                
                jQuery.fn.extend({
                    queue: function( type, data ) {
                        var setter = 2;
                        
                        if ( typeof type !== "string" ) {
                            data = type;
                            type = "fx";
                            setter--;
                        }
                        
                        if ( arguments.length < setter ) {
                            return jQuery.queue( this[0], type );
                        }
                        
                        return data === undefined ?
                            this :
                            this.each(function() {
                                var queue = jQuery.queue( this, type, data );
                                
                                // Ensure a hooks for this queue
                                jQuery._queueHooks( this, type );
                                
                                if ( type === "fx" && queue[0] !== "inprogress" ) {
                                    jQuery.dequeue( this, type );
                                }
                            });
                    },
                    dequeue: function( type ) {
                        return this.each(function() {
                            jQuery.dequeue( this, type );
                        });
                    },
                    clearQueue: function( type ) {
                        return this.queue( type || "fx", [] );
                    },
                    // Get a promise resolved when queues of a certain type
                    // are emptied (fx is the type by default)
                    promise: function( type, obj ) {
                        var tmp,
                            count = 1,
                            defer = jQuery.Deferred(),
                            elements = this,
                            i = this.length,
                            resolve = function() {
                                if ( !( --count ) ) {
                                    defer.resolveWith( elements, [ elements ] );
                                }
                            };
                        
                        if ( typeof type !== "string" ) {
                            obj = type;
                            type = undefined;
                        }
                        type = type || "fx";
                        
                        while ( i-- ) {
                            tmp = data_priv.get( elements[ i ], type + "queueHooks" );
                            if ( tmp && tmp.empty ) {
                                count++;
                                tmp.empty.add( resolve );
                            }
                        }
                        resolve();
                        return defer.promise( obj );
                    }
                });
                var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
                
                var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
                
                var isHidden = function( elem, el ) {
                    // isHidden might be called from jQuery#filter function;
                    // in that case, element will be second argument
                    elem = el || elem;
                    return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
                };
                
                var rcheckableType = (/^(?:checkbox|radio)$/i);
                
                
                
                (function() {
                    var fragment = document.createDocumentFragment(),
                        div = fragment.appendChild( document.createElement( "div" ) ),
                        input = document.createElement( "input" );
                    
                    // Support: Safari<=5.1
                    // Check state lost if the name is set (#11217)
                    // Support: Windows Web Apps (WWA)
                    // `name` and `type` must use .setAttribute for WWA (#14901)
                    input.setAttribute( "type", "radio" );
                    input.setAttribute( "checked", "checked" );
                    input.setAttribute( "name", "t" );
                    
                    div.appendChild( input );
                    
                    // Support: Safari<=5.1, Android<4.2
                    // Older WebKit doesn't clone checked state correctly in fragments
                    support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
                    
                    // Support: IE<=11+
                    // Make sure textarea (and checkbox) defaultValue is properly cloned
                    div.innerHTML = "<textarea>x</textarea>";
                    support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
                })();
                var strundefined = typeof undefined;
                
                
                
                support.focusinBubbles = "onfocusin" in window;
                
                
                var
                    rkeyEvent = /^key/,
                    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
                    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
                
                function returnTrue() {
                    return true;
                }
                
                function returnFalse() {
                    return false;
                }
                
                function safeActiveElement() {
                    try {
                        return document.activeElement;
                    } catch ( err ) { }
                }
                
                /*
                 * Helper functions for managing events -- not part of the public interface.
                 * Props to Dean Edwards' addEvent library for many of the ideas.
                 */
                jQuery.event = {
                    
                    global: {},
                    
                    add: function( elem, types, handler, data, selector ) {
                        
                        var handleObjIn, eventHandle, tmp,
                            events, t, handleObj,
                            special, handlers, type, namespaces, origType,
                            elemData = data_priv.get( elem );
                        
                        // Don't attach events to noData or text/comment nodes (but allow plain objects)
                        if ( !elemData ) {
                            return;
                        }
                        
                        // Caller can pass in an object of custom data in lieu of the handler
                        if ( handler.handler ) {
                            handleObjIn = handler;
                            handler = handleObjIn.handler;
                            selector = handleObjIn.selector;
                        }
                        
                        // Make sure that the handler has a unique ID, used to find/remove it later
                        if ( !handler.guid ) {
                            handler.guid = jQuery.guid++;
                        }
                        
                        // Init the element's event structure and main handler, if this is the first
                        if ( !(events = elemData.events) ) {
                            events = elemData.events = {};
                        }
                        if ( !(eventHandle = elemData.handle) ) {
                            eventHandle = elemData.handle = function( e ) {
                                // Discard the second event of a jQuery.event.trigger() and
                                // when an event is called after a page has unloaded
                                return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
                                    jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                            };
                        }
                        
                        // Handle multiple events separated by a space
                        types = ( types || "" ).match( rnotwhite ) || [ "" ];
                        t = types.length;
                        while ( t-- ) {
                            tmp = rtypenamespace.exec( types[t] ) || [];
                            type = origType = tmp[1];
                            namespaces = ( tmp[2] || "" ).split( "." ).sort();
                            
                            // There *must* be a type, no attaching namespace-only handlers
                            if ( !type ) {
                                continue;
                            }
                            
                            // If event changes its type, use the special event handlers for the changed type
                            special = jQuery.event.special[ type ] || {};
                            
                            // If selector defined, determine special event api type, otherwise given type
                            type = ( selector ? special.delegateType : special.bindType ) || type;
                            
                            // Update special based on newly reset type
                            special = jQuery.event.special[ type ] || {};
                            
                            // handleObj is passed to all event handlers
                            handleObj = jQuery.extend({
                                type: type,
                                origType: origType,
                                data: data,
                                handler: handler,
                                guid: handler.guid,
                                selector: selector,
                                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                                namespace: namespaces.join(".")
                            }, handleObjIn );
                            
                            // Init the event handler queue if we're the first
                            if ( !(handlers = events[ type ]) ) {
                                handlers = events[ type ] = [];
                                handlers.delegateCount = 0;
                                
                                // Only use addEventListener if the special events handler returns false
                                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                                    if ( elem.addEventListener ) {
                                        elem.addEventListener( type, eventHandle, false );
                                    }
                                }
                            }
                            
                            if ( special.add ) {
                                special.add.call( elem, handleObj );
                                
                                if ( !handleObj.handler.guid ) {
                                    handleObj.handler.guid = handler.guid;
                                }
                            }
                            
                            // Add to the element's handler list, delegates in front
                            if ( selector ) {
                                handlers.splice( handlers.delegateCount++, 0, handleObj );
                            } else {
                                handlers.push( handleObj );
                            }
                            
                            // Keep track of which events have ever been used, for event optimization
                            jQuery.event.global[ type ] = true;
                        }
                        
                    },
                    
                    // Detach an event or set of events from an element
                    remove: function( elem, types, handler, selector, mappedTypes ) {
                        
                        var j, origCount, tmp,
                            events, t, handleObj,
                            special, handlers, type, namespaces, origType,
                            elemData = data_priv.hasData( elem ) && data_priv.get( elem );
                        
                        if ( !elemData || !(events = elemData.events) ) {
                            return;
                        }
                        
                        // Once for each type.namespace in types; type may be omitted
                        types = ( types || "" ).match( rnotwhite ) || [ "" ];
                        t = types.length;
                        while ( t-- ) {
                            tmp = rtypenamespace.exec( types[t] ) || [];
                            type = origType = tmp[1];
                            namespaces = ( tmp[2] || "" ).split( "." ).sort();
                            
                            // Unbind all events (on this namespace, if provided) for the element
                            if ( !type ) {
                                for ( type in events ) {
                                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                                }
                                continue;
                            }
                            
                            special = jQuery.event.special[ type ] || {};
                            type = ( selector ? special.delegateType : special.bindType ) || type;
                            handlers = events[ type ] || [];
                            tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
                            
                            // Remove matching events
                            origCount = j = handlers.length;
                            while ( j-- ) {
                                handleObj = handlers[ j ];
                                
                                if ( ( mappedTypes || origType === handleObj.origType ) &&
                                    ( !handler || handler.guid === handleObj.guid ) &&
                                    ( !tmp || tmp.test( handleObj.namespace ) ) &&
                                    ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                                    handlers.splice( j, 1 );
                                    
                                    if ( handleObj.selector ) {
                                        handlers.delegateCount--;
                                    }
                                    if ( special.remove ) {
                                        special.remove.call( elem, handleObj );
                                    }
                                }
                            }
                            
                            // Remove generic event handler if we removed something and no more handlers exist
                            // (avoids potential for endless recursion during removal of special event handlers)
                            if ( origCount && !handlers.length ) {
                                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                                    jQuery.removeEvent( elem, type, elemData.handle );
                                }
                                
                                delete events[ type ];
                            }
                        }
                        
                        // Remove the expando if it's no longer used
                        if ( jQuery.isEmptyObject( events ) ) {
                            delete elemData.handle;
                            data_priv.remove( elem, "events" );
                        }
                    },
                    
                    trigger: function( event, data, elem, onlyHandlers ) {
                        
                        var i, cur, tmp, bubbleType, ontype, handle, special,
                            eventPath = [ elem || document ],
                            type = hasOwn.call( event, "type" ) ? event.type : event,
                            namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
                        
                        cur = tmp = elem = elem || document;
                        
                        // Don't do events on text and comment nodes
                        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                            return;
                        }
                        
                        // focus/blur morphs to focusin/out; ensure we're not firing them right now
                        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                            return;
                        }
                        
                        if ( type.indexOf(".") >= 0 ) {
                            // Namespaced trigger; create a regexp to match event type in handle()
                            namespaces = type.split(".");
                            type = namespaces.shift();
                            namespaces.sort();
                        }
                        ontype = type.indexOf(":") < 0 && "on" + type;
                        
                        // Caller can pass in a jQuery.Event object, Object, or just an event type string
                        event = event[ jQuery.expando ] ?
                            event :
                            new jQuery.Event( type, typeof event === "object" && event );
                        
                        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                        event.isTrigger = onlyHandlers ? 2 : 3;
                        event.namespace = namespaces.join(".");
                        event.namespace_re = event.namespace ?
                            new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
                            null;
                        
                        // Clean up the event in case it is being reused
                        event.result = undefined;
                        if ( !event.target ) {
                            event.target = elem;
                        }
                        
                        // Clone any incoming data and prepend the event, creating the handler arg list
                        data = data == null ?
                            [ event ] :
                            jQuery.makeArray( data, [ event ] );
                        
                        // Allow special events to draw outside the lines
                        special = jQuery.event.special[ type ] || {};
                        if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                            return;
                        }
                        
                        // Determine event propagation path in advance, per W3C events spec (#9951)
                        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                        if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
                            
                            bubbleType = special.delegateType || type;
                            if ( !rfocusMorph.test( bubbleType + type ) ) {
                                cur = cur.parentNode;
                            }
                            for ( ; cur; cur = cur.parentNode ) {
                                eventPath.push( cur );
                                tmp = cur;
                            }
                            
                            // Only add window if we got to document (e.g., not plain obj or detached DOM)
                            if ( tmp === (elem.ownerDocument || document) ) {
                                eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                            }
                        }
                        
                        // Fire handlers on the event path
                        i = 0;
                        while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
                            
                            event.type = i > 1 ?
                                bubbleType :
                            special.bindType || type;
                            
                            // jQuery handler
                            handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
                            if ( handle ) {
                                handle.apply( cur, data );
                            }
                            
                            // Native handler
                            handle = ontype && cur[ ontype ];
                            if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                                event.result = handle.apply( cur, data );
                                if ( event.result === false ) {
                                    event.preventDefault();
                                }
                            }
                        }
                        event.type = type;
                        
                        // If nobody prevented the default action, do it now
                        if ( !onlyHandlers && !event.isDefaultPrevented() ) {
                            
                            if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                                jQuery.acceptData( elem ) ) {
                                
                                // Call a native DOM method on the target with the same name name as the event.
                                // Don't do default actions on window, that's where global variables be (#6170)
                                if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
                                    
                                    // Don't re-trigger an onFOO event when we call its FOO() method
                                    tmp = elem[ ontype ];
                                    
                                    if ( tmp ) {
                                        elem[ ontype ] = null;
                                    }
                                    
                                    // Prevent re-triggering of the same event, since we already bubbled it above
                                    jQuery.event.triggered = type;
                                    elem[ type ]();
                                    jQuery.event.triggered = undefined;
                                    
                                    if ( tmp ) {
                                        elem[ ontype ] = tmp;
                                    }
                                }
                            }
                        }
                        
                        return event.result;
                    },
                    
                    dispatch: function( event ) {
                        
                        // Make a writable jQuery.Event from the native event object
                        event = jQuery.event.fix( event );
                        
                        var i, j, ret, matched, handleObj,
                            handlerQueue = [],
                            args = slice.call( arguments ),
                            handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
                            special = jQuery.event.special[ event.type ] || {};
                        
                        // Use the fix-ed jQuery.Event rather than the (read-only) native event
                        args[0] = event;
                        event.delegateTarget = this;
                        
                        // Call the preDispatch hook for the mapped type, and let it bail if desired
                        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                            return;
                        }
                        
                        // Determine handlers
                        handlerQueue = jQuery.event.handlers.call( this, event, handlers );
                        
                        // Run delegates first; they may want to stop propagation beneath us
                        i = 0;
                        while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
                            event.currentTarget = matched.elem;
                            
                            j = 0;
                            while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
                                
                                // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                                // a subset or equal to those in the bound event (both can have no namespace).
                                if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
                                    
                                    event.handleObj = handleObj;
                                    event.data = handleObj.data;
                                    
                                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                                        .apply( matched.elem, args );
                                    
                                    if ( ret !== undefined ) {
                                        if ( (event.result = ret) === false ) {
                                            event.preventDefault();
                                            event.stopPropagation();
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Call the postDispatch hook for the mapped type
                        if ( special.postDispatch ) {
                            special.postDispatch.call( this, event );
                        }
                        
                        return event.result;
                    },
                    
                    handlers: function( event, handlers ) {
                        var i, matches, sel, handleObj,
                            handlerQueue = [],
                            delegateCount = handlers.delegateCount,
                            cur = event.target;
                        
                        // Find delegate handlers
                        // Black-hole SVG <use> instance trees (#13180)
                        // Avoid non-left-click bubbling in Firefox (#3861)
                        if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
                            
                            for ( ; cur !== this; cur = cur.parentNode || this ) {
                                
                                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                                if ( cur.disabled !== true || event.type !== "click" ) {
                                    matches = [];
                                    for ( i = 0; i < delegateCount; i++ ) {
                                        handleObj = handlers[ i ];
                                        
                                        // Don't conflict with Object.prototype properties (#13203)
                                        sel = handleObj.selector + " ";
                                        
                                        if ( matches[ sel ] === undefined ) {
                                            matches[ sel ] = handleObj.needsContext ?
                                            jQuery( sel, this ).index( cur ) >= 0 :
                                                jQuery.find( sel, this, null, [ cur ] ).length;
                                        }
                                        if ( matches[ sel ] ) {
                                            matches.push( handleObj );
                                        }
                                    }
                                    if ( matches.length ) {
                                        handlerQueue.push({ elem: cur, handlers: matches });
                                    }
                                }
                            }
                        }
                        
                        // Add the remaining (directly-bound) handlers
                        if ( delegateCount < handlers.length ) {
                            handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
                        }
                        
                        return handlerQueue;
                    },
                    
                    // Includes some event props shared by KeyEvent and MouseEvent
                    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                    
                    fixHooks: {},
                    
                    keyHooks: {
                        props: "char charCode key keyCode".split(" "),
                        filter: function( event, original ) {
                            
                            // Add which for key events
                            if ( event.which == null ) {
                                event.which = original.charCode != null ? original.charCode : original.keyCode;
                            }
                            
                            return event;
                        }
                    },
                    
                    mouseHooks: {
                        props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                        filter: function( event, original ) {
                            var eventDoc, doc, body,
                                button = original.button;
                            
                            // Calculate pageX/Y if missing and clientX/Y available
                            if ( event.pageX == null && original.clientX != null ) {
                                eventDoc = event.target.ownerDocument || document;
                                doc = eventDoc.documentElement;
                                body = eventDoc.body;
                                
                                event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                                event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                            }
                            
                            // Add which for click: 1 === left; 2 === middle; 3 === right
                            // Note: button is not normalized, so don't use it
                            if ( !event.which && button !== undefined ) {
                                event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                            }
                            
                            return event;
                        }
                    },
                    
                    fix: function( event ) {
                        if ( event[ jQuery.expando ] ) {
                            return event;
                        }
                        
                        // Create a writable copy of the event object and normalize some properties
                        var i, prop, copy,
                            type = event.type,
                            originalEvent = event,
                            fixHook = this.fixHooks[ type ];
                        
                        if ( !fixHook ) {
                            this.fixHooks[ type ] = fixHook =
                                rmouseEvent.test( type ) ? this.mouseHooks :
                                    rkeyEvent.test( type ) ? this.keyHooks :
                                    {};
                        }
                        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
                        
                        event = new jQuery.Event( originalEvent );
                        
                        i = copy.length;
                        while ( i-- ) {
                            prop = copy[ i ];
                            event[ prop ] = originalEvent[ prop ];
                        }
                        
                        // Support: Cordova 2.5 (WebKit) (#13255)
                        // All events should have a target; Cordova deviceready doesn't
                        if ( !event.target ) {
                            event.target = document;
                        }
                        
                        // Support: Safari 6.0+, Chrome<28
                        // Target should not be a text node (#504, #13143)
                        if ( event.target.nodeType === 3 ) {
                            event.target = event.target.parentNode;
                        }
                        
                        return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
                    },
                    
                    special: {
                        load: {
                            // Prevent triggered image.load events from bubbling to window.load
                            noBubble: true
                        },
                        focus: {
                            // Fire native event if possible so blur/focus sequence is correct
                            trigger: function() {
                                if ( this !== safeActiveElement() && this.focus ) {
                                    this.focus();
                                    return false;
                                }
                            },
                            delegateType: "focusin"
                        },
                        blur: {
                            trigger: function() {
                                if ( this === safeActiveElement() && this.blur ) {
                                    this.blur();
                                    return false;
                                }
                            },
                            delegateType: "focusout"
                        },
                        click: {
                            // For checkbox, fire native event so checked state will be right
                            trigger: function() {
                                if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
                                    this.click();
                                    return false;
                                }
                            },
                            
                            // For cross-browser consistency, don't fire native .click() on links
                            _default: function( event ) {
                                return jQuery.nodeName( event.target, "a" );
                            }
                        },
                        
                        beforeunload: {
                            postDispatch: function( event ) {
                                
                                // Support: Firefox 20+
                                // Firefox doesn't alert if the returnValue field is not set.
                                if ( event.result !== undefined && event.originalEvent ) {
                                    event.originalEvent.returnValue = event.result;
                                }
                            }
                        }
                    },
                    
                    simulate: function( type, elem, event, bubble ) {
                        // Piggyback on a donor event to simulate a different one.
                        // Fake originalEvent to avoid donor's stopPropagation, but if the
                        // simulated event prevents default then we do the same on the donor.
                        var e = jQuery.extend(
                            new jQuery.Event(),
                            event,
                            {
                                type: type,
                                isSimulated: true,
                                originalEvent: {}
                            }
                        );
                        if ( bubble ) {
                            jQuery.event.trigger( e, null, elem );
                        } else {
                            jQuery.event.dispatch.call( elem, e );
                        }
                        if ( e.isDefaultPrevented() ) {
                            event.preventDefault();
                        }
                    }
                };
                
                jQuery.removeEvent = function( elem, type, handle ) {
                    if ( elem.removeEventListener ) {
                        elem.removeEventListener( type, handle, false );
                    }
                };
                
                jQuery.Event = function( src, props ) {
                    // Allow instantiation without the 'new' keyword
                    if ( !(this instanceof jQuery.Event) ) {
                        return new jQuery.Event( src, props );
                    }
                    
                    // Event object
                    if ( src && src.type ) {
                        this.originalEvent = src;
                        this.type = src.type;
                        
                        // Events bubbling up the document may have been marked as prevented
                        // by a handler lower down the tree; reflect the correct value.
                        this.isDefaultPrevented = src.defaultPrevented ||
                        src.defaultPrevented === undefined &&
                            // Support: Android<4.0
                        src.returnValue === false ?
                            returnTrue :
                            returnFalse;
                        
                        // Event type
                    } else {
                        this.type = src;
                    }
                    
                    // Put explicitly provided properties onto the event object
                    if ( props ) {
                        jQuery.extend( this, props );
                    }
                    
                    // Create a timestamp if incoming event doesn't have one
                    this.timeStamp = src && src.timeStamp || jQuery.now();
                    
                    // Mark it as fixed
                    this[ jQuery.expando ] = true;
                };
                
                // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
                // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
                jQuery.Event.prototype = {
                    isDefaultPrevented: returnFalse,
                    isPropagationStopped: returnFalse,
                    isImmediatePropagationStopped: returnFalse,
                    
                    preventDefault: function() {
                        var e = this.originalEvent;
                        
                        this.isDefaultPrevented = returnTrue;
                        
                        if ( e && e.preventDefault ) {
                            e.preventDefault();
                        }
                    },
                    stopPropagation: function() {
                        var e = this.originalEvent;
                        
                        this.isPropagationStopped = returnTrue;
                        
                        if ( e && e.stopPropagation ) {
                            e.stopPropagation();
                        }
                    },
                    stopImmediatePropagation: function() {
                        var e = this.originalEvent;
                        
                        this.isImmediatePropagationStopped = returnTrue;
                        
                        if ( e && e.stopImmediatePropagation ) {
                            e.stopImmediatePropagation();
                        }
                        
                        this.stopPropagation();
                    }
                };
                
                // Create mouseenter/leave events using mouseover/out and event-time checks
                // Support: Chrome 15+
                jQuery.each({
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, function( orig, fix ) {
                    jQuery.event.special[ orig ] = {
                        delegateType: fix,
                        bindType: fix,
                        
                        handle: function( event ) {
                            var ret,
                                target = this,
                                related = event.relatedTarget,
                                handleObj = event.handleObj;
                            
                            // For mousenter/leave call the handler if related is outside the target.
                            // NB: No relatedTarget if the mouse left/entered the browser window
                            if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                                event.type = handleObj.origType;
                                ret = handleObj.handler.apply( this, arguments );
                                event.type = fix;
                            }
                            return ret;
                        }
                    };
                });
                
                // Support: Firefox, Chrome, Safari
                // Create "bubbling" focus and blur events
                if ( !support.focusinBubbles ) {
                    jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
                        
                        // Attach a single capturing handler on the document while someone wants focusin/focusout
                        var handler = function( event ) {
                            jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
                        };
                        
                        jQuery.event.special[ fix ] = {
                            setup: function() {
                                var doc = this.ownerDocument || this,
                                    attaches = data_priv.access( doc, fix );
                                
                                if ( !attaches ) {
                                    doc.addEventListener( orig, handler, true );
                                }
                                data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
                            },
                            teardown: function() {
                                var doc = this.ownerDocument || this,
                                    attaches = data_priv.access( doc, fix ) - 1;
                                
                                if ( !attaches ) {
                                    doc.removeEventListener( orig, handler, true );
                                    data_priv.remove( doc, fix );
                                    
                                } else {
                                    data_priv.access( doc, fix, attaches );
                                }
                            }
                        };
                    });
                }
                
                jQuery.fn.extend({
                    
                    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
                        var origFn, type;
                        
                        // Types can be a map of types/handlers
                        if ( typeof types === "object" ) {
                            // ( types-Object, selector, data )
                            if ( typeof selector !== "string" ) {
                                // ( types-Object, data )
                                data = data || selector;
                                selector = undefined;
                            }
                            for ( type in types ) {
                                this.on( type, selector, data, types[ type ], one );
                            }
                            return this;
                        }
                        
                        if ( data == null && fn == null ) {
                            // ( types, fn )
                            fn = selector;
                            data = selector = undefined;
                        } else if ( fn == null ) {
                            if ( typeof selector === "string" ) {
                                // ( types, selector, fn )
                                fn = data;
                                data = undefined;
                            } else {
                                // ( types, data, fn )
                                fn = data;
                                data = selector;
                                selector = undefined;
                            }
                        }
                        if ( fn === false ) {
                            fn = returnFalse;
                        } else if ( !fn ) {
                            return this;
                        }
                        
                        if ( one === 1 ) {
                            origFn = fn;
                            fn = function( event ) {
                                // Can use an empty set, since event contains the info
                                jQuery().off( event );
                                return origFn.apply( this, arguments );
                            };
                            // Use same guid so caller can remove using origFn
                            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                        }
                        return this.each( function() {
                            jQuery.event.add( this, types, fn, data, selector );
                        });
                    },
                    one: function( types, selector, data, fn ) {
                        return this.on( types, selector, data, fn, 1 );
                    },
                    off: function( types, selector, fn ) {
                        var handleObj, type;
                        if ( types && types.preventDefault && types.handleObj ) {
                            // ( event )  dispatched jQuery.Event
                            handleObj = types.handleObj;
                            jQuery( types.delegateTarget ).off(
                                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                                handleObj.selector,
                                handleObj.handler
                            );
                            return this;
                        }
                        if ( typeof types === "object" ) {
                            // ( types-object [, selector] )
                            for ( type in types ) {
                                this.off( type, selector, types[ type ] );
                            }
                            return this;
                        }
                        if ( selector === false || typeof selector === "function" ) {
                            // ( types [, fn] )
                            fn = selector;
                            selector = undefined;
                        }
                        if ( fn === false ) {
                            fn = returnFalse;
                        }
                        return this.each(function() {
                            jQuery.event.remove( this, types, fn, selector );
                        });
                    },
                    
                    trigger: function( type, data ) {
                        return this.each(function() {
                            jQuery.event.trigger( type, data, this );
                        });
                    },
                    triggerHandler: function( type, data ) {
                        var elem = this[0];
                        if ( elem ) {
                            return jQuery.event.trigger( type, data, elem, true );
                        }
                    }
                });
                
                
                var
                    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
                    rtagName = /<([\w:]+)/,
                    rhtml = /<|&#?\w+;/,
                    rnoInnerhtml = /<(?:script|style|link)/i,
                // checked="checked" or checked
                    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                    rscriptType = /^$|\/(?:java|ecma)script/i,
                    rscriptTypeMasked = /^true\/(.*)/,
                    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
                
                // We have to close these tags to support XHTML (#13200)
                    wrapMap = {
                        
                        // Support: IE9
                        option: [ 1, "<select multiple='multiple'>", "</select>" ],
                        
                        thead: [ 1, "<table>", "</table>" ],
                        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
                        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
                        
                        _default: [ 0, "", "" ]
                    };
                
                // Support: IE9
                wrapMap.optgroup = wrapMap.option;
                
                wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
                wrapMap.th = wrapMap.td;
                
                // Support: 1.x compatibility
                // Manipulating tables requires a tbody
                function manipulationTarget( elem, content ) {
                    return jQuery.nodeName( elem, "table" ) &&
                    jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
                    
                    elem.getElementsByTagName("tbody")[0] ||
                    elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
                        elem;
                }
                
                // Replace/restore the type attribute of script elements for safe DOM manipulation
                function disableScript( elem ) {
                    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                    return elem;
                }
                function restoreScript( elem ) {
                    var match = rscriptTypeMasked.exec( elem.type );
                    
                    if ( match ) {
                        elem.type = match[ 1 ];
                    } else {
                        elem.removeAttribute("type");
                    }
                    
                    return elem;
                }
                
                // Mark scripts as having already been evaluated
                function setGlobalEval( elems, refElements ) {
                    var i = 0,
                        l = elems.length;
                    
                    for ( ; i < l; i++ ) {
                        data_priv.set(
                            elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
                        );
                    }
                }
                
                function cloneCopyEvent( src, dest ) {
                    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
                    
                    if ( dest.nodeType !== 1 ) {
                        return;
                    }
                    
                    // 1. Copy private data: events, handlers, etc.
                    if ( data_priv.hasData( src ) ) {
                        pdataOld = data_priv.access( src );
                        pdataCur = data_priv.set( dest, pdataOld );
                        events = pdataOld.events;
                        
                        if ( events ) {
                            delete pdataCur.handle;
                            pdataCur.events = {};
                            
                            for ( type in events ) {
                                for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                                    jQuery.event.add( dest, type, events[ type ][ i ] );
                                }
                            }
                        }
                    }
                    
                    // 2. Copy user data
                    if ( data_user.hasData( src ) ) {
                        udataOld = data_user.access( src );
                        udataCur = jQuery.extend( {}, udataOld );
                        
                        data_user.set( dest, udataCur );
                    }
                }
                
                function getAll( context, tag ) {
                    var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
                        context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
                            [];
                    
                    return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
                        jQuery.merge( [ context ], ret ) :
                        ret;
                }
                
                // Fix IE bugs, see support tests
                function fixInput( src, dest ) {
                    var nodeName = dest.nodeName.toLowerCase();
                    
                    // Fails to persist the checked state of a cloned checkbox or radio button.
                    if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
                        dest.checked = src.checked;
                        
                        // Fails to return the selected option to the default selected state when cloning options
                    } else if ( nodeName === "input" || nodeName === "textarea" ) {
                        dest.defaultValue = src.defaultValue;
                    }
                }
                
                jQuery.extend({
                    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
                        var i, l, srcElements, destElements,
                            clone = elem.cloneNode( true ),
                            inPage = jQuery.contains( elem.ownerDocument, elem );
                        
                        // Fix IE cloning issues
                        if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                            !jQuery.isXMLDoc( elem ) ) {
                            
                            // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                            destElements = getAll( clone );
                            srcElements = getAll( elem );
                            
                            for ( i = 0, l = srcElements.length; i < l; i++ ) {
                                fixInput( srcElements[ i ], destElements[ i ] );
                            }
                        }
                        
                        // Copy the events from the original to the clone
                        if ( dataAndEvents ) {
                            if ( deepDataAndEvents ) {
                                srcElements = srcElements || getAll( elem );
                                destElements = destElements || getAll( clone );
                                
                                for ( i = 0, l = srcElements.length; i < l; i++ ) {
                                    cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                                }
                            } else {
                                cloneCopyEvent( elem, clone );
                            }
                        }
                        
                        // Preserve script evaluation history
                        destElements = getAll( clone, "script" );
                        if ( destElements.length > 0 ) {
                            setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
                        }
                        
                        // Return the cloned set
                        return clone;
                    },
                    
                    buildFragment: function( elems, context, scripts, selection ) {
                        var elem, tmp, tag, wrap, contains, j,
                            fragment = context.createDocumentFragment(),
                            nodes = [],
                            i = 0,
                            l = elems.length;
                        
                        for ( ; i < l; i++ ) {
                            elem = elems[ i ];
                            
                            if ( elem || elem === 0 ) {
                                
                                // Add nodes directly
                                if ( jQuery.type( elem ) === "object" ) {
                                    // Support: QtWebKit, PhantomJS
                                    // push.apply(_, arraylike) throws on ancient WebKit
                                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
                                    
                                    // Convert non-html into a text node
                                } else if ( !rhtml.test( elem ) ) {
                                    nodes.push( context.createTextNode( elem ) );
                                    
                                    // Convert html into DOM nodes
                                } else {
                                    tmp = tmp || fragment.appendChild( context.createElement("div") );
                                    
                                    // Deserialize a standard representation
                                    tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                                    wrap = wrapMap[ tag ] || wrapMap._default;
                                    tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];
                                    
                                    // Descend through wrappers to the right content
                                    j = wrap[ 0 ];
                                    while ( j-- ) {
                                        tmp = tmp.lastChild;
                                    }
                                    
                                    // Support: QtWebKit, PhantomJS
                                    // push.apply(_, arraylike) throws on ancient WebKit
                                    jQuery.merge( nodes, tmp.childNodes );
                                    
                                    // Remember the top-level container
                                    tmp = fragment.firstChild;
                                    
                                    // Ensure the created nodes are orphaned (#12392)
                                    tmp.textContent = "";
                                }
                            }
                        }
                        
                        // Remove wrapper from fragment
                        fragment.textContent = "";
                        
                        i = 0;
                        while ( (elem = nodes[ i++ ]) ) {
                            
                            // #4087 - If origin and destination elements are the same, and this is
                            // that element, do not do anything
                            if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                                continue;
                            }
                            
                            contains = jQuery.contains( elem.ownerDocument, elem );
                            
                            // Append to fragment
                            tmp = getAll( fragment.appendChild( elem ), "script" );
                            
                            // Preserve script evaluation history
                            if ( contains ) {
                                setGlobalEval( tmp );
                            }
                            
                            // Capture executables
                            if ( scripts ) {
                                j = 0;
                                while ( (elem = tmp[ j++ ]) ) {
                                    if ( rscriptType.test( elem.type || "" ) ) {
                                        scripts.push( elem );
                                    }
                                }
                            }
                        }
                        
                        return fragment;
                    },
                    
                    cleanData: function( elems ) {
                        var data, elem, type, key,
                            special = jQuery.event.special,
                            i = 0;
                        
                        for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
                            if ( jQuery.acceptData( elem ) ) {
                                key = elem[ data_priv.expando ];
                                
                                if ( key && (data = data_priv.cache[ key ]) ) {
                                    if ( data.events ) {
                                        for ( type in data.events ) {
                                            if ( special[ type ] ) {
                                                jQuery.event.remove( elem, type );
                                                
                                                // This is a shortcut to avoid jQuery.event.remove's overhead
                                            } else {
                                                jQuery.removeEvent( elem, type, data.handle );
                                            }
                                        }
                                    }
                                    if ( data_priv.cache[ key ] ) {
                                        // Discard any remaining `private` data
                                        delete data_priv.cache[ key ];
                                    }
                                }
                            }
                            // Discard any remaining `user` data
                            delete data_user.cache[ elem[ data_user.expando ] ];
                        }
                    }
                });
                
                jQuery.fn.extend({
                    text: function( value ) {
                        return access( this, function( value ) {
                            return value === undefined ?
                                jQuery.text( this ) :
                                this.empty().each(function() {
                                    if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                        this.textContent = value;
                                    }
                                });
                        }, null, value, arguments.length );
                    },
                    
                    append: function() {
                        return this.domManip( arguments, function( elem ) {
                            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                var target = manipulationTarget( this, elem );
                                target.appendChild( elem );
                            }
                        });
                    },
                    
                    prepend: function() {
                        return this.domManip( arguments, function( elem ) {
                            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                var target = manipulationTarget( this, elem );
                                target.insertBefore( elem, target.firstChild );
                            }
                        });
                    },
                    
                    before: function() {
                        return this.domManip( arguments, function( elem ) {
                            if ( this.parentNode ) {
                                this.parentNode.insertBefore( elem, this );
                            }
                        });
                    },
                    
                    after: function() {
                        return this.domManip( arguments, function( elem ) {
                            if ( this.parentNode ) {
                                this.parentNode.insertBefore( elem, this.nextSibling );
                            }
                        });
                    },
                    
                    remove: function( selector, keepData /* Internal Use Only */ ) {
                        var elem,
                            elems = selector ? jQuery.filter( selector, this ) : this,
                            i = 0;
                        
                        for ( ; (elem = elems[i]) != null; i++ ) {
                            if ( !keepData && elem.nodeType === 1 ) {
                                jQuery.cleanData( getAll( elem ) );
                            }
                            
                            if ( elem.parentNode ) {
                                if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                                    setGlobalEval( getAll( elem, "script" ) );
                                }
                                elem.parentNode.removeChild( elem );
                            }
                        }
                        
                        return this;
                    },
                    
                    empty: function() {
                        var elem,
                            i = 0;
                        
                        for ( ; (elem = this[i]) != null; i++ ) {
                            if ( elem.nodeType === 1 ) {
                                
                                // Prevent memory leaks
                                jQuery.cleanData( getAll( elem, false ) );
                                
                                // Remove any remaining nodes
                                elem.textContent = "";
                            }
                        }
                        
                        return this;
                    },
                    
                    clone: function( dataAndEvents, deepDataAndEvents ) {
                        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                        
                        return this.map(function() {
                            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
                        });
                    },
                    
                    html: function( value ) {
                        return access( this, function( value ) {
                            var elem = this[ 0 ] || {},
                                i = 0,
                                l = this.length;
                            
                            if ( value === undefined && elem.nodeType === 1 ) {
                                return elem.innerHTML;
                            }
                            
                            // See if we can take a shortcut and just use innerHTML
                            if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                                !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
                                
                                value = value.replace( rxhtmlTag, "<$1></$2>" );
                                
                                try {
                                    for ( ; i < l; i++ ) {
                                        elem = this[ i ] || {};
                                        
                                        // Remove element nodes and prevent memory leaks
                                        if ( elem.nodeType === 1 ) {
                                            jQuery.cleanData( getAll( elem, false ) );
                                            elem.innerHTML = value;
                                        }
                                    }
                                    
                                    elem = 0;
                                    
                                    // If using innerHTML throws an exception, use the fallback method
                                } catch( e ) {}
                            }
                            
                            if ( elem ) {
                                this.empty().append( value );
                            }
                        }, null, value, arguments.length );
                    },
                    
                    replaceWith: function() {
                        var arg = arguments[ 0 ];
                        
                        // Make the changes, replacing each context element with the new content
                        this.domManip( arguments, function( elem ) {
                            arg = this.parentNode;
                            
                            jQuery.cleanData( getAll( this ) );
                            
                            if ( arg ) {
                                arg.replaceChild( elem, this );
                            }
                        });
                        
                        // Force removal if there was no new content (e.g., from empty arguments)
                        return arg && (arg.length || arg.nodeType) ? this : this.remove();
                    },
                    
                    detach: function( selector ) {
                        return this.remove( selector, true );
                    },
                    
                    domManip: function( args, callback ) {
                        
                        // Flatten any nested arrays
                        args = concat.apply( [], args );
                        
                        var fragment, first, scripts, hasScripts, node, doc,
                            i = 0,
                            l = this.length,
                            set = this,
                            iNoClone = l - 1,
                            value = args[ 0 ],
                            isFunction = jQuery.isFunction( value );
                        
                        // We can't cloneNode fragments that contain checked, in WebKit
                        if ( isFunction ||
                            ( l > 1 && typeof value === "string" &&
                            !support.checkClone && rchecked.test( value ) ) ) {
                            return this.each(function( index ) {
                                var self = set.eq( index );
                                if ( isFunction ) {
                                    args[ 0 ] = value.call( this, index, self.html() );
                                }
                                self.domManip( args, callback );
                            });
                        }
                        
                        if ( l ) {
                            fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
                            first = fragment.firstChild;
                            
                            if ( fragment.childNodes.length === 1 ) {
                                fragment = first;
                            }
                            
                            if ( first ) {
                                scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                                hasScripts = scripts.length;
                                
                                // Use the original fragment for the last item instead of the first because it can end up
                                // being emptied incorrectly in certain situations (#8070).
                                for ( ; i < l; i++ ) {
                                    node = fragment;
                                    
                                    if ( i !== iNoClone ) {
                                        node = jQuery.clone( node, true, true );
                                        
                                        // Keep references to cloned scripts for later restoration
                                        if ( hasScripts ) {
                                            // Support: QtWebKit
                                            // jQuery.merge because push.apply(_, arraylike) throws
                                            jQuery.merge( scripts, getAll( node, "script" ) );
                                        }
                                    }
                                    
                                    callback.call( this[ i ], node, i );
                                }
                                
                                if ( hasScripts ) {
                                    doc = scripts[ scripts.length - 1 ].ownerDocument;
                                    
                                    // Reenable scripts
                                    jQuery.map( scripts, restoreScript );
                                    
                                    // Evaluate executable scripts on first document insertion
                                    for ( i = 0; i < hasScripts; i++ ) {
                                        node = scripts[ i ];
                                        if ( rscriptType.test( node.type || "" ) &&
                                            !data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
                                            
                                            if ( node.src ) {
                                                // Optional AJAX dependency, but won't run scripts if not present
                                                if ( jQuery._evalUrl ) {
                                                    jQuery._evalUrl( node.src );
                                                }
                                            } else {
                                                jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        return this;
                    }
                });
                
                jQuery.each({
                    appendTo: "append",
                    prependTo: "prepend",
                    insertBefore: "before",
                    insertAfter: "after",
                    replaceAll: "replaceWith"
                }, function( name, original ) {
                    jQuery.fn[ name ] = function( selector ) {
                        var elems,
                            ret = [],
                            insert = jQuery( selector ),
                            last = insert.length - 1,
                            i = 0;
                        
                        for ( ; i <= last; i++ ) {
                            elems = i === last ? this : this.clone( true );
                            jQuery( insert[ i ] )[ original ]( elems );
                            
                            // Support: QtWebKit
                            // .get() because push.apply(_, arraylike) throws
                            push.apply( ret, elems.get() );
                        }
                        
                        return this.pushStack( ret );
                    };
                });
                
                
                var iframe,
                    elemdisplay = {};
                
                /**
                 * Retrieve the actual display of a element
                 * @param {String} name nodeName of the element
                 * @param {Object} doc Document object
                 */
                // Called only from within defaultDisplay
                function actualDisplay( name, doc ) {
                    var style,
                        elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
                    
                    // getDefaultComputedStyle might be reliably used only on attached element
                        display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?
                            
                            // Use of this method is a temporary fix (more like optimization) until something better comes along,
                            // since it was removed from specification and supported only in FF
                            style.display : jQuery.css( elem[ 0 ], "display" );
                    
                    // We don't have any data stored on the element,
                    // so use "detach" method as fast way to get rid of the element
                    elem.detach();
                    
                    return display;
                }
                
                /**
                 * Try to determine the default display value of an element
                 * @param {String} nodeName
                 */
                function defaultDisplay( nodeName ) {
                    var doc = document,
                        display = elemdisplay[ nodeName ];
                    
                    if ( !display ) {
                        display = actualDisplay( nodeName, doc );
                        
                        // If the simple way fails, read from inside an iframe
                        if ( display === "none" || !display ) {
                            
                            // Use the already-created iframe if possible
                            iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );
                            
                            // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                            doc = iframe[ 0 ].contentDocument;
                            
                            // Support: IE
                            doc.write();
                            doc.close();
                            
                            display = actualDisplay( nodeName, doc );
                            iframe.detach();
                        }
                        
                        // Store the correct default display
                        elemdisplay[ nodeName ] = display;
                    }
                    
                    return display;
                }
                var rmargin = (/^margin/);
                
                var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
                
                var getStyles = function( elem ) {
                    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
                    // IE throws on elements created in popups
                    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                    if ( elem.ownerDocument.defaultView.opener ) {
                        return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
                    }
                    
                    return window.getComputedStyle( elem, null );
                };
                
                
                
                function curCSS( elem, name, computed ) {
                    var width, minWidth, maxWidth, ret,
                        style = elem.style;
                    
                    computed = computed || getStyles( elem );
                    
                    // Support: IE9
                    // getPropertyValue is only needed for .css('filter') (#12537)
                    if ( computed ) {
                        ret = computed.getPropertyValue( name ) || computed[ name ];
                    }
                    
                    if ( computed ) {
                        
                        if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                            ret = jQuery.style( elem, name );
                        }
                        
                        // Support: iOS < 6
                        // A tribute to the "awesome hack by Dean Edwards"
                        // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                        if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
                            
                            // Remember the original values
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;
                            
                            // Put in the new values to get a computed value out
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;
                            
                            // Revert the changed values
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }
                    
                    return ret !== undefined ?
                        // Support: IE
                        // IE returns zIndex value as an integer.
                    ret + "" :
                        ret;
                }
                
                
                function addGetHookIf( conditionFn, hookFn ) {
                    // Define the hook, we'll check on the first run if it's really needed.
                    return {
                        get: function() {
                            if ( conditionFn() ) {
                                // Hook not needed (or it's not possible to use it due
                                // to missing dependency), remove it.
                                delete this.get;
                                return;
                            }
                            
                            // Hook needed; redefine it so that the support test is not executed again.
                            return (this.get = hookFn).apply( this, arguments );
                        }
                    };
                }
                
                
                (function() {
                    var pixelPositionVal, boxSizingReliableVal,
                        docElem = document.documentElement,
                        container = document.createElement( "div" ),
                        div = document.createElement( "div" );
                    
                    if ( !div.style ) {
                        return;
                    }
                    
                    // Support: IE9-11+
                    // Style of cloned element affects source element cloned (#8908)
                    div.style.backgroundClip = "content-box";
                    div.cloneNode( true ).style.backgroundClip = "";
                    support.clearCloneStyle = div.style.backgroundClip === "content-box";
                    
                    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
                        "position:absolute";
                    container.appendChild( div );
                    
                    // Executing both pixelPosition & boxSizingReliable tests require only one layout
                    // so they're executed at the same time to save the second computation.
                    function computePixelPositionAndBoxSizingReliable() {
                        div.style.cssText =
                            // Support: Firefox<29, Android 2.3
                            // Vendor-prefix box-sizing
                            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                            "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                            "border:1px;padding:1px;width:4px;position:absolute";
                        div.innerHTML = "";
                        docElem.appendChild( container );
                        
                        var divStyle = window.getComputedStyle( div, null );
                        pixelPositionVal = divStyle.top !== "1%";
                        boxSizingReliableVal = divStyle.width === "4px";
                        
                        docElem.removeChild( container );
                    }
                    
                    // Support: node.js jsdom
                    // Don't assume that getComputedStyle is a property of the global object
                    if ( window.getComputedStyle ) {
                        jQuery.extend( support, {
                            pixelPosition: function() {
                                
                                // This test is executed only once but we still do memoizing
                                // since we can use the boxSizingReliable pre-computing.
                                // No need to check if the test was already performed, though.
                                computePixelPositionAndBoxSizingReliable();
                                return pixelPositionVal;
                            },
                            boxSizingReliable: function() {
                                if ( boxSizingReliableVal == null ) {
                                    computePixelPositionAndBoxSizingReliable();
                                }
                                return boxSizingReliableVal;
                            },
                            reliableMarginRight: function() {
                                
                                // Support: Android 2.3
                                // Check if div with explicit width and no margin-right incorrectly
                                // gets computed margin-right based on width of container. (#3333)
                                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                                // This support function is only executed once so no memoizing is needed.
                                var ret,
                                    marginDiv = div.appendChild( document.createElement( "div" ) );
                                
                                // Reset CSS: box-sizing; display; margin; border; padding
                                marginDiv.style.cssText = div.style.cssText =
                                    // Support: Firefox<29, Android 2.3
                                    // Vendor-prefix box-sizing
                                    "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                                    "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                                marginDiv.style.marginRight = marginDiv.style.width = "0";
                                div.style.width = "1px";
                                docElem.appendChild( container );
                                
                                ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );
                                
                                docElem.removeChild( container );
                                div.removeChild( marginDiv );
                                
                                return ret;
                            }
                        });
                    }
                })();
                
                
                // A method for quickly swapping in/out CSS properties to get correct calculations.
                jQuery.swap = function( elem, options, callback, args ) {
                    var ret, name,
                        old = {};
                    
                    // Remember the old values, and insert the new ones
                    for ( name in options ) {
                        old[ name ] = elem.style[ name ];
                        elem.style[ name ] = options[ name ];
                    }
                    
                    ret = callback.apply( elem, args || [] );
                    
                    // Revert the old values
                    for ( name in options ) {
                        elem.style[ name ] = old[ name ];
                    }
                    
                    return ret;
                };
                
                
                var
                // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
                // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                    rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
                    rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),
                    
                    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
                    cssNormalTransform = {
                        letterSpacing: "0",
                        fontWeight: "400"
                    },
                    
                    cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
                
                // Return a css property mapped to a potentially vendor prefixed property
                function vendorPropName( style, name ) {
                    
                    // Shortcut for names that are not vendor prefixed
                    if ( name in style ) {
                        return name;
                    }
                    
                    // Check for vendor prefixed names
                    var capName = name[0].toUpperCase() + name.slice(1),
                        origName = name,
                        i = cssPrefixes.length;
                    
                    while ( i-- ) {
                        name = cssPrefixes[ i ] + capName;
                        if ( name in style ) {
                            return name;
                        }
                    }
                    
                    return origName;
                }
                
                function setPositiveNumber( elem, value, subtract ) {
                    var matches = rnumsplit.exec( value );
                    return matches ?
                        // Guard against undefined "subtract", e.g., when used as in cssHooks
                    Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
                        value;
                }
                
                function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
                    var i = extra === ( isBorderBox ? "border" : "content" ) ?
                            // If we already have the right measurement, avoid augmentation
                            4 :
                            // Otherwise initialize for horizontal or vertical properties
                            name === "width" ? 1 : 0,
                        
                        val = 0;
                    
                    for ( ; i < 4; i += 2 ) {
                        // Both box models exclude margin, so add it if we want it
                        if ( extra === "margin" ) {
                            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
                        }
                        
                        if ( isBorderBox ) {
                            // border-box includes padding, so remove it if we want content
                            if ( extra === "content" ) {
                                val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                            }
                            
                            // At this point, extra isn't border nor margin, so remove border
                            if ( extra !== "margin" ) {
                                val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                            }
                        } else {
                            // At this point, extra isn't content, so add padding
                            val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                            
                            // At this point, extra isn't content nor padding, so add border
                            if ( extra !== "padding" ) {
                                val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                            }
                        }
                    }
                    
                    return val;
                }
                
                function getWidthOrHeight( elem, name, extra ) {
                    
                    // Start with offset property, which is equivalent to the border-box value
                    var valueIsBorderBox = true,
                        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                        styles = getStyles( elem ),
                        isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
                    
                    // Some non-html elements return undefined for offsetWidth, so check for null/undefined
                    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                    if ( val <= 0 || val == null ) {
                        // Fall back to computed then uncomputed css if necessary
                        val = curCSS( elem, name, styles );
                        if ( val < 0 || val == null ) {
                            val = elem.style[ name ];
                        }
                        
                        // Computed unit is not pixels. Stop here and return.
                        if ( rnumnonpx.test(val) ) {
                            return val;
                        }
                        
                        // Check for style in case a browser which returns unreliable values
                        // for getComputedStyle silently falls back to the reliable elem.style
                        valueIsBorderBox = isBorderBox &&
                            ( support.boxSizingReliable() || val === elem.style[ name ] );
                        
                        // Normalize "", auto, and prepare for extra
                        val = parseFloat( val ) || 0;
                    }
                    
                    // Use the active box-sizing model to add/subtract irrelevant styles
                    return ( val +
                            augmentWidthOrHeight(
                                elem,
                                name,
                                extra || ( isBorderBox ? "border" : "content" ),
                                valueIsBorderBox,
                                styles
                            )
                        ) + "px";
                }
                
                function showHide( elements, show ) {
                    var display, elem, hidden,
                        values = [],
                        index = 0,
                        length = elements.length;
                    
                    for ( ; index < length; index++ ) {
                        elem = elements[ index ];
                        if ( !elem.style ) {
                            continue;
                        }
                        
                        values[ index ] = data_priv.get( elem, "olddisplay" );
                        display = elem.style.display;
                        if ( show ) {
                            // Reset the inline display of this element to learn if it is
                            // being hidden by cascaded rules or not
                            if ( !values[ index ] && display === "none" ) {
                                elem.style.display = "";
                            }
                            
                            // Set elements which have been overridden with display: none
                            // in a stylesheet to whatever the default browser style is
                            // for such an element
                            if ( elem.style.display === "" && isHidden( elem ) ) {
                                values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
                            }
                        } else {
                            hidden = isHidden( elem );
                            
                            if ( display !== "none" || !hidden ) {
                                data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
                            }
                        }
                    }
                    
                    // Set the display of most of the elements in a second loop
                    // to avoid the constant reflow
                    for ( index = 0; index < length; index++ ) {
                        elem = elements[ index ];
                        if ( !elem.style ) {
                            continue;
                        }
                        if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                            elem.style.display = show ? values[ index ] || "" : "none";
                        }
                    }
                    
                    return elements;
                }
                
                jQuery.extend({
                    
                    // Add in style property hooks for overriding the default
                    // behavior of getting and setting a style property
                    cssHooks: {
                        opacity: {
                            get: function( elem, computed ) {
                                if ( computed ) {
                                    
                                    // We should always get a number back from opacity
                                    var ret = curCSS( elem, "opacity" );
                                    return ret === "" ? "1" : ret;
                                }
                            }
                        }
                    },
                    
                    // Don't automatically add "px" to these possibly-unitless properties
                    cssNumber: {
                        "columnCount": true,
                        "fillOpacity": true,
                        "flexGrow": true,
                        "flexShrink": true,
                        "fontWeight": true,
                        "lineHeight": true,
                        "opacity": true,
                        "order": true,
                        "orphans": true,
                        "widows": true,
                        "zIndex": true,
                        "zoom": true
                    },
                    
                    // Add in properties whose names you wish to fix before
                    // setting or getting the value
                    cssProps: {
                        "float": "cssFloat"
                    },
                    
                    // Get and set the style property on a DOM Node
                    style: function( elem, name, value, extra ) {
                        
                        // Don't set styles on text and comment nodes
                        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                            return;
                        }
                        
                        // Make sure that we're working with the right name
                        var ret, type, hooks,
                            origName = jQuery.camelCase( name ),
                            style = elem.style;
                        
                        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
                        
                        // Gets hook for the prefixed version, then unprefixed version
                        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
                        
                        // Check if we're setting a value
                        if ( value !== undefined ) {
                            type = typeof value;
                            
                            // Convert "+=" or "-=" to relative numbers (#7345)
                            if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                                // Fixes bug #9237
                                type = "number";
                            }
                            
                            // Make sure that null and NaN values aren't set (#7116)
                            if ( value == null || value !== value ) {
                                return;
                            }
                            
                            // If a number, add 'px' to the (except for certain CSS properties)
                            if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                                value += "px";
                            }
                            
                            // Support: IE9-11+
                            // background-* props affect original clone's values
                            if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                                style[ name ] = "inherit";
                            }
                            
                            // If a hook was provided, use that value, otherwise just set the specified value
                            if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
                                style[ name ] = value;
                            }
                            
                        } else {
                            // If a hook was provided get the non-computed value from there
                            if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                                return ret;
                            }
                            
                            // Otherwise just get the value from the style object
                            return style[ name ];
                        }
                    },
                    
                    css: function( elem, name, extra, styles ) {
                        var val, num, hooks,
                            origName = jQuery.camelCase( name );
                        
                        // Make sure that we're working with the right name
                        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
                        
                        // Try prefixed name followed by the unprefixed name
                        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
                        
                        // If a hook was provided get the computed value from there
                        if ( hooks && "get" in hooks ) {
                            val = hooks.get( elem, true, extra );
                        }
                        
                        // Otherwise, if a way to get the computed value exists, use that
                        if ( val === undefined ) {
                            val = curCSS( elem, name, styles );
                        }
                        
                        // Convert "normal" to computed value
                        if ( val === "normal" && name in cssNormalTransform ) {
                            val = cssNormalTransform[ name ];
                        }
                        
                        // Make numeric if forced or a qualifier was provided and val looks numeric
                        if ( extra === "" || extra ) {
                            num = parseFloat( val );
                            return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
                        }
                        return val;
                    }
                });
                
                jQuery.each([ "height", "width" ], function( i, name ) {
                    jQuery.cssHooks[ name ] = {
                        get: function( elem, computed, extra ) {
                            if ( computed ) {
                                
                                // Certain elements can have dimension info if we invisibly show them
                                // but it must have a current display style that would benefit
                                return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
                                    jQuery.swap( elem, cssShow, function() {
                                        return getWidthOrHeight( elem, name, extra );
                                    }) :
                                    getWidthOrHeight( elem, name, extra );
                            }
                        },
                        
                        set: function( elem, value, extra ) {
                            var styles = extra && getStyles( elem );
                            return setPositiveNumber( elem, value, extra ?
                                    augmentWidthOrHeight(
                                        elem,
                                        name,
                                        extra,
                                        jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                                        styles
                                    ) : 0
                            );
                        }
                    };
                });
                
                // Support: Android 2.3
                jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
                    function( elem, computed ) {
                        if ( computed ) {
                            return jQuery.swap( elem, { "display": "inline-block" },
                                curCSS, [ elem, "marginRight" ] );
                        }
                    }
                );
                
                // These hooks are used by animate to expand properties
                jQuery.each({
                    margin: "",
                    padding: "",
                    border: "Width"
                }, function( prefix, suffix ) {
                    jQuery.cssHooks[ prefix + suffix ] = {
                        expand: function( value ) {
                            var i = 0,
                                expanded = {},
                            
                            // Assumes a single number if not a string
                                parts = typeof value === "string" ? value.split(" ") : [ value ];
                            
                            for ( ; i < 4; i++ ) {
                                expanded[ prefix + cssExpand[ i ] + suffix ] =
                                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                            }
                            
                            return expanded;
                        }
                    };
                    
                    if ( !rmargin.test( prefix ) ) {
                        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                    }
                });
                
                jQuery.fn.extend({
                    css: function( name, value ) {
                        return access( this, function( elem, name, value ) {
                            var styles, len,
                                map = {},
                                i = 0;
                            
                            if ( jQuery.isArray( name ) ) {
                                styles = getStyles( elem );
                                len = name.length;
                                
                                for ( ; i < len; i++ ) {
                                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                                }
                                
                                return map;
                            }
                            
                            return value !== undefined ?
                                jQuery.style( elem, name, value ) :
                                jQuery.css( elem, name );
                        }, name, value, arguments.length > 1 );
                    },
                    show: function() {
                        return showHide( this, true );
                    },
                    hide: function() {
                        return showHide( this );
                    },
                    toggle: function( state ) {
                        if ( typeof state === "boolean" ) {
                            return state ? this.show() : this.hide();
                        }
                        
                        return this.each(function() {
                            if ( isHidden( this ) ) {
                                jQuery( this ).show();
                            } else {
                                jQuery( this ).hide();
                            }
                        });
                    }
                });
                
                
                function Tween( elem, options, prop, end, easing ) {
                    return new Tween.prototype.init( elem, options, prop, end, easing );
                }
                jQuery.Tween = Tween;
                
                Tween.prototype = {
                    constructor: Tween,
                    init: function( elem, options, prop, end, easing, unit ) {
                        this.elem = elem;
                        this.prop = prop;
                        this.easing = easing || "swing";
                        this.options = options;
                        this.start = this.now = this.cur();
                        this.end = end;
                        this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
                    },
                    cur: function() {
                        var hooks = Tween.propHooks[ this.prop ];
                        
                        return hooks && hooks.get ?
                            hooks.get( this ) :
                            Tween.propHooks._default.get( this );
                    },
                    run: function( percent ) {
                        var eased,
                            hooks = Tween.propHooks[ this.prop ];
                        
                        if ( this.options.duration ) {
                            this.pos = eased = jQuery.easing[ this.easing ](
                                percent, this.options.duration * percent, 0, 1, this.options.duration
                            );
                        } else {
                            this.pos = eased = percent;
                        }
                        this.now = ( this.end - this.start ) * eased + this.start;
                        
                        if ( this.options.step ) {
                            this.options.step.call( this.elem, this.now, this );
                        }
                        
                        if ( hooks && hooks.set ) {
                            hooks.set( this );
                        } else {
                            Tween.propHooks._default.set( this );
                        }
                        return this;
                    }
                };
                
                Tween.prototype.init.prototype = Tween.prototype;
                
                Tween.propHooks = {
                    _default: {
                        get: function( tween ) {
                            var result;
                            
                            if ( tween.elem[ tween.prop ] != null &&
                                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                                return tween.elem[ tween.prop ];
                            }
                            
                            // Passing an empty string as a 3rd parameter to .css will automatically
                            // attempt a parseFloat and fallback to a string if the parse fails.
                            // Simple values such as "10px" are parsed to Float;
                            // complex values such as "rotate(1rad)" are returned as-is.
                            result = jQuery.css( tween.elem, tween.prop, "" );
                            // Empty strings, null, undefined and "auto" are converted to 0.
                            return !result || result === "auto" ? 0 : result;
                        },
                        set: function( tween ) {
                            // Use step hook for back compat.
                            // Use cssHook if its there.
                            // Use .style if available and use plain properties where available.
                            if ( jQuery.fx.step[ tween.prop ] ) {
                                jQuery.fx.step[ tween.prop ]( tween );
                            } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                            } else {
                                tween.elem[ tween.prop ] = tween.now;
                            }
                        }
                    }
                };
                
                // Support: IE9
                // Panic based approach to setting things on disconnected nodes
                Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                    set: function( tween ) {
                        if ( tween.elem.nodeType && tween.elem.parentNode ) {
                            tween.elem[ tween.prop ] = tween.now;
                        }
                    }
                };
                
                jQuery.easing = {
                    linear: function( p ) {
                        return p;
                    },
                    swing: function( p ) {
                        return 0.5 - Math.cos( p * Math.PI ) / 2;
                    }
                };
                
                jQuery.fx = Tween.prototype.init;
                
                // Back Compat <1.8 extension point
                jQuery.fx.step = {};
                
                
                
                
                var
                    fxNow, timerId,
                    rfxtypes = /^(?:toggle|show|hide)$/,
                    rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
                    rrun = /queueHooks$/,
                    animationPrefilters = [ defaultPrefilter ],
                    tweeners = {
                        "*": [ function( prop, value ) {
                            var tween = this.createTween( prop, value ),
                                target = tween.cur(),
                                parts = rfxnum.exec( value ),
                                unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
                            
                            // Starting value computation is required for potential unit mismatches
                                start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
                                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                                scale = 1,
                                maxIterations = 20;
                            
                            if ( start && start[ 3 ] !== unit ) {
                                // Trust units reported by jQuery.css
                                unit = unit || start[ 3 ];
                                
                                // Make sure we update the tween properties later on
                                parts = parts || [];
                                
                                // Iteratively approximate from a nonzero starting point
                                start = +target || 1;
                                
                                do {
                                    // If previous iteration zeroed out, double until we get *something*.
                                    // Use string for doubling so we don't accidentally see scale as unchanged below
                                    scale = scale || ".5";
                                    
                                    // Adjust and apply
                                    start = start / scale;
                                    jQuery.style( tween.elem, prop, start + unit );
                                    
                                    // Update scale, tolerating zero or NaN from tween.cur(),
                                    // break the loop if scale is unchanged or perfect, or if we've just had enough
                                } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
                            }
                            
                            // Update tween properties
                            if ( parts ) {
                                start = tween.start = +start || +target || 0;
                                tween.unit = unit;
                                // If a +=/-= token was provided, we're doing a relative animation
                                tween.end = parts[ 1 ] ?
                                start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                                    +parts[ 2 ];
                            }
                            
                            return tween;
                        } ]
                    };
                
                // Animations created synchronously will run synchronously
                function createFxNow() {
                    setTimeout(function() {
                        fxNow = undefined;
                    });
                    return ( fxNow = jQuery.now() );
                }
                
                // Generate parameters to create a standard animation
                function genFx( type, includeWidth ) {
                    var which,
                        i = 0,
                        attrs = { height: type };
                    
                    // If we include width, step value is 1 to do all cssExpand values,
                    // otherwise step value is 2 to skip over Left and Right
                    includeWidth = includeWidth ? 1 : 0;
                    for ( ; i < 4 ; i += 2 - includeWidth ) {
                        which = cssExpand[ i ];
                        attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
                    }
                    
                    if ( includeWidth ) {
                        attrs.opacity = attrs.width = type;
                    }
                    
                    return attrs;
                }
                
                function createTween( value, prop, animation ) {
                    var tween,
                        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
                        index = 0,
                        length = collection.length;
                    for ( ; index < length; index++ ) {
                        if ( (tween = collection[ index ].call( animation, prop, value )) ) {
                            
                            // We're done with this property
                            return tween;
                        }
                    }
                }
                
                function defaultPrefilter( elem, props, opts ) {
                    /* jshint validthis: true */
                    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                        anim = this,
                        orig = {},
                        style = elem.style,
                        hidden = elem.nodeType && isHidden( elem ),
                        dataShow = data_priv.get( elem, "fxshow" );
                    
                    // Handle queue: false promises
                    if ( !opts.queue ) {
                        hooks = jQuery._queueHooks( elem, "fx" );
                        if ( hooks.unqueued == null ) {
                            hooks.unqueued = 0;
                            oldfire = hooks.empty.fire;
                            hooks.empty.fire = function() {
                                if ( !hooks.unqueued ) {
                                    oldfire();
                                }
                            };
                        }
                        hooks.unqueued++;
                        
                        anim.always(function() {
                            // Ensure the complete handler is called before this completes
                            anim.always(function() {
                                hooks.unqueued--;
                                if ( !jQuery.queue( elem, "fx" ).length ) {
                                    hooks.empty.fire();
                                }
                            });
                        });
                    }
                    
                    // Height/width overflow pass
                    if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE9-10 do not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
                        
                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height animated
                        display = jQuery.css( elem, "display" );
                        
                        // Test default display if display is currently "none"
                        checkDisplay = display === "none" ?
                        data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
                        
                        if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
                            style.display = "inline-block";
                        }
                    }
                    
                    if ( opts.overflow ) {
                        style.overflow = "hidden";
                        anim.always(function() {
                            style.overflow = opts.overflow[ 0 ];
                            style.overflowX = opts.overflow[ 1 ];
                            style.overflowY = opts.overflow[ 2 ];
                        });
                    }
                    
                    // show/hide pass
                    for ( prop in props ) {
                        value = props[ prop ];
                        if ( rfxtypes.exec( value ) ) {
                            delete props[ prop ];
                            toggle = toggle || value === "toggle";
                            if ( value === ( hidden ? "hide" : "show" ) ) {
                                
                                // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                                if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                                    hidden = true;
                                } else {
                                    continue;
                                }
                            }
                            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
                            
                            // Any non-fx value stops us from restoring the original display value
                        } else {
                            display = undefined;
                        }
                    }
                    
                    if ( !jQuery.isEmptyObject( orig ) ) {
                        if ( dataShow ) {
                            if ( "hidden" in dataShow ) {
                                hidden = dataShow.hidden;
                            }
                        } else {
                            dataShow = data_priv.access( elem, "fxshow", {} );
                        }
                        
                        // Store state if its toggle - enables .stop().toggle() to "reverse"
                        if ( toggle ) {
                            dataShow.hidden = !hidden;
                        }
                        if ( hidden ) {
                            jQuery( elem ).show();
                        } else {
                            anim.done(function() {
                                jQuery( elem ).hide();
                            });
                        }
                        anim.done(function() {
                            var prop;
                            
                            data_priv.remove( elem, "fxshow" );
                            for ( prop in orig ) {
                                jQuery.style( elem, prop, orig[ prop ] );
                            }
                        });
                        for ( prop in orig ) {
                            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
                            
                            if ( !( prop in dataShow ) ) {
                                dataShow[ prop ] = tween.start;
                                if ( hidden ) {
                                    tween.end = tween.start;
                                    tween.start = prop === "width" || prop === "height" ? 1 : 0;
                                }
                            }
                        }
                        
                        // If this is a noop like .hide().hide(), restore an overwritten display value
                    } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
                        style.display = display;
                    }
                }
                
                function propFilter( props, specialEasing ) {
                    var index, name, easing, value, hooks;
                    
                    // camelCase, specialEasing and expand cssHook pass
                    for ( index in props ) {
                        name = jQuery.camelCase( index );
                        easing = specialEasing[ name ];
                        value = props[ index ];
                        if ( jQuery.isArray( value ) ) {
                            easing = value[ 1 ];
                            value = props[ index ] = value[ 0 ];
                        }
                        
                        if ( index !== name ) {
                            props[ name ] = value;
                            delete props[ index ];
                        }
                        
                        hooks = jQuery.cssHooks[ name ];
                        if ( hooks && "expand" in hooks ) {
                            value = hooks.expand( value );
                            delete props[ name ];
                            
                            // Not quite $.extend, this won't overwrite existing keys.
                            // Reusing 'index' because we have the correct "name"
                            for ( index in value ) {
                                if ( !( index in props ) ) {
                                    props[ index ] = value[ index ];
                                    specialEasing[ index ] = easing;
                                }
                            }
                        } else {
                            specialEasing[ name ] = easing;
                        }
                    }
                }
                
                function Animation( elem, properties, options ) {
                    var result,
                        stopped,
                        index = 0,
                        length = animationPrefilters.length,
                        deferred = jQuery.Deferred().always( function() {
                            // Don't match elem in the :animated selector
                            delete tick.elem;
                        }),
                        tick = function() {
                            if ( stopped ) {
                                return false;
                            }
                            var currentTime = fxNow || createFxNow(),
                                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                            // Support: Android 2.3
                            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                                temp = remaining / animation.duration || 0,
                                percent = 1 - temp,
                                index = 0,
                                length = animation.tweens.length;
                            
                            for ( ; index < length ; index++ ) {
                                animation.tweens[ index ].run( percent );
                            }
                            
                            deferred.notifyWith( elem, [ animation, percent, remaining ]);
                            
                            if ( percent < 1 && length ) {
                                return remaining;
                            } else {
                                deferred.resolveWith( elem, [ animation ] );
                                return false;
                            }
                        },
                        animation = deferred.promise({
                            elem: elem,
                            props: jQuery.extend( {}, properties ),
                            opts: jQuery.extend( true, { specialEasing: {} }, options ),
                            originalProperties: properties,
                            originalOptions: options,
                            startTime: fxNow || createFxNow(),
                            duration: options.duration,
                            tweens: [],
                            createTween: function( prop, end ) {
                                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                                    animation.opts.specialEasing[ prop ] || animation.opts.easing );
                                animation.tweens.push( tween );
                                return tween;
                            },
                            stop: function( gotoEnd ) {
                                var index = 0,
                                // If we are going to the end, we want to run all the tweens
                                // otherwise we skip this part
                                    length = gotoEnd ? animation.tweens.length : 0;
                                if ( stopped ) {
                                    return this;
                                }
                                stopped = true;
                                for ( ; index < length ; index++ ) {
                                    animation.tweens[ index ].run( 1 );
                                }
                                
                                // Resolve when we played the last frame; otherwise, reject
                                if ( gotoEnd ) {
                                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                                } else {
                                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                                }
                                return this;
                            }
                        }),
                        props = animation.props;
                    
                    propFilter( props, animation.opts.specialEasing );
                    
                    for ( ; index < length ; index++ ) {
                        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
                        if ( result ) {
                            return result;
                        }
                    }
                    
                    jQuery.map( props, createTween, animation );
                    
                    if ( jQuery.isFunction( animation.opts.start ) ) {
                        animation.opts.start.call( elem, animation );
                    }
                    
                    jQuery.fx.timer(
                        jQuery.extend( tick, {
                            elem: elem,
                            anim: animation,
                            queue: animation.opts.queue
                        })
                    );
                    
                    // attach callbacks from options
                    return animation.progress( animation.opts.progress )
                        .done( animation.opts.done, animation.opts.complete )
                        .fail( animation.opts.fail )
                        .always( animation.opts.always );
                }
                
                jQuery.Animation = jQuery.extend( Animation, {
                    
                    tweener: function( props, callback ) {
                        if ( jQuery.isFunction( props ) ) {
                            callback = props;
                            props = [ "*" ];
                        } else {
                            props = props.split(" ");
                        }
                        
                        var prop,
                            index = 0,
                            length = props.length;
                        
                        for ( ; index < length ; index++ ) {
                            prop = props[ index ];
                            tweeners[ prop ] = tweeners[ prop ] || [];
                            tweeners[ prop ].unshift( callback );
                        }
                    },
                    
                    prefilter: function( callback, prepend ) {
                        if ( prepend ) {
                            animationPrefilters.unshift( callback );
                        } else {
                            animationPrefilters.push( callback );
                        }
                    }
                });
                
                jQuery.speed = function( speed, easing, fn ) {
                    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                        complete: fn || !fn && easing ||
                        jQuery.isFunction( speed ) && speed,
                        duration: speed,
                        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
                    };
                    
                    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
                    
                    // Normalize opt.queue - true/undefined/null -> "fx"
                    if ( opt.queue == null || opt.queue === true ) {
                        opt.queue = "fx";
                    }
                    
                    // Queueing
                    opt.old = opt.complete;
                    
                    opt.complete = function() {
                        if ( jQuery.isFunction( opt.old ) ) {
                            opt.old.call( this );
                        }
                        
                        if ( opt.queue ) {
                            jQuery.dequeue( this, opt.queue );
                        }
                    };
                    
                    return opt;
                };
                
                jQuery.fn.extend({
                    fadeTo: function( speed, to, easing, callback ) {
                        
                        // Show any hidden elements after setting opacity to 0
                        return this.filter( isHidden ).css( "opacity", 0 ).show()
                            
                            // Animate to the value specified
                            .end().animate({ opacity: to }, speed, easing, callback );
                    },
                    animate: function( prop, speed, easing, callback ) {
                        var empty = jQuery.isEmptyObject( prop ),
                            optall = jQuery.speed( speed, easing, callback ),
                            doAnimation = function() {
                                // Operate on a copy of prop so per-property easing won't be lost
                                var anim = Animation( this, jQuery.extend( {}, prop ), optall );
                                
                                // Empty animations, or finishing resolves immediately
                                if ( empty || data_priv.get( this, "finish" ) ) {
                                    anim.stop( true );
                                }
                            };
                        doAnimation.finish = doAnimation;
                        
                        return empty || optall.queue === false ?
                            this.each( doAnimation ) :
                            this.queue( optall.queue, doAnimation );
                    },
                    stop: function( type, clearQueue, gotoEnd ) {
                        var stopQueue = function( hooks ) {
                            var stop = hooks.stop;
                            delete hooks.stop;
                            stop( gotoEnd );
                        };
                        
                        if ( typeof type !== "string" ) {
                            gotoEnd = clearQueue;
                            clearQueue = type;
                            type = undefined;
                        }
                        if ( clearQueue && type !== false ) {
                            this.queue( type || "fx", [] );
                        }
                        
                        return this.each(function() {
                            var dequeue = true,
                                index = type != null && type + "queueHooks",
                                timers = jQuery.timers,
                                data = data_priv.get( this );
                            
                            if ( index ) {
                                if ( data[ index ] && data[ index ].stop ) {
                                    stopQueue( data[ index ] );
                                }
                            } else {
                                for ( index in data ) {
                                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                                        stopQueue( data[ index ] );
                                    }
                                }
                            }
                            
                            for ( index = timers.length; index--; ) {
                                if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                                    timers[ index ].anim.stop( gotoEnd );
                                    dequeue = false;
                                    timers.splice( index, 1 );
                                }
                            }
                            
                            // Start the next in the queue if the last step wasn't forced.
                            // Timers currently will call their complete callbacks, which
                            // will dequeue but only if they were gotoEnd.
                            if ( dequeue || !gotoEnd ) {
                                jQuery.dequeue( this, type );
                            }
                        });
                    },
                    finish: function( type ) {
                        if ( type !== false ) {
                            type = type || "fx";
                        }
                        return this.each(function() {
                            var index,
                                data = data_priv.get( this ),
                                queue = data[ type + "queue" ],
                                hooks = data[ type + "queueHooks" ],
                                timers = jQuery.timers,
                                length = queue ? queue.length : 0;
                            
                            // Enable finishing flag on private data
                            data.finish = true;
                            
                            // Empty the queue first
                            jQuery.queue( this, type, [] );
                            
                            if ( hooks && hooks.stop ) {
                                hooks.stop.call( this, true );
                            }
                            
                            // Look for any active animations, and finish them
                            for ( index = timers.length; index--; ) {
                                if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                                    timers[ index ].anim.stop( true );
                                    timers.splice( index, 1 );
                                }
                            }
                            
                            // Look for any animations in the old queue and finish them
                            for ( index = 0; index < length; index++ ) {
                                if ( queue[ index ] && queue[ index ].finish ) {
                                    queue[ index ].finish.call( this );
                                }
                            }
                            
                            // Turn off finishing flag
                            delete data.finish;
                        });
                    }
                });
                
                jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
                    var cssFn = jQuery.fn[ name ];
                    jQuery.fn[ name ] = function( speed, easing, callback ) {
                        return speed == null || typeof speed === "boolean" ?
                            cssFn.apply( this, arguments ) :
                            this.animate( genFx( name, true ), speed, easing, callback );
                    };
                });
                
                // Generate shortcuts for custom animations
                jQuery.each({
                    slideDown: genFx("show"),
                    slideUp: genFx("hide"),
                    slideToggle: genFx("toggle"),
                    fadeIn: { opacity: "show" },
                    fadeOut: { opacity: "hide" },
                    fadeToggle: { opacity: "toggle" }
                }, function( name, props ) {
                    jQuery.fn[ name ] = function( speed, easing, callback ) {
                        return this.animate( props, speed, easing, callback );
                    };
                });
                
                jQuery.timers = [];
                jQuery.fx.tick = function() {
                    var timer,
                        i = 0,
                        timers = jQuery.timers;
                    
                    fxNow = jQuery.now();
                    
                    for ( ; i < timers.length; i++ ) {
                        timer = timers[ i ];
                        // Checks the timer has not already been removed
                        if ( !timer() && timers[ i ] === timer ) {
                            timers.splice( i--, 1 );
                        }
                    }
                    
                    if ( !timers.length ) {
                        jQuery.fx.stop();
                    }
                    fxNow = undefined;
                };
                
                jQuery.fx.timer = function( timer ) {
                    jQuery.timers.push( timer );
                    if ( timer() ) {
                        jQuery.fx.start();
                    } else {
                        jQuery.timers.pop();
                    }
                };
                
                jQuery.fx.interval = 13;
                
                jQuery.fx.start = function() {
                    if ( !timerId ) {
                        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
                    }
                };
                
                jQuery.fx.stop = function() {
                    clearInterval( timerId );
                    timerId = null;
                };
                
                jQuery.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    // Default speed
                    _default: 400
                };
                
                
                // Based off of the plugin by Clint Helfers, with permission.
                // http://blindsignals.com/index.php/2009/07/jquery-delay/
                jQuery.fn.delay = function( time, type ) {
                    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                    type = type || "fx";
                    
                    return this.queue( type, function( next, hooks ) {
                        var timeout = setTimeout( next, time );
                        hooks.stop = function() {
                            clearTimeout( timeout );
                        };
                    });
                };
                
                
                (function() {
                    var input = document.createElement( "input" ),
                        select = document.createElement( "select" ),
                        opt = select.appendChild( document.createElement( "option" ) );
                    
                    input.type = "checkbox";
                    
                    // Support: iOS<=5.1, Android<=4.2+
                    // Default value for a checkbox should be "on"
                    support.checkOn = input.value !== "";
                    
                    // Support: IE<=11+
                    // Must access selectedIndex to make default options select
                    support.optSelected = opt.selected;
                    
                    // Support: Android<=2.3
                    // Options inside disabled selects are incorrectly marked as disabled
                    select.disabled = true;
                    support.optDisabled = !opt.disabled;
                    
                    // Support: IE<=11+
                    // An input loses its value after becoming a radio
                    input = document.createElement( "input" );
                    input.value = "t";
                    input.type = "radio";
                    support.radioValue = input.value === "t";
                })();
                
                
                var nodeHook, boolHook,
                    attrHandle = jQuery.expr.attrHandle;
                
                jQuery.fn.extend({
                    attr: function( name, value ) {
                        return access( this, jQuery.attr, name, value, arguments.length > 1 );
                    },
                    
                    removeAttr: function( name ) {
                        return this.each(function() {
                            jQuery.removeAttr( this, name );
                        });
                    }
                });
                
                jQuery.extend({
                    attr: function( elem, name, value ) {
                        var hooks, ret,
                            nType = elem.nodeType;
                        
                        // don't get/set attributes on text, comment and attribute nodes
                        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                            return;
                        }
                        
                        // Fallback to prop when attributes are not supported
                        if ( typeof elem.getAttribute === strundefined ) {
                            return jQuery.prop( elem, name, value );
                        }
                        
                        // All attributes are lowercase
                        // Grab necessary hook if one is defined
                        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                            name = name.toLowerCase();
                            hooks = jQuery.attrHooks[ name ] ||
                                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
                        }
                        
                        if ( value !== undefined ) {
                            
                            if ( value === null ) {
                                jQuery.removeAttr( elem, name );
                                
                            } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                                return ret;
                                
                            } else {
                                elem.setAttribute( name, value + "" );
                                return value;
                            }
                            
                        } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                            return ret;
                            
                        } else {
                            ret = jQuery.find.attr( elem, name );
                            
                            // Non-existent attributes return null, we normalize to undefined
                            return ret == null ?
                                undefined :
                                ret;
                        }
                    },
                    
                    removeAttr: function( elem, value ) {
                        var name, propName,
                            i = 0,
                            attrNames = value && value.match( rnotwhite );
                        
                        if ( attrNames && elem.nodeType === 1 ) {
                            while ( (name = attrNames[i++]) ) {
                                propName = jQuery.propFix[ name ] || name;
                                
                                // Boolean attributes get special treatment (#10870)
                                if ( jQuery.expr.match.bool.test( name ) ) {
                                    // Set corresponding property to false
                                    elem[ propName ] = false;
                                }
                                
                                elem.removeAttribute( name );
                            }
                        }
                    },
                    
                    attrHooks: {
                        type: {
                            set: function( elem, value ) {
                                if ( !support.radioValue && value === "radio" &&
                                    jQuery.nodeName( elem, "input" ) ) {
                                    var val = elem.value;
                                    elem.setAttribute( "type", value );
                                    if ( val ) {
                                        elem.value = val;
                                    }
                                    return value;
                                }
                            }
                        }
                    }
                });
                
                // Hooks for boolean attributes
                boolHook = {
                    set: function( elem, value, name ) {
                        if ( value === false ) {
                            // Remove boolean attributes when set to false
                            jQuery.removeAttr( elem, name );
                        } else {
                            elem.setAttribute( name, name );
                        }
                        return name;
                    }
                };
                jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
                    var getter = attrHandle[ name ] || jQuery.find.attr;
                    
                    attrHandle[ name ] = function( elem, name, isXML ) {
                        var ret, handle;
                        if ( !isXML ) {
                            // Avoid an infinite loop by temporarily removing this function from the getter
                            handle = attrHandle[ name ];
                            attrHandle[ name ] = ret;
                            ret = getter( elem, name, isXML ) != null ?
                                name.toLowerCase() :
                                null;
                            attrHandle[ name ] = handle;
                        }
                        return ret;
                    };
                });
                
                
                
                
                var rfocusable = /^(?:input|select|textarea|button)$/i;
                
                jQuery.fn.extend({
                    prop: function( name, value ) {
                        return access( this, jQuery.prop, name, value, arguments.length > 1 );
                    },
                    
                    removeProp: function( name ) {
                        return this.each(function() {
                            delete this[ jQuery.propFix[ name ] || name ];
                        });
                    }
                });
                
                jQuery.extend({
                    propFix: {
                        "for": "htmlFor",
                        "class": "className"
                    },
                    
                    prop: function( elem, name, value ) {
                        var ret, hooks, notxml,
                            nType = elem.nodeType;
                        
                        // Don't get/set properties on text, comment and attribute nodes
                        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                            return;
                        }
                        
                        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
                        
                        if ( notxml ) {
                            // Fix name and attach hooks
                            name = jQuery.propFix[ name ] || name;
                            hooks = jQuery.propHooks[ name ];
                        }
                        
                        if ( value !== undefined ) {
                            return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                                ret :
                                ( elem[ name ] = value );
                            
                        } else {
                            return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                                ret :
                                elem[ name ];
                        }
                    },
                    
                    propHooks: {
                        tabIndex: {
                            get: function( elem ) {
                                return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
                                    elem.tabIndex :
                                    -1;
                            }
                        }
                    }
                });
                
                if ( !support.optSelected ) {
                    jQuery.propHooks.selected = {
                        get: function( elem ) {
                            var parent = elem.parentNode;
                            if ( parent && parent.parentNode ) {
                                parent.parentNode.selectedIndex;
                            }
                            return null;
                        }
                    };
                }
                
                jQuery.each([
                    "tabIndex",
                    "readOnly",
                    "maxLength",
                    "cellSpacing",
                    "cellPadding",
                    "rowSpan",
                    "colSpan",
                    "useMap",
                    "frameBorder",
                    "contentEditable"
                ], function() {
                    jQuery.propFix[ this.toLowerCase() ] = this;
                });
                
                
                
                
                var rclass = /[\t\r\n\f]/g;
                
                jQuery.fn.extend({
                    addClass: function( value ) {
                        var classes, elem, cur, clazz, j, finalValue,
                            proceed = typeof value === "string" && value,
                            i = 0,
                            len = this.length;
                        
                        if ( jQuery.isFunction( value ) ) {
                            return this.each(function( j ) {
                                jQuery( this ).addClass( value.call( this, j, this.className ) );
                            });
                        }
                        
                        if ( proceed ) {
                            // The disjunction here is for better compressibility (see removeClass)
                            classes = ( value || "" ).match( rnotwhite ) || [];
                            
                            for ( ; i < len; i++ ) {
                                elem = this[ i ];
                                cur = elem.nodeType === 1 && ( elem.className ?
                                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                                            " "
                                    );
                                
                                if ( cur ) {
                                    j = 0;
                                    while ( (clazz = classes[j++]) ) {
                                        if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                            cur += clazz + " ";
                                        }
                                    }
                                    
                                    // only assign if different to avoid unneeded rendering.
                                    finalValue = jQuery.trim( cur );
                                    if ( elem.className !== finalValue ) {
                                        elem.className = finalValue;
                                    }
                                }
                            }
                        }
                        
                        return this;
                    },
                    
                    removeClass: function( value ) {
                        var classes, elem, cur, clazz, j, finalValue,
                            proceed = arguments.length === 0 || typeof value === "string" && value,
                            i = 0,
                            len = this.length;
                        
                        if ( jQuery.isFunction( value ) ) {
                            return this.each(function( j ) {
                                jQuery( this ).removeClass( value.call( this, j, this.className ) );
                            });
                        }
                        if ( proceed ) {
                            classes = ( value || "" ).match( rnotwhite ) || [];
                            
                            for ( ; i < len; i++ ) {
                                elem = this[ i ];
                                // This expression is here for better compressibility (see addClass)
                                cur = elem.nodeType === 1 && ( elem.className ?
                                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                                            ""
                                    );
                                
                                if ( cur ) {
                                    j = 0;
                                    while ( (clazz = classes[j++]) ) {
                                        // Remove *all* instances
                                        while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                                            cur = cur.replace( " " + clazz + " ", " " );
                                        }
                                    }
                                    
                                    // Only assign if different to avoid unneeded rendering.
                                    finalValue = value ? jQuery.trim( cur ) : "";
                                    if ( elem.className !== finalValue ) {
                                        elem.className = finalValue;
                                    }
                                }
                            }
                        }
                        
                        return this;
                    },
                    
                    toggleClass: function( value, stateVal ) {
                        var type = typeof value;
                        
                        if ( typeof stateVal === "boolean" && type === "string" ) {
                            return stateVal ? this.addClass( value ) : this.removeClass( value );
                        }
                        
                        if ( jQuery.isFunction( value ) ) {
                            return this.each(function( i ) {
                                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                            });
                        }
                        
                        return this.each(function() {
                            if ( type === "string" ) {
                                // Toggle individual class names
                                var className,
                                    i = 0,
                                    self = jQuery( this ),
                                    classNames = value.match( rnotwhite ) || [];
                                
                                while ( (className = classNames[ i++ ]) ) {
                                    // Check each className given, space separated list
                                    if ( self.hasClass( className ) ) {
                                        self.removeClass( className );
                                    } else {
                                        self.addClass( className );
                                    }
                                }
                                
                                // Toggle whole class name
                            } else if ( type === strundefined || type === "boolean" ) {
                                if ( this.className ) {
                                    // store className if set
                                    data_priv.set( this, "__className__", this.className );
                                }
                                
                                // If the element has a class name or if we're passed `false`,
                                // then remove the whole classname (if there was one, the above saved it).
                                // Otherwise bring back whatever was previously saved (if anything),
                                // falling back to the empty string if nothing was stored.
                                this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
                            }
                        });
                    },
                    
                    hasClass: function( selector ) {
                        var className = " " + selector + " ",
                            i = 0,
                            l = this.length;
                        for ( ; i < l; i++ ) {
                            if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                                return true;
                            }
                        }
                        
                        return false;
                    }
                });
                
                
                
                
                var rreturn = /\r/g;
                
                jQuery.fn.extend({
                    val: function( value ) {
                        var hooks, ret, isFunction,
                            elem = this[0];
                        
                        if ( !arguments.length ) {
                            if ( elem ) {
                                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
                                
                                if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                                    return ret;
                                }
                                
                                ret = elem.value;
                                
                                return typeof ret === "string" ?
                                    // Handle most common string cases
                                    ret.replace(rreturn, "") :
                                    // Handle cases where value is null/undef or number
                                    ret == null ? "" : ret;
                            }
                            
                            return;
                        }
                        
                        isFunction = jQuery.isFunction( value );
                        
                        return this.each(function( i ) {
                            var val;
                            
                            if ( this.nodeType !== 1 ) {
                                return;
                            }
                            
                            if ( isFunction ) {
                                val = value.call( this, i, jQuery( this ).val() );
                            } else {
                                val = value;
                            }
                            
                            // Treat null/undefined as ""; convert numbers to string
                            if ( val == null ) {
                                val = "";
                                
                            } else if ( typeof val === "number" ) {
                                val += "";
                                
                            } else if ( jQuery.isArray( val ) ) {
                                val = jQuery.map( val, function( value ) {
                                    return value == null ? "" : value + "";
                                });
                            }
                            
                            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
                            
                            // If set returns undefined, fall back to normal setting
                            if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                                this.value = val;
                            }
                        });
                    }
                });
                
                jQuery.extend({
                    valHooks: {
                        option: {
                            get: function( elem ) {
                                var val = jQuery.find.attr( elem, "value" );
                                return val != null ?
                                    val :
                                    // Support: IE10-11+
                                    // option.text throws exceptions (#14686, #14858)
                                    jQuery.trim( jQuery.text( elem ) );
                            }
                        },
                        select: {
                            get: function( elem ) {
                                var value, option,
                                    options = elem.options,
                                    index = elem.selectedIndex,
                                    one = elem.type === "select-one" || index < 0,
                                    values = one ? null : [],
                                    max = one ? index + 1 : options.length,
                                    i = index < 0 ?
                                        max :
                                        one ? index : 0;
                                
                                // Loop through all the selected options
                                for ( ; i < max; i++ ) {
                                    option = options[ i ];
                                    
                                    // IE6-9 doesn't update selected after form reset (#2551)
                                    if ( ( option.selected || i === index ) &&
                                            // Don't return options that are disabled or in a disabled optgroup
                                        ( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
                                        ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
                                        
                                        // Get the specific value for the option
                                        value = jQuery( option ).val();
                                        
                                        // We don't need an array for one selects
                                        if ( one ) {
                                            return value;
                                        }
                                        
                                        // Multi-Selects return an array
                                        values.push( value );
                                    }
                                }
                                
                                return values;
                            },
                            
                            set: function( elem, value ) {
                                var optionSet, option,
                                    options = elem.options,
                                    values = jQuery.makeArray( value ),
                                    i = options.length;
                                
                                while ( i-- ) {
                                    option = options[ i ];
                                    if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
                                        optionSet = true;
                                    }
                                }
                                
                                // Force browsers to behave consistently when non-matching value is set
                                if ( !optionSet ) {
                                    elem.selectedIndex = -1;
                                }
                                return values;
                            }
                        }
                    }
                });
                
                // Radios and checkboxes getter/setter
                jQuery.each([ "radio", "checkbox" ], function() {
                    jQuery.valHooks[ this ] = {
                        set: function( elem, value ) {
                            if ( jQuery.isArray( value ) ) {
                                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
                            }
                        }
                    };
                    if ( !support.checkOn ) {
                        jQuery.valHooks[ this ].get = function( elem ) {
                            return elem.getAttribute("value") === null ? "on" : elem.value;
                        };
                    }
                });
                
                
                
                
                // Return jQuery for attributes-only inclusion
                
                
                jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
                "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
                    
                    // Handle event binding
                    jQuery.fn[ name ] = function( data, fn ) {
                        return arguments.length > 0 ?
                            this.on( name, null, data, fn ) :
                            this.trigger( name );
                    };
                });
                
                jQuery.fn.extend({
                    hover: function( fnOver, fnOut ) {
                        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
                    },
                    
                    bind: function( types, data, fn ) {
                        return this.on( types, null, data, fn );
                    },
                    unbind: function( types, fn ) {
                        return this.off( types, null, fn );
                    },
                    
                    delegate: function( selector, types, data, fn ) {
                        return this.on( types, selector, data, fn );
                    },
                    undelegate: function( selector, types, fn ) {
                        // ( namespace ) or ( selector, types [, fn] )
                        return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
                    }
                });
                
                
                var nonce = jQuery.now();
                
                var rquery = (/\?/);
                
                
                
                // Support: Android 2.3
                // Workaround failure to string-cast null input
                jQuery.parseJSON = function( data ) {
                    return JSON.parse( data + "" );
                };
                
                
                // Cross-browser xml parsing
                jQuery.parseXML = function( data ) {
                    var xml, tmp;
                    if ( !data || typeof data !== "string" ) {
                        return null;
                    }
                    
                    // Support: IE9
                    try {
                        tmp = new DOMParser();
                        xml = tmp.parseFromString( data, "text/xml" );
                    } catch ( e ) {
                        xml = undefined;
                    }
                    
                    if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
                        jQuery.error( "Invalid XML: " + data );
                    }
                    return xml;
                };
                
                
                var
                    rhash = /#.*$/,
                    rts = /([?&])_=[^&]*/,
                    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
                // #7653, #8125, #8152: local protocol detection
                    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                    rnoContent = /^(?:GET|HEAD)$/,
                    rprotocol = /^\/\//,
                    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
                
                /* Prefilters
                 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
                 * 2) These are called:
                 *    - BEFORE asking for a transport
                 *    - AFTER param serialization (s.data is a string if s.processData is true)
                 * 3) key is the dataType
                 * 4) the catchall symbol "*" can be used
                 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
                 */
                    prefilters = {},
                
                /* Transports bindings
                 * 1) key is the dataType
                 * 2) the catchall symbol "*" can be used
                 * 3) selection will start with transport dataType and THEN go to "*" if needed
                 */
                    transports = {},
                
                // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                    allTypes = "*/".concat( "*" ),
                
                // Document location
                    ajaxLocation = window.location.href,
                
                // Segment location into parts
                    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
                
                // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
                function addToPrefiltersOrTransports( structure ) {
                    
                    // dataTypeExpression is optional and defaults to "*"
                    return function( dataTypeExpression, func ) {
                        
                        if ( typeof dataTypeExpression !== "string" ) {
                            func = dataTypeExpression;
                            dataTypeExpression = "*";
                        }
                        
                        var dataType,
                            i = 0,
                            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
                        
                        if ( jQuery.isFunction( func ) ) {
                            // For each dataType in the dataTypeExpression
                            while ( (dataType = dataTypes[i++]) ) {
                                // Prepend if requested
                                if ( dataType[0] === "+" ) {
                                    dataType = dataType.slice( 1 ) || "*";
                                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );
                                    
                                    // Otherwise append
                                } else {
                                    (structure[ dataType ] = structure[ dataType ] || []).push( func );
                                }
                            }
                        }
                    };
                }
                
                // Base inspection function for prefilters and transports
                function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
                    
                    var inspected = {},
                        seekingTransport = ( structure === transports );
                    
                    function inspect( dataType ) {
                        var selected;
                        inspected[ dataType ] = true;
                        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                            if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                                options.dataTypes.unshift( dataTypeOrTransport );
                                inspect( dataTypeOrTransport );
                                return false;
                            } else if ( seekingTransport ) {
                                return !( selected = dataTypeOrTransport );
                            }
                        });
                        return selected;
                    }
                    
                    return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
                }
                
                // A special extend for ajax options
                // that takes "flat" options (not to be deep extended)
                // Fixes #9887
                function ajaxExtend( target, src ) {
                    var key, deep,
                        flatOptions = jQuery.ajaxSettings.flatOptions || {};
                    
                    for ( key in src ) {
                        if ( src[ key ] !== undefined ) {
                            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
                        }
                    }
                    if ( deep ) {
                        jQuery.extend( true, target, deep );
                    }
                    
                    return target;
                }
                
                /* Handles responses to an ajax request:
                 * - finds the right dataType (mediates between content-type and expected dataType)
                 * - returns the corresponding response
                 */
                function ajaxHandleResponses( s, jqXHR, responses ) {
                    
                    var ct, type, finalDataType, firstDataType,
                        contents = s.contents,
                        dataTypes = s.dataTypes;
                    
                    // Remove auto dataType and get content-type in the process
                    while ( dataTypes[ 0 ] === "*" ) {
                        dataTypes.shift();
                        if ( ct === undefined ) {
                            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                        }
                    }
                    
                    // Check if we're dealing with a known content-type
                    if ( ct ) {
                        for ( type in contents ) {
                            if ( contents[ type ] && contents[ type ].test( ct ) ) {
                                dataTypes.unshift( type );
                                break;
                            }
                        }
                    }
                    
                    // Check to see if we have a response for the expected dataType
                    if ( dataTypes[ 0 ] in responses ) {
                        finalDataType = dataTypes[ 0 ];
                    } else {
                        // Try convertible dataTypes
                        for ( type in responses ) {
                            if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                                finalDataType = type;
                                break;
                            }
                            if ( !firstDataType ) {
                                firstDataType = type;
                            }
                        }
                        // Or just use first one
                        finalDataType = finalDataType || firstDataType;
                    }
                    
                    // If we found a dataType
                    // We add the dataType to the list if needed
                    // and return the corresponding response
                    if ( finalDataType ) {
                        if ( finalDataType !== dataTypes[ 0 ] ) {
                            dataTypes.unshift( finalDataType );
                        }
                        return responses[ finalDataType ];
                    }
                }
                
                /* Chain conversions given the request and the original response
                 * Also sets the responseXXX fields on the jqXHR instance
                 */
                function ajaxConvert( s, response, jqXHR, isSuccess ) {
                    var conv2, current, conv, tmp, prev,
                        converters = {},
                    // Work with a copy of dataTypes in case we need to modify it for conversion
                        dataTypes = s.dataTypes.slice();
                    
                    // Create converters map with lowercased keys
                    if ( dataTypes[ 1 ] ) {
                        for ( conv in s.converters ) {
                            converters[ conv.toLowerCase() ] = s.converters[ conv ];
                        }
                    }
                    
                    current = dataTypes.shift();
                    
                    // Convert to each sequential dataType
                    while ( current ) {
                        
                        if ( s.responseFields[ current ] ) {
                            jqXHR[ s.responseFields[ current ] ] = response;
                        }
                        
                        // Apply the dataFilter if provided
                        if ( !prev && isSuccess && s.dataFilter ) {
                            response = s.dataFilter( response, s.dataType );
                        }
                        
                        prev = current;
                        current = dataTypes.shift();
                        
                        if ( current ) {
                            
                            // There's only work to do if current dataType is non-auto
                            if ( current === "*" ) {
                                
                                current = prev;
                                
                                // Convert response if prev dataType is non-auto and differs from current
                            } else if ( prev !== "*" && prev !== current ) {
                                
                                // Seek a direct converter
                                conv = converters[ prev + " " + current ] || converters[ "* " + current ];
                                
                                // If none found, seek a pair
                                if ( !conv ) {
                                    for ( conv2 in converters ) {
                                        
                                        // If conv2 outputs current
                                        tmp = conv2.split( " " );
                                        if ( tmp[ 1 ] === current ) {
                                            
                                            // If prev can be converted to accepted input
                                            conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                                converters[ "* " + tmp[ 0 ] ];
                                            if ( conv ) {
                                                // Condense equivalence converters
                                                if ( conv === true ) {
                                                    conv = converters[ conv2 ];
                                                    
                                                    // Otherwise, insert the intermediate dataType
                                                } else if ( converters[ conv2 ] !== true ) {
                                                    current = tmp[ 0 ];
                                                    dataTypes.unshift( tmp[ 1 ] );
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // Apply converter (if not an equivalence)
                                if ( conv !== true ) {
                                    
                                    // Unless errors are allowed to bubble, catch and return them
                                    if ( conv && s[ "throws" ] ) {
                                        response = conv( response );
                                    } else {
                                        try {
                                            response = conv( response );
                                        } catch ( e ) {
                                            return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    return { state: "success", data: response };
                }
                
                jQuery.extend({
                    
                    // Counter for holding the number of active queries
                    active: 0,
                    
                    // Last-Modified header cache for next request
                    lastModified: {},
                    etag: {},
                    
                    ajaxSettings: {
                        url: ajaxLocation,
                        type: "GET",
                        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
                        global: true,
                        processData: true,
                        async: true,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                        /*
                         timeout: 0,
                         data: null,
                         dataType: null,
                         username: null,
                         password: null,
                         cache: null,
                         throws: false,
                         traditional: false,
                         headers: {},
                         */
                        
                        accepts: {
                            "*": allTypes,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },
                        
                        contents: {
                            xml: /xml/,
                            html: /html/,
                            json: /json/
                        },
                        
                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },
                        
                        // Data converters
                        // Keys separate source (or catchall "*") and destination types with a single space
                        converters: {
                            
                            // Convert anything to text
                            "* text": String,
                            
                            // Text to html (true = no transformation)
                            "text html": true,
                            
                            // Evaluate text as a json expression
                            "text json": jQuery.parseJSON,
                            
                            // Parse text as xml
                            "text xml": jQuery.parseXML
                        },
                        
                        // For options that shouldn't be deep extended:
                        // you can add your own custom options here if
                        // and when you create one that shouldn't be
                        // deep extended (see ajaxExtend)
                        flatOptions: {
                            url: true,
                            context: true
                        }
                    },
                    
                    // Creates a full fledged settings object into target
                    // with both ajaxSettings and settings fields.
                    // If target is omitted, writes into ajaxSettings.
                    ajaxSetup: function( target, settings ) {
                        return settings ?
                            
                            // Building a settings object
                            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
                            
                            // Extending ajaxSettings
                            ajaxExtend( jQuery.ajaxSettings, target );
                    },
                    
                    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
                    ajaxTransport: addToPrefiltersOrTransports( transports ),
                    
                    // Main method
                    ajax: function( url, options ) {
                        
                        // If url is an object, simulate pre-1.5 signature
                        if ( typeof url === "object" ) {
                            options = url;
                            url = undefined;
                        }
                        
                        // Force options to be an object
                        options = options || {};
                        
                        var transport,
                        // URL without anti-cache param
                            cacheURL,
                        // Response headers
                            responseHeadersString,
                            responseHeaders,
                        // timeout handle
                            timeoutTimer,
                        // Cross-domain detection vars
                            parts,
                        // To know if global events are to be dispatched
                            fireGlobals,
                        // Loop variable
                            i,
                        // Create the final options object
                            s = jQuery.ajaxSetup( {}, options ),
                        // Callbacks context
                            callbackContext = s.context || s,
                        // Context for global events is callbackContext if it is a DOM node or jQuery collection
                            globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                                jQuery( callbackContext ) :
                                jQuery.event,
                        // Deferreds
                            deferred = jQuery.Deferred(),
                            completeDeferred = jQuery.Callbacks("once memory"),
                        // Status-dependent callbacks
                            statusCode = s.statusCode || {},
                        // Headers (they are sent all at once)
                            requestHeaders = {},
                            requestHeadersNames = {},
                        // The jqXHR state
                            state = 0,
                        // Default abort message
                            strAbort = "canceled",
                        // Fake xhr
                            jqXHR = {
                                readyState: 0,
                                
                                // Builds headers hashtable if needed
                                getResponseHeader: function( key ) {
                                    var match;
                                    if ( state === 2 ) {
                                        if ( !responseHeaders ) {
                                            responseHeaders = {};
                                            while ( (match = rheaders.exec( responseHeadersString )) ) {
                                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                            }
                                        }
                                        match = responseHeaders[ key.toLowerCase() ];
                                    }
                                    return match == null ? null : match;
                                },
                                
                                // Raw string
                                getAllResponseHeaders: function() {
                                    return state === 2 ? responseHeadersString : null;
                                },
                                
                                // Caches the header
                                setRequestHeader: function( name, value ) {
                                    var lname = name.toLowerCase();
                                    if ( !state ) {
                                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                        requestHeaders[ name ] = value;
                                    }
                                    return this;
                                },
                                
                                // Overrides response content-type header
                                overrideMimeType: function( type ) {
                                    if ( !state ) {
                                        s.mimeType = type;
                                    }
                                    return this;
                                },
                                
                                // Status-dependent callbacks
                                statusCode: function( map ) {
                                    var code;
                                    if ( map ) {
                                        if ( state < 2 ) {
                                            for ( code in map ) {
                                                // Lazy-add the new callback in a way that preserves old ones
                                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                            }
                                        } else {
                                            // Execute the appropriate callbacks
                                            jqXHR.always( map[ jqXHR.status ] );
                                        }
                                    }
                                    return this;
                                },
                                
                                // Cancel the request
                                abort: function( statusText ) {
                                    var finalText = statusText || strAbort;
                                    if ( transport ) {
                                        transport.abort( finalText );
                                    }
                                    done( 0, finalText );
                                    return this;
                                }
                            };
                        
                        // Attach deferreds
                        deferred.promise( jqXHR ).complete = completeDeferred.add;
                        jqXHR.success = jqXHR.done;
                        jqXHR.error = jqXHR.fail;
                        
                        // Remove hash character (#7531: and string promotion)
                        // Add protocol if not provided (prefilters might expect it)
                        // Handle falsy url in the settings object (#10093: consistency with old signature)
                        // We also use the url parameter if available
                        s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
                            .replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
                        
                        // Alias method option to type as per ticket #12004
                        s.type = options.method || options.type || s.method || s.type;
                        
                        // Extract dataTypes list
                        s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
                        
                        // A cross-domain request is in order when we have a protocol:host:port mismatch
                        if ( s.crossDomain == null ) {
                            parts = rurl.exec( s.url.toLowerCase() );
                            s.crossDomain = !!( parts &&
                                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                                ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                                ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
                            );
                        }
                        
                        // Convert data if not already a string
                        if ( s.data && s.processData && typeof s.data !== "string" ) {
                            s.data = jQuery.param( s.data, s.traditional );
                        }
                        
                        // Apply prefilters
                        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
                        
                        // If request was aborted inside a prefilter, stop there
                        if ( state === 2 ) {
                            return jqXHR;
                        }
                        
                        // We can fire global events as of now if asked to
                        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                        fireGlobals = jQuery.event && s.global;
                        
                        // Watch for a new set of requests
                        if ( fireGlobals && jQuery.active++ === 0 ) {
                            jQuery.event.trigger("ajaxStart");
                        }
                        
                        // Uppercase the type
                        s.type = s.type.toUpperCase();
                        
                        // Determine if request has content
                        s.hasContent = !rnoContent.test( s.type );
                        
                        // Save the URL in case we're toying with the If-Modified-Since
                        // and/or If-None-Match header later on
                        cacheURL = s.url;
                        
                        // More options handling for requests with no content
                        if ( !s.hasContent ) {
                            
                            // If data is available, append data to url
                            if ( s.data ) {
                                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                                // #9682: remove data so that it's not used in an eventual retry
                                delete s.data;
                            }
                            
                            // Add anti-cache in url if needed
                            if ( s.cache === false ) {
                                s.url = rts.test( cacheURL ) ?
                                    
                                    // If there is already a '_' parameter, set its value
                                    cacheURL.replace( rts, "$1_=" + nonce++ ) :
                                    
                                    // Otherwise add one to the end
                                cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                            }
                        }
                        
                        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                        if ( s.ifModified ) {
                            if ( jQuery.lastModified[ cacheURL ] ) {
                                jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                            }
                            if ( jQuery.etag[ cacheURL ] ) {
                                jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                            }
                        }
                        
                        // Set the correct header, if data is being sent
                        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                            jqXHR.setRequestHeader( "Content-Type", s.contentType );
                        }
                        
                        // Set the Accepts header for the server, depending on the dataType
                        jqXHR.setRequestHeader(
                            "Accept",
                            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                            s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                                s.accepts[ "*" ]
                        );
                        
                        // Check for headers option
                        for ( i in s.headers ) {
                            jqXHR.setRequestHeader( i, s.headers[ i ] );
                        }
                        
                        // Allow custom headers/mimetypes and early abort
                        if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                            // Abort if not done already and return
                            return jqXHR.abort();
                        }
                        
                        // Aborting is no longer a cancellation
                        strAbort = "abort";
                        
                        // Install callbacks on deferreds
                        for ( i in { success: 1, error: 1, complete: 1 } ) {
                            jqXHR[ i ]( s[ i ] );
                        }
                        
                        // Get transport
                        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
                        
                        // If no transport, we auto-abort
                        if ( !transport ) {
                            done( -1, "No Transport" );
                        } else {
                            jqXHR.readyState = 1;
                            
                            // Send global event
                            if ( fireGlobals ) {
                                globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                            }
                            // Timeout
                            if ( s.async && s.timeout > 0 ) {
                                timeoutTimer = setTimeout(function() {
                                    jqXHR.abort("timeout");
                                }, s.timeout );
                            }
                            
                            try {
                                state = 1;
                                transport.send( requestHeaders, done );
                            } catch ( e ) {
                                // Propagate exception as error if not done
                                if ( state < 2 ) {
                                    done( -1, e );
                                    // Simply rethrow otherwise
                                } else {
                                    throw e;
                                }
                            }
                        }
                        
                        // Callback for when everything is done
                        function done( status, nativeStatusText, responses, headers ) {
                            var isSuccess, success, error, response, modified,
                                statusText = nativeStatusText;
                            
                            // Called once
                            if ( state === 2 ) {
                                return;
                            }
                            
                            // State is "done" now
                            state = 2;
                            
                            // Clear timeout if it exists
                            if ( timeoutTimer ) {
                                clearTimeout( timeoutTimer );
                            }
                            
                            // Dereference transport for early garbage collection
                            // (no matter how long the jqXHR object will be used)
                            transport = undefined;
                            
                            // Cache response headers
                            responseHeadersString = headers || "";
                            
                            // Set readyState
                            jqXHR.readyState = status > 0 ? 4 : 0;
                            
                            // Determine if successful
                            isSuccess = status >= 200 && status < 300 || status === 304;
                            
                            // Get response data
                            if ( responses ) {
                                response = ajaxHandleResponses( s, jqXHR, responses );
                            }
                            
                            // Convert no matter what (that way responseXXX fields are always set)
                            response = ajaxConvert( s, response, jqXHR, isSuccess );
                            
                            // If successful, handle type chaining
                            if ( isSuccess ) {
                                
                                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                if ( s.ifModified ) {
                                    modified = jqXHR.getResponseHeader("Last-Modified");
                                    if ( modified ) {
                                        jQuery.lastModified[ cacheURL ] = modified;
                                    }
                                    modified = jqXHR.getResponseHeader("etag");
                                    if ( modified ) {
                                        jQuery.etag[ cacheURL ] = modified;
                                    }
                                }
                                
                                // if no content
                                if ( status === 204 || s.type === "HEAD" ) {
                                    statusText = "nocontent";
                                    
                                    // if not modified
                                } else if ( status === 304 ) {
                                    statusText = "notmodified";
                                    
                                    // If we have data, let's convert it
                                } else {
                                    statusText = response.state;
                                    success = response.data;
                                    error = response.error;
                                    isSuccess = !error;
                                }
                            } else {
                                // Extract error from statusText and normalize for non-aborts
                                error = statusText;
                                if ( status || !statusText ) {
                                    statusText = "error";
                                    if ( status < 0 ) {
                                        status = 0;
                                    }
                                }
                            }
                            
                            // Set data for the fake xhr object
                            jqXHR.status = status;
                            jqXHR.statusText = ( nativeStatusText || statusText ) + "";
                            
                            // Success/Error
                            if ( isSuccess ) {
                                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                            } else {
                                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                            }
                            
                            // Status-dependent callbacks
                            jqXHR.statusCode( statusCode );
                            statusCode = undefined;
                            
                            if ( fireGlobals ) {
                                globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                                    [ jqXHR, s, isSuccess ? success : error ] );
                            }
                            
                            // Complete
                            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
                            
                            if ( fireGlobals ) {
                                globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                                // Handle the global AJAX counter
                                if ( !( --jQuery.active ) ) {
                                    jQuery.event.trigger("ajaxStop");
                                }
                            }
                        }
                        
                        return jqXHR;
                    },
                    
                    getJSON: function( url, data, callback ) {
                        return jQuery.get( url, data, callback, "json" );
                    },
                    
                    getScript: function( url, callback ) {
                        return jQuery.get( url, undefined, callback, "script" );
                    }
                });
                
                jQuery.each( [ "get", "post" ], function( i, method ) {
                    jQuery[ method ] = function( url, data, callback, type ) {
                        // Shift arguments if data argument was omitted
                        if ( jQuery.isFunction( data ) ) {
                            type = type || callback;
                            callback = data;
                            data = undefined;
                        }
                        
                        return jQuery.ajax({
                            url: url,
                            type: method,
                            dataType: type,
                            data: data,
                            success: callback
                        });
                    };
                });
                
                
                jQuery._evalUrl = function( url ) {
                    return jQuery.ajax({
                        url: url,
                        type: "GET",
                        dataType: "script",
                        async: false,
                        global: false,
                        "throws": true
                    });
                };
                
                
                jQuery.fn.extend({
                    wrapAll: function( html ) {
                        var wrap;
                        
                        if ( jQuery.isFunction( html ) ) {
                            return this.each(function( i ) {
                                jQuery( this ).wrapAll( html.call(this, i) );
                            });
                        }
                        
                        if ( this[ 0 ] ) {
                            
                            // The elements to wrap the target around
                            wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
                            
                            if ( this[ 0 ].parentNode ) {
                                wrap.insertBefore( this[ 0 ] );
                            }
                            
                            wrap.map(function() {
                                var elem = this;
                                
                                while ( elem.firstElementChild ) {
                                    elem = elem.firstElementChild;
                                }
                                
                                return elem;
                            }).append( this );
                        }
                        
                        return this;
                    },
                    
                    wrapInner: function( html ) {
                        if ( jQuery.isFunction( html ) ) {
                            return this.each(function( i ) {
                                jQuery( this ).wrapInner( html.call(this, i) );
                            });
                        }
                        
                        return this.each(function() {
                            var self = jQuery( this ),
                                contents = self.contents();
                            
                            if ( contents.length ) {
                                contents.wrapAll( html );
                                
                            } else {
                                self.append( html );
                            }
                        });
                    },
                    
                    wrap: function( html ) {
                        var isFunction = jQuery.isFunction( html );
                        
                        return this.each(function( i ) {
                            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
                        });
                    },
                    
                    unwrap: function() {
                        return this.parent().each(function() {
                            if ( !jQuery.nodeName( this, "body" ) ) {
                                jQuery( this ).replaceWith( this.childNodes );
                            }
                        }).end();
                    }
                });
                
                
                jQuery.expr.filters.hidden = function( elem ) {
                    // Support: Opera <= 12.12
                    // Opera reports offsetWidths and offsetHeights less than zero on some elements
                    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
                };
                jQuery.expr.filters.visible = function( elem ) {
                    return !jQuery.expr.filters.hidden( elem );
                };
                
                
                
                
                var r20 = /%20/g,
                    rbracket = /\[\]$/,
                    rCRLF = /\r?\n/g,
                    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                    rsubmittable = /^(?:input|select|textarea|keygen)/i;
                
                function buildParams( prefix, obj, traditional, add ) {
                    var name;
                    
                    if ( jQuery.isArray( obj ) ) {
                        // Serialize array item.
                        jQuery.each( obj, function( i, v ) {
                            if ( traditional || rbracket.test( prefix ) ) {
                                // Treat each array item as a scalar.
                                add( prefix, v );
                                
                            } else {
                                // Item is non-scalar (array or object), encode its numeric index.
                                buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
                            }
                        });
                        
                    } else if ( !traditional && jQuery.type( obj ) === "object" ) {
                        // Serialize object item.
                        for ( name in obj ) {
                            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
                        }
                        
                    } else {
                        // Serialize scalar item.
                        add( prefix, obj );
                    }
                }
                
                // Serialize an array of form elements or a set of
                // key/values into a query string
                jQuery.param = function( a, traditional ) {
                    var prefix,
                        s = [],
                        add = function( key, value ) {
                            // If value is a function, invoke it and return its value
                            value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                            s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                        };
                    
                    // Set traditional to true for jQuery <= 1.3.2 behavior.
                    if ( traditional === undefined ) {
                        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                    }
                    
                    // If an array was passed in, assume that it is an array of form elements.
                    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
                        // Serialize the form elements
                        jQuery.each( a, function() {
                            add( this.name, this.value );
                        });
                        
                    } else {
                        // If traditional, encode the "old" way (the way 1.3.2 or older
                        // did it), otherwise encode params recursively.
                        for ( prefix in a ) {
                            buildParams( prefix, a[ prefix ], traditional, add );
                        }
                    }
                    
                    // Return the resulting serialization
                    return s.join( "&" ).replace( r20, "+" );
                };
                
                jQuery.fn.extend({
                    serialize: function() {
                        return jQuery.param( this.serializeArray() );
                    },
                    serializeArray: function() {
                        return this.map(function() {
                            // Can add propHook for "elements" to filter or add form elements
                            var elements = jQuery.prop( this, "elements" );
                            return elements ? jQuery.makeArray( elements ) : this;
                        })
                            .filter(function() {
                                var type = this.type;
                                
                                // Use .is( ":disabled" ) so that fieldset[disabled] works
                                return this.name && !jQuery( this ).is( ":disabled" ) &&
                                    rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                                    ( this.checked || !rcheckableType.test( type ) );
                            })
                            .map(function( i, elem ) {
                                var val = jQuery( this ).val();
                                
                                return val == null ?
                                    null :
                                    jQuery.isArray( val ) ?
                                        jQuery.map( val, function( val ) {
                                            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                                        }) :
                                    { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                            }).get();
                    }
                });
                
                
                jQuery.ajaxSettings.xhr = function() {
                    try {
                        return new XMLHttpRequest();
                    } catch( e ) {}
                };
                
                var xhrId = 0,
                    xhrCallbacks = {},
                    xhrSuccessStatus = {
                        // file protocol always yields status code 0, assume 200
                        0: 200,
                        // Support: IE9
                        // #1450: sometimes IE returns 1223 when it should be 204
                        1223: 204
                    },
                    xhrSupported = jQuery.ajaxSettings.xhr();
                
                // Support: IE9
                // Open requests must be manually aborted on unload (#5280)
                // See https://support.microsoft.com/kb/2856746 for more info
                if ( window.attachEvent ) {
                    window.attachEvent( "onunload", function() {
                        for ( var key in xhrCallbacks ) {
                            xhrCallbacks[ key ]();
                        }
                    });
                }
                
                support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
                support.ajax = xhrSupported = !!xhrSupported;
                
                jQuery.ajaxTransport(function( options ) {
                    var callback;
                    
                    // Cross domain only allowed if supported through XMLHttpRequest
                    if ( support.cors || xhrSupported && !options.crossDomain ) {
                        return {
                            send: function( headers, complete ) {
                                var i,
                                    xhr = options.xhr(),
                                    id = ++xhrId;
                                
                                xhr.open( options.type, options.url, options.async, options.username, options.password );
                                
                                // Apply custom fields if provided
                                if ( options.xhrFields ) {
                                    for ( i in options.xhrFields ) {
                                        xhr[ i ] = options.xhrFields[ i ];
                                    }
                                }
                                
                                // Override mime type if needed
                                if ( options.mimeType && xhr.overrideMimeType ) {
                                    xhr.overrideMimeType( options.mimeType );
                                }
                                
                                // X-Requested-With header
                                // For cross-domain requests, seeing as conditions for a preflight are
                                // akin to a jigsaw puzzle, we simply never set it to be sure.
                                // (it can always be set on a per-request basis or even using ajaxSetup)
                                // For same-domain requests, won't change header if already provided.
                                if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                                    headers["X-Requested-With"] = "XMLHttpRequest";
                                }
                                
                                // Set headers
                                for ( i in headers ) {
                                    xhr.setRequestHeader( i, headers[ i ] );
                                }
                                
                                // Callback
                                callback = function( type ) {
                                    return function() {
                                        if ( callback ) {
                                            delete xhrCallbacks[ id ];
                                            callback = xhr.onload = xhr.onerror = null;
                                            
                                            if ( type === "abort" ) {
                                                xhr.abort();
                                            } else if ( type === "error" ) {
                                                complete(
                                                    // file: protocol always yields status 0; see #8605, #14207
                                                    xhr.status,
                                                    xhr.statusText
                                                );
                                            } else {
                                                complete(
                                                    xhrSuccessStatus[ xhr.status ] || xhr.status,
                                                    xhr.statusText,
                                                    // Support: IE9
                                                    // Accessing binary-data responseText throws an exception
                                                    // (#11426)
                                                    typeof xhr.responseText === "string" ? {
                                                        text: xhr.responseText
                                                    } : undefined,
                                                    xhr.getAllResponseHeaders()
                                                );
                                            }
                                        }
                                    };
                                };
                                
                                // Listen to events
                                xhr.onload = callback();
                                xhr.onerror = callback("error");
                                
                                // Create the abort callback
                                callback = xhrCallbacks[ id ] = callback("abort");
                                
                                try {
                                    // Do send the request (this may raise an exception)
                                    xhr.send( options.hasContent && options.data || null );
                                } catch ( e ) {
                                    // #14683: Only rethrow if this hasn't been notified as an error yet
                                    if ( callback ) {
                                        throw e;
                                    }
                                }
                            },
                            
                            abort: function() {
                                if ( callback ) {
                                    callback();
                                }
                            }
                        };
                    }
                });
                
                
                
                
                // Install script dataType
                jQuery.ajaxSetup({
                    accepts: {
                        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /(?:java|ecma)script/
                    },
                    converters: {
                        "text script": function( text ) {
                            jQuery.globalEval( text );
                            return text;
                        }
                    }
                });
                
                // Handle cache's special case and crossDomain
                jQuery.ajaxPrefilter( "script", function( s ) {
                    if ( s.cache === undefined ) {
                        s.cache = false;
                    }
                    if ( s.crossDomain ) {
                        s.type = "GET";
                    }
                });
                
                // Bind script tag hack transport
                jQuery.ajaxTransport( "script", function( s ) {
                    // This transport only deals with cross domain requests
                    if ( s.crossDomain ) {
                        var script, callback;
                        return {
                            send: function( _, complete ) {
                                script = jQuery("<script>").prop({
                                    async: true,
                                    charset: s.scriptCharset,
                                    src: s.url
                                }).on(
                                    "load error",
                                    callback = function( evt ) {
                                        script.remove();
                                        callback = null;
                                        if ( evt ) {
                                            complete( evt.type === "error" ? 404 : 200, evt.type );
                                        }
                                    }
                                );
                                document.head.appendChild( script[ 0 ] );
                            },
                            abort: function() {
                                if ( callback ) {
                                    callback();
                                }
                            }
                        };
                    }
                });
                
                
                
                
                var oldCallbacks = [],
                    rjsonp = /(=)\?(?=&|$)|\?\?/;
                
                // Default jsonp settings
                jQuery.ajaxSetup({
                    jsonp: "callback",
                    jsonpCallback: function() {
                        var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
                        this[ callback ] = true;
                        return callback;
                    }
                });
                
                // Detect, normalize options and install callbacks for jsonp requests
                jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
                    
                    var callbackName, overwritten, responseContainer,
                        jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                                    "url" :
                                typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
                            );
                    
                    // Handle iff the expected data type is "jsonp" or we have a parameter to set
                    if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
                        
                        // Get callback name, remembering preexisting value associated with it
                        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                            s.jsonpCallback() :
                            s.jsonpCallback;
                        
                        // Insert callback into url or form data
                        if ( jsonProp ) {
                            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
                        } else if ( s.jsonp !== false ) {
                            s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
                        }
                        
                        // Use data converter to retrieve json after script execution
                        s.converters["script json"] = function() {
                            if ( !responseContainer ) {
                                jQuery.error( callbackName + " was not called" );
                            }
                            return responseContainer[ 0 ];
                        };
                        
                        // force json dataType
                        s.dataTypes[ 0 ] = "json";
                        
                        // Install callback
                        overwritten = window[ callbackName ];
                        window[ callbackName ] = function() {
                            responseContainer = arguments;
                        };
                        
                        // Clean-up function (fires after converters)
                        jqXHR.always(function() {
                            // Restore preexisting value
                            window[ callbackName ] = overwritten;
                            
                            // Save back as free
                            if ( s[ callbackName ] ) {
                                // make sure that re-using the options doesn't screw things around
                                s.jsonpCallback = originalSettings.jsonpCallback;
                                
                                // save the callback name for future use
                                oldCallbacks.push( callbackName );
                            }
                            
                            // Call if it was a function and we have a response
                            if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                                overwritten( responseContainer[ 0 ] );
                            }
                            
                            responseContainer = overwritten = undefined;
                        });
                        
                        // Delegate to script
                        return "script";
                    }
                });
                
                
                
                
                // data: string of html
                // context (optional): If specified, the fragment will be created in this context, defaults to document
                // keepScripts (optional): If true, will include scripts passed in the html string
                jQuery.parseHTML = function( data, context, keepScripts ) {
                    if ( !data || typeof data !== "string" ) {
                        return null;
                    }
                    if ( typeof context === "boolean" ) {
                        keepScripts = context;
                        context = false;
                    }
                    context = context || document;
                    
                    var parsed = rsingleTag.exec( data ),
                        scripts = !keepScripts && [];
                    
                    // Single tag
                    if ( parsed ) {
                        return [ context.createElement( parsed[1] ) ];
                    }
                    
                    parsed = jQuery.buildFragment( [ data ], context, scripts );
                    
                    if ( scripts && scripts.length ) {
                        jQuery( scripts ).remove();
                    }
                    
                    return jQuery.merge( [], parsed.childNodes );
                };
                
                
                // Keep a copy of the old load method
                var _load = jQuery.fn.load;
                
                /**
                 * Load a url into a page
                 */
                jQuery.fn.load = function( url, params, callback ) {
                    if ( typeof url !== "string" && _load ) {
                        return _load.apply( this, arguments );
                    }
                    
                    var selector, type, response,
                        self = this,
                        off = url.indexOf(" ");
                    
                    if ( off >= 0 ) {
                        selector = jQuery.trim( url.slice( off ) );
                        url = url.slice( 0, off );
                    }
                    
                    // If it's a function
                    if ( jQuery.isFunction( params ) ) {
                        
                        // We assume that it's the callback
                        callback = params;
                        params = undefined;
                        
                        // Otherwise, build a param string
                    } else if ( params && typeof params === "object" ) {
                        type = "POST";
                    }
                    
                    // If we have elements to modify, make the request
                    if ( self.length > 0 ) {
                        jQuery.ajax({
                            url: url,
                            
                            // if "type" variable is undefined, then "GET" method will be used
                            type: type,
                            dataType: "html",
                            data: params
                        }).done(function( responseText ) {
                            
                            // Save response for use in complete callback
                            response = arguments;
                            
                            self.html( selector ?
                                
                                // If a selector was specified, locate the right elements in a dummy div
                                // Exclude scripts to avoid IE 'Permission Denied' errors
                                jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
                                
                                // Otherwise use the full result
                                responseText );
                            
                        }).complete( callback && function( jqXHR, status ) {
                                self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
                            });
                    }
                    
                    return this;
                };
                
                
                
                
                // Attach a bunch of functions for handling common AJAX events
                jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
                    jQuery.fn[ type ] = function( fn ) {
                        return this.on( type, fn );
                    };
                });
                
                
                
                
                jQuery.expr.filters.animated = function( elem ) {
                    return jQuery.grep(jQuery.timers, function( fn ) {
                        return elem === fn.elem;
                    }).length;
                };
                
                
                
                
                var docElem = window.document.documentElement;
                
                /**
                 * Gets a window from an element
                 */
                function getWindow( elem ) {
                    return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
                }
                
                jQuery.offset = {
                    setOffset: function( elem, options, i ) {
                        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                            position = jQuery.css( elem, "position" ),
                            curElem = jQuery( elem ),
                            props = {};
                        
                        // Set position first, in-case top/left are set even on static elem
                        if ( position === "static" ) {
                            elem.style.position = "relative";
                        }
                        
                        curOffset = curElem.offset();
                        curCSSTop = jQuery.css( elem, "top" );
                        curCSSLeft = jQuery.css( elem, "left" );
                        calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                            ( curCSSTop + curCSSLeft ).indexOf("auto") > -1;
                        
                        // Need to be able to calculate position if either
                        // top or left is auto and position is either absolute or fixed
                        if ( calculatePosition ) {
                            curPosition = curElem.position();
                            curTop = curPosition.top;
                            curLeft = curPosition.left;
                            
                        } else {
                            curTop = parseFloat( curCSSTop ) || 0;
                            curLeft = parseFloat( curCSSLeft ) || 0;
                        }
                        
                        if ( jQuery.isFunction( options ) ) {
                            options = options.call( elem, i, curOffset );
                        }
                        
                        if ( options.top != null ) {
                            props.top = ( options.top - curOffset.top ) + curTop;
                        }
                        if ( options.left != null ) {
                            props.left = ( options.left - curOffset.left ) + curLeft;
                        }
                        
                        if ( "using" in options ) {
                            options.using.call( elem, props );
                            
                        } else {
                            curElem.css( props );
                        }
                    }
                };
                
                jQuery.fn.extend({
                    offset: function( options ) {
                        if ( arguments.length ) {
                            return options === undefined ?
                                this :
                                this.each(function( i ) {
                                    jQuery.offset.setOffset( this, options, i );
                                });
                        }
                        
                        var docElem, win,
                            elem = this[ 0 ],
                            box = { top: 0, left: 0 },
                            doc = elem && elem.ownerDocument;
                        
                        if ( !doc ) {
                            return;
                        }
                        
                        docElem = doc.documentElement;
                        
                        // Make sure it's not a disconnected DOM node
                        if ( !jQuery.contains( docElem, elem ) ) {
                            return box;
                        }
                        
                        // Support: BlackBerry 5, iOS 3 (original iPhone)
                        // If we don't have gBCR, just use 0,0 rather than error
                        if ( typeof elem.getBoundingClientRect !== strundefined ) {
                            box = elem.getBoundingClientRect();
                        }
                        win = getWindow( doc );
                        return {
                            top: box.top + win.pageYOffset - docElem.clientTop,
                            left: box.left + win.pageXOffset - docElem.clientLeft
                        };
                    },
                    
                    position: function() {
                        if ( !this[ 0 ] ) {
                            return;
                        }
                        
                        var offsetParent, offset,
                            elem = this[ 0 ],
                            parentOffset = { top: 0, left: 0 };
                        
                        // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
                        if ( jQuery.css( elem, "position" ) === "fixed" ) {
                            // Assume getBoundingClientRect is there when computed position is fixed
                            offset = elem.getBoundingClientRect();
                            
                        } else {
                            // Get *real* offsetParent
                            offsetParent = this.offsetParent();
                            
                            // Get correct offsets
                            offset = this.offset();
                            if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                                parentOffset = offsetParent.offset();
                            }
                            
                            // Add offsetParent borders
                            parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                            parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
                        }
                        
                        // Subtract parent offsets and element margins
                        return {
                            top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                            left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
                        };
                    },
                    
                    offsetParent: function() {
                        return this.map(function() {
                            var offsetParent = this.offsetParent || docElem;
                            
                            while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                                offsetParent = offsetParent.offsetParent;
                            }
                            
                            return offsetParent || docElem;
                        });
                    }
                });
                
                // Create scrollLeft and scrollTop methods
                jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
                    var top = "pageYOffset" === prop;
                    
                    jQuery.fn[ method ] = function( val ) {
                        return access( this, function( elem, method, val ) {
                            var win = getWindow( elem );
                            
                            if ( val === undefined ) {
                                return win ? win[ prop ] : elem[ method ];
                            }
                            
                            if ( win ) {
                                win.scrollTo(
                                    !top ? val : window.pageXOffset,
                                    top ? val : window.pageYOffset
                                );
                                
                            } else {
                                elem[ method ] = val;
                            }
                        }, method, val, arguments.length, null );
                    };
                });
                
                // Support: Safari<7+, Chrome<37+
                // Add the top/left cssHooks using jQuery.fn.position
                // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
                // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
                // getComputedStyle returns percent when specified for top/left/bottom/right;
                // rather than make the css module depend on the offset module, just check for it here
                jQuery.each( [ "top", "left" ], function( i, prop ) {
                    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
                        function( elem, computed ) {
                            if ( computed ) {
                                computed = curCSS( elem, prop );
                                // If curCSS returns percentage, fallback to offset
                                return rnumnonpx.test( computed ) ?
                                jQuery( elem ).position()[ prop ] + "px" :
                                    computed;
                            }
                        }
                    );
                });
                
                
                // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
                jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
                    jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
                        // Margin is only for outerHeight, outerWidth
                        jQuery.fn[ funcName ] = function( margin, value ) {
                            var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                                extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
                            
                            return access( this, function( elem, type, value ) {
                                var doc;
                                
                                if ( jQuery.isWindow( elem ) ) {
                                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                                    // https://github.com/jquery/jquery/pull/764
                                    return elem.document.documentElement[ "client" + name ];
                                }
                                
                                // Get document width or height
                                if ( elem.nodeType === 9 ) {
                                    doc = elem.documentElement;
                                    
                                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                    // whichever is greatest
                                    return Math.max(
                                        elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                        elem.body[ "offset" + name ], doc[ "offset" + name ],
                                        doc[ "client" + name ]
                                    );
                                }
                                
                                return value === undefined ?
                                    // Get width or height on the element, requesting but not forcing parseFloat
                                    jQuery.css( elem, type, extra ) :
                                    
                                    // Set width or height on the element
                                    jQuery.style( elem, type, value, extra );
                            }, type, chainable ? margin : undefined, chainable, null );
                        };
                    });
                });
                
                
                // The number of elements contained in the matched element set
                jQuery.fn.size = function() {
                    return this.length;
                };
                
                jQuery.fn.andSelf = jQuery.fn.addBack;
                
                
                
                
                // Register as a named AMD module, since jQuery can be concatenated with other
                // files that may use define, but not via a proper concatenation script that
                // understands anonymous AMD modules. A named AMD is safest and most robust
                // way to register. Lowercase jquery is used because AMD module names are
                // derived from file names, and jQuery is normally delivered in a lowercase
                // file name. Do this after creating the global so that if an AMD module wants
                // to call noConflict to hide this version of jQuery, it will work.
                
                // Note that for maximum portability, libraries that are not jQuery should
                // declare themselves as anonymous modules, and avoid setting a global if an
                // AMD loader is present. jQuery is a special case. For more information, see
                // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
                
                if ( typeof define === "function" && define.amd ) {
                    define( "jquery", [], function() {
                        return jQuery;
                    });
                }
                
                
                
                
                var
                // Map over jQuery in case of overwrite
                    _jQuery = window.jQuery,
                
                // Map over the $ in case of overwrite
                    _$ = window.$;
                
                jQuery.noConflict = function( deep ) {
                    if ( window.$ === jQuery ) {
                        window.$ = _$;
                    }
                    
                    if ( deep && window.jQuery === jQuery ) {
                        window.jQuery = _jQuery;
                    }
                    
                    return jQuery;
                };
                
                // Expose jQuery and $ identifiers, even in AMD
                // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
                // and CommonJS for browser emulators (#13566)
                if ( typeof noGlobal === strundefined ) {
                    window.jQuery = window.$ = jQuery;
                }
                
                
                
                
                return jQuery;
                
            }));
            
        }).call(global, module, undefined, undefined);
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{}],85:[function(require,module,exports){
    /*
     A JavaScript implementation of the SHA family of hashes, as
     defined in FIPS PUB 180-2 as well as the corresponding HMAC implementation
     as defined in FIPS PUB 198a
    
     Copyright Brian Turek 2008-2013
     Distributed under the BSD License
     See http://caligatio.github.com/jsSHA/ for more information
    
     Several functions taken from Paul Johnston
     */
    (function(T){function z(a,c,b){var g=0,f=[0],h="",l=null,h=b||"UTF8";if("UTF8"!==h&&"UTF16"!==h)throw"encoding must be UTF8 or UTF16";if("HEX"===c){if(0!==a.length%2)throw"srcString of HEX type must be in byte increments";l=B(a);g=l.binLen;f=l.value}else if("ASCII"===c||"TEXT"===c)l=J(a,h),g=l.binLen,f=l.value;else if("B64"===c)l=K(a),g=l.binLen,f=l.value;else throw"inputFormat must be HEX, TEXT, ASCII, or B64";this.getHash=function(a,c,b,h){var l=null,d=f.slice(),n=g,p;3===arguments.length?"number"!==
    typeof b&&(h=b,b=1):2===arguments.length&&(b=1);if(b!==parseInt(b,10)||1>b)throw"numRounds must a integer >= 1";switch(c){case "HEX":l=L;break;case "B64":l=M;break;default:throw"format must be HEX or B64";}if("SHA-1"===a)for(p=0;p<b;p++)d=y(d,n),n=160;else if("SHA-224"===a)for(p=0;p<b;p++)d=v(d,n,a),n=224;else if("SHA-256"===a)for(p=0;p<b;p++)d=v(d,n,a),n=256;else if("SHA-384"===a)for(p=0;p<b;p++)d=v(d,n,a),n=384;else if("SHA-512"===a)for(p=0;p<b;p++)d=v(d,n,a),n=512;else throw"Chosen SHA variant is not supported";
        return l(d,N(h))};this.getHMAC=function(a,b,c,l,s){var d,n,p,m,w=[],x=[];d=null;switch(l){case "HEX":l=L;break;case "B64":l=M;break;default:throw"outputFormat must be HEX or B64";}if("SHA-1"===c)n=64,m=160;else if("SHA-224"===c)n=64,m=224;else if("SHA-256"===c)n=64,m=256;else if("SHA-384"===c)n=128,m=384;else if("SHA-512"===c)n=128,m=512;else throw"Chosen SHA variant is not supported";if("HEX"===b)d=B(a),p=d.binLen,d=d.value;else if("ASCII"===b||"TEXT"===b)d=J(a,h),p=d.binLen,d=d.value;else if("B64"===
        b)d=K(a),p=d.binLen,d=d.value;else throw"inputFormat must be HEX, TEXT, ASCII, or B64";a=8*n;b=n/4-1;n<p/8?(d="SHA-1"===c?y(d,p):v(d,p,c),d[b]&=4294967040):n>p/8&&(d[b]&=4294967040);for(n=0;n<=b;n+=1)w[n]=d[n]^909522486,x[n]=d[n]^1549556828;c="SHA-1"===c?y(x.concat(y(w.concat(f),a+g)),a+m):v(x.concat(v(w.concat(f),a+g,c)),a+m,c);return l(c,N(s))}}function s(a,c){this.a=a;this.b=c}function J(a,c){var b=[],g,f=[],h=0,l;if("UTF8"===c)for(l=0;l<a.length;l+=1)for(g=a.charCodeAt(l),f=[],2048<g?(f[0]=224|
        (g&61440)>>>12,f[1]=128|(g&4032)>>>6,f[2]=128|g&63):128<g?(f[0]=192|(g&1984)>>>6,f[1]=128|g&63):f[0]=g,g=0;g<f.length;g+=1)b[h>>>2]|=f[g]<<24-h%4*8,h+=1;else if("UTF16"===c)for(l=0;l<a.length;l+=1)b[h>>>2]|=a.charCodeAt(l)<<16-h%4*8,h+=2;return{value:b,binLen:8*h}}function B(a){var c=[],b=a.length,g,f;if(0!==b%2)throw"String of HEX type must be in byte increments";for(g=0;g<b;g+=2){f=parseInt(a.substr(g,2),16);if(isNaN(f))throw"String of HEX type contains invalid characters";c[g>>>3]|=f<<24-g%8*4}return{value:c,
        binLen:4*b}}function K(a){var c=[],b=0,g,f,h,l,r;if(-1===a.search(/^[a-zA-Z0-9=+\/]+$/))throw"Invalid character in base-64 string";g=a.indexOf("=");a=a.replace(/\=/g,"");if(-1!==g&&g<a.length)throw"Invalid '=' found in base-64 string";for(f=0;f<a.length;f+=4){r=a.substr(f,4);for(h=l=0;h<r.length;h+=1)g="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(r[h]),l|=g<<18-6*h;for(h=0;h<r.length-1;h+=1)c[b>>2]|=(l>>>16-8*h&255)<<24-b%4*8,b+=1}return{value:c,binLen:8*b}}function L(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               c){var b="",g=4*a.length,f,h;for(f=0;f<g;f+=1)h=a[f>>>2]>>>8*(3-f%4),b+="0123456789abcdef".charAt(h>>>4&15)+"0123456789abcdef".charAt(h&15);return c.outputUpper?b.toUpperCase():b}function M(a,c){var b="",g=4*a.length,f,h,l;for(f=0;f<g;f+=3)for(l=(a[f>>>2]>>>8*(3-f%4)&255)<<16|(a[f+1>>>2]>>>8*(3-(f+1)%4)&255)<<8|a[f+2>>>2]>>>8*(3-(f+2)%4)&255,h=0;4>h;h+=1)b=8*f+6*h<=32*a.length?b+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(l>>>6*(3-h)&63):b+c.b64Pad;return b}function N(a){var c=
    {outputUpper:!1,b64Pad:"="};try{a.hasOwnProperty("outputUpper")&&(c.outputUpper=a.outputUpper),a.hasOwnProperty("b64Pad")&&(c.b64Pad=a.b64Pad)}catch(b){}if("boolean"!==typeof c.outputUpper)throw"Invalid outputUpper formatting option";if("string"!==typeof c.b64Pad)throw"Invalid b64Pad formatting option";return c}function U(a,c){return a<<c|a>>>32-c}function u(a,c){return a>>>c|a<<32-c}function t(a,c){var b=null,b=new s(a.a,a.b);return b=32>=c?new s(b.a>>>c|b.b<<32-c&4294967295,b.b>>>c|b.a<<32-c&4294967295):
        new s(b.b>>>c-32|b.a<<64-c&4294967295,b.a>>>c-32|b.b<<64-c&4294967295)}function O(a,c){var b=null;return b=32>=c?new s(a.a>>>c,a.b>>>c|a.a<<32-c&4294967295):new s(0,a.a>>>c-32)}function V(a,c,b){return a^c^b}function P(a,c,b){return a&c^~a&b}function W(a,c,b){return new s(a.a&c.a^~a.a&b.a,a.b&c.b^~a.b&b.b)}function Q(a,c,b){return a&c^a&b^c&b}function X(a,c,b){return new s(a.a&c.a^a.a&b.a^c.a&b.a,a.b&c.b^a.b&b.b^c.b&b.b)}function Y(a){return u(a,2)^u(a,13)^u(a,22)}function Z(a){var c=t(a,28),b=t(a,
        34);a=t(a,39);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function $(a){return u(a,6)^u(a,11)^u(a,25)}function aa(a){var c=t(a,14),b=t(a,18);a=t(a,41);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function ba(a){return u(a,7)^u(a,18)^a>>>3}function ca(a){var c=t(a,1),b=t(a,8);a=O(a,7);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function da(a){return u(a,17)^u(a,19)^a>>>10}function ea(a){var c=t(a,19),b=t(a,61);a=O(a,6);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function R(a,c){var b=(a&65535)+(c&65535);return((a>>>16)+(c>>>
        16)+(b>>>16)&65535)<<16|b&65535}function fa(a,c,b,g){var f=(a&65535)+(c&65535)+(b&65535)+(g&65535);return((a>>>16)+(c>>>16)+(b>>>16)+(g>>>16)+(f>>>16)&65535)<<16|f&65535}function S(a,c,b,g,f){var h=(a&65535)+(c&65535)+(b&65535)+(g&65535)+(f&65535);return((a>>>16)+(c>>>16)+(b>>>16)+(g>>>16)+(f>>>16)+(h>>>16)&65535)<<16|h&65535}function ga(a,c){var b,g,f;b=(a.b&65535)+(c.b&65535);g=(a.b>>>16)+(c.b>>>16)+(b>>>16);f=(g&65535)<<16|b&65535;b=(a.a&65535)+(c.a&65535)+(g>>>16);g=(a.a>>>16)+(c.a>>>16)+(b>>>
        16);return new s((g&65535)<<16|b&65535,f)}function ha(a,c,b,g){var f,h,l;f=(a.b&65535)+(c.b&65535)+(b.b&65535)+(g.b&65535);h=(a.b>>>16)+(c.b>>>16)+(b.b>>>16)+(g.b>>>16)+(f>>>16);l=(h&65535)<<16|f&65535;f=(a.a&65535)+(c.a&65535)+(b.a&65535)+(g.a&65535)+(h>>>16);h=(a.a>>>16)+(c.a>>>16)+(b.a>>>16)+(g.a>>>16)+(f>>>16);return new s((h&65535)<<16|f&65535,l)}function ia(a,c,b,g,f){var h,l,r;h=(a.b&65535)+(c.b&65535)+(b.b&65535)+(g.b&65535)+(f.b&65535);l=(a.b>>>16)+(c.b>>>16)+(b.b>>>16)+(g.b>>>16)+(f.b>>>
        16)+(h>>>16);r=(l&65535)<<16|h&65535;h=(a.a&65535)+(c.a&65535)+(b.a&65535)+(g.a&65535)+(f.a&65535)+(l>>>16);l=(a.a>>>16)+(c.a>>>16)+(b.a>>>16)+(g.a>>>16)+(f.a>>>16)+(h>>>16);return new s((l&65535)<<16|h&65535,r)}function y(a,c){var b=[],g,f,h,l,r,s,u=P,t=V,v=Q,d=U,n=R,p,m,w=S,x,q=[1732584193,4023233417,2562383102,271733878,3285377520];a[c>>>5]|=128<<24-c%32;a[(c+65>>>9<<4)+15]=c;x=a.length;for(p=0;p<x;p+=16){g=q[0];f=q[1];h=q[2];l=q[3];r=q[4];for(m=0;80>m;m+=1)b[m]=16>m?a[m+p]:d(b[m-3]^b[m-8]^b[m-
        14]^b[m-16],1),s=20>m?w(d(g,5),u(f,h,l),r,1518500249,b[m]):40>m?w(d(g,5),t(f,h,l),r,1859775393,b[m]):60>m?w(d(g,5),v(f,h,l),r,2400959708,b[m]):w(d(g,5),t(f,h,l),r,3395469782,b[m]),r=l,l=h,h=d(f,30),f=g,g=s;q[0]=n(g,q[0]);q[1]=n(f,q[1]);q[2]=n(h,q[2]);q[3]=n(l,q[3]);q[4]=n(r,q[4])}return q}function v(a,c,b){var g,f,h,l,r,t,u,v,z,d,n,p,m,w,x,q,y,C,D,E,F,G,H,I,e,A=[],B,k=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,
        1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,
        2361852424,2428436474,2756734187,3204031479,3329325298];d=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428];f=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];if("SHA-224"===b||"SHA-256"===b)n=64,g=(c+65>>>9<<4)+15,w=16,x=1,e=Number,q=R,y=fa,C=S,D=ba,E=da,F=Y,G=$,I=Q,H=P,d="SHA-224"===b?d:f;else if("SHA-384"===b||"SHA-512"===b)n=80,g=(c+128>>>10<<5)+31,w=32,x=2,e=s,q=ga,y=ha,C=ia,D=ca,E=ea,F=Z,G=aa,I=X,H=W,k=[new e(k[0],
        3609767458),new e(k[1],602891725),new e(k[2],3964484399),new e(k[3],2173295548),new e(k[4],4081628472),new e(k[5],3053834265),new e(k[6],2937671579),new e(k[7],3664609560),new e(k[8],2734883394),new e(k[9],1164996542),new e(k[10],1323610764),new e(k[11],3590304994),new e(k[12],4068182383),new e(k[13],991336113),new e(k[14],633803317),new e(k[15],3479774868),new e(k[16],2666613458),new e(k[17],944711139),new e(k[18],2341262773),new e(k[19],2007800933),new e(k[20],1495990901),new e(k[21],1856431235),
        new e(k[22],3175218132),new e(k[23],2198950837),new e(k[24],3999719339),new e(k[25],766784016),new e(k[26],2566594879),new e(k[27],3203337956),new e(k[28],1034457026),new e(k[29],2466948901),new e(k[30],3758326383),new e(k[31],168717936),new e(k[32],1188179964),new e(k[33],1546045734),new e(k[34],1522805485),new e(k[35],2643833823),new e(k[36],2343527390),new e(k[37],1014477480),new e(k[38],1206759142),new e(k[39],344077627),new e(k[40],1290863460),new e(k[41],3158454273),new e(k[42],3505952657),
        new e(k[43],106217008),new e(k[44],3606008344),new e(k[45],1432725776),new e(k[46],1467031594),new e(k[47],851169720),new e(k[48],3100823752),new e(k[49],1363258195),new e(k[50],3750685593),new e(k[51],3785050280),new e(k[52],3318307427),new e(k[53],3812723403),new e(k[54],2003034995),new e(k[55],3602036899),new e(k[56],1575990012),new e(k[57],1125592928),new e(k[58],2716904306),new e(k[59],442776044),new e(k[60],593698344),new e(k[61],3733110249),new e(k[62],2999351573),new e(k[63],3815920427),new e(3391569614,
            3928383900),new e(3515267271,566280711),new e(3940187606,3454069534),new e(4118630271,4000239992),new e(116418474,1914138554),new e(174292421,2731055270),new e(289380356,3203993006),new e(460393269,320620315),new e(685471733,587496836),new e(852142971,1086792851),new e(1017036298,365543100),new e(1126000580,2618297676),new e(1288033470,3409855158),new e(1501505948,4234509866),new e(1607167915,987167468),new e(1816402316,1246189591)],d="SHA-384"===b?[new e(3418070365,d[0]),new e(1654270250,d[1]),new e(2438529370,
        d[2]),new e(355462360,d[3]),new e(1731405415,d[4]),new e(41048885895,d[5]),new e(3675008525,d[6]),new e(1203062813,d[7])]:[new e(f[0],4089235720),new e(f[1],2227873595),new e(f[2],4271175723),new e(f[3],1595750129),new e(f[4],2917565137),new e(f[5],725511199),new e(f[6],4215389547),new e(f[7],327033209)];else throw"Unexpected error in SHA-2 implementation";a[c>>>5]|=128<<24-c%32;a[g]=c;B=a.length;for(p=0;p<B;p+=w){c=d[0];g=d[1];f=d[2];h=d[3];l=d[4];r=d[5];t=d[6];u=d[7];for(m=0;m<n;m+=1)A[m]=16>m?
        new e(a[m*x+p],a[m*x+p+1]):y(E(A[m-2]),A[m-7],D(A[m-15]),A[m-16]),v=C(u,G(l),H(l,r,t),k[m],A[m]),z=q(F(c),I(c,g,f)),u=t,t=r,r=l,l=q(h,v),h=f,f=g,g=c,c=q(v,z);d[0]=q(c,d[0]);d[1]=q(g,d[1]);d[2]=q(f,d[2]);d[3]=q(h,d[3]);d[4]=q(l,d[4]);d[5]=q(r,d[5]);d[6]=q(t,d[6]);d[7]=q(u,d[7])}if("SHA-224"===b)a=[d[0],d[1],d[2],d[3],d[4],d[5],d[6]];else if("SHA-256"===b)a=d;else if("SHA-384"===b)a=[d[0].a,d[0].b,d[1].a,d[1].b,d[2].a,d[2].b,d[3].a,d[3].b,d[4].a,d[4].b,d[5].a,d[5].b];else if("SHA-512"===b)a=[d[0].a,
        d[0].b,d[1].a,d[1].b,d[2].a,d[2].b,d[3].a,d[3].b,d[4].a,d[4].b,d[5].a,d[5].b,d[6].a,d[6].b,d[7].a,d[7].b];else throw"Unexpected error in SHA-2 implementation";return a}"function"===typeof define&&typeof define.amd?define(function(){return z}):"undefined"!==typeof exports?"undefined"!==typeof module&&module.exports?module.exports=exports=z:exports=z:T.jsSHA=z})(this);
    
},{}],86:[function(require,module,exports){
    // Top level file is just a mixin of submodules & constants
    'use strict';
    
    var assign    = require('./lib/utils/common').assign;
    
    var deflate   = require('./lib/deflate');
    var inflate   = require('./lib/inflate');
    var constants = require('./lib/zlib/constants');
    
    var pako = {};
    
    assign(pako, deflate, inflate, constants);
    
    module.exports = pako;
    
},{"./lib/deflate":87,"./lib/inflate":88,"./lib/utils/common":89,"./lib/zlib/constants":92}],87:[function(require,module,exports){
    'use strict';
    
    
    var zlib_deflate = require('./zlib/deflate.js');
    var utils = require('./utils/common');
    var strings = require('./utils/strings');
    var msg = require('./zlib/messages');
    var zstream = require('./zlib/zstream');
    
    var toString = Object.prototype.toString;
    
    /* Public constants ==========================================================*/
    /* ===========================================================================*/
    
    var Z_NO_FLUSH      = 0;
    var Z_FINISH        = 4;
    
    var Z_OK            = 0;
    var Z_STREAM_END    = 1;
    var Z_SYNC_FLUSH    = 2;
    
    var Z_DEFAULT_COMPRESSION = -1;
    
    var Z_DEFAULT_STRATEGY    = 0;
    
    var Z_DEFLATED  = 8;
    
    /* ===========================================================================*/
    
    
    /**
     * class Deflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[deflate]],
     * [[deflateRaw]] and [[gzip]].
     **/
    
    /* internal
     * Deflate.chunks -> Array
     *
     * Chunks of output data, if [[Deflate#onData]] not overriden.
     **/
    
    /**
     * Deflate.result -> Uint8Array|Array
     *
     * Compressed result, generated by default [[Deflate#onData]]
     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
     * push a chunk with explicit flush (call [[Deflate#push]] with
     * `Z_SYNC_FLUSH` param).
     **/
    
    /**
     * Deflate.err -> Number
     *
     * Error code after deflate finished. 0 (Z_OK) on success.
     * You will not need it in real life, because deflate errors
     * are possible only on wrong options or bad `onData` / `onEnd`
     * custom handlers.
     **/
    
    /**
     * Deflate.msg -> String
     *
     * Error message, if [[Deflate.err]] != 0
     **/
    
    
    /**
     * new Deflate(options)
     * - options (Object): zlib deflate options.
     *
     * Creates new deflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `level`
     * - `windowBits`
     * - `memLevel`
     * - `strategy`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw deflate
     * - `gzip` (Boolean) - create gzip wrapper
     * - `to` (String) - if equal to 'string', then result will be "binary string"
     *    (each char code [0..255])
     * - `header` (Object) - custom header for gzip
     *   - `text` (Boolean) - true if compressed data believed to be text
     *   - `time` (Number) - modification time, unix timestamp
     *   - `os` (Number) - operation system code
     *   - `extra` (Array) - array of bytes with extra data (max 65536)
     *   - `name` (String) - file name (binary string)
     *   - `comment` (String) - comment (binary string)
     *   - `hcrc` (Boolean) - true if header crc should be added
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
     *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * var deflate = new pako.Deflate({ level: 3});
     *
     * deflate.push(chunk1, false);
     * deflate.push(chunk2, true);  // true -> last chunk
     *
     * if (deflate.err) { throw new Error(deflate.err); }
     *
     * console.log(deflate.result);
     * ```
     **/
    var Deflate = function(options) {
        
        this.options = utils.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY,
            to: ''
        }, options || {});
        
        var opt = this.options;
        
        if (opt.raw && (opt.windowBits > 0)) {
            opt.windowBits = -opt.windowBits;
        }
        
        else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
            opt.windowBits += 16;
        }
        
        this.err    = 0;      // error code, if happens (0 = Z_OK)
        this.msg    = '';     // error message
        this.ended  = false;  // used to avoid multiple onEnd() calls
        this.chunks = [];     // chunks of compressed data
        
        this.strm = new zstream();
        this.strm.avail_out = 0;
        
        var status = zlib_deflate.deflateInit2(
            this.strm,
            opt.level,
            opt.method,
            opt.windowBits,
            opt.memLevel,
            opt.strategy
        );
        
        if (status !== Z_OK) {
            throw new Error(msg[status]);
        }
        
        if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
    };
    
    /**
     * Deflate#push(data[, mode]) -> Boolean
     * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
     *   converted to utf8 byte sequence.
     * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
     *
     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
     * new compressed chunks. Returns `true` on success. The last data block must have
     * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
     * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
     * can use mode Z_SYNC_FLUSH, keeping the compression context.
     *
     * On fail call [[Deflate#onEnd]] with error code and return false.
     *
     * We strongly recommend to use `Uint8Array` on input for best speed (output
     * array format is detected automatically). Also, don't skip last param and always
     * use the same type in your code (boolean or number). That will improve JS speed.
     *
     * For regular `Array`-s make sure all elements are [0..255].
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        
        if (this.ended) { return false; }
        
        _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);
        
        // Convert data if needed
        if (typeof data === 'string') {
            // If we need to compress text, change encoding to utf8.
            strm.input = strings.string2buf(data);
        } else if (toString.call(data) === '[object ArrayBuffer]') {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        
        do {
            if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */
            
            if (status !== Z_STREAM_END && status !== Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
            }
            if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
                if (this.options.to === 'string') {
                    this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                } else {
                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
            }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        
        // Finalize on the last chunk.
        if (_mode === Z_FINISH) {
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
        }
        
        // callback interim results if Z_SYNC_FLUSH.
        if (_mode === Z_SYNC_FLUSH) {
            this.onEnd(Z_OK);
            strm.avail_out = 0;
            return true;
        }
        
        return true;
    };
    
    
    /**
     * Deflate#onData(chunk) -> Void
     * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
     *   on js engine support. When string output requested, each chunk
     *   will be string.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    
    
    /**
     * Deflate#onEnd(status) -> Void
     * - status (Number): deflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called once after you tell deflate that the input stream is
     * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
     * or if an error happened. By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Deflate.prototype.onEnd = function(status) {
        // On success - join
        if (status === Z_OK) {
            if (this.options.to === 'string') {
                this.result = this.chunks.join('');
            } else {
                this.result = utils.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    
    
    /**
     * deflate(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * Compress `data` with deflate alrorythm and `options`.
     *
     * Supported options are:
     *
     * - level
     * - windowBits
     * - memLevel
     * - strategy
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     * - `to` (String) - if equal to 'string', then result will be "binary string"
     *    (each char code [0..255])
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
     *
     * console.log(pako.deflate(data));
     * ```
     **/
    function deflate(input, options) {
        var deflator = new Deflate(options);
        
        deflator.push(input, true);
        
        // That will never happens, if you don't cheat with options :)
        if (deflator.err) { throw deflator.msg; }
        
        return deflator.result;
    }
    
    
    /**
     * deflateRaw(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
    }
    
    
    /**
     * gzip(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but create gzip wrapper instead of
     * deflate one.
     **/
    function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
    }
    
    
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
    
},{"./utils/common":89,"./utils/strings":90,"./zlib/deflate.js":94,"./zlib/messages":99,"./zlib/zstream":101}],88:[function(require,module,exports){
    'use strict';
    
    
    var zlib_inflate = require('./zlib/inflate.js');
    var utils = require('./utils/common');
    var strings = require('./utils/strings');
    var c = require('./zlib/constants');
    var msg = require('./zlib/messages');
    var zstream = require('./zlib/zstream');
    var gzheader = require('./zlib/gzheader');
    
    var toString = Object.prototype.toString;
    
    /**
     * class Inflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[inflate]]
     * and [[inflateRaw]].
     **/
    
    /* internal
     * inflate.chunks -> Array
     *
     * Chunks of output data, if [[Inflate#onData]] not overriden.
     **/
    
    /**
     * Inflate.result -> Uint8Array|Array|String
     *
     * Uncompressed result, generated by default [[Inflate#onData]]
     * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
     * push a chunk with explicit flush (call [[Inflate#push]] with
     * `Z_SYNC_FLUSH` param).
     **/
    
    /**
     * Inflate.err -> Number
     *
     * Error code after inflate finished. 0 (Z_OK) on success.
     * Should be checked if broken data possible.
     **/
    
    /**
     * Inflate.msg -> String
     *
     * Error message, if [[Inflate.err]] != 0
     **/
    
    
    /**
     * new Inflate(options)
     * - options (Object): zlib inflate options.
     *
     * Creates new inflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `windowBits`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw inflate
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     * By default, when no options set, autodetect deflate/gzip data format via
     * wrapper header.
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
     *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * var inflate = new pako.Inflate({ level: 3});
     *
     * inflate.push(chunk1, false);
     * inflate.push(chunk2, true);  // true -> last chunk
     *
     * if (inflate.err) { throw new Error(inflate.err); }
     *
     * console.log(inflate.result);
     * ```
     **/
    var Inflate = function(options) {
        
        this.options = utils.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ''
        }, options || {});
        
        var opt = this.options;
        
        // Force window size for `raw` data, if not set directly,
        // because we have no header for autodetect.
        if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) { opt.windowBits = -15; }
        }
        
        // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
        if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
            !(options && options.windowBits)) {
            opt.windowBits += 32;
        }
        
        // Gzip header has no info about windows size, we can do autodetect only
        // for deflate. So, if window size not set, force it to max when gzip possible
        if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
            // bit 3 (16) -> gzipped data
            // bit 4 (32) -> autodetect gzip/deflate
            if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
            }
        }
        
        this.err    = 0;      // error code, if happens (0 = Z_OK)
        this.msg    = '';     // error message
        this.ended  = false;  // used to avoid multiple onEnd() calls
        this.chunks = [];     // chunks of compressed data
        
        this.strm   = new zstream();
        this.strm.avail_out = 0;
        
        var status  = zlib_inflate.inflateInit2(
            this.strm,
            opt.windowBits
        );
        
        if (status !== c.Z_OK) {
            throw new Error(msg[status]);
        }
        
        this.header = new gzheader();
        
        zlib_inflate.inflateGetHeader(this.strm, this.header);
    };
    
    /**
     * Inflate#push(data[, mode]) -> Boolean
     * - data (Uint8Array|Array|ArrayBuffer|String): input data
     * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
     *
     * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
     * new output chunks. Returns `true` on success. The last data block must have
     * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
     * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
     * can use mode Z_SYNC_FLUSH, keeping the decompression context.
     *
     * On fail call [[Inflate#onEnd]] with error code and return false.
     *
     * We strongly recommend to use `Uint8Array` on input for best speed (output
     * format is detected automatically). Also, don't skip last param and always
     * use the same type in your code (boolean or number). That will improve JS speed.
     *
     * For regular `Array`-s make sure all elements are [0..255].
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        
        // Flag to properly process Z_BUF_ERROR on testing inflate call
        // when we check that all output data was flushed.
        var allowBufError = false;
        
        if (this.ended) { return false; }
        _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);
        
        // Convert data if needed
        if (typeof data === 'string') {
            // Only binary strings can be decompressed on practice
            strm.input = strings.binstring2buf(data);
        } else if (toString.call(data) === '[object ArrayBuffer]') {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        
        do {
            if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            
            status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */
            
            if (status === c.Z_BUF_ERROR && allowBufError === true) {
                status = c.Z_OK;
                allowBufError = false;
            }
            
            if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
            }
            
            if (strm.next_out) {
                if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {
                    
                    if (this.options.to === 'string') {
                        
                        next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                        
                        tail = strm.next_out - next_out_utf8;
                        utf8str = strings.buf2string(strm.output, next_out_utf8);
                        
                        // move tail
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }
                        
                        this.onData(utf8str);
                        
                    } else {
                        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                    }
                }
            }
            
            // When no more input data, we should check that internal inflate buffers
            // are flushed. The only way to do it when avail_out = 0 - run one more
            // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
            // Here we set flag to process this error properly.
            //
            // NOTE. Deflate does not return error in this case and does not needs such
            // logic.
            if (strm.avail_in === 0 && strm.avail_out === 0) {
                allowBufError = true;
            }
            
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        
        if (status === c.Z_STREAM_END) {
            _mode = c.Z_FINISH;
        }
        
        // Finalize on the last chunk.
        if (_mode === c.Z_FINISH) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === c.Z_OK;
        }
        
        // callback interim results if Z_SYNC_FLUSH.
        if (_mode === c.Z_SYNC_FLUSH) {
            this.onEnd(c.Z_OK);
            strm.avail_out = 0;
            return true;
        }
        
        return true;
    };
    
    
    /**
     * Inflate#onData(chunk) -> Void
     * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
     *   on js engine support. When string output requested, each chunk
     *   will be string.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    
    
    /**
     * Inflate#onEnd(status) -> Void
     * - status (Number): inflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called either after you tell inflate that the input stream is
     * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
     * or if an error happened. By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Inflate.prototype.onEnd = function(status) {
        // On success - join
        if (status === c.Z_OK) {
            if (this.options.to === 'string') {
                // Glue & convert here, until we teach pako to send
                // utf8 alligned strings to onData
                this.result = this.chunks.join('');
            } else {
                this.result = utils.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    
    
    /**
     * inflate(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Decompress `data` with inflate/ungzip and `options`. Autodetect
     * format via wrapper header by default. That's why we don't provide
     * separate `ungzip` method.
     *
     * Supported options are:
     *
     * - windowBits
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
     *   , output;
     *
     * try {
 *   output = pako.inflate(input);
 * } catch (err)
     *   console.log(err);
     * }
     * ```
     **/
    function inflate(input, options) {
        var inflator = new Inflate(options);
        
        inflator.push(input, true);
        
        // That will never happens, if you don't cheat with options :)
        if (inflator.err) { throw inflator.msg; }
        
        return inflator.result;
    }
    
    
    /**
     * inflateRaw(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * The same as [[inflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
    }
    
    
    /**
     * ungzip(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Just shortcut to [[inflate]], because it autodetects format
     * by header.content. Done for convenience.
     **/
    
    
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip  = inflate;
    
},{"./utils/common":89,"./utils/strings":90,"./zlib/constants":92,"./zlib/gzheader":95,"./zlib/inflate.js":97,"./zlib/messages":99,"./zlib/zstream":101}],89:[function(require,module,exports){
    'use strict';
    
    
    var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
        (typeof Uint16Array !== 'undefined') &&
        (typeof Int32Array !== 'undefined');
    
    
    exports.assign = function (obj /*from1, from2, from3, ...*/) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
            var source = sources.shift();
            if (!source) { continue; }
            
            if (typeof source !== 'object') {
                throw new TypeError(source + 'must be non-object');
            }
            
            for (var p in source) {
                if (source.hasOwnProperty(p)) {
                    obj[p] = source[p];
                }
            }
        }
        
        return obj;
    };
    
    
    // reduce buffer size, avoiding mem copy
    exports.shrinkBuf = function (buf, size) {
        if (buf.length === size) { return buf; }
        if (buf.subarray) { return buf.subarray(0, size); }
        buf.length = size;
        return buf;
    };
    
    
    var fnTyped = {
        arraySet: function (dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
                dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
                return;
            }
            // Fallback to ordinary array
            for (var i=0; i<len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
            }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            
            // calculate data length
            len = 0;
            for (i=0, l=chunks.length; i<l; i++) {
                len += chunks[i].length;
            }
            
            // join chunks
            result = new Uint8Array(len);
            pos = 0;
            for (i=0, l=chunks.length; i<l; i++) {
                chunk = chunks[i];
                result.set(chunk, pos);
                pos += chunk.length;
            }
            
            return result;
        }
    };
    
    var fnUntyped = {
        arraySet: function (dest, src, src_offs, len, dest_offs) {
            for (var i=0; i<len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
            }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
        }
    };
    
    
    // Enable/Disable typed arrays use, for testing
    //
    exports.setTyped = function (on) {
        if (on) {
            exports.Buf8  = Uint8Array;
            exports.Buf16 = Uint16Array;
            exports.Buf32 = Int32Array;
            exports.assign(exports, fnTyped);
        } else {
            exports.Buf8  = Array;
            exports.Buf16 = Array;
            exports.Buf32 = Array;
            exports.assign(exports, fnUntyped);
        }
    };
    
    exports.setTyped(TYPED_OK);
    
},{}],90:[function(require,module,exports){
    // String encode/decode helpers
    'use strict';
    
    
    var utils = require('./common');
    
    
    // Quick check if we can use fast array to bin string conversion
    //
    // - apply(Array) can fail on Android 2.2
    // - apply(Uint8Array) can fail on iOS 5.1 Safary
    //
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    
    try { String.fromCharCode.apply(null, [0]); } catch(__) { STR_APPLY_OK = false; }
    try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch(__) { STR_APPLY_UIA_OK = false; }
    
    
    // Table with utf8 lengths (calculated by first byte of sequence)
    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
    // because max possible codepoint is 0x10ffff
    var _utf8len = new utils.Buf8(256);
    for (var q=0; q<256; q++) {
        _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
    }
    _utf8len[254]=_utf8len[254]=1; // Invalid sequence start
    
    
    // convert string to array (typed, when possible)
    exports.string2buf = function (str) {
        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        
        // count binary size
        for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
                c2 = str.charCodeAt(m_pos+1);
                if ((c2 & 0xfc00) === 0xdc00) {
                    c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                    m_pos++;
                }
            }
            buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
        }
        
        // allocate buffer
        buf = new utils.Buf8(buf_len);
        
        // convert
        for (i=0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
                c2 = str.charCodeAt(m_pos+1);
                if ((c2 & 0xfc00) === 0xdc00) {
                    c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                    m_pos++;
                }
            }
            if (c < 0x80) {
                /* one byte */
                buf[i++] = c;
            } else if (c < 0x800) {
                /* two bytes */
                buf[i++] = 0xC0 | (c >>> 6);
                buf[i++] = 0x80 | (c & 0x3f);
            } else if (c < 0x10000) {
                /* three bytes */
                buf[i++] = 0xE0 | (c >>> 12);
                buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                buf[i++] = 0x80 | (c & 0x3f);
            } else {
                /* four bytes */
                buf[i++] = 0xf0 | (c >>> 18);
                buf[i++] = 0x80 | (c >>> 12 & 0x3f);
                buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                buf[i++] = 0x80 | (c & 0x3f);
            }
        }
        
        return buf;
    };
    
    // Helper (used in 2 places)
    function buf2binstring(buf, len) {
        // use fallback for big arrays to avoid stack overflow
        if (len < 65537) {
            if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
                return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
        }
        
        var result = '';
        for (var i=0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
        }
        return result;
    }
    
    
    // Convert byte array to binary string
    exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
    };
    
    
    // Convert binary string (typed, when possible)
    exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i=0, len=buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
        }
        return buf;
    };
    
    
    // convert array to string
    exports.buf2string = function (buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;
        
        // Reserve max possible length (2 words per char)
        // NB: by unknown reasons, Array is significantly faster for
        //     String.fromCharCode.apply than Uint16Array.
        var utf16buf = new Array(len*2);
        
        for (out=0, i=0; i<len;) {
            c = buf[i++];
            // quick process ascii
            if (c < 0x80) { utf16buf[out++] = c; continue; }
            
            c_len = _utf8len[c];
            // skip 5 & 6 byte codes
            if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }
            
            // apply mask on first byte
            c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
            // join the rest
            while (c_len > 1 && i < len) {
                c = (c << 6) | (buf[i++] & 0x3f);
                c_len--;
            }
            
            // terminated by end of string?
            if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }
            
            if (c < 0x10000) {
                utf16buf[out++] = c;
            } else {
                c -= 0x10000;
                utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                utf16buf[out++] = 0xdc00 | (c & 0x3ff);
            }
        }
        
        return buf2binstring(utf16buf, out);
    };
    
    
    // Calculate max possible position in utf8 buffer,
    // that will not break sequence. If that's not possible
    // - (very small limits) return max size as is.
    //
    // buf[] - utf8 bytes array
    // max   - length limit (mandatory);
    exports.utf8border = function(buf, max) {
        var pos;
        
        max = max || buf.length;
        if (max > buf.length) { max = buf.length; }
        
        // go back from last position, until start of sequence found
        pos = max-1;
        while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }
        
        // Fuckup - very small and broken sequence,
        // return max, because we should return something anyway.
        if (pos < 0) { return max; }
        
        // If we came to start of buffer - that means vuffer is too small,
        // return max too.
        if (pos === 0) { return max; }
        
        return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };
    
},{"./common":89}],91:[function(require,module,exports){
    'use strict';
    
    // Note: adler32 takes 12% for level 0 and 2% for level 6.
    // It doesn't worth to make additional optimizationa as in original.
    // Small size is preferable.
    
    function adler32(adler, buf, len, pos) {
        var s1 = (adler & 0xffff) |0,
            s2 = ((adler >>> 16) & 0xffff) |0,
            n = 0;
        
        while (len !== 0) {
            // Set limit ~ twice less than 5552, to keep
            // s2 in 31-bits, because we force signed ints.
            // in other case %= will fail.
            n = len > 2000 ? 2000 : len;
            len -= n;
            
            do {
                s1 = (s1 + buf[pos++]) |0;
                s2 = (s2 + s1) |0;
            } while (--n);
            
            s1 %= 65521;
            s2 %= 65521;
        }
        
        return (s1 | (s2 << 16)) |0;
    }
    
    
    module.exports = adler32;
    
},{}],92:[function(require,module,exports){
    module.exports = {
        
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH:         0,
        Z_PARTIAL_FLUSH:    1,
        Z_SYNC_FLUSH:       2,
        Z_FULL_FLUSH:       3,
        Z_FINISH:           4,
        Z_BLOCK:            5,
        Z_TREES:            6,
        
        /* Return codes for the compression/decompression functions. Negative values
         * are errors, positive values are used for special but normal events.
         */
        Z_OK:               0,
        Z_STREAM_END:       1,
        Z_NEED_DICT:        2,
        Z_ERRNO:           -1,
        Z_STREAM_ERROR:    -2,
        Z_DATA_ERROR:      -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR:       -5,
        //Z_VERSION_ERROR: -6,
        
        /* compression levels */
        Z_NO_COMPRESSION:         0,
        Z_BEST_SPEED:             1,
        Z_BEST_COMPRESSION:       9,
        Z_DEFAULT_COMPRESSION:   -1,
        
        
        Z_FILTERED:               1,
        Z_HUFFMAN_ONLY:           2,
        Z_RLE:                    3,
        Z_FIXED:                  4,
        Z_DEFAULT_STRATEGY:       0,
        
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY:                 0,
        Z_TEXT:                   1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN:                2,
        
        /* The deflate compression method */
        Z_DEFLATED:               8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
    
},{}],93:[function(require,module,exports){
    'use strict';
    
    // Note: we can't get significant speed boost here.
    // So write code to minimize size - no pregenerated tables
    // and array tools dependencies.
    
    
    // Use ordinary array, since untyped makes no boost here
    function makeTable() {
        var c, table = [];
        
        for (var n =0; n < 256; n++) {
            c = n;
            for (var k =0; k < 8; k++) {
                c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            }
            table[n] = c;
        }
        
        return table;
    }
    
    // Create table on load. Just 255 signed longs. Not a problem.
    var crcTable = makeTable();
    
    
    function crc32(crc, buf, len, pos) {
        var t = crcTable,
            end = pos + len;
        
        crc = crc ^ (-1);
        
        for (var i = pos; i < end; i++) {
            crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
        }
        
        return (crc ^ (-1)); // >>> 0;
    }
    
    
    module.exports = crc32;
    
},{}],94:[function(require,module,exports){
    'use strict';
    
    var utils   = require('../utils/common');
    var trees   = require('./trees');
    var adler32 = require('./adler32');
    var crc32   = require('./crc32');
    var msg   = require('./messages');
    
    /* Public constants ==========================================================*/
    /* ===========================================================================*/
    
    
    /* Allowed flush values; see deflate() and inflate() below for details */
    var Z_NO_FLUSH      = 0;
    var Z_PARTIAL_FLUSH = 1;
    //var Z_SYNC_FLUSH    = 2;
    var Z_FULL_FLUSH    = 3;
    var Z_FINISH        = 4;
    var Z_BLOCK         = 5;
    //var Z_TREES         = 6;
    
    
    /* Return codes for the compression/decompression functions. Negative values
     * are errors, positive values are used for special but normal events.
     */
    var Z_OK            = 0;
    var Z_STREAM_END    = 1;
    //var Z_NEED_DICT     = 2;
    //var Z_ERRNO         = -1;
    var Z_STREAM_ERROR  = -2;
    var Z_DATA_ERROR    = -3;
    //var Z_MEM_ERROR     = -4;
    var Z_BUF_ERROR     = -5;
    //var Z_VERSION_ERROR = -6;
    
    
    /* compression levels */
    //var Z_NO_COMPRESSION      = 0;
    //var Z_BEST_SPEED          = 1;
    //var Z_BEST_COMPRESSION    = 9;
    var Z_DEFAULT_COMPRESSION = -1;
    
    
    var Z_FILTERED            = 1;
    var Z_HUFFMAN_ONLY        = 2;
    var Z_RLE                 = 3;
    var Z_FIXED               = 4;
    var Z_DEFAULT_STRATEGY    = 0;
    
    /* Possible values of the data_type field (though see inflate()) */
    //var Z_BINARY              = 0;
    //var Z_TEXT                = 1;
    //var Z_ASCII               = 1; // = Z_TEXT
    var Z_UNKNOWN             = 2;
    
    
    /* The deflate compression method */
    var Z_DEFLATED  = 8;
    
    /*============================================================================*/
    
    
    var MAX_MEM_LEVEL = 9;
    /* Maximum value for memLevel in deflateInit2 */
    var MAX_WBITS = 15;
    /* 32K LZ77 window */
    var DEF_MEM_LEVEL = 8;
    
    
    var LENGTH_CODES  = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    var LITERALS      = 256;
    /* number of literal bytes 0..255 */
    var L_CODES       = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */
    var D_CODES       = 30;
    /* number of distance codes */
    var BL_CODES      = 19;
    /* number of codes used to transfer the bit lengths */
    var HEAP_SIZE     = 2*L_CODES + 1;
    /* maximum heap size */
    var MAX_BITS  = 15;
    /* All codes must not exceed MAX_BITS bits */
    
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
    
    var PRESET_DICT = 0x20;
    
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    
    var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
    var BS_BLOCK_DONE     = 2; /* block flush performed */
    var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
    var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */
    
    var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
    
    function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
    }
    
    function rank(f) {
        return ((f) << 1) - ((f) > 4 ? 9 : 0);
    }
    
    function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
    
    
    /* =========================================================================
     * Flush as much pending output as possible. All deflate() output goes
     * through this function so some applications may wish to modify it
     * to avoid allocating a large strm->output buffer and copying into it.
     * (See also read_buf()).
     */
    function flush_pending(strm) {
        var s = strm.state;
        
        //_tr_flush_bits(s);
        var len = s.pending;
        if (len > strm.avail_out) {
            len = strm.avail_out;
        }
        if (len === 0) { return; }
        
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
            s.pending_out = 0;
        }
    }
    
    
    function flush_block_only (s, last) {
        trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
    }
    
    
    function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
    }
    
    
    /* =========================================================================
     * Put a short in the pending buffer. The 16-bit value is put in MSB order.
     * IN assertion: the stream state is correct and there is enough room in
     * pending_buf.
     */
    function putShortMSB(s, b) {
        //  put_byte(s, (Byte)(b >> 8));
        //  put_byte(s, (Byte)(b & 0xff));
        s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
        s.pending_buf[s.pending++] = b & 0xff;
    }
    
    
    /* ===========================================================================
     * Read a new buffer from the current input stream, update the adler32
     * and total number of bytes read.  All deflate() input goes through
     * this function so some applications may wish to modify it to avoid
     * allocating a large strm->input buffer and copying from it.
     * (See also flush_pending()).
     */
    function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        
        if (len > size) { len = size; }
        if (len === 0) { return 0; }
        
        strm.avail_in -= len;
        
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
        }
        
        else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
        }
        
        strm.next_in += len;
        strm.total_in += len;
        
        return len;
    }
    
    
    /* ===========================================================================
     * Set match_start to the longest match starting at the given string and
     * return its length. Matches shorter or equal to prev_length are discarded,
     * in which case the result is equal to prev_length and match_start is
     * garbage.
     * IN assertions: cur_match is the head of the hash chain for the current
     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
     * OUT assertion: the match length is not greater than s->lookahead.
     */
    function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;      /* max hash chain length */
        var scan = s.strstart; /* current string */
        var match;                       /* matched string */
        var len;                           /* length of current match */
        var best_len = s.prev_length;              /* best match length so far */
        var nice_match = s.nice_match;             /* stop if match long enough */
        var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;
        
        var _win = s.window; // shortcut
        
        var wmask = s.w_mask;
        var prev  = s.prev;
        
        /* Stop when cur_match becomes <= limit. To simplify the code,
         * we prevent matches with the string of window index 0.
         */
        
        var strend = s.strstart + MAX_MATCH;
        var scan_end1  = _win[scan + best_len - 1];
        var scan_end   = _win[scan + best_len];
        
        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
         * It is easy to get rid of this optimization if necessary.
         */
        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
        
        /* Do not waste too much time if we already have a good match: */
        if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
        }
        /* Do not look for matches beyond the end of the input. This is necessary
         * to make deflate deterministic.
         */
        if (nice_match > s.lookahead) { nice_match = s.lookahead; }
        
        // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
        
        do {
            // Assert(cur_match < s->strstart, "no future");
            match = cur_match;
            
            /* Skip to next match if the match length cannot increase
             * or if the match length is less than 2.  Note that the checks below
             * for insufficient lookahead only occur occasionally for performance
             * reasons.  Therefore uninitialized memory will be accessed, and
             * conditional jumps will be made that depend on those values.
             * However the length of the match is limited to the lookahead, so
             * the output of deflate is not affected by the uninitialized values.
             */
            
            if (_win[match + best_len]     !== scan_end  ||
                _win[match + best_len - 1] !== scan_end1 ||
                _win[match]                !== _win[scan] ||
                _win[++match]              !== _win[scan + 1]) {
                continue;
            }
            
            /* The check at best_len-1 can be removed because it will be made
             * again later. (This heuristic is not always a win.)
             * It is not necessary to compare scan[2] and match[2] since they
             * are always equal when the other bytes match, given that
             * the hash keys are equal and that HASH_BITS >= 8.
             */
            scan += 2;
            match++;
            // Assert(*scan == *match, "match[2]?");
            
            /* We check for insufficient lookahead only every 8th comparison;
             * the 256th check will be made at strstart+258.
             */
            do {
                /*jshint noempty:false*/
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            scan < strend);
            
            // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
            
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            
            if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                    break;
                }
                scan_end1  = _win[scan + best_len - 1];
                scan_end   = _win[scan + best_len];
            }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        
        if (best_len <= s.lookahead) {
            return best_len;
        }
        return s.lookahead;
    }
    
    
    /* ===========================================================================
     * Fill the window when the lookahead becomes insufficient.
     * Updates strstart and lookahead.
     *
     * IN assertion: lookahead < MIN_LOOKAHEAD
     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
     *    At least one byte has been read, or avail_in == 0; reads are
     *    performed for at least two bytes (required for the zip translate_eol
     *    option -- not supported here).
     */
    function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        
        //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
        
        do {
            more = s.window_size - s.lookahead - s.strstart;
            
            // JS ints have 32 bit, block below not needed
            /* Deal with !@#$% 64K limit: */
            //if (sizeof(int) <= 2) {
            //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            //        more = wsize;
            //
            //  } else if (more == (unsigned)(-1)) {
            //        /* Very unlikely, but possible on 16 bit machine if
            //         * strstart == 0 && lookahead == 1 (input done a byte at time)
            //         */
            //        more--;
            //    }
            //}
            
            
            /* If the window is almost full and there is insufficient lookahead,
             * move the upper half to the lower one to make room in the upper half.
             */
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                
                utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                /* we now have strstart >= MAX_DIST */
                s.block_start -= _w_size;
                
                /* Slide the hash table (could be avoided with 32 bit values
                 at the expense of memory usage). We slide even when level == 0
                 to keep the hash table consistent if we switch back to level > 0
                 later. (Using level 0 permanently is not an optimal usage of
                 zlib, so we don't care about this pathological case.)
                 */
                
                n = s.hash_size;
                p = n;
                do {
                    m = s.head[--p];
                    s.head[p] = (m >= _w_size ? m - _w_size : 0);
                } while (--n);
                
                n = _w_size;
                p = n;
                do {
                    m = s.prev[--p];
                    s.prev[p] = (m >= _w_size ? m - _w_size : 0);
                    /* If n is not on any hash chain, prev[n] is garbage but
                     * its value will never be used.
                     */
                } while (--n);
                
                more += _w_size;
            }
            if (s.strm.avail_in === 0) {
                break;
            }
            
            /* If there was no sliding:
             *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
             *    more == window_size - lookahead - strstart
             * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
             * => more >= window_size - 2*WSIZE + 2
             * In the BIG_MEM or MMAP case (not yet supported),
             *   window_size == input_size + MIN_LOOKAHEAD  &&
             *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
             * Otherwise, window_size == 2*WSIZE so more >= 2.
             * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
             */
            //Assert(more >= 2, "more < 2");
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            
            /* Initialize the hash value now that we have some input: */
            if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                
                /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
                //#if MIN_MATCH != 3
                //        Call update_hash() MIN_MATCH-3 more times
                //#endif
                while (s.insert) {
                    /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;
                    
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                    s.insert--;
                    if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                    }
                }
            }
            /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
             * but this is not important since only literal bytes will be emitted.
             */
            
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        
        /* If the WIN_INIT bytes after the end of the current data have never been
         * written, then zero those bytes in order to avoid memory check reports of
         * the use of uninitialized (or uninitialised as Julian writes) bytes by
         * the longest match routines.  Update the high water mark for the next
         * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
         * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
         */
        //  if (s.high_water < s.window_size) {
        //    var curr = s.strstart + s.lookahead;
        //    var init = 0;
        //
        //    if (s.high_water < curr) {
        //      /* Previous high water mark below current data -- zero WIN_INIT
        //       * bytes or up to end of window, whichever is less.
        //       */
        //      init = s.window_size - curr;
        //      if (init > WIN_INIT)
        //        init = WIN_INIT;
        //      zmemzero(s->window + curr, (unsigned)init);
        //      s->high_water = curr + init;
        //    }
        //    else if (s->high_water < (ulg)curr + WIN_INIT) {
        //      /* High water mark at or above current data, but below current data
        //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
        //       * to end of window, whichever is less.
        //       */
        //      init = (ulg)curr + WIN_INIT - s->high_water;
        //      if (init > s->window_size - s->high_water)
        //        init = s->window_size - s->high_water;
        //      zmemzero(s->window + s->high_water, (unsigned)init);
        //      s->high_water += init;
        //    }
        //  }
        //
        //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
        //    "not enough room for search");
    }
    
    /* ===========================================================================
     * Copy without compression as much as possible from the input stream, return
     * the current block state.
     * This function does not insert new strings in the dictionary since
     * uncompressible data is probably not useful. This function is used
     * only for the level=0 compression option.
     * NOTE: this function should be optimized to avoid extra copying from
     * window to pending_buf.
     */
    function deflate_stored(s, flush) {
        /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
         * to pending_buf_size, and each stored block has a 5 byte header:
         */
        var max_block_size = 0xffff;
        
        if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
        }
        
        /* Copy as much as possible from input to output: */
        for (;;) {
            /* Fill the window as much as possible: */
            if (s.lookahead <= 1) {
                
                //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                //  s->block_start >= (long)s->w_size, "slide too late");
                //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
                //        s.block_start >= s.w_size)) {
                //        throw  new Error("slide too late");
                //      }
                
                fill_window(s);
                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                
                if (s.lookahead === 0) {
                    break;
                }
                /* flush the current block */
            }
            //Assert(s->block_start >= 0L, "block gone");
            //    if (s.block_start < 0) throw new Error("block gone");
            
            s.strstart += s.lookahead;
            s.lookahead = 0;
            
            /* Emit a stored block if pending_buf will be full: */
            var max_start = s.block_start + max_block_size;
            
            if (s.strstart === 0 || s.strstart >= max_start) {
                /* strstart == 0 is possible when wraparound on 16-bit machine */
                s.lookahead = s.strstart - max_start;
                s.strstart = max_start;
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
                
                
            }
            /* Flush if we may have to slide, otherwise block_start may become
             * negative and the data will be gone:
             */
            if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        
        s.insert = 0;
        
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        
        if (s.strstart > s.block_start) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        
        return BS_NEED_MORE;
    }
    
    /* ===========================================================================
     * Compress as much as possible from the input stream, return the current
     * block state.
     * This function does not perform lazy evaluation of matches and inserts
     * new strings in the dictionary only for unmatched strings or for short
     * matches. It is used only for the fast compression options.
     */
    function deflate_fast(s, flush) {
        var hash_head;        /* head of the hash chain */
        var bflush;           /* set if current block must be flushed */
        
        for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the next match, plus MIN_MATCH bytes to insert the
             * string following the next match.
             */
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break; /* flush the current block */
                }
            }
            
            /* Insert the string window[strstart .. strstart+2] in the
             * dictionary, and set hash_head to the head of the hash chain:
             */
            hash_head = 0/*NIL*/;
            if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
            }
            
            /* Find the longest match, discarding those <= prev_length.
             * At this point we have always match_length < MIN_MATCH
             */
            if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
                /* To simplify the code, we prevent matches with the string
                 * of window index 0 (in particular we have to avoid a match
                 * of the string with itself at the start of the input file).
                 */
                s.match_length = longest_match(s, hash_head);
                /* longest_match() sets match_start */
            }
            if (s.match_length >= MIN_MATCH) {
                // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
                
                /*** _tr_tally_dist(s, s.strstart - s.match_start,
                 s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                
                s.lookahead -= s.match_length;
                
                /* Insert new strings in the hash table only if the match length
                 * is not too large. This saves time but degrades compression.
                 */
                if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
                    s.match_length--; /* string at strstart already in table */
                    do {
                        s.strstart++;
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                        /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                         * always MIN_MATCH bytes ahead.
                         */
                    } while (--s.match_length !== 0);
                    s.strstart++;
                } else
                {
                    s.strstart += s.match_length;
                    s.match_length = 0;
                    s.ins_h = s.window[s.strstart];
                    /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
                    
                    //#if MIN_MATCH != 3
                    //                Call UPDATE_HASH() MIN_MATCH-3 more times
                    //#endif
                    /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                     * matter since it will be recomputed at next deflate call.
                     */
                }
            } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s.window[s.strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    }
    
    /* ===========================================================================
     * Same as above, but achieves better compression. We use a lazy
     * evaluation for matches: a match is finally adopted only if there is
     * no better match at the next window position.
     */
    function deflate_slow(s, flush) {
        var hash_head;          /* head of hash chain */
        var bflush;              /* set if current block must be flushed */
        
        var max_insert;
        
        /* Process the input block. */
        for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the next match, plus MIN_MATCH bytes to insert the
             * string following the next match.
             */
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) { break; } /* flush the current block */
            }
            
            /* Insert the string window[strstart .. strstart+2] in the
             * dictionary, and set hash_head to the head of the hash chain:
             */
            hash_head = 0/*NIL*/;
            if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
            }
            
            /* Find the longest match, discarding those <= prev_length.
             */
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH-1;
            
            if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
                s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
                /* To simplify the code, we prevent matches with the string
                 * of window index 0 (in particular we have to avoid a match
                 * of the string with itself at the start of the input file).
                 */
                s.match_length = longest_match(s, hash_head);
                /* longest_match() sets match_start */
                
                if (s.match_length <= 5 &&
                    (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {
                    
                    /* If prev_match is also MIN_MATCH, match_start is garbage
                     * but we will ignore the current match anyway.
                     */
                    s.match_length = MIN_MATCH-1;
                }
            }
            /* If there was a match at the previous step and the current
             * match is not better, output the previous match:
             */
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                /* Do not insert strings in hash table beyond this. */
                
                //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
                
                /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                 s.prev_length - MIN_MATCH, bflush);***/
                bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);
                /* Insert in hash table all strings up to the end of the match.
                 * strstart-1 and strstart are already inserted. If there is not
                 * enough lookahead, the last two strings are not inserted in
                 * the hash table.
                 */
                s.lookahead -= s.prev_length-1;
                s.prev_length -= 2;
                do {
                    if (++s.strstart <= max_insert) {
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                    }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH-1;
                s.strstart++;
                
                if (bflush) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }
                
            } else if (s.match_available) {
                /* If there was no match at the previous position, output a
                 * single literal. If there was a match but the current match
                 * is longer, truncate the previous match to a single literal.
                 */
                //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);
                
                if (bflush) {
                    /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                    flush_block_only(s, false);
                    /***/
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            } else {
                /* There is no previous match to compare with, wait for
                 * the next step to decide.
                 */
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
            }
        }
        //Assert (flush != Z_NO_FLUSH, "no flush?");
        if (s.match_available) {
            //Tracevv((stderr,"%c", s->window[s->strstart-1]));
            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
            bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);
            
            s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        
        return BS_BLOCK_DONE;
    }
    
    
    /* ===========================================================================
     * For Z_RLE, simply look for runs of bytes, generate matches only of distance
     * one.  Do not maintain a hash table.  (It will be regenerated if this run of
     * deflate switches away from Z_RLE.)
     */
    function deflate_rle(s, flush) {
        var bflush;            /* set if current block must be flushed */
        var prev;              /* byte at distance one to match */
        var scan, strend;      /* scan goes up to strend for length of run */
        
        var _win = s.window;
        
        for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the longest run, plus one for the unrolled loop.
             */
            if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) { break; } /* flush the current block */
            }
            
            /* See how many times the previous byte repeats */
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + MAX_MATCH;
                    do {
                        /*jshint noempty:false*/
                    } while (prev === _win[++scan] && prev === _win[++scan] &&
                    prev === _win[++scan] && prev === _win[++scan] &&
                    prev === _win[++scan] && prev === _win[++scan] &&
                    prev === _win[++scan] && prev === _win[++scan] &&
                    scan < strend);
                    s.match_length = MAX_MATCH - (strend - scan);
                    if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                    }
                }
                //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
            }
            
            /* Emit match if have run of MIN_MATCH or longer, else emit literal */
            if (s.match_length >= MIN_MATCH) {
                //check_match(s, s.strstart, s.strstart - 1, s.match_length);
                
                /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
            } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s->window[s->strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    }
    
    /* ===========================================================================
     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
     * (It will be regenerated if this run of deflate switches away from Huffman.)
     */
    function deflate_huff(s, flush) {
        var bflush;             /* set if current block must be flushed */
        
        for (;;) {
            /* Make sure that we have a literal to write. */
            if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                    if (flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    break;      /* flush the current block */
                }
            }
            
            /* Output a literal byte */
            s.match_length = 0;
            //Tracevv((stderr,"%c", s->window[s->strstart]));
            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    }
    
    /* Values for max_lazy_match, good_match and max_chain_length, depending on
     * the desired pack level (0..9). The values given below have been tuned to
     * exclude worst case performance for pathological files. Better values may be
     * found for specific files.
     */
    var Config = function (good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    };
    
    var configuration_table;
    
    configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),          /* 3 */
        
        new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
    ];
    
    
    /* ===========================================================================
     * Initialize the "longest match" routines for a new zlib stream
     */
    function lm_init(s) {
        s.window_size = 2 * s.w_size;
        
        /*** CLEAR_HASH(s); ***/
        zero(s.head); // Fill with NIL (= 0);
        
        /* Set the default configuration parameters:
         */
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
    }
    
    
    function DeflateState() {
        this.strm = null;            /* pointer back to this zlib stream */
        this.status = 0;            /* as the name implies */
        this.pending_buf = null;      /* output still pending */
        this.pending_buf_size = 0;  /* size of pending_buf */
        this.pending_out = 0;       /* next pending byte to output to the stream */
        this.pending = 0;           /* nb of bytes in the pending buffer */
        this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
        this.gzhead = null;         /* gzip header information to write */
        this.gzindex = 0;           /* where in extra, name, or comment */
        this.method = Z_DEFLATED; /* can only be DEFLATED */
        this.last_flush = -1;   /* value of flush param for previous deflate call */
        
        this.w_size = 0;  /* LZ77 window size (32K by default) */
        this.w_bits = 0;  /* log2(w_size)  (8..16) */
        this.w_mask = 0;  /* w_size - 1 */
        
        this.window = null;
        /* Sliding window. Input bytes are read into the second half of the window,
         * and move to the first half later to keep a dictionary of at least wSize
         * bytes. With this organization, matches are limited to a distance of
         * wSize-MAX_MATCH bytes, but this ensures that IO is always
         * performed with a length multiple of the block size.
         */
        
        this.window_size = 0;
        /* Actual size of window: 2*wSize, except when the user input buffer
         * is directly used as sliding window.
         */
        
        this.prev = null;
        /* Link to older string with same hash index. To limit the size of this
         * array to 64K, this link is maintained only for the last 32K strings.
         * An index in this array is thus a window index modulo 32K.
         */
        
        this.head = null;   /* Heads of the hash chains or NIL. */
        
        this.ins_h = 0;       /* hash index of string to be inserted */
        this.hash_size = 0;   /* number of elements in hash table */
        this.hash_bits = 0;   /* log2(hash_size) */
        this.hash_mask = 0;   /* hash_size-1 */
        
        this.hash_shift = 0;
        /* Number of bits by which ins_h must be shifted at each input
         * step. It must be such that after MIN_MATCH steps, the oldest
         * byte no longer takes part in the hash key, that is:
         *   hash_shift * MIN_MATCH >= hash_bits
         */
        
        this.block_start = 0;
        /* Window position at the beginning of the current output block. Gets
         * negative when the window is moved backwards.
         */
        
        this.match_length = 0;      /* length of best match */
        this.prev_match = 0;        /* previous match */
        this.match_available = 0;   /* set if previous match exists */
        this.strstart = 0;          /* start of string to insert */
        this.match_start = 0;       /* start of matching string */
        this.lookahead = 0;         /* number of valid bytes ahead in window */
        
        this.prev_length = 0;
        /* Length of the best match at previous step. Matches not greater than this
         * are discarded. This is used in the lazy match evaluation.
         */
        
        this.max_chain_length = 0;
        /* To speed up deflation, hash chains are never searched beyond this
         * length.  A higher limit improves compression ratio but degrades the
         * speed.
         */
        
        this.max_lazy_match = 0;
        /* Attempt to find a better match only when the current match is strictly
         * smaller than this value. This mechanism is used only for compression
         * levels >= 4.
         */
        // That's alias to max_lazy_match, don't use directly
        //this.max_insert_length = 0;
        /* Insert new strings in the hash table only if the match length is not
         * greater than this length. This saves time but degrades compression.
         * max_insert_length is used only for compression levels <= 3.
         */
        
        this.level = 0;     /* compression level (1..9) */
        this.strategy = 0;  /* favor or force Huffman coding*/
        
        this.good_match = 0;
        /* Use a faster search when the previous match is longer than this */
        
        this.nice_match = 0; /* Stop searching when current match exceeds this */
        
        /* used by trees.c: */
        
        /* Didn't use ct_data typedef below to suppress compiler warning */
        
        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
        
        // Use flat array of DOUBLE size, with interleaved fata,
        // because JS does not support effective
        this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);
        this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        
        this.l_desc   = null;         /* desc. for literal tree */
        this.d_desc   = null;         /* desc. for distance tree */
        this.bl_desc  = null;         /* desc. for bit length tree */
        
        //ush bl_count[MAX_BITS+1];
        this.bl_count = new utils.Buf16(MAX_BITS+1);
        /* number of codes at each bit length for an optimal tree */
        
        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
        this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */
        zero(this.heap);
        
        this.heap_len = 0;               /* number of elements in the heap */
        this.heap_max = 0;               /* element of largest frequency */
        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
         * The same heap array is used to build all trees.
         */
        
        this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];
        zero(this.depth);
        /* Depth of each subtree used as tie breaker for trees of equal frequency
         */
        
        this.l_buf = 0;          /* buffer index for literals or lengths */
        
        this.lit_bufsize = 0;
        /* Size of match buffer for literals/lengths.  There are 4 reasons for
         * limiting lit_bufsize to 64K:
         *   - frequencies can be kept in 16 bit counters
         *   - if compression is not successful for the first block, all input
         *     data is still in the window so we can still emit a stored block even
         *     when input comes from standard input.  (This can also be done for
         *     all blocks if lit_bufsize is not greater than 32K.)
         *   - if compression is not successful for a file smaller than 64K, we can
         *     even emit a stored file instead of a stored block (saving 5 bytes).
         *     This is applicable only for zip (not gzip or zlib).
         *   - creating new Huffman trees less frequently may not provide fast
         *     adaptation to changes in the input data statistics. (Take for
         *     example a binary file with poorly compressible code followed by
         *     a highly compressible string table.) Smaller buffer sizes give
         *     fast adaptation but have of course the overhead of transmitting
         *     trees more frequently.
         *   - I can't count above 4
         */
        
        this.last_lit = 0;      /* running index in l_buf */
        
        this.d_buf = 0;
        /* Buffer index for distances. To simplify the code, d_buf and l_buf have
         * the same number of elements. To use different lengths, an extra flag
         * array would be necessary.
         */
        
        this.opt_len = 0;       /* bit length of current block with optimal trees */
        this.static_len = 0;    /* bit length of current block with static trees */
        this.matches = 0;       /* number of string matches in current block */
        this.insert = 0;        /* bytes at end of window left to insert */
        
        
        this.bi_buf = 0;
        /* Output buffer. bits are inserted starting at the bottom (least
         * significant bits).
         */
        this.bi_valid = 0;
        /* Number of valid bits in bi_buf.  All bits above the last valid bit
         * are always zero.
         */
        
        // Used for window memory init. We safely ignore it for JS. That makes
        // sense only for pointers and memory check tools.
        //this.high_water = 0;
        /* High water mark offset in window for initialized bytes -- bytes above
         * this are set to zero in order to avoid memory check warnings when
         * longest match routines access bytes past the input.  This is then
         * updated to the new high water mark.
         */
    }
    
    
    function deflateResetKeep(strm) {
        var s;
        
        if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
        }
        
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        
        if (s.wrap < 0) {
            s.wrap = -s.wrap;
            /* was made negative by deflate(..., Z_FINISH); */
        }
        s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
        strm.adler = (s.wrap === 2) ?
            0  // crc32(0, Z_NULL, 0)
            :
            1; // adler32(0, Z_NULL, 0)
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
    }
    
    
    function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
            lm_init(strm.state);
        }
        return ret;
    }
    
    
    function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
        strm.state.gzhead = head;
        return Z_OK;
    }
    
    
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) { // === Z_NULL
            return Z_STREAM_ERROR;
        }
        var wrap = 1;
        
        if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
        }
        
        if (windowBits < 0) { /* suppress zlib wrapper */
            wrap = 0;
            windowBits = -windowBits;
        }
        
        else if (windowBits > 15) {
            wrap = 2;           /* write gzip wrapper instead */
            windowBits -= 16;
        }
        
        
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
            windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
            strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
        }
        
        
        if (windowBits === 8) {
            windowBits = 9;
        }
        /* until 256-byte window bug fixed */
        
        var s = new DeflateState();
        
        strm.state = s;
        s.strm = strm;
        
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        
        // Don't need mem init magic for JS.
        //s.high_water = 0;  /* nothing written to s->window yet */
        
        s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
        
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        
        s.d_buf = s.lit_bufsize >> 1;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        
        return deflateReset(strm);
    }
    
    function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    
    
    function deflate(strm, flush) {
        var old_flush, s;
        var beg, val; // for gzip header write only
        
        if (!strm || !strm.state ||
            flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        
        s = strm.state;
        
        if (!strm.output ||
            (!strm.input && strm.avail_in !== 0) ||
            (s.status === FINISH_STATE && flush !== Z_FINISH)) {
            return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        
        s.strm = strm; /* just in case */
        old_flush = s.last_flush;
        s.last_flush = flush;
        
        /* Write the header */
        if (s.status === INIT_STATE) {
            
            if (s.wrap === 2) { // GZIP header
                strm.adler = 0;  //crc32(0L, Z_NULL, 0);
                put_byte(s, 31);
                put_byte(s, 139);
                put_byte(s, 8);
                if (!s.gzhead) { // s->gzhead == Z_NULL
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, s.level === 9 ? 2 :
                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                            4 : 0));
                    put_byte(s, OS_CODE);
                    s.status = BUSY_STATE;
                }
                else {
                    put_byte(s, (s.gzhead.text ? 1 : 0) +
                        (s.gzhead.hcrc ? 2 : 0) +
                        (!s.gzhead.extra ? 0 : 4) +
                        (!s.gzhead.name ? 0 : 8) +
                        (!s.gzhead.comment ? 0 : 16)
                    );
                    put_byte(s, s.gzhead.time & 0xff);
                    put_byte(s, (s.gzhead.time >> 8) & 0xff);
                    put_byte(s, (s.gzhead.time >> 16) & 0xff);
                    put_byte(s, (s.gzhead.time >> 24) & 0xff);
                    put_byte(s, s.level === 9 ? 2 :
                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                            4 : 0));
                    put_byte(s, s.gzhead.os & 0xff);
                    if (s.gzhead.extra && s.gzhead.extra.length) {
                        put_byte(s, s.gzhead.extra.length & 0xff);
                        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
                    }
                    if (s.gzhead.hcrc) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                    }
                    s.gzindex = 0;
                    s.status = EXTRA_STATE;
                }
            }
            else // DEFLATE header
            {
                var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
                var level_flags = -1;
                
                if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                    level_flags = 0;
                } else if (s.level < 6) {
                    level_flags = 1;
                } else if (s.level === 6) {
                    level_flags = 2;
                } else {
                    level_flags = 3;
                }
                header |= (level_flags << 6);
                if (s.strstart !== 0) { header |= PRESET_DICT; }
                header += 31 - (header % 31);
                
                s.status = BUSY_STATE;
                putShortMSB(s, header);
                
                /* Save the adler32 of the preset dictionary: */
                if (s.strstart !== 0) {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 0xffff);
                }
                strm.adler = 1; // adler32(0L, Z_NULL, 0);
            }
        }
        
        //#ifdef GZIP
        if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra/* != Z_NULL*/) {
                beg = s.pending;  /* start of bytes to update crc */
                
                while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            break;
                        }
                    }
                    put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                    s.gzindex++;
                }
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (s.gzindex === s.gzhead.extra.length) {
                    s.gzindex = 0;
                    s.status = NAME_STATE;
                }
            }
            else {
                s.status = NAME_STATE;
            }
        }
        if (s.status === NAME_STATE) {
            if (s.gzhead.name/* != Z_NULL*/) {
                beg = s.pending;  /* start of bytes to update crc */
                //int val;
                
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                        }
                    }
                    // JS specific: little magic to add zero terminator to end of string
                    if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                    s.gzindex = 0;
                    s.status = COMMENT_STATE;
                }
            }
            else {
                s.status = COMMENT_STATE;
            }
        }
        if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment/* != Z_NULL*/) {
                beg = s.pending;  /* start of bytes to update crc */
                //int val;
                
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                        }
                    }
                    // JS specific: little magic to add zero terminator to end of string
                    if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                    s.status = HCRC_STATE;
                }
            }
            else {
                s.status = HCRC_STATE;
            }
        }
        if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                    flush_pending(strm);
                }
                if (s.pending + 2 <= s.pending_buf_size) {
                    put_byte(s, strm.adler & 0xff);
                    put_byte(s, (strm.adler >> 8) & 0xff);
                    strm.adler = 0; //crc32(0L, Z_NULL, 0);
                    s.status = BUSY_STATE;
                }
            }
            else {
                s.status = BUSY_STATE;
            }
        }
        //#endif
        
        /* Flush as much pending output as possible */
        if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
                /* Since avail_out is 0, deflate will be called again with
                 * more output space, but possibly with both pending and
                 * avail_in equal to zero. There won't be anything to do,
                 * but this is not an error situation so make sure we
                 * return OK instead of BUF_ERROR at next call of deflate:
                 */
                s.last_flush = -1;
                return Z_OK;
            }
            
            /* Make sure there is something to do and avoid duplicate consecutive
             * flushes. For repeated and useless calls with Z_FINISH, we keep
             * returning Z_STREAM_END instead of Z_BUF_ERROR.
             */
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
            flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
        }
        
        /* User must not provide more input after the first FINISH: */
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
        }
        
        /* Start a new block or continue the current one.
         */
        if (strm.avail_in !== 0 || s.lookahead !== 0 ||
            (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
            var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
                (s.strategy === Z_RLE ? deflate_rle(s, flush) :
                    configuration_table[s.level].func(s, flush));
            
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    /* avoid BUF_ERROR next call, see above */
                }
                return Z_OK;
                /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                 * of deflate should use the same flush parameter to make sure
                 * that the flush is complete. So we don't have to output an
                 * empty block here, this will be done at next call. This also
                 * ensures that for a very small output buffer, we emit at most
                 * one empty block.
                 */
            }
            if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                    trees._tr_align(s);
                }
                else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                    
                    trees._tr_stored_block(s, 0, 0, false);
                    /* For a full flush, this empty block will be recognized
                     * as a special marker by inflate_sync().
                     */
                    if (flush === Z_FULL_FLUSH) {
                        /*** CLEAR_HASH(s); ***/             /* forget history */
                        zero(s.head); // Fill with NIL (= 0);
                        
                        if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                    }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                    return Z_OK;
                }
            }
        }
        //Assert(strm->avail_out > 0, "bug2");
        //if (strm.avail_out <= 0) { throw new Error("bug2");}
        
        if (flush !== Z_FINISH) { return Z_OK; }
        if (s.wrap <= 0) { return Z_STREAM_END; }
        
        /* Write the trailer */
        if (s.wrap === 2) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            put_byte(s, (strm.adler >> 16) & 0xff);
            put_byte(s, (strm.adler >> 24) & 0xff);
            put_byte(s, strm.total_in & 0xff);
            put_byte(s, (strm.total_in >> 8) & 0xff);
            put_byte(s, (strm.total_in >> 16) & 0xff);
            put_byte(s, (strm.total_in >> 24) & 0xff);
        }
        else
        {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
        }
        
        flush_pending(strm);
        /* If avail_out is zero, the application will call deflate again
         * to flush the rest.
         */
        if (s.wrap > 0) { s.wrap = -s.wrap; }
        /* write the trailer only once! */
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    
    function deflateEnd(strm) {
        var status;
        
        if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
            return Z_STREAM_ERROR;
        }
        
        status = strm.state.status;
        if (status !== INIT_STATE &&
            status !== EXTRA_STATE &&
            status !== NAME_STATE &&
            status !== COMMENT_STATE &&
            status !== HCRC_STATE &&
            status !== BUSY_STATE &&
            status !== FINISH_STATE
        ) {
            return err(strm, Z_STREAM_ERROR);
        }
        
        strm.state = null;
        
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    
    /* =========================================================================
     * Copy the source state to the destination state
     */
    //function deflateCopy(dest, source) {
    //
    //}
    
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';
    
    /* Not implemented
     exports.deflateBound = deflateBound;
     exports.deflateCopy = deflateCopy;
     exports.deflateSetDictionary = deflateSetDictionary;
     exports.deflateParams = deflateParams;
     exports.deflatePending = deflatePending;
     exports.deflatePrime = deflatePrime;
     exports.deflateTune = deflateTune;
     */
    
},{"../utils/common":89,"./adler32":91,"./crc32":93,"./messages":99,"./trees":100}],95:[function(require,module,exports){
    'use strict';
    
    
    function GZheader() {
        /* true if compressed data believed to be text */
        this.text       = 0;
        /* modification time */
        this.time       = 0;
        /* extra flags (not used when writing a gzip file) */
        this.xflags     = 0;
        /* operating system */
        this.os         = 0;
        /* pointer to extra field or Z_NULL if none */
        this.extra      = null;
        /* extra field length (valid if extra != Z_NULL) */
        this.extra_len  = 0; // Actually, we don't need it in JS,
                             // but leave for few code modifications
        
        //
        // Setup limits is not necessary because in js we should not preallocate memory
        // for inflate use constant limit in 65536 bytes
        //
        
        /* space at extra (only when reading header) */
        // this.extra_max  = 0;
        /* pointer to zero-terminated file name or Z_NULL */
        this.name       = '';
        /* space at name (only when reading header) */
        // this.name_max   = 0;
        /* pointer to zero-terminated comment or Z_NULL */
        this.comment    = '';
        /* space at comment (only when reading header) */
        // this.comm_max   = 0;
        /* true if there was or will be a header crc */
        this.hcrc       = 0;
        /* true when done reading gzip header (not used when writing a gzip file) */
        this.done       = false;
    }
    
    module.exports = GZheader;
    
},{}],96:[function(require,module,exports){
    'use strict';
    
    // See state defs from inflate.js
    var BAD = 30;       /* got a data error -- remain here until reset */
    var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
    
    /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.
    
     Entry assumptions:
    
     state.mode === LEN
     strm.avail_in >= 6
     strm.avail_out >= 258
     start >= strm.avail_out
     state.bits < 8
    
     On return, state.mode is one of:
    
     LEN -- ran out of enough output space or enough available input
     TYPE -- reached end of block code, inflate() to interpret next block
     BAD -- error in block data
    
     Notes:
    
     - The maximum input bits used by a length/distance pair is 15 bits for the
     length code, 5 bits for the length extra, 15 bits for the distance code,
     and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
     Therefore if strm.avail_in >= 6, then there is enough input to avoid
     checking for available input while decoding.
    
     - The maximum bytes that a single length/distance pair can output is 258
     bytes, which is the maximum length that can be coded.  inflate_fast()
     requires strm.avail_out >= 258 for each loop to avoid checking for
     output space.
     */
    module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;                    /* local strm.input */
        var last;                   /* have enough input while in < last */
        var _out;                   /* local strm.output */
        var beg;                    /* inflate()'s initial strm.output */
        var end;                    /* while out < end, enough space available */
        //#ifdef INFLATE_STRICT
        var dmax;                   /* maximum distance from zlib header */
        //#endif
        var wsize;                  /* window size or zero if not using window */
        var whave;                  /* valid bytes in the window */
        var wnext;                  /* window write index */
        // Use `s_window` instead `window`, avoid conflict with instrumentation tools
        var s_window;               /* allocated sliding window, if wsize != 0 */
        var hold;                   /* local strm.hold */
        var bits;                   /* local strm.bits */
        var lcode;                  /* local strm.lencode */
        var dcode;                  /* local strm.distcode */
        var lmask;                  /* mask for first level of length codes */
        var dmask;                  /* mask for first level of distance codes */
        var here;                   /* retrieved table entry */
        var op;                     /* code bits, operation, extra bits, or */
        /*  window position, window bytes to copy */
        var len;                    /* match length, unused bytes */
        var dist;                   /* match distance */
        var from;                   /* where to copy match from */
        var from_source;
        
        
        var input, output; // JS specific, because we have no pointers
        
        /* copy state to local variables */
        state = strm.state;
        //here = state.here;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        //#ifdef INFLATE_STRICT
        dmax = state.dmax;
        //#endif
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        
        
        /* decode literals and length/distances until end-of-block or not enough
         input data or output space */
        
        top:
            do {
                if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                }
                
                here = lcode[hold & lmask];
                
                dolen:
                    for (;;) { // Goto emulation
                        op = here >>> 24/*here.bits*/;
                        hold >>>= op;
                        bits -= op;
                        op = (here >>> 16) & 0xff/*here.op*/;
                        if (op === 0) {                          /* literal */
                            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                            //        "inflate:         literal '%c'\n" :
                            //        "inflate:         literal 0x%02x\n", here.val));
                            output[_out++] = here & 0xffff/*here.val*/;
                        }
                        else if (op & 16) {                     /* length base */
                            len = here & 0xffff/*here.val*/;
                            op &= 15;                           /* number of extra bits */
                            if (op) {
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                                len += hold & ((1 << op) - 1);
                                hold >>>= op;
                                bits -= op;
                            }
                            //Tracevv((stderr, "inflate:         length %u\n", len));
                            if (bits < 15) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                            here = dcode[hold & dmask];
                            
                            dodist:
                                for (;;) { // goto emulation
                                    op = here >>> 24/*here.bits*/;
                                    hold >>>= op;
                                    bits -= op;
                                    op = (here >>> 16) & 0xff/*here.op*/;
                                    
                                    if (op & 16) {                      /* distance base */
                                        dist = here & 0xffff/*here.val*/;
                                        op &= 15;                       /* number of extra bits */
                                        if (bits < op) {
                                            hold += input[_in++] << bits;
                                            bits += 8;
                                            if (bits < op) {
                                                hold += input[_in++] << bits;
                                                bits += 8;
                                            }
                                        }
                                        dist += hold & ((1 << op) - 1);
                                        //#ifdef INFLATE_STRICT
                                        if (dist > dmax) {
                                            strm.msg = 'invalid distance too far back';
                                            state.mode = BAD;
                                            break top;
                                        }
                                        //#endif
                                        hold >>>= op;
                                        bits -= op;
                                        //Tracevv((stderr, "inflate:         distance %u\n", dist));
                                        op = _out - beg;                /* max distance in output */
                                        if (dist > op) {                /* see if copy from window */
                                            op = dist - op;               /* distance back in window */
                                            if (op > whave) {
                                                if (state.sane) {
                                                    strm.msg = 'invalid distance too far back';
                                                    state.mode = BAD;
                                                    break top;
                                                }
                                                
                                                // (!) This block is disabled in zlib defailts,
                                                // don't enable it for binary compatibility
                                                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                                //                if (len <= op - whave) {
                                                //                  do {
                                                //                    output[_out++] = 0;
                                                //                  } while (--len);
                                                //                  continue top;
                                                //                }
                                                //                len -= op - whave;
                                                //                do {
                                                //                  output[_out++] = 0;
                                                //                } while (--op > whave);
                                                //                if (op === 0) {
                                                //                  from = _out - dist;
                                                //                  do {
                                                //                    output[_out++] = output[from++];
                                                //                  } while (--len);
                                                //                  continue top;
                                                //                }
                                                //#endif
                                            }
                                            from = 0; // window index
                                            from_source = s_window;
                                            if (wnext === 0) {           /* very common case */
                                                from += wsize - op;
                                                if (op < len) {         /* some from window */
                                                    len -= op;
                                                    do {
                                                        output[_out++] = s_window[from++];
                                                    } while (--op);
                                                    from = _out - dist;  /* rest from output */
                                                    from_source = output;
                                                }
                                            }
                                            else if (wnext < op) {      /* wrap around window */
                                                from += wsize + wnext - op;
                                                op -= wnext;
                                                if (op < len) {         /* some from end of window */
                                                    len -= op;
                                                    do {
                                                        output[_out++] = s_window[from++];
                                                    } while (--op);
                                                    from = 0;
                                                    if (wnext < len) {  /* some from start of window */
                                                        op = wnext;
                                                        len -= op;
                                                        do {
                                                            output[_out++] = s_window[from++];
                                                        } while (--op);
                                                        from = _out - dist;      /* rest from output */
                                                        from_source = output;
                                                    }
                                                }
                                            }
                                            else {                      /* contiguous in window */
                                                from += wnext - op;
                                                if (op < len) {         /* some from window */
                                                    len -= op;
                                                    do {
                                                        output[_out++] = s_window[from++];
                                                    } while (--op);
                                                    from = _out - dist;  /* rest from output */
                                                    from_source = output;
                                                }
                                            }
                                            while (len > 2) {
                                                output[_out++] = from_source[from++];
                                                output[_out++] = from_source[from++];
                                                output[_out++] = from_source[from++];
                                                len -= 3;
                                            }
                                            if (len) {
                                                output[_out++] = from_source[from++];
                                                if (len > 1) {
                                                    output[_out++] = from_source[from++];
                                                }
                                            }
                                        }
                                        else {
                                            from = _out - dist;          /* copy direct from output */
                                            do {                        /* minimum length is three */
                                                output[_out++] = output[from++];
                                                output[_out++] = output[from++];
                                                output[_out++] = output[from++];
                                                len -= 3;
                                            } while (len > 2);
                                            if (len) {
                                                output[_out++] = output[from++];
                                                if (len > 1) {
                                                    output[_out++] = output[from++];
                                                }
                                            }
                                        }
                                    }
                                    else if ((op & 64) === 0) {          /* 2nd level distance code */
                                        here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                                        continue dodist;
                                    }
                                    else {
                                        strm.msg = 'invalid distance code';
                                        state.mode = BAD;
                                        break top;
                                    }
                                    
                                    break; // need to emulate goto via "continue"
                                }
                        }
                        else if ((op & 64) === 0) {              /* 2nd level length code */
                            here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                            continue dolen;
                        }
                        else if (op & 32) {                     /* end-of-block */
                            //Tracevv((stderr, "inflate:         end of block\n"));
                            state.mode = TYPE;
                            break top;
                        }
                        else {
                            strm.msg = 'invalid literal/length code';
                            state.mode = BAD;
                            break top;
                        }
                        
                        break; // need to emulate goto via "continue"
                    }
            } while (_in < last && _out < end);
        
        /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        
        /* update state and return */
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
        strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
        state.hold = hold;
        state.bits = bits;
        return;
    };
    
},{}],97:[function(require,module,exports){
    'use strict';
    
    
    var utils = require('../utils/common');
    var adler32 = require('./adler32');
    var crc32   = require('./crc32');
    var inflate_fast = require('./inffast');
    var inflate_table = require('./inftrees');
    
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    
    /* Public constants ==========================================================*/
    /* ===========================================================================*/
    
    
    /* Allowed flush values; see deflate() and inflate() below for details */
    //var Z_NO_FLUSH      = 0;
    //var Z_PARTIAL_FLUSH = 1;
    //var Z_SYNC_FLUSH    = 2;
    //var Z_FULL_FLUSH    = 3;
    var Z_FINISH        = 4;
    var Z_BLOCK         = 5;
    var Z_TREES         = 6;
    
    
    /* Return codes for the compression/decompression functions. Negative values
     * are errors, positive values are used for special but normal events.
     */
    var Z_OK            = 0;
    var Z_STREAM_END    = 1;
    var Z_NEED_DICT     = 2;
    //var Z_ERRNO         = -1;
    var Z_STREAM_ERROR  = -2;
    var Z_DATA_ERROR    = -3;
    var Z_MEM_ERROR     = -4;
    var Z_BUF_ERROR     = -5;
    //var Z_VERSION_ERROR = -6;
    
    /* The deflate compression method */
    var Z_DEFLATED  = 8;
    
    
    /* STATES ====================================================================*/
    /* ===========================================================================*/
    
    
    var    HEAD = 1;       /* i: waiting for magic header */
    var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
    var    TIME = 3;       /* i: waiting for modification time (gzip) */
    var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
    var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
    var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
    var    NAME = 7;       /* i: waiting for end of file name (gzip) */
    var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
    var    HCRC = 9;       /* i: waiting for header crc (gzip) */
    var    DICTID = 10;    /* i: waiting for dictionary check value */
    var    DICT = 11;      /* waiting for inflateSetDictionary() call */
    var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
    var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
    var        STORED = 14;    /* i: waiting for stored size (length and complement) */
    var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
    var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
    var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
    var        LENLENS = 18;   /* i: waiting for code length code lengths */
    var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
    var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
    var            LEN = 21;       /* i: waiting for length/lit/eob code */
    var            LENEXT = 22;    /* i: waiting for length extra bits */
    var            DIST = 23;      /* i: waiting for distance code */
    var            DISTEXT = 24;   /* i: waiting for distance extra bits */
    var            MATCH = 25;     /* o: waiting for output space to copy string */
    var            LIT = 26;       /* o: waiting for output space to write literal */
    var    CHECK = 27;     /* i: waiting for 32-bit check value */
    var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
    var    DONE = 29;      /* finished check, done -- remain here until reset */
    var    BAD = 30;       /* got a data error -- remain here until reset */
    var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
    var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */
    
    /* ===========================================================================*/
    
    
    
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
    
    var MAX_WBITS = 15;
    /* 32K LZ77 window */
    var DEF_WBITS = MAX_WBITS;
    
    
    function ZSWAP32(q) {
        return  (((q >>> 24) & 0xff) +
        ((q >>> 8) & 0xff00) +
        ((q & 0xff00) << 8) +
        ((q & 0xff) << 24));
    }
    
    
    function InflateState() {
        this.mode = 0;             /* current inflate mode */
        this.last = false;          /* true if processing last block */
        this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
        this.havedict = false;      /* true if dictionary provided */
        this.flags = 0;             /* gzip header method and flags (0 if zlib) */
        this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
        this.check = 0;             /* protected copy of check value */
        this.total = 0;             /* protected copy of output count */
        // TODO: may be {}
        this.head = null;           /* where to save gzip header information */
        
        /* sliding window */
        this.wbits = 0;             /* log base 2 of requested window size */
        this.wsize = 0;             /* window size or zero if not using window */
        this.whave = 0;             /* valid bytes in the window */
        this.wnext = 0;             /* window write index */
        this.window = null;         /* allocated sliding window, if needed */
        
        /* bit accumulator */
        this.hold = 0;              /* input bit accumulator */
        this.bits = 0;              /* number of bits in "in" */
        
        /* for string and stored block copying */
        this.length = 0;            /* literal or length of data to copy */
        this.offset = 0;            /* distance back to copy string from */
        
        /* for table and code decoding */
        this.extra = 0;             /* extra bits needed */
        
        /* fixed and dynamic code tables */
        this.lencode = null;          /* starting table for length/literal codes */
        this.distcode = null;         /* starting table for distance codes */
        this.lenbits = 0;           /* index bits for lencode */
        this.distbits = 0;          /* index bits for distcode */
        
        /* dynamic table building */
        this.ncode = 0;             /* number of code length code lengths */
        this.nlen = 0;              /* number of length code lengths */
        this.ndist = 0;             /* number of distance code lengths */
        this.have = 0;              /* number of code lengths in lens[] */
        this.next = null;              /* next available space in codes[] */
        
        this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
        this.work = new utils.Buf16(288); /* work area for code table building */
        
        /*
         because we don't have pointers in js, we use lencode and distcode directly
         as buffers so we don't need codes
         */
        //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
        this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
        this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
        this.sane = 0;                   /* if false, allow invalid distance too far */
        this.back = 0;                   /* bits back of last unprocessed length/lit */
        this.was = 0;                    /* initial length of match */
    }
    
    function inflateResetKeep(strm) {
        var state;
        
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = ''; /*Z_NULL*/
        if (state.wrap) {       /* to support ill-conceived Java test suite */
            strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null/*Z_NULL*/;
        state.hold = 0;
        state.bits = 0;
        //state.lencode = state.distcode = state.next = state.codes;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        
        state.sane = 1;
        state.back = -1;
        //Tracev((stderr, "inflate: reset\n"));
        return Z_OK;
    }
    
    function inflateReset(strm) {
        var state;
        
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
        
    }
    
    function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        
        /* get the state */
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;
        
        /* extract wrap request from windowBits parameter */
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        }
        else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
                windowBits &= 15;
            }
        }
        
        /* set number of window bits, free window if different */
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
        }
        
        /* update state and reset the rest of it */
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
    }
    
    function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        
        if (!strm) { return Z_STREAM_ERROR; }
        //strm.msg = Z_NULL;                 /* in case we return an error */
        
        state = new InflateState();
        
        //if (state === Z_NULL) return Z_MEM_ERROR;
        //Tracev((stderr, "inflate: allocated\n"));
        strm.state = state;
        state.window = null/*Z_NULL*/;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
            strm.state = null/*Z_NULL*/;
        }
        return ret;
    }
    
    function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
    }
    
    
    /*
     Return state with length and distance decoding tables and index sizes set to
     fixed code decoding.  Normally this returns fixed tables from inffixed.h.
     If BUILDFIXED is defined, then instead this routine builds the tables the
     first time it's called, and returns those tables the first time and
     thereafter.  This reduces the size of the code by about 2K bytes, in
     exchange for a little execution time.  However, BUILDFIXED should not be
     used for threaded applications, since the rewriting of the tables and virgin
     may not be thread-safe.
     */
    var virgin = true;
    
    var lenfix, distfix; // We have no pointers in JS, so keep tables separate
    
    function fixedtables(state) {
        /* build fixed huffman tables if first call (may not be thread safe) */
        if (virgin) {
            var sym;
            
            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);
            
            /* literal/length table */
            sym = 0;
            while (sym < 144) { state.lens[sym++] = 8; }
            while (sym < 256) { state.lens[sym++] = 9; }
            while (sym < 280) { state.lens[sym++] = 7; }
            while (sym < 288) { state.lens[sym++] = 8; }
            
            inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});
            
            /* distance table */
            sym = 0;
            while (sym < 32) { state.lens[sym++] = 5; }
            
            inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});
            
            /* do this just once */
            virgin = false;
        }
        
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
    }
    
    
    /*
     Update the window with the last wsize (normally 32K) bytes written before
     returning.  If window does not exist yet, create it.  This is only called
     when a window is already in use, or when output has been written during this
     inflate call, but the end of the deflate stream has not been reached yet.
     It is also called to create a window for dictionary data when a dictionary
     is loaded.
    
     Providing output buffers larger than 32K to inflate() should provide a speed
     advantage, since only the last 32K of output is copied to the sliding window
     upon return from inflate(), and since all distances after the first 32K of
     output will fall in the output data, making match copies simpler and faster.
     The advantage may be dependent on the size of the processor's data caches.
     */
    function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        
        /* if it hasn't been done already, allocate space for the window */
        if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            
            state.window = new utils.Buf8(state.wsize);
        }
        
        /* copy state->wsize or less output bytes into the circular window */
        if (copy >= state.wsize) {
            utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
        }
        else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
                dist = copy;
            }
            //zmemcpy(state->window + state->wnext, end - copy, dist);
            utils.arraySet(state.window,src, end - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
                //zmemcpy(state->window, end - copy, copy);
                utils.arraySet(state.window,src, end - copy, copy, 0);
                state.wnext = copy;
                state.whave = state.wsize;
            }
            else {
                state.wnext += dist;
                if (state.wnext === state.wsize) { state.wnext = 0; }
                if (state.whave < state.wsize) { state.whave += dist; }
            }
        }
        return 0;
    }
    
    function inflate(strm, flush) {
        var state;
        var input, output;          // input/output buffers
        var next;                   /* next input INDEX */
        var put;                    /* next output INDEX */
        var have, left;             /* available input and output */
        var hold;                   /* bit buffer */
        var bits;                   /* bits in bit buffer */
        var _in, _out;              /* save starting available input and output */
        var copy;                   /* number of stored or match bytes to copy */
        var from;                   /* where to copy match bytes from */
        var from_source;
        var here = 0;               /* current decoding table entry */
        var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
        //var last;                   /* parent table entry */
        var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
        var len;                    /* length to copy for repeats, bits to drop */
        var ret;                    /* return code */
        var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
        var opts;
        
        var n; // temporary var for NEED_BITS
        
        var order = /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        
        
        if (!strm || !strm.state || !strm.output ||
            (!strm.input && strm.avail_in !== 0)) {
            return Z_STREAM_ERROR;
        }
        
        state = strm.state;
        if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */
        
        
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---
        
        _in = have;
        _out = left;
        ret = Z_OK;
        
        inf_leave: // goto emulation
            for (;;) {
                switch (state.mode) {
                    case HEAD:
                        if (state.wrap === 0) {
                            state.mode = TYPEDO;
                            break;
                        }
                        //=== NEEDBITS(16);
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
                            state.check = 0/*crc32(0L, Z_NULL, 0)*/;
                            //=== CRC2(state.check, hold);
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            //===//
                            
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            state.mode = FLAGS;
                            break;
                        }
                        state.flags = 0;           /* expect zlib header */
                        if (state.head) {
                            state.head.done = false;
                        }
                        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
                            (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
                            strm.msg = 'incorrect header check';
                            state.mode = BAD;
                            break;
                        }
                        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
                            strm.msg = 'unknown compression method';
                            state.mode = BAD;
                            break;
                        }
                        //--- DROPBITS(4) ---//
                        hold >>>= 4;
                        bits -= 4;
                        //---//
                        len = (hold & 0x0f)/*BITS(4)*/ + 8;
                        if (state.wbits === 0) {
                            state.wbits = len;
                        }
                        else if (len > state.wbits) {
                            strm.msg = 'invalid window size';
                            state.mode = BAD;
                            break;
                        }
                        state.dmax = 1 << len;
                        //Tracev((stderr, "inflate:   zlib header ok\n"));
                        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                        state.mode = hold & 0x200 ? DICTID : TYPE;
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        break;
                    case FLAGS:
                        //=== NEEDBITS(16); */
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.flags = hold;
                        if ((state.flags & 0xff) !== Z_DEFLATED) {
                            strm.msg = 'unknown compression method';
                            state.mode = BAD;
                            break;
                        }
                        if (state.flags & 0xe000) {
                            strm.msg = 'unknown header flags set';
                            state.mode = BAD;
                            break;
                        }
                        if (state.head) {
                            state.head.text = ((hold >> 8) & 1);
                        }
                        if (state.flags & 0x0200) {
                            //=== CRC2(state.check, hold);
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            //===//
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = TIME;
                    /* falls through */
                    case TIME:
                        //=== NEEDBITS(32); */
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if (state.head) {
                            state.head.time = hold;
                        }
                        if (state.flags & 0x0200) {
                            //=== CRC4(state.check, hold)
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            hbuf[2] = (hold >>> 16) & 0xff;
                            hbuf[3] = (hold >>> 24) & 0xff;
                            state.check = crc32(state.check, hbuf, 4, 0);
                            //===
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = OS;
                    /* falls through */
                    case OS:
                        //=== NEEDBITS(16); */
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if (state.head) {
                            state.head.xflags = (hold & 0xff);
                            state.head.os = (hold >> 8);
                        }
                        if (state.flags & 0x0200) {
                            //=== CRC2(state.check, hold);
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            //===//
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = EXLEN;
                    /* falls through */
                    case EXLEN:
                        if (state.flags & 0x0400) {
                            //=== NEEDBITS(16); */
                            while (bits < 16) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.length = hold;
                            if (state.head) {
                                state.head.extra_len = hold;
                            }
                            if (state.flags & 0x0200) {
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                        }
                        else if (state.head) {
                            state.head.extra = null/*Z_NULL*/;
                        }
                        state.mode = EXTRA;
                    /* falls through */
                    case EXTRA:
                        if (state.flags & 0x0400) {
                            copy = state.length;
                            if (copy > have) { copy = have; }
                            if (copy) {
                                if (state.head) {
                                    len = state.head.extra_len - state.length;
                                    if (!state.head.extra) {
                                        // Use untyped array for more conveniend processing later
                                        state.head.extra = new Array(state.head.extra_len);
                                    }
                                    utils.arraySet(
                                        state.head.extra,
                                        input,
                                        next,
                                        // extra field is limited to 65536 bytes
                                        // - no need for additional size check
                                        copy,
                                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                        len
                                    );
                                    //zmemcpy(state.head.extra + len, next,
                                    //        len + copy > state.head.extra_max ?
                                    //        state.head.extra_max - len : copy);
                                }
                                if (state.flags & 0x0200) {
                                    state.check = crc32(state.check, input, copy, next);
                                }
                                have -= copy;
                                next += copy;
                                state.length -= copy;
                            }
                            if (state.length) { break inf_leave; }
                        }
                        state.length = 0;
                        state.mode = NAME;
                    /* falls through */
                    case NAME:
                        if (state.flags & 0x0800) {
                            if (have === 0) { break inf_leave; }
                            copy = 0;
                            do {
                                // TODO: 2 or 1 bytes?
                                len = input[next + copy++];
                                /* use constant limit because in js we should not preallocate memory */
                                if (state.head && len &&
                                    (state.length < 65536 /*state.head.name_max*/)) {
                                    state.head.name += String.fromCharCode(len);
                                }
                            } while (len && copy < have);
                            
                            if (state.flags & 0x0200) {
                                state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) { break inf_leave; }
                        }
                        else if (state.head) {
                            state.head.name = null;
                        }
                        state.length = 0;
                        state.mode = COMMENT;
                    /* falls through */
                    case COMMENT:
                        if (state.flags & 0x1000) {
                            if (have === 0) { break inf_leave; }
                            copy = 0;
                            do {
                                len = input[next + copy++];
                                /* use constant limit because in js we should not preallocate memory */
                                if (state.head && len &&
                                    (state.length < 65536 /*state.head.comm_max*/)) {
                                    state.head.comment += String.fromCharCode(len);
                                }
                            } while (len && copy < have);
                            if (state.flags & 0x0200) {
                                state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) { break inf_leave; }
                        }
                        else if (state.head) {
                            state.head.comment = null;
                        }
                        state.mode = HCRC;
                    /* falls through */
                    case HCRC:
                        if (state.flags & 0x0200) {
                            //=== NEEDBITS(16); */
                            while (bits < 16) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if (hold !== (state.check & 0xffff)) {
                                strm.msg = 'header crc mismatch';
                                state.mode = BAD;
                                break;
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                        }
                        if (state.head) {
                            state.head.hcrc = ((state.flags >> 9) & 1);
                            state.head.done = true;
                        }
                        strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
                        state.mode = TYPE;
                        break;
                    case DICTID:
                        //=== NEEDBITS(32); */
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        strm.adler = state.check = ZSWAP32(hold);
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = DICT;
                    /* falls through */
                    case DICT:
                        if (state.havedict === 0) {
                            //--- RESTORE() ---
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            //---
                            return Z_NEED_DICT;
                        }
                        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                        state.mode = TYPE;
                    /* falls through */
                    case TYPE:
                        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
                    /* falls through */
                    case TYPEDO:
                        if (state.last) {
                            //--- BYTEBITS() ---//
                            hold >>>= bits & 7;
                            bits -= bits & 7;
                            //---//
                            state.mode = CHECK;
                            break;
                        }
                        //=== NEEDBITS(3); */
                        while (bits < 3) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.last = (hold & 0x01)/*BITS(1)*/;
                        //--- DROPBITS(1) ---//
                        hold >>>= 1;
                        bits -= 1;
                        //---//
                        
                        switch ((hold & 0x03)/*BITS(2)*/) {
                            case 0:                             /* stored block */
                                //Tracev((stderr, "inflate:     stored block%s\n",
                                //        state.last ? " (last)" : ""));
                                state.mode = STORED;
                                break;
                            case 1:                             /* fixed block */
                                fixedtables(state);
                                //Tracev((stderr, "inflate:     fixed codes block%s\n",
                                //        state.last ? " (last)" : ""));
                                state.mode = LEN_;             /* decode codes */
                                if (flush === Z_TREES) {
                                    //--- DROPBITS(2) ---//
                                    hold >>>= 2;
                                    bits -= 2;
                                    //---//
                                    break inf_leave;
                                }
                                break;
                            case 2:                             /* dynamic block */
                                //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                                //        state.last ? " (last)" : ""));
                                state.mode = TABLE;
                                break;
                            case 3:
                                strm.msg = 'invalid block type';
                                state.mode = BAD;
                        }
                        //--- DROPBITS(2) ---//
                        hold >>>= 2;
                        bits -= 2;
                        //---//
                        break;
                    case STORED:
                        //--- BYTEBITS() ---// /* go to byte boundary */
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        //---//
                        //=== NEEDBITS(32); */
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                            strm.msg = 'invalid stored block lengths';
                            state.mode = BAD;
                            break;
                        }
                        state.length = hold & 0xffff;
                        //Tracev((stderr, "inflate:       stored length %u\n",
                        //        state.length));
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = COPY_;
                        if (flush === Z_TREES) { break inf_leave; }
                    /* falls through */
                    case COPY_:
                        state.mode = COPY;
                    /* falls through */
                    case COPY:
                        copy = state.length;
                        if (copy) {
                            if (copy > have) { copy = have; }
                            if (copy > left) { copy = left; }
                            if (copy === 0) { break inf_leave; }
                            //--- zmemcpy(put, next, copy); ---
                            utils.arraySet(output, input, next, copy, put);
                            //---//
                            have -= copy;
                            next += copy;
                            left -= copy;
                            put += copy;
                            state.length -= copy;
                            break;
                        }
                        //Tracev((stderr, "inflate:       stored end\n"));
                        state.mode = TYPE;
                        break;
                    case TABLE:
                        //=== NEEDBITS(14); */
                        while (bits < 14) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
                        //--- DROPBITS(5) ---//
                        hold >>>= 5;
                        bits -= 5;
                        //---//
                        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
                        //--- DROPBITS(5) ---//
                        hold >>>= 5;
                        bits -= 5;
                        //---//
                        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
                        //--- DROPBITS(4) ---//
                        hold >>>= 4;
                        bits -= 4;
                        //---//
                        //#ifndef PKZIP_BUG_WORKAROUND
                        if (state.nlen > 286 || state.ndist > 30) {
                            strm.msg = 'too many length or distance symbols';
                            state.mode = BAD;
                            break;
                        }
                        //#endif
                        //Tracev((stderr, "inflate:       table sizes ok\n"));
                        state.have = 0;
                        state.mode = LENLENS;
                    /* falls through */
                    case LENLENS:
                        while (state.have < state.ncode) {
                            //=== NEEDBITS(3);
                            while (bits < 3) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
                            //--- DROPBITS(3) ---//
                            hold >>>= 3;
                            bits -= 3;
                            //---//
                        }
                        while (state.have < 19) {
                            state.lens[order[state.have++]] = 0;
                        }
                        // We have separate tables & no pointers. 2 commented lines below not needed.
                        //state.next = state.codes;
                        //state.lencode = state.next;
                        // Switch to use dynamic table
                        state.lencode = state.lendyn;
                        state.lenbits = 7;
                        
                        opts = {bits: state.lenbits};
                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        
                        if (ret) {
                            strm.msg = 'invalid code lengths set';
                            state.mode = BAD;
                            break;
                        }
                        //Tracev((stderr, "inflate:       code lengths ok\n"));
                        state.have = 0;
                        state.mode = CODELENS;
                    /* falls through */
                    case CODELENS:
                        while (state.have < state.nlen + state.ndist) {
                            for (;;) {
                                here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;
                                
                                if ((here_bits) <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            if (here_val < 16) {
                                //--- DROPBITS(here.bits) ---//
                                hold >>>= here_bits;
                                bits -= here_bits;
                                //---//
                                state.lens[state.have++] = here_val;
                            }
                            else {
                                if (here_val === 16) {
                                    //=== NEEDBITS(here.bits + 2);
                                    n = here_bits + 2;
                                    while (bits < n) {
                                        if (have === 0) { break inf_leave; }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    if (state.have === 0) {
                                        strm.msg = 'invalid bit length repeat';
                                        state.mode = BAD;
                                        break;
                                    }
                                    len = state.lens[state.have - 1];
                                    copy = 3 + (hold & 0x03);//BITS(2);
                                    //--- DROPBITS(2) ---//
                                    hold >>>= 2;
                                    bits -= 2;
                                    //---//
                                }
                                else if (here_val === 17) {
                                    //=== NEEDBITS(here.bits + 3);
                                    n = here_bits + 3;
                                    while (bits < n) {
                                        if (have === 0) { break inf_leave; }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    len = 0;
                                    copy = 3 + (hold & 0x07);//BITS(3);
                                    //--- DROPBITS(3) ---//
                                    hold >>>= 3;
                                    bits -= 3;
                                    //---//
                                }
                                else {
                                    //=== NEEDBITS(here.bits + 7);
                                    n = here_bits + 7;
                                    while (bits < n) {
                                        if (have === 0) { break inf_leave; }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    len = 0;
                                    copy = 11 + (hold & 0x7f);//BITS(7);
                                    //--- DROPBITS(7) ---//
                                    hold >>>= 7;
                                    bits -= 7;
                                    //---//
                                }
                                if (state.have + copy > state.nlen + state.ndist) {
                                    strm.msg = 'invalid bit length repeat';
                                    state.mode = BAD;
                                    break;
                                }
                                while (copy--) {
                                    state.lens[state.have++] = len;
                                }
                            }
                        }
                        
                        /* handle error breaks in while */
                        if (state.mode === BAD) { break; }
                        
                        /* check for end-of-block code (better have one) */
                        if (state.lens[256] === 0) {
                            strm.msg = 'invalid code -- missing end-of-block';
                            state.mode = BAD;
                            break;
                        }
                        
                        /* build code tables -- note: do not change the lenbits or distbits
                         values here (9 and 6) without reading the comments in inftrees.h
                         concerning the ENOUGH constants, which depend on those values */
                        state.lenbits = 9;
                        
                        opts = {bits: state.lenbits};
                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                        // We have separate tables & no pointers. 2 commented lines below not needed.
                        // state.next_index = opts.table_index;
                        state.lenbits = opts.bits;
                        // state.lencode = state.next;
                        
                        if (ret) {
                            strm.msg = 'invalid literal/lengths set';
                            state.mode = BAD;
                            break;
                        }
                        
                        state.distbits = 6;
                        //state.distcode.copy(state.codes);
                        // Switch to use dynamic table
                        state.distcode = state.distdyn;
                        opts = {bits: state.distbits};
                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                        // We have separate tables & no pointers. 2 commented lines below not needed.
                        // state.next_index = opts.table_index;
                        state.distbits = opts.bits;
                        // state.distcode = state.next;
                        
                        if (ret) {
                            strm.msg = 'invalid distances set';
                            state.mode = BAD;
                            break;
                        }
                        //Tracev((stderr, 'inflate:       codes ok\n'));
                        state.mode = LEN_;
                        if (flush === Z_TREES) { break inf_leave; }
                    /* falls through */
                    case LEN_:
                        state.mode = LEN;
                    /* falls through */
                    case LEN:
                        if (have >= 6 && left >= 258) {
                            //--- RESTORE() ---
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            //---
                            inflate_fast(strm, _out);
                            //--- LOAD() ---
                            put = strm.next_out;
                            output = strm.output;
                            left = strm.avail_out;
                            next = strm.next_in;
                            input = strm.input;
                            have = strm.avail_in;
                            hold = state.hold;
                            bits = state.bits;
                            //---
                            
                            if (state.mode === TYPE) {
                                state.back = -1;
                            }
                            break;
                        }
                        state.back = 0;
                        for (;;) {
                            here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/
                            here_bits = here >>> 24;
                            here_op = (here >>> 16) & 0xff;
                            here_val = here & 0xffff;
                            
                            if (here_bits <= bits) { break; }
                            //--- PULLBYTE() ---//
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                            //---//
                        }
                        if (here_op && (here_op & 0xf0) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (;;) {
                                here = state.lencode[last_val +
                                ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;
                                
                                if ((last_bits + here_bits) <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            //--- DROPBITS(last.bits) ---//
                            hold >>>= last_bits;
                            bits -= last_bits;
                            //---//
                            state.back += last_bits;
                        }
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits;
                        bits -= here_bits;
                        //---//
                        state.back += here_bits;
                        state.length = here_val;
                        if (here_op === 0) {
                            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                            //        "inflate:         literal '%c'\n" :
                            //        "inflate:         literal 0x%02x\n", here.val));
                            state.mode = LIT;
                            break;
                        }
                        if (here_op & 32) {
                            //Tracevv((stderr, "inflate:         end of block\n"));
                            state.back = -1;
                            state.mode = TYPE;
                            break;
                        }
                        if (here_op & 64) {
                            strm.msg = 'invalid literal/length code';
                            state.mode = BAD;
                            break;
                        }
                        state.extra = here_op & 15;
                        state.mode = LENEXT;
                    /* falls through */
                    case LENEXT:
                        if (state.extra) {
                            //=== NEEDBITS(state.extra);
                            n = state.extra;
                            while (bits < n) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
                            //--- DROPBITS(state.extra) ---//
                            hold >>>= state.extra;
                            bits -= state.extra;
                            //---//
                            state.back += state.extra;
                        }
                        //Tracevv((stderr, "inflate:         length %u\n", state.length));
                        state.was = state.length;
                        state.mode = DIST;
                    /* falls through */
                    case DIST:
                        for (;;) {
                            here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/
                            here_bits = here >>> 24;
                            here_op = (here >>> 16) & 0xff;
                            here_val = here & 0xffff;
                            
                            if ((here_bits) <= bits) { break; }
                            //--- PULLBYTE() ---//
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                            //---//
                        }
                        if ((here_op & 0xf0) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (;;) {
                                here = state.distcode[last_val +
                                ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;
                                
                                if ((last_bits + here_bits) <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            //--- DROPBITS(last.bits) ---//
                            hold >>>= last_bits;
                            bits -= last_bits;
                            //---//
                            state.back += last_bits;
                        }
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits;
                        bits -= here_bits;
                        //---//
                        state.back += here_bits;
                        if (here_op & 64) {
                            strm.msg = 'invalid distance code';
                            state.mode = BAD;
                            break;
                        }
                        state.offset = here_val;
                        state.extra = (here_op) & 15;
                        state.mode = DISTEXT;
                    /* falls through */
                    case DISTEXT:
                        if (state.extra) {
                            //=== NEEDBITS(state.extra);
                            n = state.extra;
                            while (bits < n) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
                            //--- DROPBITS(state.extra) ---//
                            hold >>>= state.extra;
                            bits -= state.extra;
                            //---//
                            state.back += state.extra;
                        }
                        //#ifdef INFLATE_STRICT
                        if (state.offset > state.dmax) {
                            strm.msg = 'invalid distance too far back';
                            state.mode = BAD;
                            break;
                        }
                        //#endif
                        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
                        state.mode = MATCH;
                    /* falls through */
                    case MATCH:
                        if (left === 0) { break inf_leave; }
                        copy = _out - left;
                        if (state.offset > copy) {         /* copy from window */
                            copy = state.offset - copy;
                            if (copy > state.whave) {
                                if (state.sane) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD;
                                    break;
                                }
                                // (!) This block is disabled in zlib defailts,
                                // don't enable it for binary compatibility
                                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                //          Trace((stderr, "inflate.c too far\n"));
                                //          copy -= state.whave;
                                //          if (copy > state.length) { copy = state.length; }
                                //          if (copy > left) { copy = left; }
                                //          left -= copy;
                                //          state.length -= copy;
                                //          do {
                                //            output[put++] = 0;
                                //          } while (--copy);
                                //          if (state.length === 0) { state.mode = LEN; }
                                //          break;
                                //#endif
                            }
                            if (copy > state.wnext) {
                                copy -= state.wnext;
                                from = state.wsize - copy;
                            }
                            else {
                                from = state.wnext - copy;
                            }
                            if (copy > state.length) { copy = state.length; }
                            from_source = state.window;
                        }
                        else {                              /* copy from output */
                            from_source = output;
                            from = put - state.offset;
                            copy = state.length;
                        }
                        if (copy > left) { copy = left; }
                        left -= copy;
                        state.length -= copy;
                        do {
                            output[put++] = from_source[from++];
                        } while (--copy);
                        if (state.length === 0) { state.mode = LEN; }
                        break;
                    case LIT:
                        if (left === 0) { break inf_leave; }
                        output[put++] = state.length;
                        left--;
                        state.mode = LEN;
                        break;
                    case CHECK:
                        if (state.wrap) {
                            //=== NEEDBITS(32);
                            while (bits < 32) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                // Use '|' insdead of '+' to make sure that result is signed
                                hold |= input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            _out -= left;
                            strm.total_out += _out;
                            state.total += _out;
                            if (_out) {
                                strm.adler = state.check =
                                    /*UPDATE(state.check, put - _out, _out);*/
                                    (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
                                
                            }
                            _out = left;
                            // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too
                            if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
                                strm.msg = 'incorrect data check';
                                state.mode = BAD;
                                break;
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            //Tracev((stderr, "inflate:   check matches trailer\n"));
                        }
                        state.mode = LENGTH;
                    /* falls through */
                    case LENGTH:
                        if (state.wrap && state.flags) {
                            //=== NEEDBITS(32);
                            while (bits < 32) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if (hold !== (state.total & 0xffffffff)) {
                                strm.msg = 'incorrect length check';
                                state.mode = BAD;
                                break;
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            //Tracev((stderr, "inflate:   length matches trailer\n"));
                        }
                        state.mode = DONE;
                    /* falls through */
                    case DONE:
                        ret = Z_STREAM_END;
                        break inf_leave;
                    case BAD:
                        ret = Z_DATA_ERROR;
                        break inf_leave;
                    case MEM:
                        return Z_MEM_ERROR;
                    case SYNC:
                    /* falls through */
                    default:
                        return Z_STREAM_ERROR;
                }
            }
        
        // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"
        
        /*
         Return from inflate(), updating the total counts and the check value.
         If there was no progress during the inflate() call, return a buffer
         error.  Call updatewindow() to create and/or update the window state.
         Note: a memory error from inflate() is non-recoverable.
         */
        
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        
        if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
            (state.mode < CHECK || flush !== Z_FINISH))) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                state.mode = MEM;
                return Z_MEM_ERROR;
            }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
            strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) +
            (state.mode === TYPE ? 128 : 0) +
            (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
        }
        return ret;
    }
    
    function inflateEnd(strm) {
        
        if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
            return Z_STREAM_ERROR;
        }
        
        var state = strm.state;
        if (state.window) {
            state.window = null;
        }
        strm.state = null;
        return Z_OK;
    }
    
    function inflateGetHeader(strm, head) {
        var state;
        
        /* check state */
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;
        if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }
        
        /* save header structure */
        state.head = head;
        head.done = false;
        return Z_OK;
    }
    
    
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';
    
    /* Not implemented
     exports.inflateCopy = inflateCopy;
     exports.inflateGetDictionary = inflateGetDictionary;
     exports.inflateMark = inflateMark;
     exports.inflatePrime = inflatePrime;
     exports.inflateSetDictionary = inflateSetDictionary;
     exports.inflateSync = inflateSync;
     exports.inflateSyncPoint = inflateSyncPoint;
     exports.inflateUndermine = inflateUndermine;
     */
    
},{"../utils/common":89,"./adler32":91,"./crc32":93,"./inffast":96,"./inftrees":98}],98:[function(require,module,exports){
    'use strict';
    
    
    var utils = require('../utils/common');
    
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
    
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    
    var lbase = [ /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ];
    
    var lext = [ /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
    ];
    
    var dbase = [ /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0
    ];
    
    var dext = [ /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64
    ];
    
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
    {
        var bits = opts.bits;
        //here = opts.here; /* table entry for duplication */
        
        var len = 0;               /* a code's length in bits */
        var sym = 0;               /* index of code symbols */
        var min = 0, max = 0;          /* minimum and maximum code lengths */
        var root = 0;              /* number of index bits for root table */
        var curr = 0;              /* number of index bits for current table */
        var drop = 0;              /* code bits to drop for sub-table */
        var left = 0;                   /* number of prefix codes available */
        var used = 0;              /* code entries in table used */
        var huff = 0;              /* Huffman code */
        var incr;              /* for incrementing code, index */
        var fill;              /* index for replicating entries */
        var low;               /* low bits for current root entry */
        var mask;              /* mask for low root bits */
        var next;             /* next available space in table */
        var base = null;     /* base value table to use */
        var base_index = 0;
        //  var shoextra;    /* extra bits table to use */
        var end;                    /* use base and extra for symbol > end */
        var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */
        var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */
        var extra = null;
        var extra_index = 0;
        
        var here_bits, here_op, here_val;
        
        /*
         Process a set of code lengths to create a canonical Huffman code.  The
         code lengths are lens[0..codes-1].  Each length corresponds to the
         symbols 0..codes-1.  The Huffman code is generated by first sorting the
         symbols by length from short to long, and retaining the symbol order
         for codes with equal lengths.  Then the code starts with all zero bits
         for the first code of the shortest length, and the codes are integer
         increments for the same length, and zeros are appended as the length
         increases.  For the deflate format, these bits are stored backwards
         from their more natural integer increment ordering, and so when the
         decoding tables are built in the large loop below, the integer codes
         are incremented backwards.
        
         This routine assumes, but does not check, that all of the entries in
         lens[] are in the range 0..MAXBITS.  The caller must assure this.
         1..MAXBITS is interpreted as that code length.  zero means that that
         symbol does not occur in this code.
        
         The codes are sorted by computing a count of codes for each length,
         creating from that a table of starting indices for each length in the
         sorted table, and then entering the symbols in order in the sorted
         table.  The sorted table is work[], with that space being provided by
         the caller.
        
         The length counts are used for other purposes as well, i.e. finding
         the minimum and maximum length codes, determining if there are any
         codes at all, checking for a valid set of lengths, and looking ahead
         at length counts to determine sub-table sizes when building the
         decoding tables.
         */
        
        /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
        for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
        }
        
        /* bound code lengths, force root to be within code lengths */
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) { break; }
        }
        if (root > max) {
            root = max;
        }
        if (max === 0) {                     /* no symbols to code at all */
            //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
            //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
            //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
            table[table_index++] = (1 << 24) | (64 << 16) | 0;
            
            
            //table.op[opts.table_index] = 64;
            //table.bits[opts.table_index] = 1;
            //table.val[opts.table_index++] = 0;
            table[table_index++] = (1 << 24) | (64 << 16) | 0;
            
            opts.bits = 1;
            return 0;     /* no symbols, but wait for decoding to report error */
        }
        for (min = 1; min < max; min++) {
            if (count[min] !== 0) { break; }
        }
        if (root < min) {
            root = min;
        }
        
        /* check for an over-subscribed or incomplete set of lengths */
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                return -1;
            }        /* over-subscribed */
        }
        if (left > 0 && (type === CODES || max !== 1)) {
            return -1;                      /* incomplete set */
        }
        
        /* generate offsets into symbol table for each length for sorting */
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
        }
        
        /* sort symbols by length, by symbol order within each length */
        for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
            }
        }
        
        /*
         Create and fill in decoding tables.  In this loop, the table being
         filled is at next and has curr index bits.  The code being used is huff
         with length len.  That code is converted to an index by dropping drop
         bits off of the bottom.  For codes where len is less than drop + curr,
         those top drop + curr - len bits are incremented through all values to
         fill the table with replicated entries.
        
         root is the number of index bits for the root table.  When len exceeds
         root, sub-tables are created pointed to by the root entry with an index
         of the low root bits of huff.  This is saved in low to check for when a
         new sub-table should be started.  drop is zero when the root table is
         being filled, and drop is root when sub-tables are being filled.
        
         When a new sub-table is needed, it is necessary to look ahead in the
         code lengths to determine what size sub-table is needed.  The length
         counts are used for this, and so count[] is decremented as codes are
         entered in the tables.
        
         used keeps track of how many table entries have been allocated from the
         provided *table space.  It is checked for LENS and DIST tables against
         the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
         the initial root table size constants.  See the comments in inftrees.h
         for more information.
        
         sym increments through all symbols, and the loop terminates when
         all codes of length max, i.e. all codes, have been processed.  This
         routine permits incomplete codes, so another loop after this one fills
         in the rest of the decoding tables with invalid code markers.
         */
        
        /* set up for code type */
        // poor man optimization - use if-else instead of switch,
        // to avoid deopts in old v8
        if (type === CODES) {
            base = extra = work;    /* dummy value--not used */
            end = 19;
            
        } else if (type === LENS) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;
            
        } else {                    /* DISTS */
            base = dbase;
            extra = dext;
            end = -1;
        }
        
        /* initialize opts for loop */
        huff = 0;                   /* starting code */
        sym = 0;                    /* starting code symbol */
        len = min;                  /* starting code length */
        next = table_index;              /* current table to fill in */
        curr = root;                /* current table index bits */
        drop = 0;                   /* current bits to drop from code for index */
        low = -1;                   /* trigger new sub-table when len > root */
        used = 1 << root;          /* use root table entries */
        mask = used - 1;            /* mask for comparing low */
        
        /* check available table space */
        if ((type === LENS && used > ENOUGH_LENS) ||
            (type === DISTS && used > ENOUGH_DISTS)) {
            return 1;
        }
        
        var i=0;
        /* process all codes and make table entries */
        for (;;) {
            i++;
            /* create table entry */
            here_bits = len - drop;
            if (work[sym] < end) {
                here_op = 0;
                here_val = work[sym];
            }
            else if (work[sym] > end) {
                here_op = extra[extra_index + work[sym]];
                here_val = base[base_index + work[sym]];
            }
            else {
                here_op = 32 + 64;         /* end of block */
                here_val = 0;
            }
            
            /* replicate for those indices with low len bits equal to huff */
            incr = 1 << (len - drop);
            fill = 1 << curr;
            min = fill;                 /* save offset to next table */
            do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
            } while (fill !== 0);
            
            /* backwards increment the len-bit code huff */
            incr = 1 << (len - 1);
            while (huff & incr) {
                incr >>= 1;
            }
            if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
            } else {
                huff = 0;
            }
            
            /* go to next symbol, update count, len */
            sym++;
            if (--count[len] === 0) {
                if (len === max) { break; }
                len = lens[lens_index + work[sym]];
            }
            
            /* create new sub-table if needed */
            if (len > root && (huff & mask) !== low) {
                /* if first time, transition to sub-tables */
                if (drop === 0) {
                    drop = root;
                }
                
                /* increment past last table */
                next += min;            /* here min is 1 << curr */
                
                /* determine length of next table */
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                    left -= count[curr + drop];
                    if (left <= 0) { break; }
                    curr++;
                    left <<= 1;
                }
                
                /* check for enough space */
                used += 1 << curr;
                if ((type === LENS && used > ENOUGH_LENS) ||
                    (type === DISTS && used > ENOUGH_DISTS)) {
                    return 1;
                }
                
                /* point entry in root table to sub-table */
                low = huff & mask;
                /*table.op[low] = curr;
                 table.bits[low] = root;
                 table.val[low] = next - opts.table_index;*/
                table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
            }
        }
        
        /* fill in remaining table entry if code is incomplete (guaranteed to have
         at most one remaining entry, since if the code is incomplete, the
         maximum code length that was allowed to get this far is one bit) */
        if (huff !== 0) {
            //table.op[next + huff] = 64;            /* invalid code marker */
            //table.bits[next + huff] = len - drop;
            //table.val[next + huff] = 0;
            table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
        }
        
        /* set return parameters */
        //opts.table_index += used;
        opts.bits = root;
        return 0;
    };
    
},{"../utils/common":89}],99:[function(require,module,exports){
    'use strict';
    
    module.exports = {
        '2':    'need dictionary',     /* Z_NEED_DICT       2  */
        '1':    'stream end',          /* Z_STREAM_END      1  */
        '0':    '',                    /* Z_OK              0  */
        '-1':   'file error',          /* Z_ERRNO         (-1) */
        '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
        '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
        '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
        '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
        '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
    };
    
},{}],100:[function(require,module,exports){
    'use strict';
    
    
    var utils = require('../utils/common');
    
    /* Public constants ==========================================================*/
    /* ===========================================================================*/
    
    
    //var Z_FILTERED          = 1;
    //var Z_HUFFMAN_ONLY      = 2;
    //var Z_RLE               = 3;
    var Z_FIXED               = 4;
    //var Z_DEFAULT_STRATEGY  = 0;
    
    /* Possible values of the data_type field (though see inflate()) */
    var Z_BINARY              = 0;
    var Z_TEXT                = 1;
    //var Z_ASCII             = 1; // = Z_TEXT
    var Z_UNKNOWN             = 2;
    
    /*============================================================================*/
    
    
    function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
    
    // From zutil.h
    
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES    = 2;
    /* The three kinds of block type */
    
    var MIN_MATCH    = 3;
    var MAX_MATCH    = 258;
    /* The minimum and maximum match lengths */
    
    // From deflate.h
    /* ===========================================================================
     * Internal compression state.
     */
    
    var LENGTH_CODES  = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    
    var LITERALS      = 256;
    /* number of literal bytes 0..255 */
    
    var L_CODES       = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */
    
    var D_CODES       = 30;
    /* number of distance codes */
    
    var BL_CODES      = 19;
    /* number of codes used to transfer the bit lengths */
    
    var HEAP_SIZE     = 2*L_CODES + 1;
    /* maximum heap size */
    
    var MAX_BITS      = 15;
    /* All codes must not exceed MAX_BITS bits */
    
    var Buf_size      = 16;
    /* size of bit buffer in bi_buf */
    
    
    /* ===========================================================================
     * Constants
     */
    
    var MAX_BL_BITS = 7;
    /* Bit length codes must not exceed MAX_BL_BITS bits */
    
    var END_BLOCK   = 256;
    /* end of block literal code */
    
    var REP_3_6     = 16;
    /* repeat previous bit length 3-6 times (2 bits of repeat count) */
    
    var REPZ_3_10   = 17;
    /* repeat a zero length 3-10 times  (3 bits of repeat count) */
    
    var REPZ_11_138 = 18;
    /* repeat a zero length 11-138 times  (7 bits of repeat count) */
    
    var extra_lbits =   /* extra bits for each length code */
        [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
    
    var extra_dbits =   /* extra bits for each distance code */
        [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
    
    var extra_blbits =  /* extra bits for each bit length code */
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
    
    var bl_order =
        [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
    /* The lengths of the bit length codes are sent in order of decreasing
     * probability, to avoid transmitting the lengths for unused bit length codes.
     */
    
    /* ===========================================================================
     * Local data. These are initialized only once.
     */
    
    // We pre-fill arrays with 0 to avoid uninitialized gaps
    
    var DIST_CODE_LEN = 512; /* see definition of array dist_code below */
    
    // !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
    var static_ltree  = new Array((L_CODES+2) * 2);
    zero(static_ltree);
    /* The static literal tree. Since the bit lengths are imposed, there is no
     * need for the L_CODES extra codes used during heap construction. However
     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
     * below).
     */
    
    var static_dtree  = new Array(D_CODES * 2);
    zero(static_dtree);
    /* The static distance tree. (Actually a trivial tree since all codes use
     * 5 bits.)
     */
    
    var _dist_code    = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    /* Distance codes. The first 256 values correspond to the distances
     * 3 .. 258, the last 256 values correspond to the top 8 bits of
     * the 15 bit distances.
     */
    
    var _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);
    zero(_length_code);
    /* length code for each normalized match length (0 == MIN_MATCH) */
    
    var base_length   = new Array(LENGTH_CODES);
    zero(base_length);
    /* First normalized length for each code (0 = MIN_MATCH) */
    
    var base_dist     = new Array(D_CODES);
    zero(base_dist);
    /* First normalized distance for each code (0 = distance of 1) */
    
    
    var StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {
        
        this.static_tree  = static_tree;  /* static tree or NULL */
        this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
        this.extra_base   = extra_base;   /* base index for extra_bits */
        this.elems        = elems;        /* max number of elements in the tree */
        this.max_length   = max_length;   /* max bit length for the codes */
        
        // show if `static_tree` has data or dummy - needed for monomorphic objects
        this.has_stree    = static_tree && static_tree.length;
    };
    
    
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    
    
    var TreeDesc = function(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;     /* the dynamic tree */
        this.max_code = 0;            /* largest code with non zero frequency */
        this.stat_desc = stat_desc;   /* the corresponding static tree */
    };
    
    
    
    function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    
    
    /* ===========================================================================
     * Output a short LSB first on the stream.
     * IN assertion: there is enough room in pendingBuf.
     */
    function put_short (s, w) {
        //    put_byte(s, (uch)((w) & 0xff));
        //    put_byte(s, (uch)((ush)(w) >> 8));
        s.pending_buf[s.pending++] = (w) & 0xff;
        s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    }
    
    
    /* ===========================================================================
     * Send a value on a given number of bits.
     * IN assertion: length <= 16 and value fits in length bits.
     */
    function send_bits(s, value, length) {
        if (s.bi_valid > (Buf_size - length)) {
            s.bi_buf |= (value << s.bi_valid) & 0xffff;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> (Buf_size - s.bi_valid);
            s.bi_valid += length - Buf_size;
        } else {
            s.bi_buf |= (value << s.bi_valid) & 0xffff;
            s.bi_valid += length;
        }
    }
    
    
    function send_code(s, c, tree) {
        send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);
    }
    
    
    /* ===========================================================================
     * Reverse the first len bits of a code, using straightforward code (a faster
     * method would use a table)
     * IN assertion: 1 <= len <= 15
     */
    function bi_reverse(code, len) {
        var res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        } while (--len > 0);
        return res >>> 1;
    }
    
    
    /* ===========================================================================
     * Flush the bit buffer, keeping at most 7 bits in it.
     */
    function bi_flush(s) {
        if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
            
        } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 0xff;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
        }
    }
    
    
    /* ===========================================================================
     * Compute the optimal bit lengths for a tree and update the total bit length
     * for the current block.
     * IN assertion: the fields freq and dad are set, heap[heap_max] and
     *    above are the tree nodes sorted by increasing frequency.
     * OUT assertions: the field len is set to the optimal bit length, the
     *     array bl_count contains the frequencies for each bit length.
     *     The length opt_len is updated; static_len is also updated if stree is
     *     not null.
     */
    function gen_bitlen(s, desc)
    //    deflate_state *s;
    //    tree_desc *desc;    /* the tree descriptor */
    {
        var tree            = desc.dyn_tree;
        var max_code        = desc.max_code;
        var stree           = desc.stat_desc.static_tree;
        var has_stree       = desc.stat_desc.has_stree;
        var extra           = desc.stat_desc.extra_bits;
        var base            = desc.stat_desc.extra_base;
        var max_length      = desc.stat_desc.max_length;
        var h;              /* heap index */
        var n, m;           /* iterate over the tree elements */
        var bits;           /* bit length */
        var xbits;          /* extra bits */
        var f;              /* frequency */
        var overflow = 0;   /* number of elements with bit length too large */
        
        for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
        }
        
        /* In a first pass, compute the optimal bit lengths (which may
         * overflow in the case of the bit length tree).
         */
        tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */
        
        for (h = s.heap_max+1; h < HEAP_SIZE; h++) {
            n = s.heap[h];
            bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n*2 + 1]/*.Len*/ = bits;
            /* We overwrite tree[n].Dad which is no longer needed */
            
            if (n > max_code) { continue; } /* not a leaf node */
            
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
                xbits = extra[n-base];
            }
            f = tree[n * 2]/*.Freq*/;
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
                s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);
            }
        }
        if (overflow === 0) { return; }
        
        // Trace((stderr,"\nbit length overflow\n"));
        /* This happens for example on obj2 and pic of the Calgary corpus */
        
        /* Find the first bit length which could increase: */
        do {
            bits = max_length-1;
            while (s.bl_count[bits] === 0) { bits--; }
            s.bl_count[bits]--;      /* move one leaf down the tree */
            s.bl_count[bits+1] += 2; /* move one overflow item as its brother */
            s.bl_count[max_length]--;
            /* The brother of the overflow item also moves one step up,
             * but this does not affect bl_count[max_length]
             */
            overflow -= 2;
        } while (overflow > 0);
        
        /* Now recompute all bit lengths, scanning in increasing frequency.
         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
         * lengths instead of fixing only the wrong ones. This idea is taken
         * from 'ar' written by Haruhiko Okumura.)
         */
        for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
                m = s.heap[--h];
                if (m > max_code) { continue; }
                if (tree[m*2 + 1]/*.Len*/ !== bits) {
                    // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                    s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;
                    tree[m*2 + 1]/*.Len*/ = bits;
                }
                n--;
            }
        }
    }
    
    
    /* ===========================================================================
     * Generate the codes for a given tree and bit counts (which need not be
     * optimal).
     * IN assertion: the array bl_count contains the bit length statistics for
     * the given tree and the field len is set for all tree elements.
     * OUT assertion: the field code is set for all tree elements of non
     *     zero code length.
     */
    function gen_codes(tree, max_code, bl_count)
    //    ct_data *tree;             /* the tree to decorate */
    //    int max_code;              /* largest code with non zero frequency */
    //    ushf *bl_count;            /* number of codes at each bit length */
    {
        var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */
        var code = 0;              /* running code value */
        var bits;                  /* bit index */
        var n;                     /* code index */
        
        /* The distribution counts are first used to generate the code values
         * without bit reversal.
         */
        for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = (code + bl_count[bits-1]) << 1;
        }
        /* Check that the bit counts in bl_count are consistent. The last code
         * must be all ones.
         */
        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        //        "inconsistent bit counts");
        //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
        
        for (n = 0;  n <= max_code; n++) {
            var len = tree[n*2 + 1]/*.Len*/;
            if (len === 0) { continue; }
            /* Now reverse the bits */
            tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);
            
            //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
            //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        }
    }
    
    
    /* ===========================================================================
     * Initialize the various 'constant' tables.
     */
    function tr_static_init() {
        var n;        /* iterates over tree elements */
        var bits;     /* bit counter */
        var length;   /* length value */
        var code;     /* code value */
        var dist;     /* distance index */
        var bl_count = new Array(MAX_BITS+1);
        /* number of codes at each bit length for an optimal tree */
        
        // do check in _tr_init()
        //if (static_init_done) return;
        
        /* For some embedded targets, global variables are not initialized: */
        /*#ifdef NO_INIT_GLOBAL_POINTERS
         static_l_desc.static_tree = static_ltree;
         static_l_desc.extra_bits = extra_lbits;
         static_d_desc.static_tree = static_dtree;
         static_d_desc.extra_bits = extra_dbits;
         static_bl_desc.extra_bits = extra_blbits;
         #endif*/
        
        /* Initialize the mapping length (0..255) -> length code (0..28) */
        length = 0;
        for (code = 0; code < LENGTH_CODES-1; code++) {
            base_length[code] = length;
            for (n = 0; n < (1<<extra_lbits[code]); n++) {
                _length_code[length++] = code;
            }
        }
        //Assert (length == 256, "tr_static_init: length != 256");
        /* Note that the length 255 (match length 258) can be represented
         * in two different ways: code 284 + 5 bits or code 285, so we
         * overwrite length_code[255] to use the best encoding:
         */
        _length_code[length-1] = code;
        
        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
        dist = 0;
        for (code = 0 ; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < (1<<extra_dbits[code]); n++) {
                _dist_code[dist++] = code;
            }
        }
        //Assert (dist == 256, "tr_static_init: dist != 256");
        dist >>= 7; /* from now on, all distances are divided by 128 */
        for (; code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
                _dist_code[256 + dist++] = code;
            }
        }
        //Assert (dist == 256, "tr_static_init: 256+dist != 512");
        
        /* Construct the codes of the static literal tree */
        for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
        }
        
        n = 0;
        while (n <= 143) {
            static_ltree[n*2 + 1]/*.Len*/ = 8;
            n++;
            bl_count[8]++;
        }
        while (n <= 255) {
            static_ltree[n*2 + 1]/*.Len*/ = 9;
            n++;
            bl_count[9]++;
        }
        while (n <= 279) {
            static_ltree[n*2 + 1]/*.Len*/ = 7;
            n++;
            bl_count[7]++;
        }
        while (n <= 287) {
            static_ltree[n*2 + 1]/*.Len*/ = 8;
            n++;
            bl_count[8]++;
        }
        /* Codes 286 and 287 do not exist, but we must include them in the
         * tree construction to get a canonical Huffman tree (longest code
         * all ones)
         */
        gen_codes(static_ltree, L_CODES+1, bl_count);
        
        /* The static distance tree is trivial: */
        for (n = 0; n < D_CODES; n++) {
            static_dtree[n*2 + 1]/*.Len*/ = 5;
            static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);
        }
        
        // Now data ready and we can init static trees
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
        static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);
        
        //static_init_done = true;
    }
    
    
    /* ===========================================================================
     * Initialize a new block.
     */
    function init_block(s) {
        var n; /* iterates over tree elements */
        
        /* Initialize the trees. */
        for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }
        for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }
        for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }
        
        s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
    }
    
    
    /* ===========================================================================
     * Flush the bit buffer and align the output on a byte boundary
     */
    function bi_windup(s)
    {
        if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
            //put_byte(s, (Byte)s->bi_buf);
            s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
    }
    
    /* ===========================================================================
     * Copy a stored block, storing first the length and its
     * one's complement if requested.
     */
    function copy_block(s, buf, len, header)
    //DeflateState *s;
    //charf    *buf;    /* the input data */
    //unsigned len;     /* its length */
    //int      header;  /* true if block header must be written */
    {
        bi_windup(s);        /* align on byte boundary */
        
        if (header) {
            put_short(s, len);
            put_short(s, ~len);
        }
        //  while (len--) {
        //    put_byte(s, *buf++);
        //  }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
    }
    
    /* ===========================================================================
     * Compares to subtrees, using the tree depth as tie breaker when
     * the subtrees have equal frequency. This minimizes the worst case length.
     */
    function smaller(tree, n, m, depth) {
        var _n2 = n*2;
        var _m2 = m*2;
        return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
        (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
    }
    
    /* ===========================================================================
     * Restore the heap property by moving down the tree starting at node k,
     * exchanging a node with the smallest of its two sons if necessary, stopping
     * when the heap property is re-established (each father smaller than its
     * two sons).
     */
    function pqdownheap(s, tree, k)
    //    deflate_state *s;
    //    ct_data *tree;  /* the tree to restore */
    //    int k;               /* node to move down */
    {
        var v = s.heap[k];
        var j = k << 1;  /* left son of k */
        while (j <= s.heap_len) {
            /* Set j to the smallest of the two sons: */
            if (j < s.heap_len &&
                smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {
                j++;
            }
            /* Exit if v is smaller than both sons */
            if (smaller(tree, v, s.heap[j], s.depth)) { break; }
            
            /* Exchange v with the smallest son */
            s.heap[k] = s.heap[j];
            k = j;
            
            /* And continue down the tree, setting j to the left son of k */
            j <<= 1;
        }
        s.heap[k] = v;
    }
    
    
    // inlined manually
    // var SMALLEST = 1;
    
    /* ===========================================================================
     * Send the block data compressed using the given Huffman trees
     */
    function compress_block(s, ltree, dtree)
    //    deflate_state *s;
    //    const ct_data *ltree; /* literal tree */
    //    const ct_data *dtree; /* distance tree */
    {
        var dist;           /* distance of matched string */
        var lc;             /* match length or unmatched char (if dist == 0) */
        var lx = 0;         /* running index in l_buf */
        var code;           /* the code to send */
        var extra;          /* number of extra bits to send */
        
        if (s.last_lit !== 0) {
            do {
                dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);
                lc = s.pending_buf[s.l_buf + lx];
                lx++;
                
                if (dist === 0) {
                    send_code(s, lc, ltree); /* send a literal byte */
                    //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                } else {
                    /* Here, lc is the match length - MIN_MATCH */
                    code = _length_code[lc];
                    send_code(s, code+LITERALS+1, ltree); /* send the length code */
                    extra = extra_lbits[code];
                    if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);       /* send the extra length bits */
                    }
                    dist--; /* dist is now the match distance - 1 */
                    code = d_code(dist);
                    //Assert (code < D_CODES, "bad d_code");
                    
                    send_code(s, code, dtree);       /* send the distance code */
                    extra = extra_dbits[code];
                    if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);   /* send the extra distance bits */
                    }
                } /* literal or match pair ? */
                
                /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                //       "pendingBuf overflow");
                
            } while (lx < s.last_lit);
        }
        
        send_code(s, END_BLOCK, ltree);
    }
    
    
    /* ===========================================================================
     * Construct one Huffman tree and assigns the code bit strings and lengths.
     * Update the total bit length for the current block.
     * IN assertion: the field freq is set for all tree elements.
     * OUT assertions: the fields len and code are set to the optimal bit length
     *     and corresponding code. The length opt_len is updated; static_len is
     *     also updated if stree is not null. The field max_code is set.
     */
    function build_tree(s, desc)
    //    deflate_state *s;
    //    tree_desc *desc; /* the tree descriptor */
    {
        var tree     = desc.dyn_tree;
        var stree    = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems    = desc.stat_desc.elems;
        var n, m;          /* iterate over heap elements */
        var max_code = -1; /* largest code with non zero frequency */
        var node;          /* new node being created */
        
        /* Construct the initial heap, with least frequent element in
         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
         * heap[0] is not used.
         */
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        
        for (n = 0; n < elems; n++) {
            if (tree[n * 2]/*.Freq*/ !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
                
            } else {
                tree[n*2 + 1]/*.Len*/ = 0;
            }
        }
        
        /* The pkzip format requires that at least one distance code exists,
         * and that at least one bit should be sent even if there is only one
         * possible code. So to avoid special checks later on we force at least
         * two codes of non zero frequency.
         */
        while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
            tree[node * 2]/*.Freq*/ = 1;
            s.depth[node] = 0;
            s.opt_len--;
            
            if (has_stree) {
                s.static_len -= stree[node*2 + 1]/*.Len*/;
            }
            /* node is 0 or 1 so it does not have extra bits */
        }
        desc.max_code = max_code;
        
        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
         * establish sub-heaps of increasing lengths:
         */
        for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }
        
        /* Construct the Huffman tree by repeatedly combining the least two
         * frequent nodes.
         */
        node = elems;              /* next internal node of the tree */
        do {
            //pqremove(s, tree, n);  /* n = node of least frequency */
            /*** pqremove ***/
            n = s.heap[1/*SMALLEST*/];
            s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1/*SMALLEST*/);
            /***/
            
            m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */
            
            s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
            s.heap[--s.heap_max] = m;
            
            /* Create a new node father of n and m */
            tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;
            
            /* and insert the new node in the heap */
            s.heap[1/*SMALLEST*/] = node++;
            pqdownheap(s, tree, 1/*SMALLEST*/);
            
        } while (s.heap_len >= 2);
        
        s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];
        
        /* At this point, the fields freq and dad are set. We can now
         * generate the bit lengths.
         */
        gen_bitlen(s, desc);
        
        /* The field len is now set, we can generate the bit codes */
        gen_codes(tree, max_code, s.bl_count);
    }
    
    
    /* ===========================================================================
     * Scan a literal or distance tree to determine the frequencies of the codes
     * in the bit length tree.
     */
    function scan_tree(s, tree, max_code)
    //    deflate_state *s;
    //    ct_data *tree;   /* the tree to be scanned */
    //    int max_code;    /* and its largest code of non zero frequency */
    {
        var n;                     /* iterates over all tree elements */
        var prevlen = -1;          /* last emitted length */
        var curlen;                /* length of current code */
        
        var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */
        
        var count = 0;             /* repeat count of the current code */
        var max_count = 7;         /* max repeat count */
        var min_count = 4;         /* min repeat count */
        
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */
        
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n+1)*2 + 1]/*.Len*/;
            
            if (++count < max_count && curlen === nextlen) {
                continue;
                
            } else if (count < min_count) {
                s.bl_tree[curlen * 2]/*.Freq*/ += count;
                
            } else if (curlen !== 0) {
                
                if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
                s.bl_tree[REP_3_6*2]/*.Freq*/++;
                
            } else if (count <= 10) {
                s.bl_tree[REPZ_3_10*2]/*.Freq*/++;
                
            } else {
                s.bl_tree[REPZ_11_138*2]/*.Freq*/++;
            }
            
            count = 0;
            prevlen = curlen;
            
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
                
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
                
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    
    
    /* ===========================================================================
     * Send a literal or distance tree in compressed form, using the codes in
     * bl_tree.
     */
    function send_tree(s, tree, max_code)
    //    deflate_state *s;
    //    ct_data *tree; /* the tree to be scanned */
    //    int max_code;       /* and its largest code of non zero frequency */
    {
        var n;                     /* iterates over all tree elements */
        var prevlen = -1;          /* last emitted length */
        var curlen;                /* length of current code */
        
        var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */
        
        var count = 0;             /* repeat count of the current code */
        var max_count = 7;         /* max repeat count */
        var min_count = 4;         /* min repeat count */
        
        /* tree[max_code+1].Len = -1; */  /* guard already set */
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n+1)*2 + 1]/*.Len*/;
            
            if (++count < max_count && curlen === nextlen) {
                continue;
                
            } else if (count < min_count) {
                do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);
                
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    send_code(s, curlen, s.bl_tree);
                    count--;
                }
                //Assert(count >= 3 && count <= 6, " 3_6?");
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count-3, 2);
                
            } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count-3, 3);
                
            } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count-11, 7);
            }
            
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
                
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
                
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    
    
    /* ===========================================================================
     * Construct the Huffman tree for the bit lengths and return the index in
     * bl_order of the last bit length code to send.
     */
    function build_bl_tree(s) {
        var max_blindex;  /* index of last bit length code of non zero freq */
        
        /* Determine the bit length frequencies for literal and distance trees */
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        
        /* Build the bit length tree: */
        build_tree(s, s.bl_desc);
        /* opt_len now includes the length of the tree representations, except
         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
         */
        
        /* Determine the number of bit length codes to send. The pkzip format
         * requires that at least 4 bit length codes be sent. (appnote.txt says
         * 3 but the actual value used is 4.)
         */
        for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {
                break;
            }
        }
        /* Update opt_len to include the bit length tree and counts */
        s.opt_len += 3*(max_blindex+1) + 5+5+4;
        //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
        //        s->opt_len, s->static_len));
        
        return max_blindex;
    }
    
    
    /* ===========================================================================
     * Send the header for a block using dynamic Huffman trees: the counts, the
     * lengths of the bit length codes, the literal tree and the distance tree.
     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
     */
    function send_all_trees(s, lcodes, dcodes, blcodes)
    //    deflate_state *s;
    //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
    {
        var rank;                    /* index in bl_order */
        
        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        //        "too many codes");
        //Tracev((stderr, "\nbl counts: "));
        send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
        send_bits(s, dcodes-1,   5);
        send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
        for (rank = 0; rank < blcodes; rank++) {
            //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
            send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);
        }
        //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
        
        send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */
        //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
        
        send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */
        //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
    }
    
    
    /* ===========================================================================
     * Check if the data type is TEXT or BINARY, using the following algorithm:
     * - TEXT if the two conditions below are satisfied:
     *    a) There are no non-portable control characters belonging to the
     *       "black list" (0..6, 14..25, 28..31).
     *    b) There is at least one printable character belonging to the
     *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
     * - BINARY otherwise.
     * - The following partially-portable control characters form a
     *   "gray list" that is ignored in this detection algorithm:
     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
     * IN assertion: the fields Freq of dyn_ltree are set.
     */
    function detect_data_type(s) {
        /* black_mask is the bit mask of black-listed bytes
         * set bits 0..6, 14..25, and 28..31
         * 0xf3ffc07f = binary 11110011111111111100000001111111
         */
        var black_mask = 0xf3ffc07f;
        var n;
        
        /* Check for non-textual ("black-listed") bytes. */
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {
                return Z_BINARY;
            }
        }
        
        /* Check for textual ("white-listed") bytes. */
        if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
            s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
            return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
                return Z_TEXT;
            }
        }
        
        /* There are no "black-listed" or "white-listed" bytes:
         * this stream either is empty or has tolerated ("gray-listed") bytes only.
         */
        return Z_BINARY;
    }
    
    
    var static_init_done = false;
    
    /* ===========================================================================
     * Initialize the tree data structures for a new zlib stream.
     */
    function _tr_init(s)
    {
        
        if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
        }
        
        s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        
        s.bi_buf = 0;
        s.bi_valid = 0;
        
        /* Initialize the first block of the first file: */
        init_block(s);
    }
    
    
    /* ===========================================================================
     * Send a stored block
     */
    function _tr_stored_block(s, buf, stored_len, last)
    //DeflateState *s;
    //charf *buf;       /* input block */
    //ulg stored_len;   /* length of input block */
    //int last;         /* one if this is the last block for a file */
    {
        send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */
        copy_block(s, buf, stored_len, true); /* with header */
    }
    
    
    /* ===========================================================================
     * Send one empty static block to give enough lookahead for inflate.
     * This takes 10 bits, of which 7 may remain in the bit buffer.
     */
    function _tr_align(s) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
    }
    
    
    /* ===========================================================================
     * Determine the best encoding for the current block: dynamic trees, static
     * trees or store, and output the encoded block to the zip file.
     */
    function _tr_flush_block(s, buf, stored_len, last)
    //DeflateState *s;
    //charf *buf;       /* input block, or NULL if too old */
    //ulg stored_len;   /* length of input block */
    //int last;         /* one if this is the last block for a file */
    {
        var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
        var max_blindex = 0;        /* index of last bit length code of non zero freq */
        
        /* Build the Huffman trees unless a stored block is forced */
        if (s.level > 0) {
            
            /* Check if the file is binary or text */
            if (s.strm.data_type === Z_UNKNOWN) {
                s.strm.data_type = detect_data_type(s);
            }
            
            /* Construct the literal and distance trees */
            build_tree(s, s.l_desc);
            // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
            //        s->static_len));
            
            build_tree(s, s.d_desc);
            // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
            //        s->static_len));
            /* At this point, opt_len and static_len are the total bit lengths of
             * the compressed block data, excluding the tree representations.
             */
            
            /* Build the bit length tree for the above two trees, and get the index
             * in bl_order of the last bit length code to send.
             */
            max_blindex = build_bl_tree(s);
            
            /* Determine the best encoding. Compute the block lengths in bytes. */
            opt_lenb = (s.opt_len+3+7) >>> 3;
            static_lenb = (s.static_len+3+7) >>> 3;
            
            // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
            //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
            //        s->last_lit));
            
            if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }
            
        } else {
            // Assert(buf != (char*)0, "lost buf");
            opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
        }
        
        if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {
            /* 4: two words for the lengths */
            
            /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
             * Otherwise we can't have processed more than WSIZE input bytes since
             * the last block flush, because compression would have been
             * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
             * transform a block into a stored block.
             */
            _tr_stored_block(s, buf, stored_len, last);
            
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
            
            send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
            
        } else {
            send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
        /* The above check is made mod 2^32, for files larger than 512 MB
         * and uLong implemented on 32 bits.
         */
        init_block(s);
        
        if (last) {
            bi_windup(s);
        }
        // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
        //       s->compressed_len-7*last));
    }
    
    /* ===========================================================================
     * Save the match info and tally the frequency counts. Return true if
     * the current block must be flushed.
     */
    function _tr_tally(s, dist, lc)
    //    deflate_state *s;
    //    unsigned dist;  /* distance of matched string */
    //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
    {
        //var out_length, in_length, dcode;
        
        s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
        
        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
        s.last_lit++;
        
        if (dist === 0) {
            /* lc is the unmatched char */
            s.dyn_ltree[lc*2]/*.Freq*/++;
        } else {
            s.matches++;
            /* Here, lc is the match length - MIN_MATCH */
            dist--;             /* dist = match distance - 1 */
            //Assert((ush)dist < (ush)MAX_DIST(s) &&
            //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
            //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
            
            s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;
            s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
        }
        
        // (!) This block is disabled in zlib defailts,
        // don't enable it for binary compatibility
        
        //#ifdef TRUNCATE_BLOCK
        //  /* Try to guess if it is profitable to stop the current block here */
        //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
        //    /* Compute an upper bound for the compressed length */
        //    out_length = s.last_lit*8;
        //    in_length = s.strstart - s.block_start;
        //
        //    for (dcode = 0; dcode < D_CODES; dcode++) {
        //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
        //    }
        //    out_length >>>= 3;
        //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
        //    //       s->last_lit, in_length, out_length,
        //    //       100L - out_length*100L/in_length));
        //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
        //      return true;
        //    }
        //  }
        //#endif
        
        return (s.last_lit === s.lit_bufsize-1);
        /* We avoid equality with lit_bufsize because of wraparound at 64K
         * on 16 bit machines and because stored blocks are restricted to
         * 64K-1 bytes.
         */
    }
    
    exports._tr_init  = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block  = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
    
},{"../utils/common":89}],101:[function(require,module,exports){
    'use strict';
    
    
    function ZStream() {
        /* next input byte */
        this.input = null; // JS specific, because we have no pointers
        this.next_in = 0;
        /* number of bytes available at input */
        this.avail_in = 0;
        /* total number of input bytes read so far */
        this.total_in = 0;
        /* next output byte should be put there */
        this.output = null; // JS specific, because we have no pointers
        this.next_out = 0;
        /* remaining free space at output */
        this.avail_out = 0;
        /* total number of bytes output so far */
        this.total_out = 0;
        /* last error message, NULL if no error */
        this.msg = ''/*Z_NULL*/;
        /* not visible by applications */
        this.state = null;
        /* best guess about the data type: binary or text */
        this.data_type = 2/*Z_UNKNOWN*/;
        /* adler32 value of the uncompressed data */
        this.adler = 0;
    }
    
    module.exports = ZStream;
    
},{}],102:[function(require,module,exports){
    module.exports = require('./lib/retry');
},{"./lib/retry":103}],103:[function(require,module,exports){
    var RetryOperation = require('./retry_operation');
    
    exports.operation = function(options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts);
    };
    
    exports.timeouts = function(options) {
        if (options instanceof Array) {
            return [].concat(options);
        }
        
        var opts = {
            retries: 10,
            factor: 2,
            minTimeout: 1 * 1000,
            maxTimeout: Infinity,
            randomize: false
        };
        for (var key in options) {
            opts[key] = options[key];
        }
        
        if (opts.minTimeout > opts.maxTimeout) {
            throw new Error('minTimeout is greater than maxTimeout');
        }
        
        var timeouts = [];
        for (var i = 0; i < opts.retries; i++) {
            timeouts.push(this._createTimeout(i, opts));
        }
        
        // sort the array numerically ascending
        timeouts.sort(function(a,b) {
            return a - b;
        });
        
        return timeouts;
    };
    
    exports._createTimeout = function(attempt, opts) {
        var random = (opts.randomize)
            ? (Math.random() + 1)
            : 1;
        
        var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
        timeout = Math.min(timeout, opts.maxTimeout);
        
        return timeout;
    };
},{"./retry_operation":104}],104:[function(require,module,exports){
    function RetryOperation(timeouts) {
        this._timeouts = timeouts;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
    }
    module.exports = RetryOperation;
    
    RetryOperation.prototype.retry = function(err) {
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        
        if (!err) {
            return false;
        }
        
        this._errors.push(err);
        
        var timeout = this._timeouts.shift();
        if (timeout === undefined) {
            return false;
        }
        
        this._attempts++;
        
        var self = this;
        setTimeout(function() {
            self._fn(self._attempts);
            
            if (self._operationTimeoutCb) {
                self._timeout = setTimeout(function() {
                    self._operationTimeoutCb(self._attempts);
                }, self._operationTimeout);
            }
        }, timeout);
        
        return true;
    };
    
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
        this._fn = fn;
        
        if (timeoutOps) {
            if (timeoutOps.timeout) {
                this._operationTimeout = timeoutOps.timeout;
            }
            if (timeoutOps.cb) {
                this._operationTimeoutCb = timeoutOps.cb;
            }
        }
        
        this._fn(this._attempts);
        
        var self = this;
        if (this._operationTimeoutCb) {
            this._timeout = setTimeout(function() {
                self._operationTimeoutCb();
            }, self._operationTimeout);
        }
    };
    
    RetryOperation.prototype.try = function(fn) {
        console.log('Using RetryOperation.try() is deprecated');
        this.attempt(fn);
    };
    
    RetryOperation.prototype.start = function(fn) {
        console.log('Using RetryOperation.start() is deprecated');
        this.attempt(fn);
    };
    
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    
    RetryOperation.prototype.errors = function() {
        return this._errors;
    };
    
    RetryOperation.prototype.attempts = function() {
        return this._attempts;
    };
    
    RetryOperation.prototype.mainError = function() {
        if (this._errors.length === 0) {
            return null;
        }
        
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        
        for (var i = 0; i < this._errors.length; i++) {
            var error = this._errors[i];
            var message = error.message;
            var count = (counts[message] || 0) + 1;
            
            counts[message] = count;
            
            if (count >= mainErrorCount) {
                mainError = error;
                mainErrorCount = count;
            }
        }
        
        return mainError;
    };
},{}],105:[function(require,module,exports){
    /* Copyright @ 2015 Atlassian Pty Ltd
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    module.exports = function arrayEquals(array) {
        // if the other array is a falsy value, return
        if (!array)
            return false;
        
        // compare lengths - can save a lot of time
        if (this.length != array.length)
            return false;
        
        for (var i = 0, l = this.length; i < l; i++) {
            // Check if we have nested arrays
            if (this[i] instanceof Array && array[i] instanceof Array) {
                // recurse into the nested arrays
                if (!arrayEquals.apply(this[i], [array[i]]))
                    return false;
            } else if (this[i] != array[i]) {
                // Warning - two different object instances will never be equal:
                // {x:20} != {x:20}
                return false;
            }
        }
        return true;
    };
    
    
},{}],106:[function(require,module,exports){
    /* Copyright @ 2015 Atlassian Pty Ltd
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    exports.Interop = require('./interop');
    
},{"./interop":107}],107:[function(require,module,exports){
    /* Copyright @ 2015 Atlassian Pty Ltd
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    /* global RTCSessionDescription */
    /* jshint -W097 */
    "use strict";
    
    var transform = require('./transform');
    var arrayEquals = require('./array-equals');
    
    function Interop() {
        
        /**
         * This map holds the most recent Unified Plan offer/answer SDP that was
         * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and
         * the SDP string as values.
         *
         * @type {{}}
         */
        this.cache = {};
    }
    
    module.exports = Interop;
    
    /**
     * Returns the index of the first m-line with the given media type and with a
     * direction which allows sending, in the last Unified Plan description with
     * type "answer" converted to Plan B. Returns {null} if there is no saved
     * answer, or if none of its m-lines with the given type allow sending.
     * @param type the media type ("audio" or "video").
     * @returns {*}
     */
    Interop.prototype.getFirstSendingIndexFromAnswer = function(type) {
        if (!this.cache.answer) {
            return null;
        }
        
        var session = transform.parse(this.cache.answer);
        if (session && session.media && Array.isArray(session.media)){
            for (var i = 0; i < session.media.length; i++) {
                if (session.media[i].type == type &&
                    (!session.media[i].direction /* default to sendrecv */ ||
                    session.media[i].direction === 'sendrecv' ||
                    session.media[i].direction === 'sendonly')){
                    return i;
                }
            }
        }
        
        return null;
    };
    
    /**
     * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A
     * PeerConnection wrapper transforms the SDP to Plan B before passing it to the
     * application.
     *
     * @param desc
     * @returns {*}
     */
    Interop.prototype.toPlanB = function(desc) {
        var self = this;
        //#region Preliminary input validation.
        
        if (typeof desc !== 'object' || desc === null ||
            typeof desc.sdp !== 'string') {
            console.warn('An empty description was passed as an argument.');
            return desc;
        }
        
        // Objectify the SDP for easier manipulation.
        var session = transform.parse(desc.sdp);
        
        // If the SDP contains no media, there's nothing to transform.
        if (typeof session.media === 'undefined' ||
            !Array.isArray(session.media) || session.media.length === 0) {
            console.warn('The description has no media.');
            return desc;
        }
        
        // Try some heuristics to "make sure" this is a Unified Plan SDP. Plan B
        // SDP has a video, an audio and a data "channel" at most.
        if (session.media.length <= 3 && session.media.every(function(m) {
                return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;
            })) {
            console.warn('This description does not look like Unified Plan.');
            return desc;
        }
        
        //#endregion
        
        // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443
        var sdp = desc.sdp;
        var rewrite = false;
        for (var i = 0; i < session.media.length; i++) {
            var uLine = session.media[i];
            uLine.rtp.forEach(function(rtp) {
                if (rtp.codec === 'NULL')
                {
                    rewrite = true;
                    var offer = transform.parse(self.cache['offer']);
                    rtp.codec = offer.media[i].rtp[0].codec;
                }
            });
        };
        if (rewrite) {
            sdp = transform.write(session);
        }
        
        // Unified Plan SDP is our "precious". Cache it for later use in the Plan B
        // -> Unified Plan transformation.
        this.cache[desc.type] = sdp;
        
        //#region Convert from Unified Plan to Plan B.
        
        // We rebuild the session.media array.
        var media = session.media;
        session.media = [];
        
        // Associative array that maps channel types to channel objects for fast
        // access to channel objects by their type, e.g. type2bl['audio']->channel
        // obj.
        var type2bl = {};
        
        // Used to build the group:BUNDLE value after the channels construction
        // loop.
        var types = [];
        
        // Implode the Unified Plan m-lines/tracks into Plan B channels.
        media.forEach(function(uLine) {
            
            // rtcp-mux is required in the Plan B SDP.
            if ((typeof uLine.rtcpMux !== 'string' ||
                uLine.rtcpMux !== 'rtcp-mux') &&
                uLine.direction !== 'inactive') {
                throw new Error('Cannot convert to Plan B because m-lines ' +
                    'without the rtcp-mux attribute were found.');
            }
            
            if (uLine.type === 'application') {
                session.media.push(uLine);
                types.push(uLine.mid);
                return;
            }
            
            // If we don't have a channel for this uLine.type, then use this
            // uLine as the channel basis.
            if (typeof type2bl[uLine.type] === 'undefined') {
                type2bl[uLine.type] = uLine;
            }
            
            // Add sources to the channel and handle a=msid.
            if (typeof uLine.sources === 'object') {
                Object.keys(uLine.sources).forEach(function(ssrc) {
                    if (typeof type2bl[uLine.type].sources !== 'object')
                        type2bl[uLine.type].sources = {};
                    
                    // Assign the sources to the channel.
                    type2bl[uLine.type].sources[ssrc] =
                        uLine.sources[ssrc];
                    
                    if (typeof uLine.msid !== 'undefined') {
                        // In Plan B the msid is an SSRC attribute. Also, we don't
                        // care about the obsolete label and mslabel attributes.
                        //
                        // Note that it is not guaranteed that the uLine will
                        // have an msid. recvonly channels in particular don't have
                        // one.
                        type2bl[uLine.type].sources[ssrc].msid =
                            uLine.msid;
                    }
                    // NOTE ssrcs in ssrc groups will share msids, as
                    // draft-uberti-rtcweb-plan-00 mandates.
                });
            }
            
            // Add ssrc groups to the channel.
            if (typeof uLine.ssrcGroups !== 'undefined' &&
                Array.isArray(uLine.ssrcGroups)) {
                
                // Create the ssrcGroups array, if it's not defined.
                if (typeof type2bl[uLine.type].ssrcGroups === 'undefined' ||
                    !Array.isArray(type2bl[uLine.type].ssrcGroups)) {
                    type2bl[uLine.type].ssrcGroups = [];
                }
                
                type2bl[uLine.type].ssrcGroups =
                    type2bl[uLine.type].ssrcGroups.concat(
                        uLine.ssrcGroups);
            }
            
            if (type2bl[uLine.type] === uLine) {
                // Copy ICE related stuff from the principal media line.
                uLine.candidates = media[0].candidates;
                uLine.iceUfrag = media[0].iceUfrag;
                uLine.icePwd = media[0].icePwd;
                uLine.fingerprint = media[0].fingerprint;
                
                // Plan B mids are in ['audio', 'video', 'data']
                uLine.mid = uLine.type;
                
                // Plan B doesn't support/need the bundle-only attribute.
                delete uLine.bundleOnly;
                
                // In Plan B the msid is an SSRC attribute.
                delete uLine.msid;
                
                // Used to build the group:BUNDLE value after this loop.
                types.push(uLine.type);
                
                // Add the channel to the new media array.
                session.media.push(uLine);
            }
        });
        
        // We regenerate the BUNDLE group with the new mids.
        session.groups.some(function(group) {
            if (group.type === 'BUNDLE') {
                group.mids = types.join(' ');
                return true;
            }
        });
        
        // msid semantic
        session.msidSemantic = {
            semantic: 'WMS',
            token: '*'
        };
        
        var resStr = transform.write(session);
        
        return new RTCSessionDescription({
            type: desc.type,
            sdp: resStr
        });
        
        //#endregion
    };
    
    /**
     * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A
     * PeerConnection wrapper transforms the SDP to Unified Plan before passing it
     * to FF.
     *
     * @param desc
     * @returns {*}
     */
    Interop.prototype.toUnifiedPlan = function(desc) {
        var self = this;
        //#region Preliminary input validation.
        
        if (typeof desc !== 'object' || desc === null ||
            typeof desc.sdp !== 'string') {
            console.warn('An empty description was passed as an argument.');
            return desc;
        }
        
        var session = transform.parse(desc.sdp);
        
        // If the SDP contains no media, there's nothing to transform.
        if (typeof session.media === 'undefined' ||
            !Array.isArray(session.media) || session.media.length === 0) {
            console.warn('The description has no media.');
            return desc;
        }
        
        // Try some heuristics to "make sure" this is a Plan B SDP. Plan B SDP has
        // a video, an audio and a data "channel" at most.
        if (session.media.length > 3 || !session.media.every(function(m) {
                return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;
            })) {
            console.warn('This description does not look like Plan B.');
            return desc;
        }
        
        // Make sure this Plan B SDP can be converted to a Unified Plan SDP.
        var mids = [];
        session.media.forEach(function(m) {
            mids.push(m.mid);
        });
        
        var hasBundle = false;
        if (typeof session.groups !== 'undefined' &&
            Array.isArray(session.groups)) {
            hasBundle = session.groups.every(function(g) {
                return g.type !== 'BUNDLE' ||
                    arrayEquals.apply(g.mids.sort(), [mids.sort()]);
            });
        }
        
        if (!hasBundle) {
            throw new Error("Cannot convert to Unified Plan because m-lines that" +
                " are not bundled were found.");
        }
        
        //#endregion
        
        
        //#region Convert from Plan B to Unified Plan.
        
        // Unfortunately, a Plan B offer/answer doesn't have enough information to
        // rebuild an equivalent Unified Plan offer/answer.
        //
        // For example, if this is a local answer (in Unified Plan style) that we
        // convert to Plan B prior to handing it over to the application (the
        // PeerConnection wrapper called us, for instance, after a successful
        // createAnswer), we want to remember the m-line at which we've seen the
        // (local) SSRC. That's because when the application wants to do call the
        // SLD method, forcing us to do the inverse transformation (from Plan B to
        // Unified Plan), we need to know to which m-line to assign the (local)
        // SSRC. We also need to know all the other m-lines that the original
        // answer had and include them in the transformed answer as well.
        //
        // Another example is if this is a remote offer that we convert to Plan B
        // prior to giving it to the application, we want to remember the mid at
        // which we've seen the (remote) SSRC.
        //
        // In the iteration that follows, we use the cached Unified Plan (if it
        // exists) to assign mids to ssrcs.
        
        var cached;
        if (typeof this.cache[desc.type] !== 'undefined') {
            cached = transform.parse(this.cache[desc.type]);
        }
        
        var recvonlySsrcs = {
            audio: {},
            video: {}
        };
        
        // A helper map that sends mids to m-line objects. We use it later to
        // rebuild the Unified Plan style session.media array.
        var mid2ul = {};
        session.media.forEach(function(bLine) {
            if ((typeof bLine.rtcpMux !== 'string' ||
                bLine.rtcpMux !== 'rtcp-mux') &&
                bLine.direction !== 'inactive') {
                throw new Error("Cannot convert to Unified Plan because m-lines " +
                    "without the rtcp-mux attribute were found.");
            }
            
            if (bLine.type === 'application') {
                mid2ul[bLine.mid] = bLine;
                return;
            }
            
            // With rtcp-mux and bundle all the channels should have the same ICE
            // stuff.
            var sources = bLine.sources;
            var ssrcGroups = bLine.ssrcGroups;
            var candidates = bLine.candidates;
            var iceUfrag = bLine.iceUfrag;
            var icePwd = bLine.icePwd;
            var fingerprint = bLine.fingerprint;
            var port = bLine.port;
            
            // We'll use the "bLine" object as a prototype for each new "mLine"
            // that we create, but first we need to clean it up a bit.
            delete bLine.sources;
            delete bLine.ssrcGroups;
            delete bLine.candidates;
            delete bLine.iceUfrag;
            delete bLine.icePwd;
            delete bLine.fingerprint;
            delete bLine.port;
            delete bLine.mid;
            
            // inverted ssrc group map
            var ssrc2group = {};
            if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {
                ssrcGroups.forEach(function (ssrcGroup) {
                    
                    // TODO(gp) find out how to receive simulcast with FF. For the
                    // time being, hide it.
                    if (ssrcGroup.semantics === 'SIM') {
                        return;
                    }
                    
                    // XXX This might brake if an SSRC is in more than one group
                    // for some reason.
                    if (typeof ssrcGroup.ssrcs !== 'undefined' &&
                        Array.isArray(ssrcGroup.ssrcs)) {
                        ssrcGroup.ssrcs.forEach(function (ssrc) {
                            if (typeof ssrc2group[ssrc] === 'undefined') {
                                ssrc2group[ssrc] = [];
                            }
                            
                            ssrc2group[ssrc].push(ssrcGroup);
                        });
                    }
                });
            }
            
            // ssrc to m-line index.
            var ssrc2ml = {};
            
            if (typeof sources === 'object') {
                
                // Explode the Plan B channel sources with one m-line per source.
                Object.keys(sources).forEach(function(ssrc) {
                    
                    // The (unified) m-line for this SSRC. We either create it from
                    // scratch or, if it's a grouped SSRC, we re-use a related
                    // mline. In other words, if the source is grouped with another
                    // source, put the two together in the same m-line.
                    var uLine;
                    
                    // We assume here that we are the answerer in the O/A, so any
                    // offers which we translate come from the remote side, while
                    // answers are local. So the check below is to make that we
                    // handle receive-only SSRCs in a special way only if they come
                    // from the remote side.
                    if (desc.type==='offer') {
                        // We want to detect SSRCs which are used by a remote peer
                        // in an m-line with direction=recvonly (i.e. they are
                        // being used for RTCP only).
                        // This information would have gotten lost if the remote
                        // peer used Unified Plan and their local description was
                        // translated to Plan B. So we use the lack of an MSID
                        // attribute to deduce a "receive only" SSRC.
                        if (!sources[ssrc].msid) {
                            recvonlySsrcs[bLine.type][ssrc] = sources[ssrc];
                            // Receive-only SSRCs must not create new m-lines. We
                            // will assign them to an existing m-line later.
                            return;
                        }
                    }
                    
                    if (typeof ssrc2group[ssrc] !== 'undefined' &&
                        Array.isArray(ssrc2group[ssrc])) {
                        ssrc2group[ssrc].some(function (ssrcGroup) {
                            // ssrcGroup.ssrcs *is* an Array, no need to check
                            // again here.
                            return ssrcGroup.ssrcs.some(function (related) {
                                if (typeof ssrc2ml[related] === 'object') {
                                    uLine = ssrc2ml[related];
                                    return true;
                                }
                            });
                        });
                    }
                    
                    if (typeof uLine === 'object') {
                        // the m-line already exists. Just add the source.
                        uLine.sources[ssrc] = sources[ssrc];
                        delete sources[ssrc].msid;
                    } else {
                        // Use the "bLine" as a prototype for the "uLine".
                        uLine = Object.create(bLine);
                        ssrc2ml[ssrc] = uLine;
                        
                        if (typeof sources[ssrc].msid !== 'undefined') {
                            // Assign the msid of the source to the m-line. Note
                            // that it is not guaranteed that the source will have
                            // msid. In particular "recvonly" sources don't have an
                            // msid. Note that "recvonly" is a term only defined
                            // for m-lines.
                            uLine.msid = sources[ssrc].msid;
                            uLine.direction = 'sendrecv';
                            delete sources[ssrc].msid;
                        }
                        
                        // We assign one SSRC per media line.
                        uLine.sources = {};
                        uLine.sources[ssrc] = sources[ssrc];
                        uLine.ssrcGroups = ssrc2group[ssrc];
                        
                        // Use the cached Unified Plan SDP (if it exists) to assign
                        // SSRCs to mids.
                        if (typeof cached !== 'undefined' &&
                            typeof cached.media !== 'undefined' &&
                            Array.isArray(cached.media)) {
                            
                            cached.media.forEach(function (m) {
                                if (typeof m.sources === 'object') {
                                    Object.keys(m.sources).forEach(function (s) {
                                        if (s === ssrc) {
                                            uLine.mid = m.mid;
                                        }
                                    });
                                }
                            });
                        }
                        
                        if (typeof uLine.mid === 'undefined') {
                            
                            // If this is an SSRC that we see for the first time
                            // assign it a new mid. This is typically the case when
                            // this method is called to transform a remote
                            // description for the first time or when there is a
                            // new SSRC in the remote description because a new
                            // peer has joined the conference. Local SSRCs should
                            // have already been added to the map in the toPlanB
                            // method.
                            //
                            // Because FF generates answers in Unified Plan style,
                            // we MUST already have a cached answer with all the
                            // local SSRCs mapped to some m-line/mid.
                            
                            if (desc.type === 'answer') {
                                throw new Error("An unmapped SSRC was found.");
                            }
                            
                            uLine.mid = [bLine.type, '-', ssrc].join('');
                        }
                        
                        // Include the candidates in the 1st media line.
                        uLine.candidates = candidates;
                        uLine.iceUfrag = iceUfrag;
                        uLine.icePwd = icePwd;
                        uLine.fingerprint = fingerprint;
                        uLine.port = port;
                        
                        mid2ul[uLine.mid] = uLine;
                    }
                });
            }
        });
        
        // Rebuild the media array in the right order and add the missing mLines
        // (missing from the Plan B SDP).
        session.media = [];
        mids = []; // reuse
        
        if (desc.type === 'answer') {
            
            // The media lines in the answer must match the media lines in the
            // offer. The order is important too. Here we assume that Firefox is
            // the answerer, so we merely have to use the reconstructed (unified)
            // answer to update the cached (unified) answer accordingly.
            //
            // In the general case, one would have to use the cached (unified)
            // offer to find the m-lines that are missing from the reconstructed
            // answer, potentially grabbing them from the cached (unified) answer.
            // One has to be careful with this approach because inactive m-lines do
            // not always have an mid, making it tricky (impossible?) to find where
            // exactly and which m-lines are missing from the reconstructed answer.
            
            for (var i = 0; i < cached.media.length; i++) {
                var uLine = cached.media[i];
                
                if (typeof mid2ul[uLine.mid] === 'undefined') {
                    
                    // The mid isn't in the reconstructed (unified) answer.
                    // This is either a (unified) m-line containing a remote
                    // track only, or a (unified) m-line containing a remote
                    // track and a local track that has been removed.
                    // In either case, it MUST exist in the cached
                    // (unified) answer.
                    //
                    // In case this is a removed local track, clean-up
                    // the (unified) m-line and make sure it's 'recvonly' or
                    // 'inactive'.
                    
                    delete uLine.msid;
                    delete uLine.sources;
                    delete uLine.ssrcGroups;
                    if (!uLine.direction
                        || uLine.direction === 'sendrecv')
                        uLine.direction = 'recvonly';
                    else if (uLine.direction === 'sendonly')
                        uLine.direction = 'inactive';
                } else {
                    // This is an (unified) m-line/channel that contains a local
                    // track (sendrecv or sendonly channel) or it's a unified
                    // recvonly m-line/channel. In either case, since we're
                    // going from PlanB -> Unified Plan this m-line MUST
                    // exist in the cached answer.
                }
                
                session.media.push(uLine);
                
                if (typeof uLine.mid === 'string') {
                    // inactive lines don't/may not have an mid.
                    mids.push(uLine.mid);
                }
            }
        } else {
            
            // SDP offer/answer (and the JSEP spec) forbids removing an m-section
            // under any circumstances. If we are no longer interested in sending a
            // track, we just remove the msid and ssrc attributes and set it to
            // either a=recvonly (as the reofferer, we must use recvonly if the
            // other side was previously sending on the m-section, but we can also
            // leave the possibility open if it wasn't previously in use), or
            // a=inactive.
            
            if (typeof cached !== 'undefined' &&
                typeof cached.media !== 'undefined' &&
                Array.isArray(cached.media)) {
                cached.media.forEach(function(uLine) {
                    mids.push(uLine.mid);
                    if (typeof mid2ul[uLine.mid] !== 'undefined') {
                        session.media.push(mid2ul[uLine.mid]);
                    } else {
                        delete uLine.msid;
                        delete uLine.sources;
                        delete uLine.ssrcGroups;
                        if (!uLine.direction
                            || uLine.direction === 'sendrecv')
                            uLine.direction = 'recvonly';
                        if (!uLine.direction
                            || uLine.direction === 'sendonly')
                            uLine.direction = 'inactive';
                        session.media.push(uLine);
                    }
                });
            }
            
            // Add all the remaining (new) m-lines of the transformed SDP.
            Object.keys(mid2ul).forEach(function(mid) {
                if (mids.indexOf(mid) === -1) {
                    mids.push(mid);
                    if (mid2ul[mid].direction === 'recvonly') {
                        // This is a remote recvonly channel. Add its SSRC to the
                        // appropriate sendrecv or sendonly channel.
                        // TODO(gp) what if we don't have sendrecv/sendonly
                        // channel?
                        
                        session.media.some(function (uLine) {
                            if ((uLine.direction === 'sendrecv' ||
                                uLine.direction === 'sendonly') &&
                                uLine.type === mid2ul[mid].type) {
                                
                                // mid2ul[mid] shouldn't have any ssrc-groups
                                Object.keys(mid2ul[mid].sources).forEach(
                                    function (ssrc) {
                                        uLine.sources[ssrc] =
                                            mid2ul[mid].sources[ssrc];
                                    });
                                
                                return true;
                            }
                        });
                    } else {
                        session.media.push(mid2ul[mid]);
                    }
                }
            });
        }
        
        // After we have constructed the Plan Unified m-lines we can figure out
        // where (in which m-line) to place the 'recvonly SSRCs'.
        // Note: we assume here that we are the answerer in the O/A, so any offers
        // which we translate come from the remote side, while answers are local
        // (and so our last local description is cached as an 'answer').
        ["audio", "video"].forEach(function (type) {
            if (!session || !session.media || !Array.isArray(session.media))
                return;
            
            var idx = null;
            if (Object.keys(recvonlySsrcs[type]).length > 0) {
                idx = self.getFirstSendingIndexFromAnswer(type);
                if (idx === null){
                    // If this is the first offer we receive, we don't have a
                    // cached answer. Assume that we will be sending media using
                    // the first m-line for each media type.
                    
                    for (var i = 0; i < session.media.length; i++) {
                        if (session.media[i].type === type) {
                            idx = i;
                            break;
                        }
                    }
                }
            }
            
            if (idx && session.media.length > idx) {
                var mLine = session.media[idx];
                Object.keys(recvonlySsrcs[type]).forEach(function(ssrc) {
                    if (mLine.sources && mLine.sources[ssrc]) {
                        console.warn("Replacing an existing SSRC.");
                    }
                    if (!mLine.sources) {
                        mLine.sources = {};
                    }
                    
                    mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];
                });
            }
        });
        
        // We regenerate the BUNDLE group (since we regenerated the mids)
        session.groups.some(function(group) {
            if (group.type === 'BUNDLE') {
                group.mids = mids.join(' ');
                return true;
            }
        });
        
        // msid semantic
        session.msidSemantic = {
            semantic: 'WMS',
            token: '*'
        };
        
        var resStr = transform.write(session);
        
        // Cache the transformed SDP (Unified Plan) for later re-use in this
        // function.
        this.cache[desc.type] = resStr;
        
        return new RTCSessionDescription({
            type: desc.type,
            sdp: resStr
        });
        
        //#endregion
    };
    
},{"./array-equals":105,"./transform":108}],108:[function(require,module,exports){
    /* Copyright @ 2015 Atlassian Pty Ltd
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    var transform = require('sdp-transform');
    
    exports.write = function(session, opts) {
        
        if (typeof session !== 'undefined' &&
            typeof session.media !== 'undefined' &&
            Array.isArray(session.media)) {
            
            session.media.forEach(function (mLine) {
                // expand sources to ssrcs
                if (typeof mLine.sources !== 'undefined' &&
                    Object.keys(mLine.sources).length !== 0) {
                    mLine.ssrcs = [];
                    Object.keys(mLine.sources).forEach(function (ssrc) {
                        var source = mLine.sources[ssrc];
                        Object.keys(source).forEach(function (attribute) {
                            mLine.ssrcs.push({
                                id: ssrc,
                                attribute: attribute,
                                value: source[attribute]
                            });
                        });
                    });
                    delete mLine.sources;
                }
                
                // join ssrcs in ssrc groups
                if (typeof mLine.ssrcGroups !== 'undefined' &&
                    Array.isArray(mLine.ssrcGroups)) {
                    mLine.ssrcGroups.forEach(function (ssrcGroup) {
                        if (typeof ssrcGroup.ssrcs !== 'undefined' &&
                            Array.isArray(ssrcGroup.ssrcs)) {
                            ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');
                        }
                    });
                }
            });
        }
        
        // join group mids
        if (typeof session !== 'undefined' &&
            typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {
            
            session.groups.forEach(function (g) {
                if (typeof g.mids !== 'undefined' && Array.isArray(g.mids)) {
                    g.mids = g.mids.join(' ');
                }
            });
        }
        
        return transform.write(session, opts);
    };
    
    exports.parse = function(sdp) {
        var session = transform.parse(sdp);
        
        if (typeof session !== 'undefined' && typeof session.media !== 'undefined' &&
            Array.isArray(session.media)) {
            
            session.media.forEach(function (mLine) {
                // group sources attributes by ssrc
                if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {
                    mLine.sources = {};
                    mLine.ssrcs.forEach(function (ssrc) {
                        if (!mLine.sources[ssrc.id])
                            mLine.sources[ssrc.id] = {};
                        mLine.sources[ssrc.id][ssrc.attribute] = ssrc.value;
                    });
                    
                    delete mLine.ssrcs;
                }
                
                // split ssrcs in ssrc groups
                if (typeof mLine.ssrcGroups !== 'undefined' &&
                    Array.isArray(mLine.ssrcGroups)) {
                    mLine.ssrcGroups.forEach(function (ssrcGroup) {
                        if (typeof ssrcGroup.ssrcs === 'string') {
                            ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');
                        }
                    });
                }
            });
        }
        // split group mids
        if (typeof session !== 'undefined' &&
            typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {
            
            session.groups.forEach(function (g) {
                if (typeof g.mids === 'string') {
                    g.mids = g.mids.split(' ');
                }
            });
        }
        
        return session;
    };
    
    
},{"sdp-transform":110}],109:[function(require,module,exports){
    var grammar = module.exports = {
        v: [{
            name: 'version',
            reg: /^(\d*)$/
        }],
        o: [{ //o=- 20518 0 IN IP4 203.0.113.1
            // NB: sessionId will be a String in most cases because it is huge
            name: 'origin',
            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
            names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
            format: "%s %s %d %s IP%d %s"
        }],
        // default parsing of these only (though some of these feel outdated)
        s: [{ name: 'name' }],
        i: [{ name: 'description' }],
        u: [{ name: 'uri' }],
        e: [{ name: 'email' }],
        p: [{ name: 'phone' }],
        z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
        r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
        //k: [{}], // outdated thing ignored
        t: [{ //t=0 0
            name: 'timing',
            reg: /^(\d*) (\d*)/,
            names: ['start', 'stop'],
            format: "%d %d"
        }],
        c: [{ //c=IN IP4 10.47.197.26
            name: 'connection',
            reg: /^IN IP(\d) (\S*)/,
            names: ['version', 'ip'],
            format: "IN IP%d %s"
        }],
        b: [{ //b=AS:4000
            push: 'bandwidth',
            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
            names: ['type', 'limit'],
            format: "%s:%s"
        }],
        m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
            // NB: special - pushes to session
            // TODO: rtp/fmtp should be filtered by the payloads found here?
            reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
            names: ['type', 'port', 'protocol', 'payloads'],
            format: "%s %d %s %s"
        }],
        a: [
            { //a=rtpmap:110 opus/48000/2
                push: 'rtp',
                reg: /^rtpmap:(\d*) ([\w\-]*)\/(\d*)(?:\s*\/(\S*))?/,
                names: ['payload', 'codec', 'rate', 'encoding'],
                format: function (o) {
                    return (o.encoding) ?
                        "rtpmap:%d %s/%s/%s":
                        "rtpmap:%d %s/%s";
                }
            },
            {
                //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
                //a=fmtp:111 minptime=10; useinbandfec=1
                push: 'fmtp',
                reg: /^fmtp:(\d*) ([\S| ]*)/,
                names: ['payload', 'config'],
                format: "fmtp:%d %s"
            },
            { //a=control:streamid=0
                name: 'control',
                reg: /^control:(.*)/,
                format: "control:%s"
            },
            { //a=rtcp:65179 IN IP4 193.84.77.194
                name: 'rtcp',
                reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                names: ['port', 'netType', 'ipVer', 'address'],
                format: function (o) {
                    return (o.address != null) ?
                        "rtcp:%d %s IP%d %s":
                        "rtcp:%d";
                }
            },
            { //a=rtcp-fb:98 trr-int 100
                push: 'rtcpFbTrrInt',
                reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                names: ['payload', 'value'],
                format: "rtcp-fb:%d trr-int %d"
            },
            { //a=rtcp-fb:98 nack rpsi
                push: 'rtcpFb',
                reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                names: ['payload', 'type', 'subtype'],
                format: function (o) {
                    return (o.subtype != null) ?
                        "rtcp-fb:%s %s %s":
                        "rtcp-fb:%s %s";
                }
            },
            { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
                //a=extmap:1/recvonly URI-gps-string
                push: 'ext',
                reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                names: ['value', 'uri', 'config'], // value may include "/direction" suffix
                format: function (o) {
                    return (o.config != null) ?
                        "extmap:%s %s %s":
                        "extmap:%s %s";
                }
            },
            {
                //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
                push: 'crypto',
                reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                names: ['id', 'suite', 'config', 'sessionConfig'],
                format: function (o) {
                    return (o.sessionConfig != null) ?
                        "crypto:%d %s %s %s":
                        "crypto:%d %s %s";
                }
            },
            { //a=setup:actpass
                name: 'setup',
                reg: /^setup:(\w*)/,
                format: "setup:%s"
            },
            { //a=mid:1
                name: 'mid',
                reg: /^mid:([^\s]*)/,
                format: "mid:%s"
            },
            { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
                name: 'msid',
                reg: /^msid:(.*)/,
                format: "msid:%s"
            },
            { //a=ptime:20
                name: 'ptime',
                reg: /^ptime:(\d*)/,
                format: "ptime:%d"
            },
            { //a=maxptime:60
                name: 'maxptime',
                reg: /^maxptime:(\d*)/,
                format: "maxptime:%d"
            },
            { //a=sendrecv
                name: 'direction',
                reg: /^(sendrecv|recvonly|sendonly|inactive)/
            },
            { //a=ice-lite
                name: 'icelite',
                reg: /^(ice-lite)/
            },
            { //a=ice-ufrag:F7gI
                name: 'iceUfrag',
                reg: /^ice-ufrag:(\S*)/,
                format: "ice-ufrag:%s"
            },
            { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
                name: 'icePwd',
                reg: /^ice-pwd:(\S*)/,
                format: "ice-pwd:%s"
            },
            { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
                name: 'fingerprint',
                reg: /^fingerprint:(\S*) (\S*)/,
                names: ['type', 'hash'],
                format: "fingerprint:%s %s"
            },
            {
                //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
                //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
                //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
                push:'candidates',
                reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: generation (\d*))?/,
                names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'generation'],
                format: function (o) {
                    var str = "candidate:%s %d %s %d %s %d typ %s";
                    // NB: candidate has two optional chunks, so %void middle one if it's missing
                    str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";
                    if (o.generation != null) {
                        str += " generation %d";
                    }
                    return str;
                }
            },
            { //a=end-of-candidates (keep after the candidates line for readability)
                name: 'endOfCandidates',
                reg: /^(end-of-candidates)/
            },
            { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
                name: 'remoteCandidates',
                reg: /^remote-candidates:(.*)/,
                format: "remote-candidates:%s"
            },
            { //a=ice-options:google-ice
                name: 'iceOptions',
                reg: /^ice-options:(\S*)/,
                format: "ice-options:%s"
            },
            { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
                push: "ssrcs",
                reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
                names: ['id', 'attribute', 'value'],
                format: "ssrc:%d %s:%s"
            },
            { //a=ssrc-group:FEC 1 2
                push: "ssrcGroups",
                reg: /^ssrc-group:(\w*) (.*)/,
                names: ['semantics', 'ssrcs'],
                format: "ssrc-group:%s %s"
            },
            { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
                name: "msidSemantic",
                reg: /^msid-semantic:\s?(\w*) (\S*)/,
                names: ['semantic', 'token'],
                format: "msid-semantic: %s %s" // space after ":" is not accidental
            },
            { //a=group:BUNDLE audio video
                push: 'groups',
                reg: /^group:(\w*) (.*)/,
                names: ['type', 'mids'],
                format: "group:%s %s"
            },
            { //a=rtcp-mux
                name: 'rtcpMux',
                reg: /^(rtcp-mux)/
            },
            { //a=rtcp-rsize
                name: 'rtcpRsize',
                reg: /^(rtcp-rsize)/
            },
            { // any a= that we don't understand is kepts verbatim on media.invalid
                push: 'invalid',
                names: ["value"]
            }
        ]
    };
    
    // set sensible defaults to avoid polluting the grammar with boring details
    Object.keys(grammar).forEach(function (key) {
        var objs = grammar[key];
        objs.forEach(function (obj) {
            if (!obj.reg) {
                obj.reg = /(.*)/;
            }
            if (!obj.format) {
                obj.format = "%s";
            }
        });
    });
    
},{}],110:[function(require,module,exports){
    var parser = require('./parser');
    var writer = require('./writer');
    
    exports.write = writer;
    exports.parse = parser.parse;
    exports.parseFmtpConfig = parser.parseFmtpConfig;
    exports.parsePayloads = parser.parsePayloads;
    exports.parseRemoteCandidates = parser.parseRemoteCandidates;
    
},{"./parser":111,"./writer":112}],111:[function(require,module,exports){
    var toIntIfInt = function (v) {
        return String(Number(v)) === v ? Number(v) : v;
    };
    
    var attachProperties = function (match, location, names, rawName) {
        if (rawName && !names) {
            location[rawName] = toIntIfInt(match[1]);
        }
        else {
            for (var i = 0; i < names.length; i += 1) {
                if (match[i+1] != null) {
                    location[names[i]] = toIntIfInt(match[i+1]);
                }
            }
        }
    };
    
    var parseReg = function (obj, location, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location[obj.push]) {
            location[obj.push] = [];
        }
        else if (needsBlank && !location[obj.name]) {
            location[obj.name] = {};
        }
        var keyLocation = obj.push ?
        {} :  // blank object that will be pushed
            needsBlank ? location[obj.name] : location; // otherwise, named location or root
        
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        
        if (obj.push) {
            location[obj.push].push(keyLocation);
        }
    };
    
    var grammar = require('./grammar');
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    
    exports.parse = function (sdp) {
        var session = {}
            , media = []
            , location = session; // points at where properties go under (one of the above)
        
        // parse lines we understand
        sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
            var type = l[0];
            var content = l.slice(2);
            if (type === 'm') {
                media.push({rtp: [], fmtp: []});
                location = media[media.length-1]; // point at latest media line
            }
            
            for (var j = 0; j < (grammar[type] || []).length; j += 1) {
                var obj = grammar[type][j];
                if (obj.reg.test(content)) {
                    return parseReg(obj, location, content);
                }
            }
        });
        
        session.media = media; // link it up
        return session;
    };
    
    var fmtpReducer = function (acc, expr) {
        var s = expr.split('=');
        if (s.length === 2) {
            acc[s[0]] = toIntIfInt(s[1]);
        }
        return acc;
    };
    
    exports.parseFmtpConfig = function (str) {
        return str.split(/\;\s?/).reduce(fmtpReducer, {});
    };
    
    exports.parsePayloads = function (str) {
        return str.split(' ').map(Number);
    };
    
    exports.parseRemoteCandidates = function (str) {
        var candidates = [];
        var parts = str.split(' ').map(toIntIfInt);
        for (var i = 0; i < parts.length; i += 3) {
            candidates.push({
                component: parts[i],
                ip: parts[i + 1],
                port: parts[i + 2]
            });
        }
        return candidates;
    };
    
},{"./grammar":109}],112:[function(require,module,exports){
    var grammar = require('./grammar');
    
    // customized util.format - discards excess arguments and can void middle ones
    var formatRegExp = /%[sdv%]/g;
    var format = function (formatStr) {
        var i = 1;
        var args = arguments;
        var len = args.length;
        return formatStr.replace(formatRegExp, function (x) {
            if (i >= len) {
                return x; // missing argument
            }
            var arg = args[i];
            i += 1;
            switch (x) {
                case '%%':
                    return '%';
                case '%s':
                    return String(arg);
                case '%d':
                    return Number(arg);
                case '%v':
                    return '';
            }
        });
        // NB: we discard excess arguments - they are typically undefined from makeLine
    };
    
    var makeLine = function (type, obj, location) {
        var str = obj.format instanceof Function ?
            (obj.format(obj.push ? location : location[obj.name])) :
            obj.format;
        
        var args = [type + '=' + str];
        if (obj.names) {
            for (var i = 0; i < obj.names.length; i += 1) {
                var n = obj.names[i];
                if (obj.name) {
                    args.push(location[obj.name][n]);
                }
                else { // for mLine and push attributes
                    args.push(location[obj.names[i]]);
                }
            }
        }
        else {
            args.push(location[obj.name]);
        }
        return format.apply(null, args);
    };
    
    // RFC specified order
    // TODO: extend this with all the rest
    var defaultOuterOrder = [
        'v', 'o', 's', 'i',
        'u', 'e', 'p', 'c',
        'b', 't', 'r', 'z', 'a'
    ];
    var defaultInnerOrder = ['i', 'c', 'b', 'a'];
    
    
    module.exports = function (session, opts) {
        opts = opts || {};
        // ensure certain properties exist
        if (session.version == null) {
            session.version = 0; // "v=0" must be there (only defined version atm)
        }
        if (session.name == null) {
            session.name = " "; // "s= " must be there if no meaningful name set
        }
        session.media.forEach(function (mLine) {
            if (mLine.payloads == null) {
                mLine.payloads = "";
            }
        });
        
        var outerOrder = opts.outerOrder || defaultOuterOrder;
        var innerOrder = opts.innerOrder || defaultInnerOrder;
        var sdp = [];
        
        // loop through outerOrder for matching properties on session
        outerOrder.forEach(function (type) {
            grammar[type].forEach(function (obj) {
                if (obj.name in session && session[obj.name] != null) {
                    sdp.push(makeLine(type, obj, session));
                }
                else if (obj.push in session && session[obj.push] != null) {
                    session[obj.push].forEach(function (el) {
                        sdp.push(makeLine(type, obj, el));
                    });
                }
            });
        });
        
        // then for each media line, follow the innerOrder
        session.media.forEach(function (mLine) {
            sdp.push(makeLine('m', grammar.m[0], mLine));
            
            innerOrder.forEach(function (type) {
                grammar[type].forEach(function (obj) {
                    if (obj.name in mLine && mLine[obj.name] != null) {
                        sdp.push(makeLine(type, obj, mLine));
                    }
                    else if (obj.push in mLine && mLine[obj.push] != null) {
                        mLine[obj.push].forEach(function (el) {
                            sdp.push(makeLine(type, obj, el));
                        });
                    }
                });
            });
        });
        
        return sdp.join('\r\n') + '\r\n';
    };
    
},{"./grammar":109}],113:[function(require,module,exports){
    var transform = require('sdp-transform');
    var transformUtils = require('./transform-utils');
    var parseSsrcs = transformUtils.parseSsrcs;
    var writeSsrcs = transformUtils.writeSsrcs;
    
    //region Constants
    
    var DEFAULT_NUM_OF_LAYERS = 3;
    
    //endregion
    
    //region Ctor
    
    function Simulcast(options) {
        
        this.options = options ? options : {};
        
        if (!this.options.numOfLayers) {
            this.options.numOfLayers = DEFAULT_NUM_OF_LAYERS;
        }
        
        this.layers = [];
    }
    
    //endregion
    
    //region Stateless private utility functions
    
    /**
     * Returns a random integer between min (included) and max (excluded)
     * Using Math.round() gives a non-uniform distribution!
     * @returns {number}
     */
    function generateSSRC() {
        var min = 0, max = 0xffffffff;
        return Math.floor(Math.random() * (max - min)) + min;
    };
    
    function processVideo(session, action) {
        if (session == null || !Array.isArray(session.media)) {
            return;
        }
        
        session.media.forEach(function (mLine) {
            if (mLine.type === 'video') {
                action(mLine);
            }
        });
    }
    
    function validateDescription(desc)
    {
        return desc && desc != null
            && desc.type && desc.type != ''
            && desc.sdp && desc.sdp != '';
    }
    
    function explodeRemoteSimulcast(mLine) {
        
        if (!mLine || !Array.isArray(mLine.ssrcGroups)) {
            return;
        }
        
        var sources = parseSsrcs(mLine);
        var order = [];
        
        // Find the SIM group and explode its sources.
        var j = mLine.ssrcGroups.length;
        while (j--) {
            
            if (mLine.ssrcGroups[j].semantics !== 'SIM') {
                continue;
            }
            
            var simulcastSsrcs = mLine.ssrcGroups[j].ssrcs.split(' ');
            
            for (var i = 0; i < simulcastSsrcs.length; i++) {
                
                var ssrc = simulcastSsrcs[i];
                order.push(ssrc);
                
                var parts = sources[ssrc].msid.split(' ');
                sources[ssrc].msid = [parts[0], '/', i, ' ', parts[1], '/', i].join('');
                sources[ssrc].cname = [sources[ssrc].cname, '/', i].join('');
                
                // Remove all the groups that this SSRC participates in.
                mLine.ssrcGroups.forEach(function (relatedGroup) {
                    if (relatedGroup.semantics === 'SIM') {
                        return;
                    }
                    
                    var relatedSsrcs = relatedGroup.ssrcs.split(' ');
                    if (relatedSsrcs.indexOf(ssrc) === -1) {
                        return;
                    }
                    
                    // Nuke all the related SSRCs.
                    relatedSsrcs.forEach(function (relatedSSRC) {
                        sources[relatedSSRC].msid = sources[ssrc].msid;
                        sources[relatedSSRC].cname = sources[ssrc].cname;
                        if (relatedSSRC !== ssrc) {
                            order.push(relatedSSRC);
                        }
                    });
                    
                    // Schedule the related group for nuking.
                })
            }
            
            mLine.ssrcs = writeSsrcs(sources, order);
            mLine.ssrcGroups.splice(j, 1);
        };
    }
    
    function squeezeRemoteSimulcast(mLine) {
        
        if (!mLine || !Array.isArray(mLine.ssrcGroups)) {
            return;
        }
        
        var sources = parseSsrcs(mLine);
        
        // Find the SIM group and nuke it.
        mLine.ssrcGroups.some(function (simulcastGroup) {
            if (simulcastGroup.semantics !== 'SIM') {
                return false;
            }
            
            // Schedule the SIM group for nuking.
            simulcastGroup.nuke = true;
            
            var simulcastSsrcs = simulcastGroup.ssrcs.split(' ');
            
            // Nuke all the higher layer SSRCs.
            for (var i = 1; i < simulcastSsrcs.length; i++) {
                
                var ssrc = simulcastSsrcs[i];
                delete sources[ssrc];
                
                // Remove all the groups that this SSRC participates in.
                mLine.ssrcGroups.forEach(function (relatedGroup) {
                    if (relatedGroup.semantics === 'SIM') {
                        return;
                    }
                    
                    var relatedSsrcs = relatedGroup.ssrcs.split(' ');
                    if (relatedSsrcs.indexOf(ssrc) === -1) {
                        return;
                    }
                    
                    // Nuke all the related SSRCs.
                    relatedSsrcs.forEach(function (relatedSSRC) {
                        delete sources[relatedSSRC];
                    });
                    
                    // Schedule the related group for nuking.
                    relatedGroup.nuke = true;
                })
            }
            
            return true;
        });
        
        mLine.ssrcs = writeSsrcs(sources);
        
        // Nuke all the scheduled groups.
        var i = mLine.ssrcGroups.length;
        while (i--) {
            if (mLine.ssrcGroups[i].nuke) {
                mLine.ssrcGroups.splice(i, 1);
            }
        }
    }
    
    function removeGoogConference(mLine) {
        if (!mLine || !Array.isArray(mLine.invalid)) {
            return;
        }
        
        var i = mLine.invalid.length;
        while (i--) {
            if (mLine.invalid[i].value == 'x-google-flag:conference') {
                mLine.invalid.splice(i, 1);
            }
        }
    }
    
    function assertGoogConference(mLine) {
        if (!mLine) {
            return;
        }
        
        if (!Array.isArray(mLine.invalid)) {
            mLine.invalid = [];
        }
        
        if (!mLine.invalid.some(
                function (i) { return i.value === 'x-google-flag:conference' })) {
            mLine.invalid.push({'value': 'x-google-flag:conference'});
        }
    }
    
    //endregion
    
    //region "Private" functions
    
    /**
     *
     * @param mLine
     * @private
     */
    Simulcast.prototype._maybeInitializeLayers = function(mLine) {
        
        if (!mLine || mLine.type !== 'video') {
            return;
        }
        
        var sources = parseSsrcs(mLine);
        
        if (Object.keys(sources).length === 0) {
            
            // no sources, disable simulcast.
            if (this.layers.length !== 0) {
                this.layers = [];
            }
            
            return;
        }
        
        // find the base layer (we'll reuse its msid and cname).
        var baseLayerSSRC = Object.keys(sources)[0];
        var baseLayer = sources[baseLayerSSRC];
        
        // todo(gp) handle screen sharing.
        
        // check if base CNAME has changed and reinitialise layers.
        if (this.layers.length > 0
            && sources[baseLayerSSRC].cname !== this.layers[0].cname) {
            this.layers = [];
        }
        
        // (re)initialise layers
        if (this.layers.length < 1) {
            
            // first push the base layer.
            this.layers.push({
                ssrc: baseLayerSSRC,
                msid: baseLayer.msid,
                cname: baseLayer.cname
            });
            
            var rtx = false; // RFC 4588
            if (Array.isArray(mLine.rtp)) {
                rtx = mLine.rtp.some(
                    function (rtpmap) { return rtpmap.codec === 'rtx'; });
            }
            
            if (rtx) {
                this.layers[0].rtx = generateSSRC();
            }
            
            // now push additional layers.
            for (var i = 1; i < Math.max(1, this.options.numOfLayers); i++) {
                
                var layer = { ssrc: generateSSRC() };
                if (rtx) {
                    layer.rtx = generateSSRC();
                }
                
                this.layers.push(layer);
            }
        }
    };
    
    /**
     *
     * @param mLine
     * @private
     */
    Simulcast.prototype._restoreSimulcastView = function(mLine) {
        if (mLine && mLine.type === 'video' && this.layers.length !== 0) {
            
            var sources = {};
            
            var msid = this.layers[0].msid;
            var cname = this.layers[0].cname;
            var simulcastSsrcs = [];
            var ssrcGroups = [];
            
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                
                sources[layer.ssrc] = { msid: msid, cname: cname };
                simulcastSsrcs.push(layer.ssrc);
                
                if (layer.rtx) {
                    
                    sources[layer.rtx] = {
                        msid: msid,
                        cname: cname
                    }
                    
                    ssrcGroups.push({
                        semantics: 'FID',
                        ssrcs: [layer.ssrc, layer.rtx].join(' ')
                    });
                }
            }
            
            ssrcGroups.push({
                semantics: 'SIM',
                ssrcs: simulcastSsrcs.join(' ')
            });
            
            mLine.ssrcGroups = ssrcGroups;
            mLine.ssrcs = writeSsrcs(sources);
        }
    }
    
    //endregion
    
    //region "Public" functions
    
    Simulcast.prototype.isSupported = function () {
        return window.chrome;
        
        // TODO this needs improvements. For example I doubt that Chrome in Android
        // has simulcast support. Also, only recent versions of Chromium have native
        // simulcast support.
    }
    
    /**
     *
     * @param desc
     * @returns {RTCSessionDescription}
     */
    Simulcast.prototype.mungeRemoteDescription = function (desc) {
        
        if (!validateDescription(desc)) {
            return desc;
        }
        
        var session = transform.parse(desc.sdp);
        
        var self = this;
        processVideo(session, function (mLine) {
            
            // Handle simulcast reception.
            if (self.options.explodeRemoteSimulcast) {
                explodeRemoteSimulcast(mLine);
            } else {
                squeezeRemoteSimulcast(mLine);
            }
            
            // If native simulcast is enabled, we must append the x-goog-conference
            // attribute to the SDP.
            if (self.layers.length < 1) {
                removeGoogConference(mLine);
            } else {
                assertGoogConference(mLine);
            }
        });
        
        return new RTCSessionDescription({
            type: desc.type,
            sdp: transform.write(session)
        });
    };
    
    /**
     *
     * @param desc
     * @returns {RTCSessionDescription}
     */
    Simulcast.prototype.mungeLocalDescription = function (desc) {
        
        if (!validateDescription(desc) || !this.isSupported()) {
            return desc;
        }
        
        var session = transform.parse(desc.sdp);
        
        var self = this;
        processVideo(session, function (mLine) {
            // Initialize native simulcast layers, if not already done.
            self._maybeInitializeLayers(mLine);
            
            // Update the SDP with the simulcast layers.
            self._restoreSimulcastView(mLine);
        });
        
        return new RTCSessionDescription({
            type: desc.type,
            sdp: transform.write(session)
        });
    };
    
    //endregion
    
    module.exports = Simulcast;
    
},{"./transform-utils":114,"sdp-transform":116}],114:[function(require,module,exports){
    exports.writeSsrcs = function(sources, order) {
        var ssrcs = [];
        
        // expand sources to ssrcs
        if (typeof sources !== 'undefined' &&
            Object.keys(sources).length !== 0) {
            
            if (Array.isArray(order)) {
                for (var i = 0; i < order.length; i++) {
                    var ssrc = order[i];
                    var source = sources[ssrc];
                    Object.keys(source).forEach(function (attribute) {
                        ssrcs.push({
                            id: ssrc,
                            attribute: attribute,
                            value: source[attribute]
                        });
                    });
                }
            } else {
                Object.keys(sources).forEach(function (ssrc) {
                    var source = sources[ssrc];
                    Object.keys(source).forEach(function (attribute) {
                        ssrcs.push({
                            id: ssrc,
                            attribute: attribute,
                            value: source[attribute]
                        });
                    });
                });
            }
        }
        
        return ssrcs;
    };
    
    exports.parseSsrcs = function (mLine) {
        var sources = {};
        // group sources attributes by ssrc.
        if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {
            mLine.ssrcs.forEach(function (ssrc) {
                if (!sources[ssrc.id])
                    sources[ssrc.id] = {};
                sources[ssrc.id][ssrc.attribute] = ssrc.value;
            });
        }
        return sources;
    };
    
    
},{}],115:[function(require,module,exports){
    var grammar = module.exports = {
        v: [{
            name: 'version',
            reg: /^(\d*)$/
        }],
        o: [{ //o=- 20518 0 IN IP4 203.0.113.1
            // NB: sessionId will be a String in most cases because it is huge
            name: 'origin',
            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
            names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
            format: "%s %s %d %s IP%d %s"
        }],
        // default parsing of these only (though some of these feel outdated)
        s: [{ name: 'name' }],
        i: [{ name: 'description' }],
        u: [{ name: 'uri' }],
        e: [{ name: 'email' }],
        p: [{ name: 'phone' }],
        z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
        r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
        //k: [{}], // outdated thing ignored
        t: [{ //t=0 0
            name: 'timing',
            reg: /^(\d*) (\d*)/,
            names: ['start', 'stop'],
            format: "%d %d"
        }],
        c: [{ //c=IN IP4 10.47.197.26
            name: 'connection',
            reg: /^IN IP(\d) (\S*)/,
            names: ['version', 'ip'],
            format: "IN IP%d %s"
        }],
        b: [{ //b=AS:4000
            push: 'bandwidth',
            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
            names: ['type', 'limit'],
            format: "%s:%s"
        }],
        m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
            // NB: special - pushes to session
            // TODO: rtp/fmtp should be filtered by the payloads found here?
            reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
            names: ['type', 'port', 'protocol', 'payloads'],
            format: "%s %d %s %s"
        }],
        a: [
            { //a=rtpmap:110 opus/48000/2
                push: 'rtp',
                reg: /^rtpmap:(\d*) ([\w\-]*)\/(\d*)(?:\s*\/(\S*))?/,
                names: ['payload', 'codec', 'rate', 'encoding'],
                format: function (o) {
                    return (o.encoding) ?
                        "rtpmap:%d %s/%s/%s":
                        "rtpmap:%d %s/%s";
                }
            },
            { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
                push: 'fmtp',
                reg: /^fmtp:(\d*) (\S*)/,
                names: ['payload', 'config'],
                format: "fmtp:%d %s"
            },
            { //a=control:streamid=0
                name: 'control',
                reg: /^control:(.*)/,
                format: "control:%s"
            },
            { //a=rtcp:65179 IN IP4 193.84.77.194
                name: 'rtcp',
                reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                names: ['port', 'netType', 'ipVer', 'address'],
                format: function (o) {
                    return (o.address != null) ?
                        "rtcp:%d %s IP%d %s":
                        "rtcp:%d";
                }
            },
            { //a=rtcp-fb:98 trr-int 100
                push: 'rtcpFbTrrInt',
                reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                names: ['payload', 'value'],
                format: "rtcp-fb:%d trr-int %d"
            },
            { //a=rtcp-fb:98 nack rpsi
                push: 'rtcpFb',
                reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                names: ['payload', 'type', 'subtype'],
                format: function (o) {
                    return (o.subtype != null) ?
                        "rtcp-fb:%s %s %s":
                        "rtcp-fb:%s %s";
                }
            },
            { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
                //a=extmap:1/recvonly URI-gps-string
                push: 'ext',
                reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                names: ['value', 'uri', 'config'], // value may include "/direction" suffix
                format: function (o) {
                    return (o.config != null) ?
                        "extmap:%s %s %s":
                        "extmap:%s %s";
                }
            },
            {
                //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
                push: 'crypto',
                reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                names: ['id', 'suite', 'config', 'sessionConfig'],
                format: function (o) {
                    return (o.sessionConfig != null) ?
                        "crypto:%d %s %s %s":
                        "crypto:%d %s %s";
                }
            },
            { //a=setup:actpass
                name: 'setup',
                reg: /^setup:(\w*)/,
                format: "setup:%s"
            },
            { //a=mid:1
                name: 'mid',
                reg: /^mid:([^\s]*)/,
                format: "mid:%s"
            },
            { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
                name: 'msid',
                reg: /^msid:(.*)/,
                format: "msid:%s"
            },
            { //a=ptime:20
                name: 'ptime',
                reg: /^ptime:(\d*)/,
                format: "ptime:%d"
            },
            { //a=maxptime:60
                name: 'maxptime',
                reg: /^maxptime:(\d*)/,
                format: "maxptime:%d"
            },
            { //a=sendrecv
                name: 'direction',
                reg: /^(sendrecv|recvonly|sendonly|inactive)/
            },
            { //a=ice-lite
                name: 'icelite',
                reg: /^(ice-lite)/
            },
            { //a=ice-ufrag:F7gI
                name: 'iceUfrag',
                reg: /^ice-ufrag:(\S*)/,
                format: "ice-ufrag:%s"
            },
            { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
                name: 'icePwd',
                reg: /^ice-pwd:(\S*)/,
                format: "ice-pwd:%s"
            },
            { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
                name: 'fingerprint',
                reg: /^fingerprint:(\S*) (\S*)/,
                names: ['type', 'hash'],
                format: "fingerprint:%s %s"
            },
            {
                //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
                //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
                //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
                push:'candidates',
                reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: generation (\d*))?/,
                names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'generation'],
                format: function (o) {
                    var str = "candidate:%s %d %s %d %s %d typ %s";
                    // NB: candidate has two optional chunks, so %void middle one if it's missing
                    str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";
                    if (o.generation != null) {
                        str += " generation %d";
                    }
                    return str;
                }
            },
            { //a=end-of-candidates (keep after the candidates line for readability)
                name: 'endOfCandidates',
                reg: /^(end-of-candidates)/
            },
            { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
                name: 'remoteCandidates',
                reg: /^remote-candidates:(.*)/,
                format: "remote-candidates:%s"
            },
            { //a=ice-options:google-ice
                name: 'iceOptions',
                reg: /^ice-options:(\S*)/,
                format: "ice-options:%s"
            },
            { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
                push: "ssrcs",
                reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
                names: ['id', 'attribute', 'value'],
                format: "ssrc:%d %s:%s"
            },
            { //a=ssrc-group:FEC 1 2
                push: "ssrcGroups",
                reg: /^ssrc-group:(\w*) (.*)/,
                names: ['semantics', 'ssrcs'],
                format: "ssrc-group:%s %s"
            },
            { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
                name: "msidSemantic",
                reg: /^msid-semantic:\s?(\w*) (\S*)/,
                names: ['semantic', 'token'],
                format: "msid-semantic: %s %s" // space after ":" is not accidental
            },
            { //a=group:BUNDLE audio video
                push: 'groups',
                reg: /^group:(\w*) (.*)/,
                names: ['type', 'mids'],
                format: "group:%s %s"
            },
            { //a=rtcp-mux
                name: 'rtcpMux',
                reg: /^(rtcp-mux)/
            },
            { //a=rtcp-rsize
                name: 'rtcpRsize',
                reg: /^(rtcp-rsize)/
            },
            { // any a= that we don't understand is kepts verbatim on media.invalid
                push: 'invalid',
                names: ["value"]
            }
        ]
    };
    
    // set sensible defaults to avoid polluting the grammar with boring details
    Object.keys(grammar).forEach(function (key) {
        var objs = grammar[key];
        objs.forEach(function (obj) {
            if (!obj.reg) {
                obj.reg = /(.*)/;
            }
            if (!obj.format) {
                obj.format = "%s";
            }
        });
    });
    
},{}],116:[function(require,module,exports){
    arguments[4][110][0].apply(exports,arguments)
},{"./parser":117,"./writer":118,"dup":110}],117:[function(require,module,exports){
    var toIntIfInt = function (v) {
        return String(Number(v)) === v ? Number(v) : v;
    };
    
    var attachProperties = function (match, location, names, rawName) {
        if (rawName && !names) {
            location[rawName] = toIntIfInt(match[1]);
        }
        else {
            for (var i = 0; i < names.length; i += 1) {
                if (match[i+1] != null) {
                    location[names[i]] = toIntIfInt(match[i+1]);
                }
            }
        }
    };
    
    var parseReg = function (obj, location, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location[obj.push]) {
            location[obj.push] = [];
        }
        else if (needsBlank && !location[obj.name]) {
            location[obj.name] = {};
        }
        var keyLocation = obj.push ?
        {} :  // blank object that will be pushed
            needsBlank ? location[obj.name] : location; // otherwise, named location or root
        
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        
        if (obj.push) {
            location[obj.push].push(keyLocation);
        }
    };
    
    var grammar = require('./grammar');
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    
    exports.parse = function (sdp) {
        var session = {}
            , media = []
            , location = session; // points at where properties go under (one of the above)
        
        // parse lines we understand
        sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
            var type = l[0];
            var content = l.slice(2);
            if (type === 'm') {
                media.push({rtp: [], fmtp: []});
                location = media[media.length-1]; // point at latest media line
            }
            
            for (var j = 0; j < (grammar[type] || []).length; j += 1) {
                var obj = grammar[type][j];
                if (obj.reg.test(content)) {
                    return parseReg(obj, location, content);
                }
            }
        });
        
        session.media = media; // link it up
        return session;
    };
    
    var fmtpReducer = function (acc, expr) {
        var s = expr.split('=');
        if (s.length === 2) {
            acc[s[0]] = toIntIfInt(s[1]);
        }
        return acc;
    };
    
    exports.parseFmtpConfig = function (str) {
        return str.split(';').reduce(fmtpReducer, {});
    };
    
    exports.parsePayloads = function (str) {
        return str.split(' ').map(Number);
    };
    
    exports.parseRemoteCandidates = function (str) {
        var candidates = [];
        var parts = str.split(' ').map(toIntIfInt);
        for (var i = 0; i < parts.length; i += 3) {
            candidates.push({
                component: parts[i],
                ip: parts[i + 1],
                port: parts[i + 2]
            });
        }
        return candidates;
    };
    
},{"./grammar":115}],118:[function(require,module,exports){
    arguments[4][112][0].apply(exports,arguments)
},{"./grammar":115,"dup":112}],119:[function(require,module,exports){
    arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],120:[function(require,module,exports){
    arguments[4][110][0].apply(exports,arguments)
},{"./parser":121,"./writer":122,"dup":110}],121:[function(require,module,exports){
    arguments[4][111][0].apply(exports,arguments)
},{"./grammar":119,"dup":111}],122:[function(require,module,exports){
    arguments[4][112][0].apply(exports,arguments)
},{"./grammar":119,"dup":112}],123:[function(require,module,exports){
    
    module.exports = require('./lib/');
    
},{"./lib/":124}],124:[function(require,module,exports){
    
    /**
     * Module dependencies.
     */
    
    var url = require('./url');
    var parser = require('socket.io-parser');
    var Manager = require('./manager');
    var debug = require('debug')('socket.io-client');
    
    /**
     * Module exports.
     */
    
    module.exports = exports = lookup;
    
    /**
     * Managers cache.
     */
    
    var cache = exports.managers = {};
    
    /**
     * Looks up an existing `Manager` for multiplexing.
     * If the user summons:
     *
     *   `io('http://localhost/a');`
     *   `io('http://localhost/b');`
     *
     * We reuse the existing instance based on same scheme/port/host,
     * and we initialize sockets for each namespace.
     *
     * @api public
     */
    
    function lookup(uri, opts) {
        if (typeof uri == 'object') {
            opts = uri;
            uri = undefined;
        }
        
        opts = opts || {};
        
        var parsed = url(uri);
        var source = parsed.source;
        var id = parsed.id;
        var io;
        
        if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
            debug('ignoring socket cache for %s', source);
            io = Manager(source, opts);
        } else {
            if (!cache[id]) {
                debug('new io instance for %s', source);
                cache[id] = Manager(source, opts);
            }
            io = cache[id];
        }
        
        return io.socket(parsed.path);
    }
    
    /**
     * Protocol version.
     *
     * @api public
     */
    
    exports.protocol = parser.protocol;
    
    /**
     * `connect`.
     *
     * @param {String} uri
     * @api public
     */
    
    exports.connect = lookup;
    
    /**
     * Expose constructors for standalone build.
     *
     * @api public
     */
    
    exports.Manager = require('./manager');
    exports.Socket = require('./socket');
    
},{"./manager":125,"./socket":127,"./url":128,"debug":132,"socket.io-parser":168}],125:[function(require,module,exports){
    
    /**
     * Module dependencies.
     */
    
    var url = require('./url');
    var eio = require('engine.io-client');
    var Socket = require('./socket');
    var Emitter = require('component-emitter');
    var parser = require('socket.io-parser');
    var on = require('./on');
    var bind = require('component-bind');
    var object = require('object-component');
    var debug = require('debug')('socket.io-client:manager');
    var indexOf = require('indexof');
    var Backoff = require('backo2');
    
    /**
     * Module exports
     */
    
    module.exports = Manager;
    
    /**
     * `Manager` constructor.
     *
     * @param {String} engine instance or engine uri/opts
     * @param {Object} options
     * @api public
     */
    
    function Manager(uri, opts){
        if (!(this instanceof Manager)) return new Manager(uri, opts);
        if (uri && ('object' == typeof uri)) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        
        opts.path = opts.path || '/socket.io';
        this.nsps = {};
        this.subs = [];
        this.opts = opts;
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor(opts.randomizationFactor || 0.5);
        this.backoff = new Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this.readyState = 'closed';
        this.uri = uri;
        this.connected = [];
        this.encoding = false;
        this.packetBuffer = [];
        this.encoder = new parser.Encoder();
        this.decoder = new parser.Decoder();
        this.autoConnect = opts.autoConnect !== false;
        if (this.autoConnect) this.open();
    }
    
    /**
     * Propagate given event to sockets and emit on `this`
     *
     * @api private
     */
    
    Manager.prototype.emitAll = function() {
        this.emit.apply(this, arguments);
        for (var nsp in this.nsps) {
            this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
    };
    
    /**
     * Update `socket.id` of all sockets
     *
     * @api private
     */
    
    Manager.prototype.updateSocketIds = function(){
        for (var nsp in this.nsps) {
            this.nsps[nsp].id = this.engine.id;
        }
    };
    
    /**
     * Mix in `Emitter`.
     */
    
    Emitter(Manager.prototype);
    
    /**
     * Sets the `reconnection` config.
     *
     * @param {Boolean} true/false if it should automatically reconnect
     * @return {Manager} self or value
     * @api public
     */
    
    Manager.prototype.reconnection = function(v){
        if (!arguments.length) return this._reconnection;
        this._reconnection = !!v;
        return this;
    };
    
    /**
     * Sets the reconnection attempts config.
     *
     * @param {Number} max reconnection attempts before giving up
     * @return {Manager} self or value
     * @api public
     */
    
    Manager.prototype.reconnectionAttempts = function(v){
        if (!arguments.length) return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    };
    
    /**
     * Sets the delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */
    
    Manager.prototype.reconnectionDelay = function(v){
        if (!arguments.length) return this._reconnectionDelay;
        this._reconnectionDelay = v;
        this.backoff && this.backoff.setMin(v);
        return this;
    };
    
    Manager.prototype.randomizationFactor = function(v){
        if (!arguments.length) return this._randomizationFactor;
        this._randomizationFactor = v;
        this.backoff && this.backoff.setJitter(v);
        return this;
    };
    
    /**
     * Sets the maximum delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */
    
    Manager.prototype.reconnectionDelayMax = function(v){
        if (!arguments.length) return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        this.backoff && this.backoff.setMax(v);
        return this;
    };
    
    /**
     * Sets the connection timeout. `false` to disable
     *
     * @return {Manager} self or value
     * @api public
     */
    
    Manager.prototype.timeout = function(v){
        if (!arguments.length) return this._timeout;
        this._timeout = v;
        return this;
    };
    
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @api private
     */
    
    Manager.prototype.maybeReconnectOnOpen = function() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    };
    
    
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} optional, callback
     * @return {Manager} self
     * @api public
     */
    
    Manager.prototype.open =
        Manager.prototype.connect = function(fn){
            debug('readyState %s', this.readyState);
            if (~this.readyState.indexOf('open')) return this;
            
            debug('opening %s', this.uri);
            this.engine = eio(this.uri, this.opts);
            var socket = this.engine;
            var self = this;
            this.readyState = 'opening';
            this.skipReconnect = false;
            
            // emit `open`
            var openSub = on(socket, 'open', function() {
                self.onopen();
                fn && fn();
            });
            
            // emit `connect_error`
            var errorSub = on(socket, 'error', function(data){
                debug('connect_error');
                self.cleanup();
                self.readyState = 'closed';
                self.emitAll('connect_error', data);
                if (fn) {
                    var err = new Error('Connection error');
                    err.data = data;
                    fn(err);
                } else {
                    // Only do this if there is no fn to handle the error
                    self.maybeReconnectOnOpen();
                }
            });
            
            // emit `connect_timeout`
            if (false !== this._timeout) {
                var timeout = this._timeout;
                debug('connect attempt will timeout after %d', timeout);
                
                // set timer
                var timer = setTimeout(function(){
                    debug('connect attempt timed out after %d', timeout);
                    openSub.destroy();
                    socket.close();
                    socket.emit('error', 'timeout');
                    self.emitAll('connect_timeout', timeout);
                }, timeout);
                
                this.subs.push({
                    destroy: function(){
                        clearTimeout(timer);
                    }
                });
            }
            
            this.subs.push(openSub);
            this.subs.push(errorSub);
            
            return this;
        };
    
    /**
     * Called upon transport open.
     *
     * @api private
     */
    
    Manager.prototype.onopen = function(){
        debug('open');
        
        // clear old subs
        this.cleanup();
        
        // mark as open
        this.readyState = 'open';
        this.emit('open');
        
        // add new subs
        var socket = this.engine;
        this.subs.push(on(socket, 'data', bind(this, 'ondata')));
        this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
        this.subs.push(on(socket, 'error', bind(this, 'onerror')));
        this.subs.push(on(socket, 'close', bind(this, 'onclose')));
    };
    
    /**
     * Called with data.
     *
     * @api private
     */
    
    Manager.prototype.ondata = function(data){
        this.decoder.add(data);
    };
    
    /**
     * Called when parser fully decodes a packet.
     *
     * @api private
     */
    
    Manager.prototype.ondecoded = function(packet) {
        this.emit('packet', packet);
    };
    
    /**
     * Called upon socket error.
     *
     * @api private
     */
    
    Manager.prototype.onerror = function(err){
        debug('error', err);
        this.emitAll('error', err);
    };
    
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @api public
     */
    
    Manager.prototype.socket = function(nsp){
        var socket = this.nsps[nsp];
        if (!socket) {
            socket = new Socket(this, nsp);
            this.nsps[nsp] = socket;
            var self = this;
            socket.on('connect', function(){
                socket.id = self.engine.id;
                if (!~indexOf(self.connected, socket)) {
                    self.connected.push(socket);
                }
            });
        }
        return socket;
    };
    
    /**
     * Called upon a socket close.
     *
     * @param {Socket} socket
     */
    
    Manager.prototype.destroy = function(socket){
        var index = indexOf(this.connected, socket);
        if (~index) this.connected.splice(index, 1);
        if (this.connected.length) return;
        
        this.close();
    };
    
    /**
     * Writes a packet.
     *
     * @param {Object} packet
     * @api private
     */
    
    Manager.prototype.packet = function(packet){
        debug('writing packet %j', packet);
        var self = this;
        
        if (!self.encoding) {
            // encode, then write to engine with result
            self.encoding = true;
            this.encoder.encode(packet, function(encodedPackets) {
                for (var i = 0; i < encodedPackets.length; i++) {
                    self.engine.write(encodedPackets[i]);
                }
                self.encoding = false;
                self.processPacketQueue();
            });
        } else { // add packet to the queue
            self.packetBuffer.push(packet);
        }
    };
    
    /**
     * If packet buffer is non-empty, begins encoding the
     * next packet in line.
     *
     * @api private
     */
    
    Manager.prototype.processPacketQueue = function() {
        if (this.packetBuffer.length > 0 && !this.encoding) {
            var pack = this.packetBuffer.shift();
            this.packet(pack);
        }
    };
    
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @api private
     */
    
    Manager.prototype.cleanup = function(){
        var sub;
        while (sub = this.subs.shift()) sub.destroy();
        
        this.packetBuffer = [];
        this.encoding = false;
        
        this.decoder.destroy();
    };
    
    /**
     * Close the current socket.
     *
     * @api private
     */
    
    Manager.prototype.close =
        Manager.prototype.disconnect = function(){
            this.skipReconnect = true;
            this.backoff.reset();
            this.readyState = 'closed';
            this.engine && this.engine.close();
        };
    
    /**
     * Called upon engine close.
     *
     * @api private
     */
    
    Manager.prototype.onclose = function(reason){
        debug('close');
        this.cleanup();
        this.backoff.reset();
        this.readyState = 'closed';
        this.emit('close', reason);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    };
    
    /**
     * Attempt a reconnection.
     *
     * @api private
     */
    
    Manager.prototype.reconnect = function(){
        if (this.reconnecting || this.skipReconnect) return this;
        
        var self = this;
        
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug('reconnect failed');
            this.backoff.reset();
            this.emitAll('reconnect_failed');
            this.reconnecting = false;
        } else {
            var delay = this.backoff.duration();
            debug('will wait %dms before reconnect attempt', delay);
            
            this.reconnecting = true;
            var timer = setTimeout(function(){
                if (self.skipReconnect) return;
                
                debug('attempting reconnect');
                self.emitAll('reconnect_attempt', self.backoff.attempts);
                self.emitAll('reconnecting', self.backoff.attempts);
                
                // check again for the case socket closed in above events
                if (self.skipReconnect) return;
                
                self.open(function(err){
                    if (err) {
                        debug('reconnect attempt error');
                        self.reconnecting = false;
                        self.reconnect();
                        self.emitAll('reconnect_error', err.data);
                    } else {
                        debug('reconnect success');
                        self.onreconnect();
                    }
                });
            }, delay);
            
            this.subs.push({
                destroy: function(){
                    clearTimeout(timer);
                }
            });
        }
    };
    
    /**
     * Called upon successful reconnect.
     *
     * @api private
     */
    
    Manager.prototype.onreconnect = function(){
        var attempt = this.backoff.attempts;
        this.reconnecting = false;
        this.backoff.reset();
        this.updateSocketIds();
        this.emitAll('reconnect', attempt);
    };
    
},{"./on":126,"./socket":127,"./url":128,"backo2":129,"component-bind":130,"component-emitter":131,"debug":132,"engine.io-client":133,"indexof":164,"object-component":165,"socket.io-parser":168}],126:[function(require,module,exports){
    
    /**
     * Module exports.
     */
    
    module.exports = on;
    
    /**
     * Helper for subscriptions.
     *
     * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
     * @param {String} event name
     * @param {Function} callback
     * @api public
     */
    
    function on(obj, ev, fn) {
        obj.on(ev, fn);
        return {
            destroy: function(){
                obj.removeListener(ev, fn);
            }
        };
    }
    
},{}],127:[function(require,module,exports){
    
    /**
     * Module dependencies.
     */
    
    var parser = require('socket.io-parser');
    var Emitter = require('component-emitter');
    var toArray = require('to-array');
    var on = require('./on');
    var bind = require('component-bind');
    var debug = require('debug')('socket.io-client:socket');
    var hasBin = require('has-binary');
    
    /**
     * Module exports.
     */
    
    module.exports = exports = Socket;
    
    /**
     * Internal events (blacklisted).
     * These events can't be emitted by the user.
     *
     * @api private
     */
    
    var events = {
        connect: 1,
        connect_error: 1,
        connect_timeout: 1,
        disconnect: 1,
        error: 1,
        reconnect: 1,
        reconnect_attempt: 1,
        reconnect_failed: 1,
        reconnect_error: 1,
        reconnecting: 1
    };
    
    /**
     * Shortcut to `Emitter#emit`.
     */
    
    var emit = Emitter.prototype.emit;
    
    /**
     * `Socket` constructor.
     *
     * @api public
     */
    
    function Socket(io, nsp){
        this.io = io;
        this.nsp = nsp;
        this.json = this; // compat
        this.ids = 0;
        this.acks = {};
        if (this.io.autoConnect) this.open();
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.connected = false;
        this.disconnected = true;
    }
    
    /**
     * Mix in `Emitter`.
     */
    
    Emitter(Socket.prototype);
    
    /**
     * Subscribe to open, close and packet events
     *
     * @api private
     */
    
    Socket.prototype.subEvents = function() {
        if (this.subs) return;
        
        var io = this.io;
        this.subs = [
            on(io, 'open', bind(this, 'onopen')),
            on(io, 'packet', bind(this, 'onpacket')),
            on(io, 'close', bind(this, 'onclose'))
        ];
    };
    
    /**
     * "Opens" the socket.
     *
     * @api public
     */
    
    Socket.prototype.open =
        Socket.prototype.connect = function(){
            if (this.connected) return this;
            
            this.subEvents();
            this.io.open(); // ensure open
            if ('open' == this.io.readyState) this.onopen();
            return this;
        };
    
    /**
     * Sends a `message` event.
     *
     * @return {Socket} self
     * @api public
     */
    
    Socket.prototype.send = function(){
        var args = toArray(arguments);
        args.unshift('message');
        this.emit.apply(this, args);
        return this;
    };
    
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @param {String} event name
     * @return {Socket} self
     * @api public
     */
    
    Socket.prototype.emit = function(ev){
        if (events.hasOwnProperty(ev)) {
            emit.apply(this, arguments);
            return this;
        }
        
        var args = toArray(arguments);
        var parserType = parser.EVENT; // default
        if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
        var packet = { type: parserType, data: args };
        
        // event ack callback
        if ('function' == typeof args[args.length - 1]) {
            debug('emitting packet with ack id %d', this.ids);
            this.acks[this.ids] = args.pop();
            packet.id = this.ids++;
        }
        
        if (this.connected) {
            this.packet(packet);
        } else {
            this.sendBuffer.push(packet);
        }
        
        return this;
    };
    
    /**
     * Sends a packet.
     *
     * @param {Object} packet
     * @api private
     */
    
    Socket.prototype.packet = function(packet){
        packet.nsp = this.nsp;
        this.io.packet(packet);
    };
    
    /**
     * Called upon engine `open`.
     *
     * @api private
     */
    
    Socket.prototype.onopen = function(){
        debug('transport is open - connecting');
        
        // write connect packet if necessary
        if ('/' != this.nsp) {
            this.packet({ type: parser.CONNECT });
        }
    };
    
    /**
     * Called upon engine `close`.
     *
     * @param {String} reason
     * @api private
     */
    
    Socket.prototype.onclose = function(reason){
        debug('close (%s)', reason);
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emit('disconnect', reason);
    };
    
    /**
     * Called with socket packet.
     *
     * @param {Object} packet
     * @api private
     */
    
    Socket.prototype.onpacket = function(packet){
        if (packet.nsp != this.nsp) return;
        
        switch (packet.type) {
            case parser.CONNECT:
                this.onconnect();
                break;
            
            case parser.EVENT:
                this.onevent(packet);
                break;
            
            case parser.BINARY_EVENT:
                this.onevent(packet);
                break;
            
            case parser.ACK:
                this.onack(packet);
                break;
            
            case parser.BINARY_ACK:
                this.onack(packet);
                break;
            
            case parser.DISCONNECT:
                this.ondisconnect();
                break;
            
            case parser.ERROR:
                this.emit('error', packet.data);
                break;
        }
    };
    
    /**
     * Called upon a server event.
     *
     * @param {Object} packet
     * @api private
     */
    
    Socket.prototype.onevent = function(packet){
        var args = packet.data || [];
        debug('emitting event %j', args);
        
        if (null != packet.id) {
            debug('attaching ack callback to event');
            args.push(this.ack(packet.id));
        }
        
        if (this.connected) {
            emit.apply(this, args);
        } else {
            this.receiveBuffer.push(args);
        }
    };
    
    /**
     * Produces an ack callback to emit with an event.
     *
     * @api private
     */
    
    Socket.prototype.ack = function(id){
        var self = this;
        var sent = false;
        return function(){
            // prevent double callbacks
            if (sent) return;
            sent = true;
            var args = toArray(arguments);
            debug('sending ack %j', args);
            
            var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
            self.packet({
                type: type,
                id: id,
                data: args
            });
        };
    };
    
    /**
     * Called upon a server acknowlegement.
     *
     * @param {Object} packet
     * @api private
     */
    
    Socket.prototype.onack = function(packet){
        debug('calling ack %s with %j', packet.id, packet.data);
        var fn = this.acks[packet.id];
        fn.apply(this, packet.data);
        delete this.acks[packet.id];
    };
    
    /**
     * Called upon server connect.
     *
     * @api private
     */
    
    Socket.prototype.onconnect = function(){
        this.connected = true;
        this.disconnected = false;
        this.emit('connect');
        this.emitBuffered();
    };
    
    /**
     * Emit buffered events (received and emitted).
     *
     * @api private
     */
    
    Socket.prototype.emitBuffered = function(){
        var i;
        for (i = 0; i < this.receiveBuffer.length; i++) {
            emit.apply(this, this.receiveBuffer[i]);
        }
        this.receiveBuffer = [];
        
        for (i = 0; i < this.sendBuffer.length; i++) {
            this.packet(this.sendBuffer[i]);
        }
        this.sendBuffer = [];
    };
    
    /**
     * Called upon server disconnect.
     *
     * @api private
     */
    
    Socket.prototype.ondisconnect = function(){
        debug('server disconnect (%s)', this.nsp);
        this.destroy();
        this.onclose('io server disconnect');
    };
    
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @api private.
     */
    
    Socket.prototype.destroy = function(){
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            for (var i = 0; i < this.subs.length; i++) {
                this.subs[i].destroy();
            }
            this.subs = null;
        }
        
        this.io.destroy(this);
    };
    
    /**
     * Disconnects the socket manually.
     *
     * @return {Socket} self
     * @api public
     */
    
    Socket.prototype.close =
        Socket.prototype.disconnect = function(){
            if (this.connected) {
                debug('performing disconnect (%s)', this.nsp);
                this.packet({ type: parser.DISCONNECT });
            }
            
            // remove socket from pool
            this.destroy();
            
            if (this.connected) {
                // fire events
                this.onclose('io client disconnect');
            }
            return this;
        };
    
},{"./on":126,"component-bind":130,"component-emitter":131,"debug":132,"has-binary":162,"socket.io-parser":168,"to-array":172}],128:[function(require,module,exports){
    (function (global){
        
        /**
         * Module dependencies.
         */
        
        var parseuri = require('parseuri');
        var debug = require('debug')('socket.io-client:url');
        
        /**
         * Module exports.
         */
        
        module.exports = url;
        
        /**
         * URL parser.
         *
         * @param {String} url
         * @param {Object} An object meant to mimic window.location.
         *                 Defaults to window.location.
         * @api public
         */
        
        function url(uri, loc){
            var obj = uri;
            
            // default to window.location
            var loc = loc || global.location;
            if (null == uri) uri = loc.protocol + '//' + loc.host;
            
            // relative path support
            if ('string' == typeof uri) {
                if ('/' == uri.charAt(0)) {
                    if ('/' == uri.charAt(1)) {
                        uri = loc.protocol + uri;
                    } else {
                        uri = loc.hostname + uri;
                    }
                }
                
                if (!/^(https?|wss?):\/\//.test(uri)) {
                    debug('protocol-less url %s', uri);
                    if ('undefined' != typeof loc) {
                        uri = loc.protocol + '//' + uri;
                    } else {
                        uri = 'https://' + uri;
                    }
                }
                
                // parse
                debug('parse %s', uri);
                obj = parseuri(uri);
            }
            
            // make sure we treat `localhost:80` and `localhost` equally
            if (!obj.port) {
                if (/^(http|ws)$/.test(obj.protocol)) {
                    obj.port = '80';
                }
                else if (/^(http|ws)s$/.test(obj.protocol)) {
                    obj.port = '443';
                }
            }
            
            obj.path = obj.path || '/';
            
            // define unique id
            obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
            // define href
            obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
            
            return obj;
        }
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"debug":132,"parseuri":166}],129:[function(require,module,exports){
    
    /**
     * Expose `Backoff`.
     */
    
    module.exports = Backoff;
    
    /**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */
    
    function Backoff(opts) {
        opts = opts || {};
        this.ms = opts.min || 100;
        this.max = opts.max || 10000;
        this.factor = opts.factor || 2;
        this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
        this.attempts = 0;
    }
    
    /**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */
    
    Backoff.prototype.duration = function(){
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
            var rand =  Math.random();
            var deviation = Math.floor(rand * this.jitter * ms);
            ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
    };
    
    /**
     * Reset the number of attempts.
     *
     * @api public
     */
    
    Backoff.prototype.reset = function(){
        this.attempts = 0;
    };
    
    /**
     * Set the minimum duration
     *
     * @api public
     */
    
    Backoff.prototype.setMin = function(min){
        this.ms = min;
    };
    
    /**
     * Set the maximum duration
     *
     * @api public
     */
    
    Backoff.prototype.setMax = function(max){
        this.max = max;
    };
    
    /**
     * Set the jitter
     *
     * @api public
     */
    
    Backoff.prototype.setJitter = function(jitter){
        this.jitter = jitter;
    };
    
    
},{}],130:[function(require,module,exports){
    /**
     * Slice reference.
     */
    
    var slice = [].slice;
    
    /**
     * Bind `obj` to `fn`.
     *
     * @param {Object} obj
     * @param {Function|String} fn or string
     * @return {Function}
     * @api public
     */
    
    module.exports = function(obj, fn){
        if ('string' == typeof fn) fn = obj[fn];
        if ('function' != typeof fn) throw new Error('bind() requires a function');
        var args = slice.call(arguments, 2);
        return function(){
            return fn.apply(obj, args.concat(slice.call(arguments)));
        }
    };
    
},{}],131:[function(require,module,exports){
    
    /**
     * Expose `Emitter`.
     */
    
    module.exports = Emitter;
    
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */
    
    function Emitter(obj) {
        if (obj) return mixin(obj);
    };
    
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */
    
    function mixin(obj) {
        for (var key in Emitter.prototype) {
            obj[key] = Emitter.prototype[key];
        }
        return obj;
    }
    
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.on =
        Emitter.prototype.addEventListener = function(event, fn){
            this._callbacks = this._callbacks || {};
            (this._callbacks[event] = this._callbacks[event] || [])
                .push(fn);
            return this;
        };
    
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.once = function(event, fn){
        var self = this;
        this._callbacks = this._callbacks || {};
        
        function on() {
            self.off(event, on);
            fn.apply(this, arguments);
        }
        
        on.fn = fn;
        this.on(event, on);
        return this;
    };
    
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.off =
        Emitter.prototype.removeListener =
            Emitter.prototype.removeAllListeners =
                Emitter.prototype.removeEventListener = function(event, fn){
                    this._callbacks = this._callbacks || {};
                    
                    // all
                    if (0 == arguments.length) {
                        this._callbacks = {};
                        return this;
                    }
                    
                    // specific event
                    var callbacks = this._callbacks[event];
                    if (!callbacks) return this;
                    
                    // remove all handlers
                    if (1 == arguments.length) {
                        delete this._callbacks[event];
                        return this;
                    }
                    
                    // remove specific handler
                    var cb;
                    for (var i = 0; i < callbacks.length; i++) {
                        cb = callbacks[i];
                        if (cb === fn || cb.fn === fn) {
                            callbacks.splice(i, 1);
                            break;
                        }
                    }
                    return this;
                };
    
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */
    
    Emitter.prototype.emit = function(event){
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1)
            , callbacks = this._callbacks[event];
        
        if (callbacks) {
            callbacks = callbacks.slice(0);
            for (var i = 0, len = callbacks.length; i < len; ++i) {
                callbacks[i].apply(this, args);
            }
        }
        
        return this;
    };
    
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */
    
    Emitter.prototype.listeners = function(event){
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
    };
    
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */
    
    Emitter.prototype.hasListeners = function(event){
        return !! this.listeners(event).length;
    };
    
},{}],132:[function(require,module,exports){
    
    /**
     * Expose `debug()` as the module.
     */
    
    module.exports = debug;
    
    /**
     * Create a debugger with the given `name`.
     *
     * @param {String} name
     * @return {Type}
     * @api public
     */
    
    function debug(name) {
        if (!debug.enabled(name)) return function(){};
        
        return function(fmt){
            fmt = coerce(fmt);
            
            var curr = new Date;
            var ms = curr - (debug[name] || curr);
            debug[name] = curr;
            
            fmt = name
                + ' '
                + fmt
                + ' +' + debug.humanize(ms);
            
            // This hackery is required for IE8
            // where `console.log` doesn't have 'apply'
            window.console
            && console.log
            && Function.prototype.apply.call(console.log, console, arguments);
        }
    }
    
    /**
     * The currently active debug mode names.
     */
    
    debug.names = [];
    debug.skips = [];
    
    /**
     * Enables a debug mode by name. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} name
     * @api public
     */
    
    debug.enable = function(name) {
        try {
            localStorage.debug = name;
        } catch(e){}
        
        var split = (name || '').split(/[\s,]+/)
            , len = split.length;
        
        for (var i = 0; i < len; i++) {
            name = split[i].replace('*', '.*?');
            if (name[0] === '-') {
                debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
            }
            else {
                debug.names.push(new RegExp('^' + name + '$'));
            }
        }
    };
    
    /**
     * Disable debug output.
     *
     * @api public
     */
    
    debug.disable = function(){
        debug.enable('');
    };
    
    /**
     * Humanize the given `ms`.
     *
     * @param {Number} m
     * @return {String}
     * @api private
     */
    
    debug.humanize = function(ms) {
        var sec = 1000
            , min = 60 * 1000
            , hour = 60 * min;
        
        if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
        if (ms >= min) return (ms / min).toFixed(1) + 'm';
        if (ms >= sec) return (ms / sec | 0) + 's';
        return ms + 'ms';
    };
    
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */
    
    debug.enabled = function(name) {
        for (var i = 0, len = debug.skips.length; i < len; i++) {
            if (debug.skips[i].test(name)) {
                return false;
            }
        }
        for (var i = 0, len = debug.names.length; i < len; i++) {
            if (debug.names[i].test(name)) {
                return true;
            }
        }
        return false;
    };
    
    /**
     * Coerce `val`.
     */
    
    function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    
    // persist
    
    try {
        if (window.localStorage) debug.enable(localStorage.debug);
    } catch(e){}
    
},{}],133:[function(require,module,exports){
    
    module.exports =  require('./lib/');
    
},{"./lib/":134}],134:[function(require,module,exports){
    
    module.exports = require('./socket');
    
    /**
     * Exports parser
     *
     * @api public
     *
     */
    module.exports.parser = require('engine.io-parser');
    
},{"./socket":135,"engine.io-parser":147}],135:[function(require,module,exports){
    (function (global){
        /**
         * Module dependencies.
         */
        
        var transports = require('./transports');
        var Emitter = require('component-emitter');
        var debug = require('debug')('engine.io-client:socket');
        var index = require('indexof');
        var parser = require('engine.io-parser');
        var parseuri = require('parseuri');
        var parsejson = require('parsejson');
        var parseqs = require('parseqs');
        
        /**
         * Module exports.
         */
        
        module.exports = Socket;
        
        /**
         * Noop function.
         *
         * @api private
         */
        
        function noop(){}
        
        /**
         * Socket constructor.
         *
         * @param {String|Object} uri or options
         * @param {Object} options
         * @api public
         */
        
        function Socket(uri, opts){
            if (!(this instanceof Socket)) return new Socket(uri, opts);
            
            opts = opts || {};
            
            if (uri && 'object' == typeof uri) {
                opts = uri;
                uri = null;
            }
            
            if (uri) {
                uri = parseuri(uri);
                opts.host = uri.host;
                opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
                opts.port = uri.port;
                if (uri.query) opts.query = uri.query;
            }
            
            this.secure = null != opts.secure ? opts.secure :
                (global.location && 'https:' == location.protocol);
            
            if (opts.host) {
                var pieces = opts.host.split(':');
                opts.hostname = pieces.shift();
                if (pieces.length) {
                    opts.port = pieces.pop();
                } else if (!opts.port) {
                    // if no port is specified manually, use the protocol default
                    opts.port = this.secure ? '443' : '80';
                }
            }
            
            this.agent = opts.agent || false;
            this.hostname = opts.hostname ||
                (global.location ? location.hostname : 'localhost');
            this.port = opts.port || (global.location && location.port ?
                    location.port :
                    (this.secure ? 443 : 80));
            this.query = opts.query || {};
            if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
            this.upgrade = false !== opts.upgrade;
            this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
            this.forceJSONP = !!opts.forceJSONP;
            this.jsonp = false !== opts.jsonp;
            this.forceBase64 = !!opts.forceBase64;
            this.enablesXDR = !!opts.enablesXDR;
            this.timestampParam = opts.timestampParam || 't';
            this.timestampRequests = opts.timestampRequests;
            this.transports = opts.transports || ['polling', 'websocket'];
            this.readyState = '';
            this.writeBuffer = [];
            this.callbackBuffer = [];
            this.policyPort = opts.policyPort || 843;
            this.rememberUpgrade = opts.rememberUpgrade || false;
            this.binaryType = null;
            this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
            
            // SSL options for Node.js client
            this.pfx = opts.pfx || null;
            this.key = opts.key || null;
            this.passphrase = opts.passphrase || null;
            this.cert = opts.cert || null;
            this.ca = opts.ca || null;
            this.ciphers = opts.ciphers || null;
            this.rejectUnauthorized = opts.rejectUnauthorized || null;
            
            this.open();
        }
        
        Socket.priorWebsocketSuccess = false;
        
        /**
         * Mix in `Emitter`.
         */
        
        Emitter(Socket.prototype);
        
        /**
         * Protocol version.
         *
         * @api public
         */
        
        Socket.protocol = parser.protocol; // this is an int
        
        /**
         * Expose deps for legacy compatibility
         * and standalone browser access.
         */
        
        Socket.Socket = Socket;
        Socket.Transport = require('./transport');
        Socket.transports = require('./transports');
        Socket.parser = require('engine.io-parser');
        
        /**
         * Creates transport of the given type.
         *
         * @param {String} transport name
         * @return {Transport}
         * @api private
         */
        
        Socket.prototype.createTransport = function (name) {
            debug('creating transport "%s"', name);
            var query = clone(this.query);
            
            // append engine.io protocol identifier
            query.EIO = parser.protocol;
            
            // transport name
            query.transport = name;
            
            // session id if we already have one
            if (this.id) query.sid = this.id;
            
            var transport = new transports[name]({
                agent: this.agent,
                hostname: this.hostname,
                port: this.port,
                secure: this.secure,
                path: this.path,
                query: query,
                forceJSONP: this.forceJSONP,
                jsonp: this.jsonp,
                forceBase64: this.forceBase64,
                enablesXDR: this.enablesXDR,
                timestampRequests: this.timestampRequests,
                timestampParam: this.timestampParam,
                policyPort: this.policyPort,
                socket: this,
                pfx: this.pfx,
                key: this.key,
                passphrase: this.passphrase,
                cert: this.cert,
                ca: this.ca,
                ciphers: this.ciphers,
                rejectUnauthorized: this.rejectUnauthorized
            });
            
            return transport;
        };
        
        function clone (obj) {
            var o = {};
            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    o[i] = obj[i];
                }
            }
            return o;
        }
        
        /**
         * Initializes transport to use and starts probe.
         *
         * @api private
         */
        Socket.prototype.open = function () {
            var transport;
            if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
                transport = 'websocket';
            } else if (0 == this.transports.length) {
                // Emit error on next tick so it can be listened to
                var self = this;
                setTimeout(function() {
                    self.emit('error', 'No transports available');
                }, 0);
                return;
            } else {
                transport = this.transports[0];
            }
            this.readyState = 'opening';
            
            // Retry with the next transport if the transport is disabled (jsonp: false)
            var transport;
            try {
                transport = this.createTransport(transport);
            } catch (e) {
                this.transports.shift();
                this.open();
                return;
            }
            
            transport.open();
            this.setTransport(transport);
        };
        
        /**
         * Sets the current transport. Disables the existing one (if any).
         *
         * @api private
         */
        
        Socket.prototype.setTransport = function(transport){
            debug('setting transport %s', transport.name);
            var self = this;
            
            if (this.transport) {
                debug('clearing existing transport %s', this.transport.name);
                this.transport.removeAllListeners();
            }
            
            // set up transport
            this.transport = transport;
            
            // set up transport listeners
            transport
                .on('drain', function(){
                    self.onDrain();
                })
                .on('packet', function(packet){
                    self.onPacket(packet);
                })
                .on('error', function(e){
                    self.onError(e);
                })
                .on('close', function(){
                    self.onClose('transport close');
                });
        };
        
        /**
         * Probes a transport.
         *
         * @param {String} transport name
         * @api private
         */
        
        Socket.prototype.probe = function (name) {
            debug('probing transport "%s"', name);
            var transport = this.createTransport(name, { probe: 1 })
                , failed = false
                , self = this;
            
            Socket.priorWebsocketSuccess = false;
            
            function onTransportOpen(){
                if (self.onlyBinaryUpgrades) {
                    var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
                    failed = failed || upgradeLosesBinary;
                }
                if (failed) return;
                
                debug('probe transport "%s" opened', name);
                transport.send([{ type: 'ping', data: 'probe' }]);
                transport.once('packet', function (msg) {
                    if (failed) return;
                    if ('pong' == msg.type && 'probe' == msg.data) {
                        debug('probe transport "%s" pong', name);
                        self.upgrading = true;
                        self.emit('upgrading', transport);
                        if (!transport) return;
                        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
                        
                        debug('pausing current transport "%s"', self.transport.name);
                        self.transport.pause(function () {
                            if (failed) return;
                            if ('closed' == self.readyState) return;
                            debug('changing transport and sending upgrade packet');
                            
                            cleanup();
                            
                            self.setTransport(transport);
                            transport.send([{ type: 'upgrade' }]);
                            self.emit('upgrade', transport);
                            transport = null;
                            self.upgrading = false;
                            self.flush();
                        });
                    } else {
                        debug('probe transport "%s" failed', name);
                        var err = new Error('probe error');
                        err.transport = transport.name;
                        self.emit('upgradeError', err);
                    }
                });
            }
            
            function freezeTransport() {
                if (failed) return;
                
                // Any callback called by transport should be ignored since now
                failed = true;
                
                cleanup();
                
                transport.close();
                transport = null;
            }
            
            //Handle any error that happens while probing
            function onerror(err) {
                var error = new Error('probe error: ' + err);
                error.transport = transport.name;
                
                freezeTransport();
                
                debug('probe transport "%s" failed because of error: %s', name, err);
                
                self.emit('upgradeError', error);
            }
            
            function onTransportClose(){
                onerror("transport closed");
            }
            
            //When the socket is closed while we're probing
            function onclose(){
                onerror("socket closed");
            }
            
            //When the socket is upgraded while we're probing
            function onupgrade(to){
                if (transport && to.name != transport.name) {
                    debug('"%s" works - aborting "%s"', to.name, transport.name);
                    freezeTransport();
                }
            }
            
            //Remove all listeners on the transport and on self
            function cleanup(){
                transport.removeListener('open', onTransportOpen);
                transport.removeListener('error', onerror);
                transport.removeListener('close', onTransportClose);
                self.removeListener('close', onclose);
                self.removeListener('upgrading', onupgrade);
            }
            
            transport.once('open', onTransportOpen);
            transport.once('error', onerror);
            transport.once('close', onTransportClose);
            
            this.once('close', onclose);
            this.once('upgrading', onupgrade);
            
            transport.open();
            
        };
        
        /**
         * Called when connection is deemed open.
         *
         * @api public
         */
        
        Socket.prototype.onOpen = function () {
            debug('socket open');
            this.readyState = 'open';
            Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
            this.emit('open');
            this.flush();
            
            // we check for `readyState` in case an `open`
            // listener already closed the socket
            if ('open' == this.readyState && this.upgrade && this.transport.pause) {
                debug('starting upgrade probes');
                for (var i = 0, l = this.upgrades.length; i < l; i++) {
                    this.probe(this.upgrades[i]);
                }
            }
        };
        
        /**
         * Handles a packet.
         *
         * @api private
         */
        
        Socket.prototype.onPacket = function (packet) {
            if ('opening' == this.readyState || 'open' == this.readyState) {
                debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
                
                this.emit('packet', packet);
                
                // Socket is live - any packet counts
                this.emit('heartbeat');
                
                switch (packet.type) {
                    case 'open':
                        this.onHandshake(parsejson(packet.data));
                        break;
                    
                    case 'pong':
                        this.setPing();
                        break;
                    
                    case 'error':
                        var err = new Error('server error');
                        err.code = packet.data;
                        this.emit('error', err);
                        break;
                    
                    case 'message':
                        this.emit('data', packet.data);
                        this.emit('message', packet.data);
                        break;
                }
            } else {
                debug('packet received with socket readyState "%s"', this.readyState);
            }
        };
        
        /**
         * Called upon handshake completion.
         *
         * @param {Object} handshake obj
         * @api private
         */
        
        Socket.prototype.onHandshake = function (data) {
            this.emit('handshake', data);
            this.id = data.sid;
            this.transport.query.sid = data.sid;
            this.upgrades = this.filterUpgrades(data.upgrades);
            this.pingInterval = data.pingInterval;
            this.pingTimeout = data.pingTimeout;
            this.onOpen();
            // In case open handler closes socket
            if  ('closed' == this.readyState) return;
            this.setPing();
            
            // Prolong liveness of socket on heartbeat
            this.removeListener('heartbeat', this.onHeartbeat);
            this.on('heartbeat', this.onHeartbeat);
        };
        
        /**
         * Resets ping timeout.
         *
         * @api private
         */
        
        Socket.prototype.onHeartbeat = function (timeout) {
            clearTimeout(this.pingTimeoutTimer);
            var self = this;
            self.pingTimeoutTimer = setTimeout(function () {
                if ('closed' == self.readyState) return;
                self.onClose('ping timeout');
            }, timeout || (self.pingInterval + self.pingTimeout));
        };
        
        /**
         * Pings server every `this.pingInterval` and expects response
         * within `this.pingTimeout` or closes connection.
         *
         * @api private
         */
        
        Socket.prototype.setPing = function () {
            var self = this;
            clearTimeout(self.pingIntervalTimer);
            self.pingIntervalTimer = setTimeout(function () {
                debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
                self.ping();
                self.onHeartbeat(self.pingTimeout);
            }, self.pingInterval);
        };
        
        /**
         * Sends a ping packet.
         *
         * @api public
         */
        
        Socket.prototype.ping = function () {
            this.sendPacket('ping');
        };
        
        /**
         * Called on `drain` event
         *
         * @api private
         */
        
        Socket.prototype.onDrain = function() {
            for (var i = 0; i < this.prevBufferLen; i++) {
                if (this.callbackBuffer[i]) {
                    this.callbackBuffer[i]();
                }
            }
            
            this.writeBuffer.splice(0, this.prevBufferLen);
            this.callbackBuffer.splice(0, this.prevBufferLen);
            
            // setting prevBufferLen = 0 is very important
            // for example, when upgrading, upgrade packet is sent over,
            // and a nonzero prevBufferLen could cause problems on `drain`
            this.prevBufferLen = 0;
            
            if (this.writeBuffer.length == 0) {
                this.emit('drain');
            } else {
                this.flush();
            }
        };
        
        /**
         * Flush write buffers.
         *
         * @api private
         */
        
        Socket.prototype.flush = function () {
            if ('closed' != this.readyState && this.transport.writable &&
                !this.upgrading && this.writeBuffer.length) {
                debug('flushing %d packets in socket', this.writeBuffer.length);
                this.transport.send(this.writeBuffer);
                // keep track of current length of writeBuffer
                // splice writeBuffer and callbackBuffer on `drain`
                this.prevBufferLen = this.writeBuffer.length;
                this.emit('flush');
            }
        };
        
        /**
         * Sends a message.
         *
         * @param {String} message.
         * @param {Function} callback function.
         * @return {Socket} for chaining.
         * @api public
         */
        
        Socket.prototype.write =
            Socket.prototype.send = function (msg, fn) {
                this.sendPacket('message', msg, fn);
                return this;
            };
        
        /**
         * Sends a packet.
         *
         * @param {String} packet type.
         * @param {String} data.
         * @param {Function} callback function.
         * @api private
         */
        
        Socket.prototype.sendPacket = function (type, data, fn) {
            if ('closing' == this.readyState || 'closed' == this.readyState) {
                return;
            }
            
            var packet = { type: type, data: data };
            this.emit('packetCreate', packet);
            this.writeBuffer.push(packet);
            this.callbackBuffer.push(fn);
            this.flush();
        };
        
        /**
         * Closes the connection.
         *
         * @api private
         */
        
        Socket.prototype.close = function () {
            if ('opening' == this.readyState || 'open' == this.readyState) {
                this.readyState = 'closing';
                
                var self = this;
                
                function close() {
                    self.onClose('forced close');
                    debug('socket closing - telling transport to close');
                    self.transport.close();
                }
                
                function cleanupAndClose() {
                    self.removeListener('upgrade', cleanupAndClose);
                    self.removeListener('upgradeError', cleanupAndClose);
                    close();
                }
                
                function waitForUpgrade() {
                    // wait for upgrade to finish since we can't send packets while pausing a transport
                    self.once('upgrade', cleanupAndClose);
                    self.once('upgradeError', cleanupAndClose);
                }
                
                if (this.writeBuffer.length) {
                    this.once('drain', function() {
                        if (this.upgrading) {
                            waitForUpgrade();
                        } else {
                            close();
                        }
                    });
                } else if (this.upgrading) {
                    waitForUpgrade();
                } else {
                    close();
                }
            }
            
            return this;
        };
        
        /**
         * Called upon transport error
         *
         * @api private
         */
        
        Socket.prototype.onError = function (err) {
            debug('socket error %j', err);
            Socket.priorWebsocketSuccess = false;
            this.emit('error', err);
            this.onClose('transport error', err);
        };
        
        /**
         * Called upon transport close.
         *
         * @api private
         */
        
        Socket.prototype.onClose = function (reason, desc) {
            if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
                debug('socket close with reason: "%s"', reason);
                var self = this;
                
                // clear timers
                clearTimeout(this.pingIntervalTimer);
                clearTimeout(this.pingTimeoutTimer);
                
                // clean buffers in next tick, so developers can still
                // grab the buffers on `close` event
                setTimeout(function() {
                    self.writeBuffer = [];
                    self.callbackBuffer = [];
                    self.prevBufferLen = 0;
                }, 0);
                
                // stop event from firing again for transport
                this.transport.removeAllListeners('close');
                
                // ensure transport won't stay open
                this.transport.close();
                
                // ignore further transport communication
                this.transport.removeAllListeners();
                
                // set ready state
                this.readyState = 'closed';
                
                // clear session id
                this.id = null;
                
                // emit close event
                this.emit('close', reason, desc);
            }
        };
        
        /**
         * Filters upgrades, returning only those matching client transports.
         *
         * @param {Array} server upgrades
         * @api private
         *
         */
        
        Socket.prototype.filterUpgrades = function (upgrades) {
            var filteredUpgrades = [];
            for (var i = 0, j = upgrades.length; i<j; i++) {
                if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
            }
            return filteredUpgrades;
        };
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"./transport":136,"./transports":137,"component-emitter":131,"debug":144,"engine.io-parser":147,"indexof":164,"parsejson":158,"parseqs":159,"parseuri":160}],136:[function(require,module,exports){
    /**
     * Module dependencies.
     */
    
    var parser = require('engine.io-parser');
    var Emitter = require('component-emitter');
    
    /**
     * Module exports.
     */
    
    module.exports = Transport;
    
    /**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */
    
    function Transport (opts) {
        this.path = opts.path;
        this.hostname = opts.hostname;
        this.port = opts.port;
        this.secure = opts.secure;
        this.query = opts.query;
        this.timestampParam = opts.timestampParam;
        this.timestampRequests = opts.timestampRequests;
        this.readyState = '';
        this.agent = opts.agent || false;
        this.socket = opts.socket;
        this.enablesXDR = opts.enablesXDR;
        
        // SSL options for Node.js client
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;
    }
    
    /**
     * Mix in `Emitter`.
     */
    
    Emitter(Transport.prototype);
    
    /**
     * A counter used to prevent collisions in the timestamps used
     * for cache busting.
     */
    
    Transport.timestamps = 0;
    
    /**
     * Emits an error.
     *
     * @param {String} str
     * @return {Transport} for chaining
     * @api public
     */
    
    Transport.prototype.onError = function (msg, desc) {
        var err = new Error(msg);
        err.type = 'TransportError';
        err.description = desc;
        this.emit('error', err);
        return this;
    };
    
    /**
     * Opens the transport.
     *
     * @api public
     */
    
    Transport.prototype.open = function () {
        if ('closed' == this.readyState || '' == this.readyState) {
            this.readyState = 'opening';
            this.doOpen();
        }
        
        return this;
    };
    
    /**
     * Closes the transport.
     *
     * @api private
     */
    
    Transport.prototype.close = function () {
        if ('opening' == this.readyState || 'open' == this.readyState) {
            this.doClose();
            this.onClose();
        }
        
        return this;
    };
    
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api private
     */
    
    Transport.prototype.send = function(packets){
        if ('open' == this.readyState) {
            this.write(packets);
        } else {
            throw new Error('Transport not open');
        }
    };
    
    /**
     * Called upon open
     *
     * @api private
     */
    
    Transport.prototype.onOpen = function () {
        this.readyState = 'open';
        this.writable = true;
        this.emit('open');
    };
    
    /**
     * Called with data.
     *
     * @param {String} data
     * @api private
     */
    
    Transport.prototype.onData = function(data){
        var packet = parser.decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
    };
    
    /**
     * Called with a decoded packet.
     */
    
    Transport.prototype.onPacket = function (packet) {
        this.emit('packet', packet);
    };
    
    /**
     * Called upon close.
     *
     * @api private
     */
    
    Transport.prototype.onClose = function () {
        this.readyState = 'closed';
        this.emit('close');
    };
    
},{"component-emitter":131,"engine.io-parser":147}],137:[function(require,module,exports){
    (function (global){
        /**
         * Module dependencies
         */
        
        var XMLHttpRequest = require('xmlhttprequest');
        var XHR = require('./polling-xhr');
        var JSONP = require('./polling-jsonp');
        var websocket = require('./websocket');
        
        /**
         * Export transports.
         */
        
        exports.polling = polling;
        exports.websocket = websocket;
        
        /**
         * Polling transport polymorphic constructor.
         * Decides on xhr vs jsonp based on feature detection.
         *
         * @api private
         */
        
        function polling(opts){
            var xhr;
            var xd = false;
            var xs = false;
            var jsonp = false !== opts.jsonp;
            
            if (global.location) {
                var isSSL = 'https:' == location.protocol;
                var port = location.port;
                
                // some user agents have empty `location.port`
                if (!port) {
                    port = isSSL ? 443 : 80;
                }
                
                xd = opts.hostname != location.hostname || port != opts.port;
                xs = opts.secure != isSSL;
            }
            
            opts.xdomain = xd;
            opts.xscheme = xs;
            xhr = new XMLHttpRequest(opts);
            
            if ('open' in xhr && !opts.forceJSONP) {
                return new XHR(opts);
            } else {
                if (!jsonp) throw new Error('JSONP disabled');
                return new JSONP(opts);
            }
        }
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"./polling-jsonp":138,"./polling-xhr":139,"./websocket":141,"xmlhttprequest":142}],138:[function(require,module,exports){
    (function (global){
        
        /**
         * Module requirements.
         */
        
        var Polling = require('./polling');
        var inherit = require('component-inherit');
        
        /**
         * Module exports.
         */
        
        module.exports = JSONPPolling;
        
        /**
         * Cached regular expressions.
         */
        
        var rNewline = /\n/g;
        var rEscapedNewline = /\\n/g;
        
        /**
         * Global JSONP callbacks.
         */
        
        var callbacks;
        
        /**
         * Callbacks count.
         */
        
        var index = 0;
        
        /**
         * Noop.
         */
        
        function empty () { }
        
        /**
         * JSONP Polling constructor.
         *
         * @param {Object} opts.
         * @api public
         */
        
        function JSONPPolling (opts) {
            Polling.call(this, opts);
            
            this.query = this.query || {};
            
            // define global callbacks array if not present
            // we do this here (lazily) to avoid unneeded global pollution
            if (!callbacks) {
                // we need to consider multiple engines in the same page
                if (!global.___eio) global.___eio = [];
                callbacks = global.___eio;
            }
            
            // callback identifier
            this.index = callbacks.length;
            
            // add callback to jsonp global
            var self = this;
            callbacks.push(function (msg) {
                self.onData(msg);
            });
            
            // append to query string
            this.query.j = this.index;
            
            // prevent spurious errors from being emitted when the window is unloaded
            if (global.document && global.addEventListener) {
                global.addEventListener('beforeunload', function () {
                    if (self.script) self.script.onerror = empty;
                }, false);
            }
        }
        
        /**
         * Inherits from Polling.
         */
        
        inherit(JSONPPolling, Polling);
        
        /*
         * JSONP only supports binary as base64 encoded strings
         */
        
        JSONPPolling.prototype.supportsBinary = false;
        
        /**
         * Closes the socket.
         *
         * @api private
         */
        
        JSONPPolling.prototype.doClose = function () {
            if (this.script) {
                this.script.parentNode.removeChild(this.script);
                this.script = null;
            }
            
            if (this.form) {
                this.form.parentNode.removeChild(this.form);
                this.form = null;
                this.iframe = null;
            }
            
            Polling.prototype.doClose.call(this);
        };
        
        /**
         * Starts a poll cycle.
         *
         * @api private
         */
        
        JSONPPolling.prototype.doPoll = function () {
            var self = this;
            var script = document.createElement('script');
            
            if (this.script) {
                this.script.parentNode.removeChild(this.script);
                this.script = null;
            }
            
            script.async = true;
            script.src = this.uri();
            script.onerror = function(e){
                self.onError('jsonp poll error',e);
            };
            
            var insertAt = document.getElementsByTagName('script')[0];
            insertAt.parentNode.insertBefore(script, insertAt);
            this.script = script;
            
            var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
            
            if (isUAgecko) {
                setTimeout(function () {
                    var iframe = document.createElement('iframe');
                    document.body.appendChild(iframe);
                    document.body.removeChild(iframe);
                }, 100);
            }
        };
        
        /**
         * Writes with a hidden iframe.
         *
         * @param {String} data to send
         * @param {Function} called upon flush.
         * @api private
         */
        
        JSONPPolling.prototype.doWrite = function (data, fn) {
            var self = this;
            
            if (!this.form) {
                var form = document.createElement('form');
                var area = document.createElement('textarea');
                var id = this.iframeId = 'eio_iframe_' + this.index;
                var iframe;
                
                form.className = 'socketio';
                form.style.position = 'absolute';
                form.style.top = '-1000px';
                form.style.left = '-1000px';
                form.target = id;
                form.method = 'POST';
                form.setAttribute('accept-charset', 'utf-8');
                area.name = 'd';
                form.appendChild(area);
                document.body.appendChild(form);
                
                this.form = form;
                this.area = area;
            }
            
            this.form.action = this.uri();
            
            function complete () {
                initIframe();
                fn();
            }
            
            function initIframe () {
                if (self.iframe) {
                    try {
                        self.form.removeChild(self.iframe);
                    } catch (e) {
                        self.onError('jsonp polling iframe removal error', e);
                    }
                }
                
                try {
                    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
                    var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
                    iframe = document.createElement(html);
                } catch (e) {
                    iframe = document.createElement('iframe');
                    iframe.name = self.iframeId;
                    iframe.src = 'javascript:0';
                }
                
                iframe.id = self.iframeId;
                
                self.form.appendChild(iframe);
                self.iframe = iframe;
            }
            
            initIframe();
            
            // escape \n to prevent it from being converted into \r\n by some UAs
            // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
            data = data.replace(rEscapedNewline, '\\\n');
            this.area.value = data.replace(rNewline, '\\n');
            
            try {
                this.form.submit();
            } catch(e) {}
            
            if (this.iframe.attachEvent) {
                this.iframe.onreadystatechange = function(){
                    if (self.iframe.readyState == 'complete') {
                        complete();
                    }
                };
            } else {
                this.iframe.onload = complete;
            }
        };
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"./polling":140,"component-inherit":143}],139:[function(require,module,exports){
    (function (global){
        /**
         * Module requirements.
         */
        
        var XMLHttpRequest = require('xmlhttprequest');
        var Polling = require('./polling');
        var Emitter = require('component-emitter');
        var inherit = require('component-inherit');
        var debug = require('debug')('engine.io-client:polling-xhr');
        
        /**
         * Module exports.
         */
        
        module.exports = XHR;
        module.exports.Request = Request;
        
        /**
         * Empty function
         */
        
        function empty(){}
        
        /**
         * XHR Polling constructor.
         *
         * @param {Object} opts
         * @api public
         */
        
        function XHR(opts){
            Polling.call(this, opts);
            
            if (global.location) {
                var isSSL = 'https:' == location.protocol;
                var port = location.port;
                
                // some user agents have empty `location.port`
                if (!port) {
                    port = isSSL ? 443 : 80;
                }
                
                this.xd = opts.hostname != global.location.hostname ||
                    port != opts.port;
                this.xs = opts.secure != isSSL;
            }
        }
        
        /**
         * Inherits from Polling.
         */
        
        inherit(XHR, Polling);
        
        /**
         * XHR supports binary
         */
        
        XHR.prototype.supportsBinary = true;
        
        /**
         * Creates a request.
         *
         * @param {String} method
         * @api private
         */
        
        XHR.prototype.request = function(opts){
            opts = opts || {};
            opts.uri = this.uri();
            opts.xd = this.xd;
            opts.xs = this.xs;
            opts.agent = this.agent || false;
            opts.supportsBinary = this.supportsBinary;
            opts.enablesXDR = this.enablesXDR;
            
            // SSL options for Node.js client
            opts.pfx = this.pfx;
            opts.key = this.key;
            opts.passphrase = this.passphrase;
            opts.cert = this.cert;
            opts.ca = this.ca;
            opts.ciphers = this.ciphers;
            opts.rejectUnauthorized = this.rejectUnauthorized;
            
            return new Request(opts);
        };
        
        /**
         * Sends data.
         *
         * @param {String} data to send.
         * @param {Function} called upon flush.
         * @api private
         */
        
        XHR.prototype.doWrite = function(data, fn){
            var isBinary = typeof data !== 'string' && data !== undefined;
            var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
            var self = this;
            req.on('success', fn);
            req.on('error', function(err){
                self.onError('xhr post error', err);
            });
            this.sendXhr = req;
        };
        
        /**
         * Starts a poll cycle.
         *
         * @api private
         */
        
        XHR.prototype.doPoll = function(){
            debug('xhr poll');
            var req = this.request();
            var self = this;
            req.on('data', function(data){
                self.onData(data);
            });
            req.on('error', function(err){
                self.onError('xhr poll error', err);
            });
            this.pollXhr = req;
        };
        
        /**
         * Request constructor
         *
         * @param {Object} options
         * @api public
         */
        
        function Request(opts){
            this.method = opts.method || 'GET';
            this.uri = opts.uri;
            this.xd = !!opts.xd;
            this.xs = !!opts.xs;
            this.async = false !== opts.async;
            this.data = undefined != opts.data ? opts.data : null;
            this.agent = opts.agent;
            this.isBinary = opts.isBinary;
            this.supportsBinary = opts.supportsBinary;
            this.enablesXDR = opts.enablesXDR;
            
            // SSL options for Node.js client
            this.pfx = opts.pfx;
            this.key = opts.key;
            this.passphrase = opts.passphrase;
            this.cert = opts.cert;
            this.ca = opts.ca;
            this.ciphers = opts.ciphers;
            this.rejectUnauthorized = opts.rejectUnauthorized;
            
            this.create();
        }
        
        /**
         * Mix in `Emitter`.
         */
        
        Emitter(Request.prototype);
        
        /**
         * Creates the XHR object and sends the request.
         *
         * @api private
         */
        
        Request.prototype.create = function(){
            var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
            
            // SSL options for Node.js client
            opts.pfx = this.pfx;
            opts.key = this.key;
            opts.passphrase = this.passphrase;
            opts.cert = this.cert;
            opts.ca = this.ca;
            opts.ciphers = this.ciphers;
            opts.rejectUnauthorized = this.rejectUnauthorized;
            
            var xhr = this.xhr = new XMLHttpRequest(opts);
            var self = this;
            
            try {
                debug('xhr open %s: %s', this.method, this.uri);
                xhr.open(this.method, this.uri, this.async);
                if (this.supportsBinary) {
                    // This has to be done after open because Firefox is stupid
                    // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
                    xhr.responseType = 'arraybuffer';
                }
                
                if ('POST' == this.method) {
                    try {
                        if (this.isBinary) {
                            xhr.setRequestHeader('Content-type', 'application/octet-stream');
                        } else {
                            xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
                        }
                    } catch (e) {}
                }
                
                // ie6 check
                if ('withCredentials' in xhr) {
                    xhr.withCredentials = true;
                }
                
                if (this.hasXDR()) {
                    xhr.onload = function(){
                        self.onLoad();
                    };
                    xhr.onerror = function(){
                        self.onError(xhr.responseText);
                    };
                } else {
                    xhr.onreadystatechange = function(){
                        if (4 != xhr.readyState) return;
                        if (200 == xhr.status || 1223 == xhr.status) {
                            self.onLoad();
                        } else {
                            // make sure the `error` event handler that's user-set
                            // does not throw in the same tick and gets caught here
                            setTimeout(function(){
                                self.onError(xhr.status);
                            }, 0);
                        }
                    };
                }
                
                debug('xhr data %s', this.data);
                xhr.send(this.data);
            } catch (e) {
                // Need to defer since .create() is called directly fhrom the constructor
                // and thus the 'error' event can only be only bound *after* this exception
                // occurs.  Therefore, also, we cannot throw here at all.
                setTimeout(function() {
                    self.onError(e);
                }, 0);
                return;
            }
            
            if (global.document) {
                this.index = Request.requestsCount++;
                Request.requests[this.index] = this;
            }
        };
        
        /**
         * Called upon successful response.
         *
         * @api private
         */
        
        Request.prototype.onSuccess = function(){
            this.emit('success');
            this.cleanup();
        };
        
        /**
         * Called if we have data.
         *
         * @api private
         */
        
        Request.prototype.onData = function(data){
            this.emit('data', data);
            this.onSuccess();
        };
        
        /**
         * Called upon error.
         *
         * @api private
         */
        
        Request.prototype.onError = function(err){
            this.emit('error', err);
            this.cleanup(true);
        };
        
        /**
         * Cleans up house.
         *
         * @api private
         */
        
        Request.prototype.cleanup = function(fromError){
            if ('undefined' == typeof this.xhr || null === this.xhr) {
                return;
            }
            // xmlhttprequest
            if (this.hasXDR()) {
                this.xhr.onload = this.xhr.onerror = empty;
            } else {
                this.xhr.onreadystatechange = empty;
            }
            
            if (fromError) {
                try {
                    this.xhr.abort();
                } catch(e) {}
            }
            
            if (global.document) {
                delete Request.requests[this.index];
            }
            
            this.xhr = null;
        };
        
        /**
         * Called upon load.
         *
         * @api private
         */
        
        Request.prototype.onLoad = function(){
            var data;
            try {
                var contentType;
                try {
                    contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
                } catch (e) {}
                if (contentType === 'application/octet-stream') {
                    data = this.xhr.response;
                } else {
                    if (!this.supportsBinary) {
                        data = this.xhr.responseText;
                    } else {
                        data = 'ok';
                    }
                }
            } catch (e) {
                this.onError(e);
            }
            if (null != data) {
                this.onData(data);
            }
        };
        
        /**
         * Check if it has XDomainRequest.
         *
         * @api private
         */
        
        Request.prototype.hasXDR = function(){
            return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
        };
        
        /**
         * Aborts the request.
         *
         * @api public
         */
        
        Request.prototype.abort = function(){
            this.cleanup();
        };
        
        /**
         * Aborts pending requests when unloading the window. This is needed to prevent
         * memory leaks (e.g. when using IE) and to ensure that no spurious error is
         * emitted.
         */
        
        if (global.document) {
            Request.requestsCount = 0;
            Request.requests = {};
            if (global.attachEvent) {
                global.attachEvent('onunload', unloadHandler);
            } else if (global.addEventListener) {
                global.addEventListener('beforeunload', unloadHandler, false);
            }
        }
        
        function unloadHandler() {
            for (var i in Request.requests) {
                if (Request.requests.hasOwnProperty(i)) {
                    Request.requests[i].abort();
                }
            }
        }
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"./polling":140,"component-emitter":131,"component-inherit":143,"debug":144,"xmlhttprequest":142}],140:[function(require,module,exports){
    /**
     * Module dependencies.
     */
    
    var Transport = require('../transport');
    var parseqs = require('parseqs');
    var parser = require('engine.io-parser');
    var inherit = require('component-inherit');
    var debug = require('debug')('engine.io-client:polling');
    
    /**
     * Module exports.
     */
    
    module.exports = Polling;
    
    /**
     * Is XHR2 supported?
     */
    
    var hasXHR2 = (function() {
        var XMLHttpRequest = require('xmlhttprequest');
        var xhr = new XMLHttpRequest({ xdomain: false });
        return null != xhr.responseType;
    })();
    
    /**
     * Polling interface.
     *
     * @param {Object} opts
     * @api private
     */
    
    function Polling(opts){
        var forceBase64 = (opts && opts.forceBase64);
        if (!hasXHR2 || forceBase64) {
            this.supportsBinary = false;
        }
        Transport.call(this, opts);
    }
    
    /**
     * Inherits from Transport.
     */
    
    inherit(Polling, Transport);
    
    /**
     * Transport name.
     */
    
    Polling.prototype.name = 'polling';
    
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */
    
    Polling.prototype.doOpen = function(){
        this.poll();
    };
    
    /**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */
    
    Polling.prototype.pause = function(onPause){
        var pending = 0;
        var self = this;
        
        this.readyState = 'pausing';
        
        function pause(){
            debug('paused');
            self.readyState = 'paused';
            onPause();
        }
        
        if (this.polling || !this.writable) {
            var total = 0;
            
            if (this.polling) {
                debug('we are currently polling - waiting to pause');
                total++;
                this.once('pollComplete', function(){
                    debug('pre-pause polling complete');
                    --total || pause();
                });
            }
            
            if (!this.writable) {
                debug('we are currently writing - waiting to pause');
                total++;
                this.once('drain', function(){
                    debug('pre-pause writing complete');
                    --total || pause();
                });
            }
        } else {
            pause();
        }
    };
    
    /**
     * Starts polling cycle.
     *
     * @api public
     */
    
    Polling.prototype.poll = function(){
        debug('polling');
        this.polling = true;
        this.doPoll();
        this.emit('poll');
    };
    
    /**
     * Overloads onData to detect payloads.
     *
     * @api private
     */
    
    Polling.prototype.onData = function(data){
        var self = this;
        debug('polling got data %s', data);
        var callback = function(packet, index, total) {
            // if its the first message we consider the transport open
            if ('opening' == self.readyState) {
                self.onOpen();
            }
            
            // if its a close packet, we close the ongoing requests
            if ('close' == packet.type) {
                self.onClose();
                return false;
            }
            
            // otherwise bypass onData and handle the message
            self.onPacket(packet);
        };
        
        // decode payload
        parser.decodePayload(data, this.socket.binaryType, callback);
        
        // if an event did not trigger closing
        if ('closed' != this.readyState) {
            // if we got data we're not polling
            this.polling = false;
            this.emit('pollComplete');
            
            if ('open' == this.readyState) {
                this.poll();
            } else {
                debug('ignoring poll - transport state "%s"', this.readyState);
            }
        }
    };
    
    /**
     * For polling, send a close packet.
     *
     * @api private
     */
    
    Polling.prototype.doClose = function(){
        var self = this;
        
        function close(){
            debug('writing close packet');
            self.write([{ type: 'close' }]);
        }
        
        if ('open' == this.readyState) {
            debug('transport open - closing');
            close();
        } else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            debug('transport not open - deferring close');
            this.once('open', close);
        }
    };
    
    /**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */
    
    Polling.prototype.write = function(packets){
        var self = this;
        this.writable = false;
        var callbackfn = function() {
            self.writable = true;
            self.emit('drain');
        };
        
        var self = this;
        parser.encodePayload(packets, this.supportsBinary, function(data) {
            self.doWrite(data, callbackfn);
        });
    };
    
    /**
     * Generates uri for connection.
     *
     * @api private
     */
    
    Polling.prototype.uri = function(){
        var query = this.query || {};
        var schema = this.secure ? 'https' : 'http';
        var port = '';
        
        // cache busting is forced
        if (false !== this.timestampRequests) {
            query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
        }
        
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        
        query = parseqs.encode(query);
        
        // avoid port if default for schema
        if (this.port && (('https' == schema && this.port != 443) ||
            ('http' == schema && this.port != 80))) {
            port = ':' + this.port;
        }
        
        // prepend ? to query
        if (query.length) {
            query = '?' + query;
        }
        
        return schema + '://' + this.hostname + port + this.path + query;
    };
    
},{"../transport":136,"component-inherit":143,"debug":144,"engine.io-parser":147,"parseqs":159,"xmlhttprequest":142}],141:[function(require,module,exports){
    /**
     * Module dependencies.
     */
    
    var Transport = require('../transport');
    var parser = require('engine.io-parser');
    var parseqs = require('parseqs');
    var inherit = require('component-inherit');
    var debug = require('debug')('engine.io-client:websocket');
    
    /**
     * `ws` exposes a WebSocket-compatible interface in
     * Node, or the `WebSocket` or `MozWebSocket` globals
     * in the browser.
     */
    
    var WebSocket = require('ws');
    
    /**
     * Module exports.
     */
    
    module.exports = WS;
    
    /**
     * WebSocket transport constructor.
     *
     * @api {Object} connection options
     * @api public
     */
    
    function WS(opts){
        var forceBase64 = (opts && opts.forceBase64);
        if (forceBase64) {
            this.supportsBinary = false;
        }
        Transport.call(this, opts);
    }
    
    /**
     * Inherits from Transport.
     */
    
    inherit(WS, Transport);
    
    /**
     * Transport name.
     *
     * @api public
     */
    
    WS.prototype.name = 'websocket';
    
    /*
     * WebSockets support binary
     */
    
    WS.prototype.supportsBinary = true;
    
    /**
     * Opens socket.
     *
     * @api private
     */
    
    WS.prototype.doOpen = function(){
        if (!this.check()) {
            // let probe timeout
            return;
        }
        
        var self = this;
        var uri = this.uri();
        var protocols = void(0);
        var opts = { agent: this.agent };
        
        // SSL options for Node.js client
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        
        this.ws = new WebSocket(uri, protocols, opts);
        
        if (this.ws.binaryType === undefined) {
            this.supportsBinary = false;
        }
        
        this.ws.binaryType = 'arraybuffer';
        this.addEventListeners();
    };
    
    /**
     * Adds event listeners to the socket
     *
     * @api private
     */
    
    WS.prototype.addEventListeners = function(){
        var self = this;
        
        this.ws.onopen = function(){
            self.onOpen();
        };
        this.ws.onclose = function(){
            self.onClose();
        };
        this.ws.onmessage = function(ev){
            self.onData(ev.data);
        };
        this.ws.onerror = function(e){
            self.onError('websocket error', e);
        };
    };
    
    /**
     * Override `onData` to use a timer on iOS.
     * See: https://gist.github.com/mloughran/2052006
     *
     * @api private
     */
    
    if ('undefined' != typeof navigator
        && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
        WS.prototype.onData = function(data){
            var self = this;
            setTimeout(function(){
                Transport.prototype.onData.call(self, data);
            }, 0);
        };
    }
    
    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */
    
    WS.prototype.write = function(packets){
        var self = this;
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (var i = 0, l = packets.length; i < l; i++) {
            parser.encodePacket(packets[i], this.supportsBinary, function(data) {
                //Sometimes the websocket has already been closed but the browser didn't
                //have a chance of informing us about it yet, in that case send will
                //throw an error
                try {
                    self.ws.send(data);
                } catch (e){
                    debug('websocket closed before onclose event');
                }
            });
        }
        
        function ondrain() {
            self.writable = true;
            self.emit('drain');
        }
        // fake drain
        // defer to next tick to allow Socket to clear writeBuffer
        setTimeout(ondrain, 0);
    };
    
    /**
     * Called upon close
     *
     * @api private
     */
    
    WS.prototype.onClose = function(){
        Transport.prototype.onClose.call(this);
    };
    
    /**
     * Closes socket.
     *
     * @api private
     */
    
    WS.prototype.doClose = function(){
        if (typeof this.ws !== 'undefined') {
            this.ws.close();
        }
    };
    
    /**
     * Generates uri for connection.
     *
     * @api private
     */
    
    WS.prototype.uri = function(){
        var query = this.query || {};
        var schema = this.secure ? 'wss' : 'ws';
        var port = '';
        
        // avoid port if default for schema
        if (this.port && (('wss' == schema && this.port != 443)
            || ('ws' == schema && this.port != 80))) {
            port = ':' + this.port;
        }
        
        // append timestamp to URI
        if (this.timestampRequests) {
            query[this.timestampParam] = +new Date;
        }
        
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        
        query = parseqs.encode(query);
        
        // prepend ? to query
        if (query.length) {
            query = '?' + query;
        }
        
        return schema + '://' + this.hostname + port + this.path + query;
    };
    
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */
    
    WS.prototype.check = function(){
        return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
    };
    
},{"../transport":136,"component-inherit":143,"debug":144,"engine.io-parser":147,"parseqs":159,"ws":161}],142:[function(require,module,exports){
    // browser shim for xmlhttprequest module
    var hasCORS = require('has-cors');
    
    module.exports = function(opts) {
        var xdomain = opts.xdomain;
        
        // scheme must be same when usign XDomainRequest
        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
        var xscheme = opts.xscheme;
        
        // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
        // https://github.com/Automattic/engine.io-client/pull/217
        var enablesXDR = opts.enablesXDR;
        
        // XMLHttpRequest can be disabled on IE
        try {
            if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
                return new XMLHttpRequest();
            }
        } catch (e) { }
        
        // Use XDomainRequest for IE8 if enablesXDR is true
        // because loading bar keeps flashing when using jsonp-polling
        // https://github.com/yujiosaka/socke.io-ie8-loading-example
        try {
            if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
                return new XDomainRequest();
            }
        } catch (e) { }
        
        if (!xdomain) {
            try {
                return new ActiveXObject('Microsoft.XMLHTTP');
            } catch(e) { }
        }
    }
    
},{"has-cors":156}],143:[function(require,module,exports){
    
    module.exports = function(a, b){
        var fn = function(){};
        fn.prototype = b.prototype;
        a.prototype = new fn;
        a.prototype.constructor = a;
    };
},{}],144:[function(require,module,exports){
    
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports = require('./debug');
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    
    /**
     * Colors.
     */
    
    exports.colors = [
        'lightseagreen',
        'forestgreen',
        'goldenrod',
        'dodgerblue',
        'darkorchid',
        'crimson'
    ];
    
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    
    function useColors() {
        // is webkit? http://stackoverflow.com/a/16459606/376773
        return ('WebkitAppearance' in document.documentElement.style) ||
                // is firebug? http://stackoverflow.com/a/398120/376773
            (window.console && (console.firebug || (console.exception && console.table))) ||
                // is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
    }
    
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */
    
    exports.formatters.j = function(v) {
        return JSON.stringify(v);
    };
    
    
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */
    
    function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;
        
        args[0] = (useColors ? '%c' : '')
            + this.namespace
            + (useColors ? ' %c' : ' ')
            + args[0]
            + (useColors ? '%c ' : ' ')
            + '+' + exports.humanize(this.diff);
        
        if (!useColors) return args;
        
        var c = 'color: ' + this.color;
        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
        
        // the final "%c" is somewhat tricky, because there could be other
        // arguments passed either before or after the %c, so we need to
        // figure out the correct index to insert the CSS into
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function(match) {
            if ('%%' === match) return;
            index++;
            if ('%c' === match) {
                // we only are interested in the *last* %c
                // (the user may have provided their own)
                lastC = index;
            }
        });
        
        args.splice(lastC, 0, c);
        return args;
    }
    
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */
    
    function log() {
        // This hackery is required for IE8,
        // where the `console.log` function doesn't have 'apply'
        return 'object' == typeof console
            && 'function' == typeof console.log
            && Function.prototype.apply.call(console.log, console, arguments);
    }
    
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    
    function save(namespaces) {
        try {
            if (null == namespaces) {
                localStorage.removeItem('debug');
            } else {
                localStorage.debug = namespaces;
            }
        } catch(e) {}
    }
    
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    
    function load() {
        var r;
        try {
            r = localStorage.debug;
        } catch(e) {}
        return r;
    }
    
    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */
    
    exports.enable(load());
    
},{"./debug":145}],145:[function(require,module,exports){
    
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require('ms');
    
    /**
     * The currently active debug mode names, and names to skip.
     */
    
    exports.names = [];
    exports.skips = [];
    
    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lowercased letter, i.e. "n".
     */
    
    exports.formatters = {};
    
    /**
     * Previously assigned color.
     */
    
    var prevColor = 0;
    
    /**
     * Previous log timestamp.
     */
    
    var prevTime;
    
    /**
     * Select a color.
     *
     * @return {Number}
     * @api private
     */
    
    function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length];
    }
    
    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */
    
    function debug(namespace) {
        
        // define the `disabled` version
        function disabled() {
        }
        disabled.enabled = false;
        
        // define the `enabled` version
        function enabled() {
            
            var self = enabled;
            
            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            
            // add the `color` if not set
            if (null == self.useColors) self.useColors = exports.useColors();
            if (null == self.color && self.useColors) self.color = selectColor();
            
            var args = Array.prototype.slice.call(arguments);
            
            args[0] = exports.coerce(args[0]);
            
            if ('string' !== typeof args[0]) {
                // anything else let's inspect with %o
                args = ['%o'].concat(args);
            }
            
            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                // if we encounter an escaped % then don't increase the array index
                if (match === '%%') return match;
                index++;
                var formatter = exports.formatters[format];
                if ('function' === typeof formatter) {
                    var val = args[index];
                    match = formatter.call(self, val);
                    
                    // now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            
            if ('function' === typeof exports.formatArgs) {
                args = exports.formatArgs.apply(self, args);
            }
            var logFn = enabled.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
        }
        enabled.enabled = true;
        
        var fn = exports.enabled(namespace) ? enabled : disabled;
        
        fn.namespace = namespace;
        
        return fn;
    }
    
    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */
    
    function enable(namespaces) {
        exports.save(namespaces);
        
        var split = (namespaces || '').split(/[\s,]+/);
        var len = split.length;
        
        for (var i = 0; i < len; i++) {
            if (!split[i]) continue; // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            } else {
                exports.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
    }
    
    /**
     * Disable debug output.
     *
     * @api public
     */
    
    function disable() {
        exports.enable('');
    }
    
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */
    
    function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
                return false;
            }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */
    
    function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    
},{"ms":146}],146:[function(require,module,exports){
    /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
        options = options || {};
        if ('string' == typeof val) return parse(val);
        return options.long
            ? long(val)
            : short(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
        var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
        if (!match) return;
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch (type) {
            case 'years':
            case 'year':
            case 'y':
                return n * y;
            case 'days':
            case 'day':
            case 'd':
                return n * d;
            case 'hours':
            case 'hour':
            case 'h':
                return n * h;
            case 'minutes':
            case 'minute':
            case 'm':
                return n * m;
            case 'seconds':
            case 'second':
            case 's':
                return n * s;
            case 'ms':
                return n;
        }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function short(ms) {
        if (ms >= d) return Math.round(ms / d) + 'd';
        if (ms >= h) return Math.round(ms / h) + 'h';
        if (ms >= m) return Math.round(ms / m) + 'm';
        if (ms >= s) return Math.round(ms / s) + 's';
        return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function long(ms) {
        return plural(ms, d, 'day')
            || plural(ms, h, 'hour')
            || plural(ms, m, 'minute')
            || plural(ms, s, 'second')
            || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
        if (ms < n) return;
        if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
        return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
},{}],147:[function(require,module,exports){
    (function (global){
        /**
         * Module dependencies.
         */
        
        var keys = require('./keys');
        var hasBinary = require('has-binary');
        var sliceBuffer = require('arraybuffer.slice');
        var base64encoder = require('base64-arraybuffer');
        var after = require('after');
        var utf8 = require('utf8');
        
        /**
         * Check if we are running an android browser. That requires us to use
         * ArrayBuffer with polling transports...
         *
         * http://ghinda.net/jpeg-blob-ajax-android/
         */
        
        var isAndroid = navigator.userAgent.match(/Android/i);
        
        /**
         * Check if we are running in PhantomJS.
         * Uploading a Blob with PhantomJS does not work correctly, as reported here:
         * https://github.com/ariya/phantomjs/issues/11395
         * @type boolean
         */
        var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
        
        /**
         * When true, avoids using Blobs to encode payloads.
         * @type boolean
         */
        var dontSendBlobs = isAndroid || isPhantomJS;
        
        /**
         * Current protocol version.
         */
        
        exports.protocol = 3;
        
        /**
         * Packet types.
         */
        
        var packets = exports.packets = {
            open:     0    // non-ws
            , close:    1    // non-ws
            , ping:     2
            , pong:     3
            , message:  4
            , upgrade:  5
            , noop:     6
        };
        
        var packetslist = keys(packets);
        
        /**
         * Premade error packet.
         */
        
        var err = { type: 'error', data: 'parser error' };
        
        /**
         * Create a blob api even for blob builder when vendor prefixes exist
         */
        
        var Blob = require('blob');
        
        /**
         * Encodes a packet.
         *
         *     <packet type id> [ <data> ]
         *
         * Example:
         *
         *     5hello world
         *     3
         *     4
         *
         * Binary is encoded in an identical principle
         *
         * @api private
         */
        
        exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
            if ('function' == typeof supportsBinary) {
                callback = supportsBinary;
                supportsBinary = false;
            }
            
            if ('function' == typeof utf8encode) {
                callback = utf8encode;
                utf8encode = null;
            }
            
            var data = (packet.data === undefined)
                ? undefined
                : packet.data.buffer || packet.data;
            
            if (global.ArrayBuffer && data instanceof ArrayBuffer) {
                return encodeArrayBuffer(packet, supportsBinary, callback);
            } else if (Blob && data instanceof global.Blob) {
                return encodeBlob(packet, supportsBinary, callback);
            }
            
            // might be an object with { base64: true, data: dataAsBase64String }
            if (data && data.base64) {
                return encodeBase64Object(packet, callback);
            }
            
            // Sending data as a utf-8 string
            var encoded = packets[packet.type];
            
            // data fragment is optional
            if (undefined !== packet.data) {
                encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
            }
            
            return callback('' + encoded);
            
        };
        
        function encodeBase64Object(packet, callback) {
            // packet data is an object { base64: true, data: dataAsBase64String }
            var message = 'b' + exports.packets[packet.type] + packet.data.data;
            return callback(message);
        }
        
        /**
         * Encode packet helpers for binary types
         */
        
        function encodeArrayBuffer(packet, supportsBinary, callback) {
            if (!supportsBinary) {
                return exports.encodeBase64Packet(packet, callback);
            }
            
            var data = packet.data;
            var contentArray = new Uint8Array(data);
            var resultBuffer = new Uint8Array(1 + data.byteLength);
            
            resultBuffer[0] = packets[packet.type];
            for (var i = 0; i < contentArray.length; i++) {
                resultBuffer[i+1] = contentArray[i];
            }
            
            return callback(resultBuffer.buffer);
        }
        
        function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
            if (!supportsBinary) {
                return exports.encodeBase64Packet(packet, callback);
            }
            
            var fr = new FileReader();
            fr.onload = function() {
                packet.data = fr.result;
                exports.encodePacket(packet, supportsBinary, true, callback);
            };
            return fr.readAsArrayBuffer(packet.data);
        }
        
        function encodeBlob(packet, supportsBinary, callback) {
            if (!supportsBinary) {
                return exports.encodeBase64Packet(packet, callback);
            }
            
            if (dontSendBlobs) {
                return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
            }
            
            var length = new Uint8Array(1);
            length[0] = packets[packet.type];
            var blob = new Blob([length.buffer, packet.data]);
            
            return callback(blob);
        }
        
        /**
         * Encodes a packet with binary data in a base64 string
         *
         * @param {Object} packet, has `type` and `data`
         * @return {String} base64 encoded message
         */
        
        exports.encodeBase64Packet = function(packet, callback) {
            var message = 'b' + exports.packets[packet.type];
            if (Blob && packet.data instanceof Blob) {
                var fr = new FileReader();
                fr.onload = function() {
                    var b64 = fr.result.split(',')[1];
                    callback(message + b64);
                };
                return fr.readAsDataURL(packet.data);
            }
            
            var b64data;
            try {
                b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
            } catch (e) {
                // iPhone Safari doesn't let you apply with typed arrays
                var typed = new Uint8Array(packet.data);
                var basic = new Array(typed.length);
                for (var i = 0; i < typed.length; i++) {
                    basic[i] = typed[i];
                }
                b64data = String.fromCharCode.apply(null, basic);
            }
            message += global.btoa(b64data);
            return callback(message);
        };
        
        /**
         * Decodes a packet. Changes format to Blob if requested.
         *
         * @return {Object} with `type` and `data` (if any)
         * @api private
         */
        
        exports.decodePacket = function (data, binaryType, utf8decode) {
            // String data
            if (typeof data == 'string' || data === undefined) {
                if (data.charAt(0) == 'b') {
                    return exports.decodeBase64Packet(data.substr(1), binaryType);
                }
                
                if (utf8decode) {
                    try {
                        data = utf8.decode(data);
                    } catch (e) {
                        return err;
                    }
                }
                var type = data.charAt(0);
                
                if (Number(type) != type || !packetslist[type]) {
                    return err;
                }
                
                if (data.length > 1) {
                    return { type: packetslist[type], data: data.substring(1) };
                } else {
                    return { type: packetslist[type] };
                }
            }
            
            var asArray = new Uint8Array(data);
            var type = asArray[0];
            var rest = sliceBuffer(data, 1);
            if (Blob && binaryType === 'blob') {
                rest = new Blob([rest]);
            }
            return { type: packetslist[type], data: rest };
        };
        
        /**
         * Decodes a packet encoded in a base64 string
         *
         * @param {String} base64 encoded message
         * @return {Object} with `type` and `data` (if any)
         */
        
        exports.decodeBase64Packet = function(msg, binaryType) {
            var type = packetslist[msg.charAt(0)];
            if (!global.ArrayBuffer) {
                return { type: type, data: { base64: true, data: msg.substr(1) } };
            }
            
            var data = base64encoder.decode(msg.substr(1));
            
            if (binaryType === 'blob' && Blob) {
                data = new Blob([data]);
            }
            
            return { type: type, data: data };
        };
        
        /**
         * Encodes multiple messages (payload).
         *
         *     <length>:data
         *
         * Example:
         *
         *     11:hello world2:hi
         *
         * If any contents are binary, they will be encoded as base64 strings. Base64
         * encoded strings are marked with a b before the length specifier
         *
         * @param {Array} packets
         * @api private
         */
        
        exports.encodePayload = function (packets, supportsBinary, callback) {
            if (typeof supportsBinary == 'function') {
                callback = supportsBinary;
                supportsBinary = null;
            }
            
            var isBinary = hasBinary(packets);
            
            if (supportsBinary && isBinary) {
                if (Blob && !dontSendBlobs) {
                    return exports.encodePayloadAsBlob(packets, callback);
                }
                
                return exports.encodePayloadAsArrayBuffer(packets, callback);
            }
            
            if (!packets.length) {
                return callback('0:');
            }
            
            function setLengthHeader(message) {
                return message.length + ':' + message;
            }
            
            function encodeOne(packet, doneCallback) {
                exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
                    doneCallback(null, setLengthHeader(message));
                });
            }
            
            map(packets, encodeOne, function(err, results) {
                return callback(results.join(''));
            });
        };
        
        /**
         * Async array map using after
         */
        
        function map(ary, each, done) {
            var result = new Array(ary.length);
            var next = after(ary.length, done);
            
            var eachWithIndex = function(i, el, cb) {
                each(el, function(error, msg) {
                    result[i] = msg;
                    cb(error, result);
                });
            };
            
            for (var i = 0; i < ary.length; i++) {
                eachWithIndex(i, ary[i], next);
            }
        }
        
        /*
         * Decodes data when a payload is maybe expected. Possible binary contents are
         * decoded from their base64 representation
         *
         * @param {String} data, callback method
         * @api public
         */
        
        exports.decodePayload = function (data, binaryType, callback) {
            if (typeof data != 'string') {
                return exports.decodePayloadAsBinary(data, binaryType, callback);
            }
            
            if (typeof binaryType === 'function') {
                callback = binaryType;
                binaryType = null;
            }
            
            var packet;
            if (data == '') {
                // parser error - ignoring payload
                return callback(err, 0, 1);
            }
            
            var length = ''
                , n, msg;
            
            for (var i = 0, l = data.length; i < l; i++) {
                var chr = data.charAt(i);
                
                if (':' != chr) {
                    length += chr;
                } else {
                    if ('' == length || (length != (n = Number(length)))) {
                        // parser error - ignoring payload
                        return callback(err, 0, 1);
                    }
                    
                    msg = data.substr(i + 1, n);
                    
                    if (length != msg.length) {
                        // parser error - ignoring payload
                        return callback(err, 0, 1);
                    }
                    
                    if (msg.length) {
                        packet = exports.decodePacket(msg, binaryType, true);
                        
                        if (err.type == packet.type && err.data == packet.data) {
                            // parser error in individual packet - ignoring payload
                            return callback(err, 0, 1);
                        }
                        
                        var ret = callback(packet, i + n, l);
                        if (false === ret) return;
                    }
                    
                    // advance cursor
                    i += n;
                    length = '';
                }
            }
            
            if (length != '') {
                // parser error - ignoring payload
                return callback(err, 0, 1);
            }
            
        };
        
        /**
         * Encodes multiple messages (payload) as binary.
         *
         * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
         * 255><data>
         *
         * Example:
         * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
         *
         * @param {Array} packets
         * @return {ArrayBuffer} encoded payload
         * @api private
         */
        
        exports.encodePayloadAsArrayBuffer = function(packets, callback) {
            if (!packets.length) {
                return callback(new ArrayBuffer(0));
            }
            
            function encodeOne(packet, doneCallback) {
                exports.encodePacket(packet, true, true, function(data) {
                    return doneCallback(null, data);
                });
            }
            
            map(packets, encodeOne, function(err, encodedPackets) {
                var totalLength = encodedPackets.reduce(function(acc, p) {
                    var len;
                    if (typeof p === 'string'){
                        len = p.length;
                    } else {
                        len = p.byteLength;
                    }
                    return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
                }, 0);
                
                var resultArray = new Uint8Array(totalLength);
                
                var bufferIndex = 0;
                encodedPackets.forEach(function(p) {
                    var isString = typeof p === 'string';
                    var ab = p;
                    if (isString) {
                        var view = new Uint8Array(p.length);
                        for (var i = 0; i < p.length; i++) {
                            view[i] = p.charCodeAt(i);
                        }
                        ab = view.buffer;
                    }
                    
                    if (isString) { // not true binary
                        resultArray[bufferIndex++] = 0;
                    } else { // true binary
                        resultArray[bufferIndex++] = 1;
                    }
                    
                    var lenStr = ab.byteLength.toString();
                    for (var i = 0; i < lenStr.length; i++) {
                        resultArray[bufferIndex++] = parseInt(lenStr[i]);
                    }
                    resultArray[bufferIndex++] = 255;
                    
                    var view = new Uint8Array(ab);
                    for (var i = 0; i < view.length; i++) {
                        resultArray[bufferIndex++] = view[i];
                    }
                });
                
                return callback(resultArray.buffer);
            });
        };
        
        /**
         * Encode as Blob
         */
        
        exports.encodePayloadAsBlob = function(packets, callback) {
            function encodeOne(packet, doneCallback) {
                exports.encodePacket(packet, true, true, function(encoded) {
                    var binaryIdentifier = new Uint8Array(1);
                    binaryIdentifier[0] = 1;
                    if (typeof encoded === 'string') {
                        var view = new Uint8Array(encoded.length);
                        for (var i = 0; i < encoded.length; i++) {
                            view[i] = encoded.charCodeAt(i);
                        }
                        encoded = view.buffer;
                        binaryIdentifier[0] = 0;
                    }
                    
                    var len = (encoded instanceof ArrayBuffer)
                        ? encoded.byteLength
                        : encoded.size;
                    
                    var lenStr = len.toString();
                    var lengthAry = new Uint8Array(lenStr.length + 1);
                    for (var i = 0; i < lenStr.length; i++) {
                        lengthAry[i] = parseInt(lenStr[i]);
                    }
                    lengthAry[lenStr.length] = 255;
                    
                    if (Blob) {
                        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
                        doneCallback(null, blob);
                    }
                });
            }
            
            map(packets, encodeOne, function(err, results) {
                return callback(new Blob(results));
            });
        };
        
        /*
         * Decodes data when a payload is maybe expected. Strings are decoded by
         * interpreting each byte as a key code for entries marked to start with 0. See
         * description of encodePayloadAsBinary
         *
         * @param {ArrayBuffer} data, callback method
         * @api public
         */
        
        exports.decodePayloadAsBinary = function (data, binaryType, callback) {
            if (typeof binaryType === 'function') {
                callback = binaryType;
                binaryType = null;
            }
            
            var bufferTail = data;
            var buffers = [];
            
            var numberTooLong = false;
            while (bufferTail.byteLength > 0) {
                var tailArray = new Uint8Array(bufferTail);
                var isString = tailArray[0] === 0;
                var msgLength = '';
                
                for (var i = 1; ; i++) {
                    if (tailArray[i] == 255) break;
                    
                    if (msgLength.length > 310) {
                        numberTooLong = true;
                        break;
                    }
                    
                    msgLength += tailArray[i];
                }
                
                if(numberTooLong) return callback(err, 0, 1);
                
                bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
                msgLength = parseInt(msgLength);
                
                var msg = sliceBuffer(bufferTail, 0, msgLength);
                if (isString) {
                    try {
                        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
                    } catch (e) {
                        // iPhone Safari doesn't let you apply to typed arrays
                        var typed = new Uint8Array(msg);
                        msg = '';
                        for (var i = 0; i < typed.length; i++) {
                            msg += String.fromCharCode(typed[i]);
                        }
                    }
                }
                
                buffers.push(msg);
                bufferTail = sliceBuffer(bufferTail, msgLength);
            }
            
            var total = buffers.length;
            buffers.forEach(function(buffer, i) {
                callback(exports.decodePacket(buffer, binaryType, true), i, total);
            });
        };
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"./keys":148,"after":149,"arraybuffer.slice":150,"base64-arraybuffer":151,"blob":152,"has-binary":153,"utf8":155}],148:[function(require,module,exports){
    
    /**
     * Gets the keys for an object.
     *
     * @return {Array} keys
     * @api private
     */
    
    module.exports = Object.keys || function keys (obj){
            var arr = [];
            var has = Object.prototype.hasOwnProperty;
            
            for (var i in obj) {
                if (has.call(obj, i)) {
                    arr.push(i);
                }
            }
            return arr;
        };
    
},{}],149:[function(require,module,exports){
    module.exports = after
    
    function after(count, callback, err_cb) {
        var bail = false
        err_cb = err_cb || noop
        proxy.count = count
        
        return (count === 0) ? callback() : proxy
        
        function proxy(err, result) {
            if (proxy.count <= 0) {
                throw new Error('after called too many times')
            }
            --proxy.count
            
            // after first error, rest are passed to err_cb
            if (err) {
                bail = true
                callback(err)
                // future error callbacks will go to error handler
                callback = err_cb
            } else if (proxy.count === 0 && !bail) {
                callback(null, result)
            }
        }
    }
    
    function noop() {}
    
},{}],150:[function(require,module,exports){
    /**
     * An abstraction for slicing an arraybuffer even when
     * ArrayBuffer.prototype.slice is not supported
     *
     * @api public
     */
    
    module.exports = function(arraybuffer, start, end) {
        var bytes = arraybuffer.byteLength;
        start = start || 0;
        end = end || bytes;
        
        if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
        
        if (start < 0) { start += bytes; }
        if (end < 0) { end += bytes; }
        if (end > bytes) { end = bytes; }
        
        if (start >= bytes || start >= end || bytes === 0) {
            return new ArrayBuffer(0);
        }
        
        var abv = new Uint8Array(arraybuffer);
        var result = new Uint8Array(end - start);
        for (var i = start, ii = 0; i < end; i++, ii++) {
            result[ii] = abv[i];
        }
        return result.buffer;
    };
    
},{}],151:[function(require,module,exports){
    /*
     * base64-arraybuffer
     * https://github.com/niklasvh/base64-arraybuffer
     *
     * Copyright (c) 2012 Niklas von Hertzen
     * Licensed under the MIT license.
     */
    (function(chars){
        "use strict";
        
        exports.encode = function(arraybuffer) {
            var bytes = new Uint8Array(arraybuffer),
                i, len = bytes.length, base64 = "";
            
            for (i = 0; i < len; i+=3) {
                base64 += chars[bytes[i] >> 2];
                base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += chars[bytes[i + 2] & 63];
            }
            
            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
            } else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
            }
            
            return base64;
        };
        
        exports.decode =  function(base64) {
            var bufferLength = base64.length * 0.75,
                len = base64.length, i, p = 0,
                encoded1, encoded2, encoded3, encoded4;
            
            if (base64[base64.length - 1] === "=") {
                bufferLength--;
                if (base64[base64.length - 2] === "=") {
                    bufferLength--;
                }
            }
            
            var arraybuffer = new ArrayBuffer(bufferLength),
                bytes = new Uint8Array(arraybuffer);
            
            for (i = 0; i < len; i+=4) {
                encoded1 = chars.indexOf(base64[i]);
                encoded2 = chars.indexOf(base64[i+1]);
                encoded3 = chars.indexOf(base64[i+2]);
                encoded4 = chars.indexOf(base64[i+3]);
                
                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }
            
            return arraybuffer;
        };
    })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    
},{}],152:[function(require,module,exports){
    (function (global){
        /**
         * Create a blob builder even when vendor prefixes exist
         */
        
        var BlobBuilder = global.BlobBuilder
            || global.WebKitBlobBuilder
            || global.MSBlobBuilder
            || global.MozBlobBuilder;
        
        /**
         * Check if Blob constructor is supported
         */
        
        var blobSupported = (function() {
            try {
                var b = new Blob(['hi']);
                return b.size == 2;
            } catch(e) {
                return false;
            }
        })();
        
        /**
         * Check if BlobBuilder is supported
         */
        
        var blobBuilderSupported = BlobBuilder
            && BlobBuilder.prototype.append
            && BlobBuilder.prototype.getBlob;
        
        function BlobBuilderConstructor(ary, options) {
            options = options || {};
            
            var bb = new BlobBuilder();
            for (var i = 0; i < ary.length; i++) {
                bb.append(ary[i]);
            }
            return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
        };
        
        module.exports = (function() {
            if (blobSupported) {
                return global.Blob;
            } else if (blobBuilderSupported) {
                return BlobBuilderConstructor;
            } else {
                return undefined;
            }
        })();
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{}],153:[function(require,module,exports){
    (function (global){
        
        /*
         * Module requirements.
         */
        
        var isArray = require('isarray');
        
        /**
         * Module exports.
         */
        
        module.exports = hasBinary;
        
        /**
         * Checks for binary data.
         *
         * Right now only Buffer and ArrayBuffer are supported..
         *
         * @param {Object} anything
         * @api public
         */
        
        function hasBinary(data) {
            
            function _hasBinary(obj) {
                if (!obj) return false;
                
                if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
                    (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
                    (global.Blob && obj instanceof Blob) ||
                    (global.File && obj instanceof File)
                ) {
                    return true;
                }
                
                if (isArray(obj)) {
                    for (var i = 0; i < obj.length; i++) {
                        if (_hasBinary(obj[i])) {
                            return true;
                        }
                    }
                } else if (obj && 'object' == typeof obj) {
                    if (obj.toJSON) {
                        obj = obj.toJSON();
                    }
                    
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            return _hasBinary(data);
        }
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"isarray":154}],154:[function(require,module,exports){
    module.exports = Array.isArray || function (arr) {
            return Object.prototype.toString.call(arr) == '[object Array]';
        };
    
},{}],155:[function(require,module,exports){
    (function (global){
        /*! http://mths.be/utf8js v2.0.0 by @mathias */
        ;(function(root) {
            
            // Detect free variables `exports`
            var freeExports = typeof exports == 'object' && exports;
            
            // Detect free variable `module`
            var freeModule = typeof module == 'object' && module &&
                module.exports == freeExports && module;
            
            // Detect free variable `global`, from Node.js or Browserified code,
            // and use it as `root`
            var freeGlobal = typeof global == 'object' && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                root = freeGlobal;
            }
            
            /*--------------------------------------------------------------------------*/
            
            var stringFromCharCode = String.fromCharCode;
            
            // Taken from http://mths.be/punycode
            function ucs2decode(string) {
                var output = [];
                var counter = 0;
                var length = string.length;
                var value;
                var extra;
                while (counter < length) {
                    value = string.charCodeAt(counter++);
                    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                        // high surrogate, and there is a next character
                        extra = string.charCodeAt(counter++);
                        if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                        } else {
                            // unmatched surrogate; only append this code unit, in case the next
                            // code unit is the high surrogate of a surrogate pair
                            output.push(value);
                            counter--;
                        }
                    } else {
                        output.push(value);
                    }
                }
                return output;
            }
            
            // Taken from http://mths.be/punycode
            function ucs2encode(array) {
                var length = array.length;
                var index = -1;
                var value;
                var output = '';
                while (++index < length) {
                    value = array[index];
                    if (value > 0xFFFF) {
                        value -= 0x10000;
                        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                        value = 0xDC00 | value & 0x3FF;
                    }
                    output += stringFromCharCode(value);
                }
                return output;
            }
            
            /*--------------------------------------------------------------------------*/
            
            function createByte(codePoint, shift) {
                return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
            }
            
            function encodeCodePoint(codePoint) {
                if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
                    return stringFromCharCode(codePoint);
                }
                var symbol = '';
                if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
                    symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
                }
                else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
                    symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
                    symbol += createByte(codePoint, 6);
                }
                else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
                    symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
                    symbol += createByte(codePoint, 12);
                    symbol += createByte(codePoint, 6);
                }
                symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
                return symbol;
            }
            
            function utf8encode(string) {
                var codePoints = ucs2decode(string);
                
                // console.log(JSON.stringify(codePoints.map(function(x) {
                // 	return 'U+' + x.toString(16).toUpperCase();
                // })));
                
                var length = codePoints.length;
                var index = -1;
                var codePoint;
                var byteString = '';
                while (++index < length) {
                    codePoint = codePoints[index];
                    byteString += encodeCodePoint(codePoint);
                }
                return byteString;
            }
            
            /*--------------------------------------------------------------------------*/
            
            function readContinuationByte() {
                if (byteIndex >= byteCount) {
                    throw Error('Invalid byte index');
                }
                
                var continuationByte = byteArray[byteIndex] & 0xFF;
                byteIndex++;
                
                if ((continuationByte & 0xC0) == 0x80) {
                    return continuationByte & 0x3F;
                }
                
                // If we end up here, it’s not a continuation byte
                throw Error('Invalid continuation byte');
            }
            
            function decodeSymbol() {
                var byte1;
                var byte2;
                var byte3;
                var byte4;
                var codePoint;
                
                if (byteIndex > byteCount) {
                    throw Error('Invalid byte index');
                }
                
                if (byteIndex == byteCount) {
                    return false;
                }
                
                // Read first byte
                byte1 = byteArray[byteIndex] & 0xFF;
                byteIndex++;
                
                // 1-byte sequence (no continuation bytes)
                if ((byte1 & 0x80) == 0) {
                    return byte1;
                }
                
                // 2-byte sequence
                if ((byte1 & 0xE0) == 0xC0) {
                    var byte2 = readContinuationByte();
                    codePoint = ((byte1 & 0x1F) << 6) | byte2;
                    if (codePoint >= 0x80) {
                        return codePoint;
                    } else {
                        throw Error('Invalid continuation byte');
                    }
                }
                
                // 3-byte sequence (may include unpaired surrogates)
                if ((byte1 & 0xF0) == 0xE0) {
                    byte2 = readContinuationByte();
                    byte3 = readContinuationByte();
                    codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
                    if (codePoint >= 0x0800) {
                        return codePoint;
                    } else {
                        throw Error('Invalid continuation byte');
                    }
                }
                
                // 4-byte sequence
                if ((byte1 & 0xF8) == 0xF0) {
                    byte2 = readContinuationByte();
                    byte3 = readContinuationByte();
                    byte4 = readContinuationByte();
                    codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
                        (byte3 << 0x06) | byte4;
                    if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
                        return codePoint;
                    }
                }
                
                throw Error('Invalid UTF-8 detected');
            }
            
            var byteArray;
            var byteCount;
            var byteIndex;
            function utf8decode(byteString) {
                byteArray = ucs2decode(byteString);
                byteCount = byteArray.length;
                byteIndex = 0;
                var codePoints = [];
                var tmp;
                while ((tmp = decodeSymbol()) !== false) {
                    codePoints.push(tmp);
                }
                return ucs2encode(codePoints);
            }
            
            /*--------------------------------------------------------------------------*/
            
            var utf8 = {
                'version': '2.0.0',
                'encode': utf8encode,
                'decode': utf8decode
            };
            
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (
                typeof define == 'function' &&
                typeof define.amd == 'object' &&
                define.amd
            ) {
                define(function() {
                    return utf8;
                });
            }	else if (freeExports && !freeExports.nodeType) {
                if (freeModule) { // in Node.js or RingoJS v0.8.0+
                    freeModule.exports = utf8;
                } else { // in Narwhal or RingoJS v0.7.0-
                    var object = {};
                    var hasOwnProperty = object.hasOwnProperty;
                    for (var key in utf8) {
                        hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
                    }
                }
            } else { // in Rhino or a web browser
                root.utf8 = utf8;
            }
            
        }(this));
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{}],156:[function(require,module,exports){
    
    /**
     * Module dependencies.
     */
    
    var global = require('global');
    
    /**
     * Module exports.
     *
     * Logic borrowed from Modernizr:
     *
     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
     */
    
    try {
        module.exports = 'XMLHttpRequest' in global &&
            'withCredentials' in new global.XMLHttpRequest();
    } catch (err) {
        // if XMLHttp support is disabled in IE then it will throw
        // when trying to create
        module.exports = false;
    }
    
},{"global":157}],157:[function(require,module,exports){
    
    /**
     * Returns `this`. Execute this without a "context" (i.e. without it being
     * attached to an object of the left-hand side), and `this` points to the
     * "global" scope of the current JS execution.
     */
    
    module.exports = (function () { return this; })();
    
},{}],158:[function(require,module,exports){
    (function (global){
        /**
         * JSON parse.
         *
         * @see Based on jQuery#parseJSON (MIT) and JSON2
         * @api private
         */
        
        var rvalidchars = /^[\],:{}\s]*$/;
        var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
        var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
        var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
        var rtrimLeft = /^\s+/;
        var rtrimRight = /\s+$/;
        
        module.exports = function parsejson(data) {
            if ('string' != typeof data || !data) {
                return null;
            }
            
            data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
            
            // Attempt to parse using the native JSON parser first
            if (global.JSON && JSON.parse) {
                return JSON.parse(data);
            }
            
            if (rvalidchars.test(data.replace(rvalidescape, '@')
                    .replace(rvalidtokens, ']')
                    .replace(rvalidbraces, ''))) {
                return (new Function('return ' + data))();
            }
        };
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{}],159:[function(require,module,exports){
    /**
     * Compiles a querystring
     * Returns string representation of the object
     *
     * @param {Object}
     * @api private
     */
    
    exports.encode = function (obj) {
        var str = '';
        
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
                if (str.length) str += '&';
                str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
            }
        }
        
        return str;
    };
    
    /**
     * Parses a simple querystring into an object
     *
     * @param {String} qs
     * @api private
     */
    
    exports.decode = function(qs){
        var qry = {};
        var pairs = qs.split('&');
        for (var i = 0, l = pairs.length; i < l; i++) {
            var pair = pairs[i].split('=');
            qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return qry;
    };
    
},{}],160:[function(require,module,exports){
    /**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */
    
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    
    var parts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];
    
    module.exports = function parseuri(str) {
        var src = str,
            b = str.indexOf('['),
            e = str.indexOf(']');
        
        if (b != -1 && e != -1) {
            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }
        
        var m = re.exec(str || ''),
            uri = {},
            i = 14;
        
        while (i--) {
            uri[parts[i]] = m[i] || '';
        }
        
        if (b != -1 && e != -1) {
            uri.source = src;
            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
            uri.ipv6uri = true;
        }
        
        return uri;
    };
    
},{}],161:[function(require,module,exports){
    
    /**
     * Module dependencies.
     */
    
    var global = (function() { return this; })();
    
    /**
     * WebSocket constructor.
     */
    
    var WebSocket = global.WebSocket || global.MozWebSocket;
    
    /**
     * Module exports.
     */
    
    module.exports = WebSocket ? ws : null;
    
    /**
     * WebSocket constructor.
     *
     * The third `opts` options object gets ignored in web browsers, since it's
     * non-standard, and throws a TypeError if passed to the constructor.
     * See: https://github.com/einaros/ws/issues/227
     *
     * @param {String} uri
     * @param {Array} protocols (optional)
     * @param {Object) opts (optional)
     * @api public
     */
    
    function ws(uri, protocols, opts) {
        var instance;
        if (protocols) {
            instance = new WebSocket(uri, protocols);
        } else {
            instance = new WebSocket(uri);
        }
        return instance;
    }
    
    if (WebSocket) ws.prototype = WebSocket.prototype;
    
},{}],162:[function(require,module,exports){
    (function (global){
        
        /*
         * Module requirements.
         */
        
        var isArray = require('isarray');
        
        /**
         * Module exports.
         */
        
        module.exports = hasBinary;
        
        /**
         * Checks for binary data.
         *
         * Right now only Buffer and ArrayBuffer are supported..
         *
         * @param {Object} anything
         * @api public
         */
        
        function hasBinary(data) {
            
            function _hasBinary(obj) {
                if (!obj) return false;
                
                if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
                    (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
                    (global.Blob && obj instanceof Blob) ||
                    (global.File && obj instanceof File)
                ) {
                    return true;
                }
                
                if (isArray(obj)) {
                    for (var i = 0; i < obj.length; i++) {
                        if (_hasBinary(obj[i])) {
                            return true;
                        }
                    }
                } else if (obj && 'object' == typeof obj) {
                    if (obj.toJSON) {
                        obj = obj.toJSON();
                    }
                    
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            return _hasBinary(data);
        }
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"isarray":163}],163:[function(require,module,exports){
    arguments[4][154][0].apply(exports,arguments)
},{"dup":154}],164:[function(require,module,exports){
    
    var indexOf = [].indexOf;
    
    module.exports = function(arr, obj){
        if (indexOf) return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
            if (arr[i] === obj) return i;
        }
        return -1;
    };
},{}],165:[function(require,module,exports){
    
    /**
     * HOP ref.
     */
    
    var has = Object.prototype.hasOwnProperty;
    
    /**
     * Return own keys in `obj`.
     *
     * @param {Object} obj
     * @return {Array}
     * @api public
     */
    
    exports.keys = Object.keys || function(obj){
            var keys = [];
            for (var key in obj) {
                if (has.call(obj, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    
    /**
     * Return own values in `obj`.
     *
     * @param {Object} obj
     * @return {Array}
     * @api public
     */
    
    exports.values = function(obj){
        var vals = [];
        for (var key in obj) {
            if (has.call(obj, key)) {
                vals.push(obj[key]);
            }
        }
        return vals;
    };
    
    /**
     * Merge `b` into `a`.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object} a
     * @api public
     */
    
    exports.merge = function(a, b){
        for (var key in b) {
            if (has.call(b, key)) {
                a[key] = b[key];
            }
        }
        return a;
    };
    
    /**
     * Return length of `obj`.
     *
     * @param {Object} obj
     * @return {Number}
     * @api public
     */
    
    exports.length = function(obj){
        return exports.keys(obj).length;
    };
    
    /**
     * Check if `obj` is empty.
     *
     * @param {Object} obj
     * @return {Boolean}
     * @api public
     */
    
    exports.isEmpty = function(obj){
        return 0 == exports.length(obj);
    };
},{}],166:[function(require,module,exports){
    /**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */
    
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    
    var parts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
        , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];
    
    module.exports = function parseuri(str) {
        var m = re.exec(str || '')
            , uri = {}
            , i = 14;
        
        while (i--) {
            uri[parts[i]] = m[i] || '';
        }
        
        return uri;
    };
    
},{}],167:[function(require,module,exports){
    (function (global){
        /*global Blob,File*/
        
        /**
         * Module requirements
         */
        
        var isArray = require('isarray');
        var isBuf = require('./is-buffer');
        
        /**
         * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
         * Anything with blobs or files should be fed through removeBlobs before coming
         * here.
         *
         * @param {Object} packet - socket.io event packet
         * @return {Object} with deconstructed packet and list of buffers
         * @api public
         */
        
        exports.deconstructPacket = function(packet){
            var buffers = [];
            var packetData = packet.data;
            
            function _deconstructPacket(data) {
                if (!data) return data;
                
                if (isBuf(data)) {
                    var placeholder = { _placeholder: true, num: buffers.length };
                    buffers.push(data);
                    return placeholder;
                } else if (isArray(data)) {
                    var newData = new Array(data.length);
                    for (var i = 0; i < data.length; i++) {
                        newData[i] = _deconstructPacket(data[i]);
                    }
                    return newData;
                } else if ('object' == typeof data && !(data instanceof Date)) {
                    var newData = {};
                    for (var key in data) {
                        newData[key] = _deconstructPacket(data[key]);
                    }
                    return newData;
                }
                return data;
            }
            
            var pack = packet;
            pack.data = _deconstructPacket(packetData);
            pack.attachments = buffers.length; // number of binary 'attachments'
            return {packet: pack, buffers: buffers};
        };
        
        /**
         * Reconstructs a binary packet from its placeholder packet and buffers
         *
         * @param {Object} packet - event packet with placeholders
         * @param {Array} buffers - binary buffers to put in placeholder positions
         * @return {Object} reconstructed packet
         * @api public
         */
        
        exports.reconstructPacket = function(packet, buffers) {
            var curPlaceHolder = 0;
            
            function _reconstructPacket(data) {
                if (data && data._placeholder) {
                    var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
                    return buf;
                } else if (isArray(data)) {
                    for (var i = 0; i < data.length; i++) {
                        data[i] = _reconstructPacket(data[i]);
                    }
                    return data;
                } else if (data && 'object' == typeof data) {
                    for (var key in data) {
                        data[key] = _reconstructPacket(data[key]);
                    }
                    return data;
                }
                return data;
            }
            
            packet.data = _reconstructPacket(packet.data);
            packet.attachments = undefined; // no longer useful
            return packet;
        };
        
        /**
         * Asynchronously removes Blobs or Files from data via
         * FileReader's readAsArrayBuffer method. Used before encoding
         * data as msgpack. Calls callback with the blobless data.
         *
         * @param {Object} data
         * @param {Function} callback
         * @api private
         */
        
        exports.removeBlobs = function(data, callback) {
            function _removeBlobs(obj, curKey, containingObject) {
                if (!obj) return obj;
                
                // convert any blob
                if ((global.Blob && obj instanceof Blob) ||
                    (global.File && obj instanceof File)) {
                    pendingBlobs++;
                    
                    // async filereader
                    var fileReader = new FileReader();
                    fileReader.onload = function() { // this.result == arraybuffer
                        if (containingObject) {
                            containingObject[curKey] = this.result;
                        }
                        else {
                            bloblessData = this.result;
                        }
                        
                        // if nothing pending its callback time
                        if(! --pendingBlobs) {
                            callback(bloblessData);
                        }
                    };
                    
                    fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
                } else if (isArray(obj)) { // handle array
                    for (var i = 0; i < obj.length; i++) {
                        _removeBlobs(obj[i], i, obj);
                    }
                } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
                    for (var key in obj) {
                        _removeBlobs(obj[key], key, obj);
                    }
                }
            }
            
            var pendingBlobs = 0;
            var bloblessData = data;
            _removeBlobs(bloblessData);
            if (!pendingBlobs) {
                callback(bloblessData);
            }
        };
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"./is-buffer":169,"isarray":170}],168:[function(require,module,exports){
    
    /**
     * Module dependencies.
     */
    
    var debug = require('debug')('socket.io-parser');
    var json = require('json3');
    var isArray = require('isarray');
    var Emitter = require('component-emitter');
    var binary = require('./binary');
    var isBuf = require('./is-buffer');
    
    /**
     * Protocol version.
     *
     * @api public
     */
    
    exports.protocol = 4;
    
    /**
     * Packet types.
     *
     * @api public
     */
    
    exports.types = [
        'CONNECT',
        'DISCONNECT',
        'EVENT',
        'BINARY_EVENT',
        'ACK',
        'BINARY_ACK',
        'ERROR'
    ];
    
    /**
     * Packet type `connect`.
     *
     * @api public
     */
    
    exports.CONNECT = 0;
    
    /**
     * Packet type `disconnect`.
     *
     * @api public
     */
    
    exports.DISCONNECT = 1;
    
    /**
     * Packet type `event`.
     *
     * @api public
     */
    
    exports.EVENT = 2;
    
    /**
     * Packet type `ack`.
     *
     * @api public
     */
    
    exports.ACK = 3;
    
    /**
     * Packet type `error`.
     *
     * @api public
     */
    
    exports.ERROR = 4;
    
    /**
     * Packet type 'binary event'
     *
     * @api public
     */
    
    exports.BINARY_EVENT = 5;
    
    /**
     * Packet type `binary ack`. For acks with binary arguments.
     *
     * @api public
     */
    
    exports.BINARY_ACK = 6;
    
    /**
     * Encoder constructor.
     *
     * @api public
     */
    
    exports.Encoder = Encoder;
    
    /**
     * Decoder constructor.
     *
     * @api public
     */
    
    exports.Decoder = Decoder;
    
    /**
     * A socket.io Encoder instance
     *
     * @api public
     */
    
    function Encoder() {}
    
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     * @param {Function} callback - function to handle encodings (likely engine.write)
     * @return Calls callback with Array of encodings
     * @api public
     */
    
    Encoder.prototype.encode = function(obj, callback){
        debug('encoding packet %j', obj);
        
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
            encodeAsBinary(obj, callback);
        }
        else {
            var encoding = encodeAsString(obj);
            callback([encoding]);
        }
    };
    
    /**
     * Encode packet as string.
     *
     * @param {Object} packet
     * @return {String} encoded
     * @api private
     */
    
    function encodeAsString(obj) {
        var str = '';
        var nsp = false;
        
        // first is type
        str += obj.type;
        
        // attachments if we have them
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
            str += obj.attachments;
            str += '-';
        }
        
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && '/' != obj.nsp) {
            nsp = true;
            str += obj.nsp;
        }
        
        // immediately followed by the id
        if (null != obj.id) {
            if (nsp) {
                str += ',';
                nsp = false;
            }
            str += obj.id;
        }
        
        // json data
        if (null != obj.data) {
            if (nsp) str += ',';
            str += json.stringify(obj.data);
        }
        
        debug('encoded %j as %s', obj, str);
        return str;
    }
    
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     *
     * @param {Object} packet
     * @return {Buffer} encoded
     * @api private
     */
    
    function encodeAsBinary(obj, callback) {
        
        function writeEncoding(bloblessData) {
            var deconstruction = binary.deconstructPacket(bloblessData);
            var pack = encodeAsString(deconstruction.packet);
            var buffers = deconstruction.buffers;
            
            buffers.unshift(pack); // add packet info to beginning of data list
            callback(buffers); // write all the buffers
        }
        
        binary.removeBlobs(obj, writeEncoding);
    }
    
    /**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     * @api public
     */
    
    function Decoder() {
        this.reconstructor = null;
    }
    
    /**
     * Mix in `Emitter` with Decoder.
     */
    
    Emitter(Decoder.prototype);
    
    /**
     * Decodes an ecoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     * @return {Object} packet
     * @api public
     */
    
    Decoder.prototype.add = function(obj) {
        var packet;
        if ('string' == typeof obj) {
            packet = decodeString(obj);
            if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                
                // no attachments, labeled binary but no binary data to follow
                if (this.reconstructor.reconPack.attachments === 0) {
                    this.emit('decoded', packet);
                }
            } else { // non-binary full packet
                this.emit('decoded', packet);
            }
        }
        else if (isBuf(obj) || obj.base64) { // raw binary data
            if (!this.reconstructor) {
                throw new Error('got binary data when not reconstructing a packet');
            } else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) { // received final buffer
                    this.reconstructor = null;
                    this.emit('decoded', packet);
                }
            }
        }
        else {
            throw new Error('Unknown type: ' + obj);
        }
    };
    
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     * @api private
     */
    
    function decodeString(str) {
        var p = {};
        var i = 0;
        
        // look up type
        p.type = Number(str.charAt(0));
        if (null == exports.types[p.type]) return error();
        
        // look up attachments if type binary
        if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
            var buf = '';
            while (str.charAt(++i) != '-') {
                buf += str.charAt(i);
                if (i == str.length) break;
            }
            if (buf != Number(buf) || str.charAt(i) != '-') {
                throw new Error('Illegal attachments');
            }
            p.attachments = Number(buf);
        }
        
        // look up namespace (if any)
        if ('/' == str.charAt(i + 1)) {
            p.nsp = '';
            while (++i) {
                var c = str.charAt(i);
                if (',' == c) break;
                p.nsp += c;
                if (i == str.length) break;
            }
        } else {
            p.nsp = '/';
        }
        
        // look up id
        var next = str.charAt(i + 1);
        if ('' !== next && Number(next) == next) {
            p.id = '';
            while (++i) {
                var c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                p.id += str.charAt(i);
                if (i == str.length) break;
            }
            p.id = Number(p.id);
        }
        
        // look up json data
        if (str.charAt(++i)) {
            try {
                p.data = json.parse(str.substr(i));
            } catch(e){
                return error();
            }
        }
        
        debug('decoded %s as %j', str, p);
        return p;
    }
    
    /**
     * Deallocates a parser's resources
     *
     * @api public
     */
    
    Decoder.prototype.destroy = function() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
        }
    };
    
    /**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     * @api private
     */
    
    function BinaryReconstructor(packet) {
        this.reconPack = packet;
        this.buffers = [];
    }
    
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     * @api private
     */
    
    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
        this.buffers.push(binData);
        if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
            var packet = binary.reconstructPacket(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    };
    
    /**
     * Cleans up binary packet reconstruction variables.
     *
     * @api private
     */
    
    BinaryReconstructor.prototype.finishedReconstruction = function() {
        this.reconPack = null;
        this.buffers = [];
    };
    
    function error(data){
        return {
            type: exports.ERROR,
            data: 'parser error'
        };
    }
    
},{"./binary":167,"./is-buffer":169,"component-emitter":131,"debug":132,"isarray":170,"json3":171}],169:[function(require,module,exports){
    (function (global){
        
        module.exports = isBuf;
        
        /**
         * Returns true if obj is a buffer or an arraybuffer.
         *
         * @api private
         */
        
        function isBuf(obj) {
            return (global.Buffer && global.Buffer.isBuffer(obj)) ||
                (global.ArrayBuffer && obj instanceof ArrayBuffer);
        }
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{}],170:[function(require,module,exports){
    arguments[4][154][0].apply(exports,arguments)
},{"dup":154}],171:[function(require,module,exports){
    /*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
    ;(function (window) {
        // Convenience aliases.
        var getClass = {}.toString, isProperty, forEach, undef;
        
        // Detect the `define` function exposed by asynchronous module loaders. The
        // strict `define` check is necessary for compatibility with `r.js`.
        var isLoader = typeof define === "function" && define.amd;
        
        // Detect native implementations.
        var nativeJSON = typeof JSON == "object" && JSON;
        
        // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
        // available.
        var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;
        
        if (JSON3 && nativeJSON) {
            // Explicitly delegate to the native `stringify` and `parse`
            // implementations in CommonJS environments.
            JSON3.stringify = nativeJSON.stringify;
            JSON3.parse = nativeJSON.parse;
        } else {
            // Export for web browsers, JavaScript engines, and asynchronous module
            // loaders, using the global `JSON` object if available.
            JSON3 = window.JSON = nativeJSON || {};
        }
        
        // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
        var isExtended = new Date(-3509827334573292);
        try {
            // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
            // results for certain dates in Opera >= 10.53.
            isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
                    // Safari < 2.0.2 stores the internal millisecond time value correctly,
                    // but clips the values returned by the date methods to the range of
                    // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
                isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
        } catch (exception) {}
        
        // Internal: Determines whether the native `JSON.stringify` and `parse`
        // implementations are spec-compliant. Based on work by Ken Snyder.
        function has(name) {
            if (has[name] !== undef) {
                // Return cached feature test result.
                return has[name];
            }
            
            var isSupported;
            if (name == "bug-string-char-index") {
                // IE <= 7 doesn't support accessing string characters using square
                // bracket notation. IE 8 only supports this for primitives.
                isSupported = "a"[0] != "a";
            } else if (name == "json") {
                // Indicates whether both `JSON.stringify` and `JSON.parse` are
                // supported.
                isSupported = has("json-stringify") && has("json-parse");
            } else {
                var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                // Test `JSON.stringify`.
                if (name == "json-stringify") {
                    var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
                    if (stringifySupported) {
                        // A test function object with a custom `toJSON` method.
                        (value = function () {
                            return 1;
                        }).toJSON = value;
                        try {
                            stringifySupported =
                                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                                // primitives as object literals.
                                stringify(0) === "0" &&
                                    // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                                    // literals.
                                stringify(new Number()) === "0" &&
                                stringify(new String()) == '""' &&
                                    // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                                    // does not define a canonical JSON representation (this applies to
                                    // objects with `toJSON` properties as well, *unless* they are nested
                                    // within an object or array).
                                stringify(getClass) === undef &&
                                    // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                                    // FF 3.1b3 pass this test.
                                stringify(undef) === undef &&
                                    // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                                    // respectively, if the value is omitted entirely.
                                stringify() === undef &&
                                    // FF 3.1b1, 2 throw an error if the given value is not a number,
                                    // string, array, object, Boolean, or `null` literal. This applies to
                                    // objects with custom `toJSON` methods as well, unless they are nested
                                    // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                                    // methods entirely.
                                stringify(value) === "1" &&
                                stringify([value]) == "[1]" &&
                                    // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                                    // `"[null]"`.
                                stringify([undef]) == "[null]" &&
                                    // YUI 3.0.0b1 fails to serialize `null` literals.
                                stringify(null) == "null" &&
                                    // FF 3.1b1, 2 halts serialization if an array contains a function:
                                    // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                                    // elides non-JSON values from objects and arrays, unless they
                                    // define custom `toJSON` methods.
                                stringify([undef, getClass, null]) == "[null,null,null]" &&
                                    // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                                    // where character escape codes are expected (e.g., `\b` => `\u0008`).
                                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                                    // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                                stringify(null, value) === "1" &&
                                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                                    // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                                    // serialize extended years.
                                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                                    // The milliseconds are optional in ES 5, but required in 5.1.
                                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                                    // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                                    // four-digit years instead of six-digit years. Credits: @Yaffle.
                                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                                    // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                                    // values less than 1000. Credits: @Yaffle.
                                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                        } catch (exception) {
                            stringifySupported = false;
                        }
                    }
                    isSupported = stringifySupported;
                }
                // Test `JSON.parse`.
                if (name == "json-parse") {
                    var parse = JSON3.parse;
                    if (typeof parse == "function") {
                        try {
                            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                            // Conforming implementations should also coerce the initial argument to
                            // a string prior to parsing.
                            if (parse("0") === 0 && !parse(false)) {
                                // Simple parsing test.
                                value = parse(serialized);
                                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                                if (parseSupported) {
                                    try {
                                        // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                        parseSupported = !parse('"\t"');
                                    } catch (exception) {}
                                    if (parseSupported) {
                                        try {
                                            // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                                            // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                                            // certain octal literals.
                                            parseSupported = parse("01") !== 1;
                                        } catch (exception) {}
                                    }
                                    if (parseSupported) {
                                        try {
                                            // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                                            // points. These environments, along with FF 3.1b1 and 2,
                                            // also allow trailing commas in JSON objects and arrays.
                                            parseSupported = parse("1.") !== 1;
                                        } catch (exception) {}
                                    }
                                }
                            }
                        } catch (exception) {
                            parseSupported = false;
                        }
                    }
                    isSupported = parseSupported;
                }
            }
            return has[name] = !!isSupported;
        }
        
        if (!has("json")) {
            // Common `[[Class]]` name aliases.
            var functionClass = "[object Function]";
            var dateClass = "[object Date]";
            var numberClass = "[object Number]";
            var stringClass = "[object String]";
            var arrayClass = "[object Array]";
            var booleanClass = "[object Boolean]";
            
            // Detect incomplete support for accessing string characters by index.
            var charIndexBuggy = has("bug-string-char-index");
            
            // Define additional utility methods if the `Date` methods are buggy.
            if (!isExtended) {
                var floor = Math.floor;
                // A mapping between the months of the year and the number of days between
                // January 1st and the first of the respective month.
                var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                // Internal: Calculates the number of days between the Unix epoch and the
                // first day of the given month.
                var getDay = function (year, month) {
                    return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                };
            }
            
            // Internal: Determines if a property is a direct property of the given
            // object. Delegates to the native `Object#hasOwnProperty` method.
            if (!(isProperty = {}.hasOwnProperty)) {
                isProperty = function (property) {
                    var members = {}, constructor;
                    if ((members.__proto__ = null, members.__proto__ = {
                            // The *proto* property cannot be set multiple times in recent
                            // versions of Firefox and SeaMonkey.
                            "toString": 1
                        }, members).toString != getClass) {
                        // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
                        // supports the mutable *proto* property.
                        isProperty = function (property) {
                            // Capture and break the object's prototype chain (see section 8.6.2
                            // of the ES 5.1 spec). The parenthesized expression prevents an
                            // unsafe transformation by the Closure Compiler.
                            var original = this.__proto__, result = property in (this.__proto__ = null, this);
                            // Restore the original prototype chain.
                            this.__proto__ = original;
                            return result;
                        };
                    } else {
                        // Capture a reference to the top-level `Object` constructor.
                        constructor = members.constructor;
                        // Use the `constructor` property to simulate `Object#hasOwnProperty` in
                        // other environments.
                        isProperty = function (property) {
                            var parent = (this.constructor || constructor).prototype;
                            return property in this && !(property in parent && this[property] === parent[property]);
                        };
                    }
                    members = null;
                    return isProperty.call(this, property);
                };
            }
            
            // Internal: A set of primitive types used by `isHostType`.
            var PrimitiveTypes = {
                'boolean': 1,
                'number': 1,
                'string': 1,
                'undefined': 1
            };
            
            // Internal: Determines if the given object `property` value is a
            // non-primitive.
            var isHostType = function (object, property) {
                var type = typeof object[property];
                return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
            };
            
            // Internal: Normalizes the `for...in` iteration algorithm across
            // environments. Each enumerated key is yielded to a `callback` function.
            forEach = function (object, callback) {
                var size = 0, Properties, members, property;
                
                // Tests for bugs in the current environment's `for...in` algorithm. The
                // `valueOf` property inherits the non-enumerable flag from
                // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
                (Properties = function () {
                    this.valueOf = 0;
                }).prototype.valueOf = 0;
                
                // Iterate over a new instance of the `Properties` class.
                members = new Properties();
                for (property in members) {
                    // Ignore all properties inherited from `Object.prototype`.
                    if (isProperty.call(members, property)) {
                        size++;
                    }
                }
                Properties = members = null;
                
                // Normalize the iteration algorithm.
                if (!size) {
                    // A list of non-enumerable properties inherited from `Object.prototype`.
                    members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
                    // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
                    // properties.
                    forEach = function (object, callback) {
                        var isFunction = getClass.call(object) == functionClass, property, length;
                        var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
                        for (property in object) {
                            // Gecko <= 1.0 enumerates the `prototype` property of functions under
                            // certain conditions; IE does not.
                            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                                callback(property);
                            }
                        }
                        // Manually invoke the callback for each non-enumerable property.
                        for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
                    };
                } else if (size == 2) {
                    // Safari <= 2.0.4 enumerates shadowed properties twice.
                    forEach = function (object, callback) {
                        // Create a set of iterated properties.
                        var members = {}, isFunction = getClass.call(object) == functionClass, property;
                        for (property in object) {
                            // Store each property name to prevent double enumeration. The
                            // `prototype` property of functions is not enumerated due to cross-
                            // environment inconsistencies.
                            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                                callback(property);
                            }
                        }
                    };
                } else {
                    // No bugs detected; use the standard `for...in` algorithm.
                    forEach = function (object, callback) {
                        var isFunction = getClass.call(object) == functionClass, property, isConstructor;
                        for (property in object) {
                            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                                callback(property);
                            }
                        }
                        // Manually invoke the callback for the `constructor` property due to
                        // cross-environment inconsistencies.
                        if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                            callback(property);
                        }
                    };
                }
                return forEach(object, callback);
            };
            
            // Public: Serializes a JavaScript `value` as a JSON string. The optional
            // `filter` argument may specify either a function that alters how object and
            // array members are serialized, or an array of strings and numbers that
            // indicates which properties should be serialized. The optional `width`
            // argument may be either a string or number that specifies the indentation
            // level of the output.
            if (!has("json-stringify")) {
                // Internal: A map of control characters and their escaped equivalents.
                var Escapes = {
                    92: "\\\\",
                    34: '\\"',
                    8: "\\b",
                    12: "\\f",
                    10: "\\n",
                    13: "\\r",
                    9: "\\t"
                };
                
                // Internal: Converts `value` into a zero-padded string such that its
                // length is at least equal to `width`. The `width` must be <= 6.
                var leadingZeroes = "000000";
                var toPaddedString = function (width, value) {
                    // The `|| 0` expression is necessary to work around a bug in
                    // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
                    return (leadingZeroes + (value || 0)).slice(-width);
                };
                
                // Internal: Double-quotes a string `value`, replacing all ASCII control
                // characters (characters with code unit values between 0 and 31) with
                // their escaped equivalents. This is an implementation of the
                // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
                var unicodePrefix = "\\u00";
                var quote = function (value) {
                    var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
                    if (isLarge) {
                        symbols = value.split("");
                    }
                    for (; index < length; index++) {
                        var charCode = value.charCodeAt(index);
                        // If the character is a control character, append its Unicode or
                        // shorthand escape sequence; otherwise, append the character as-is.
                        switch (charCode) {
                            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                            result += Escapes[charCode];
                            break;
                            default:
                                if (charCode < 32) {
                                    result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                                    break;
                                }
                                result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
                        }
                    }
                    return result + '"';
                };
                
                // Internal: Recursively serializes an object. Implements the
                // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
                var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
                    var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                    try {
                        // Necessary for host object support.
                        value = object[property];
                    } catch (exception) {}
                    if (typeof value == "object" && value) {
                        className = getClass.call(value);
                        if (className == dateClass && !isProperty.call(value, "toJSON")) {
                            if (value > -1 / 0 && value < 1 / 0) {
                                // Dates are serialized according to the `Date#toJSON` method
                                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                                // for the ISO 8601 date time string format.
                                if (getDay) {
                                    // Manually compute the year, month, date, hours, minutes,
                                    // seconds, and milliseconds if the `getUTC*` methods are
                                    // buggy. Adapted from @Yaffle's `date-shim` project.
                                    date = floor(value / 864e5);
                                    for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                                    for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                                    date = 1 + date - getDay(year, month);
                                    // The `time` value specifies the time within the day (see ES
                                    // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                                    // to compute `A modulo B`, as the `%` operator does not
                                    // correspond to the `modulo` operation for negative numbers.
                                    time = (value % 864e5 + 864e5) % 864e5;
                                    // The hours, minutes, seconds, and milliseconds are obtained by
                                    // decomposing the time within the day. See section 15.9.1.10.
                                    hours = floor(time / 36e5) % 24;
                                    minutes = floor(time / 6e4) % 60;
                                    seconds = floor(time / 1e3) % 60;
                                    milliseconds = time % 1e3;
                                } else {
                                    year = value.getUTCFullYear();
                                    month = value.getUTCMonth();
                                    date = value.getUTCDate();
                                    hours = value.getUTCHours();
                                    minutes = value.getUTCMinutes();
                                    seconds = value.getUTCSeconds();
                                    milliseconds = value.getUTCMilliseconds();
                                }
                                // Serialize extended years correctly.
                                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                                    "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                                        // Months, dates, hours, minutes, and seconds should have two
                                        // digits; milliseconds should have three.
                                    "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                                        // Milliseconds are optional in ES 5.0, but required in 5.1.
                                    "." + toPaddedString(3, milliseconds) + "Z";
                            } else {
                                value = null;
                            }
                        } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                            // ignores all `toJSON` methods on these objects unless they are
                            // defined directly on an instance.
                            value = value.toJSON(property);
                        }
                    }
                    if (callback) {
                        // If a replacement function was provided, call it to obtain the value
                        // for serialization.
                        value = callback.call(object, property, value);
                    }
                    if (value === null) {
                        return "null";
                    }
                    className = getClass.call(value);
                    if (className == booleanClass) {
                        // Booleans are represented literally.
                        return "" + value;
                    } else if (className == numberClass) {
                        // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                        // `"null"`.
                        return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                    } else if (className == stringClass) {
                        // Strings are double-quoted and escaped.
                        return quote("" + value);
                    }
                    // Recursively serialize objects and arrays.
                    if (typeof value == "object") {
                        // Check for cyclic structures. This is a linear search; performance
                        // is inversely proportional to the number of unique nested objects.
                        for (length = stack.length; length--;) {
                            if (stack[length] === value) {
                                // Cyclic structures cannot be serialized by `JSON.stringify`.
                                throw TypeError();
                            }
                        }
                        // Add the object to the stack of traversed objects.
                        stack.push(value);
                        results = [];
                        // Save the current indentation level and indent one additional level.
                        prefix = indentation;
                        indentation += whitespace;
                        if (className == arrayClass) {
                            // Recursively serialize array elements.
                            for (index = 0, length = value.length; index < length; index++) {
                                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                                results.push(element === undef ? "null" : element);
                            }
                            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                        } else {
                            // Recursively serialize object members. Members are selected from
                            // either a user-specified list of property names, or the object
                            // itself.
                            forEach(properties || value, function (property) {
                                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                if (element !== undef) {
                                    // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                                    // is not the empty string, let `member` {quote(property) + ":"}
                                    // be the concatenation of `member` and the `space` character."
                                    // The "`space` character" refers to the literal space
                                    // character, not the `space` {width} argument provided to
                                    // `JSON.stringify`.
                                    results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                                }
                            });
                            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                        }
                        // Remove the object from the traversed object stack.
                        stack.pop();
                        return result;
                    }
                };
                
                // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
                JSON3.stringify = function (source, filter, width) {
                    var whitespace, callback, properties, className;
                    if (typeof filter == "function" || typeof filter == "object" && filter) {
                        if ((className = getClass.call(filter)) == functionClass) {
                            callback = filter;
                        } else if (className == arrayClass) {
                            // Convert the property names array into a makeshift set.
                            properties = {};
                            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
                        }
                    }
                    if (width) {
                        if ((className = getClass.call(width)) == numberClass) {
                            // Convert the `width` to an integer and create a string containing
                            // `width` number of space characters.
                            if ((width -= width % 1) > 0) {
                                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
                            }
                        } else if (className == stringClass) {
                            whitespace = width.length <= 10 ? width : width.slice(0, 10);
                        }
                    }
                    // Opera <= 7.54u2 discards the values associated with empty string keys
                    // (`""`) only if they are used directly within an object member list
                    // (e.g., `!("" in { "": 1})`).
                    return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                };
            }
            
            // Public: Parses a JSON source string.
            if (!has("json-parse")) {
                var fromCharCode = String.fromCharCode;
                
                // Internal: A map of escaped control characters and their unescaped
                // equivalents.
                var Unescapes = {
                    92: "\\",
                    34: '"',
                    47: "/",
                    98: "\b",
                    116: "\t",
                    110: "\n",
                    102: "\f",
                    114: "\r"
                };
                
                // Internal: Stores the parser state.
                var Index, Source;
                
                // Internal: Resets the parser state and throws a `SyntaxError`.
                var abort = function() {
                    Index = Source = null;
                    throw SyntaxError();
                };
                
                // Internal: Returns the next token, or `"$"` if the parser has reached
                // the end of the source string. A token may be a string, number, `null`
                // literal, or Boolean literal.
                var lex = function () {
                    var source = Source, length = source.length, value, begin, position, isSigned, charCode;
                    while (Index < length) {
                        charCode = source.charCodeAt(Index);
                        switch (charCode) {
                            case 9: case 10: case 13: case 32:
                            // Skip whitespace tokens, including tabs, carriage returns, line
                            // feeds, and space characters.
                            Index++;
                            break;
                            case 123: case 125: case 91: case 93: case 58: case 44:
                            // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                            // the current position.
                            value = charIndexBuggy ? source.charAt(Index) : source[Index];
                            Index++;
                            return value;
                            case 34:
                                // `"` delimits a JSON string; advance to the next character and
                                // begin parsing the string. String tokens are prefixed with the
                                // sentinel `@` character to distinguish them from punctuators and
                                // end-of-string tokens.
                                for (value = "@", Index++; Index < length;) {
                                    charCode = source.charCodeAt(Index);
                                    if (charCode < 32) {
                                        // Unescaped ASCII control characters (those with a code unit
                                        // less than the space character) are not permitted.
                                        abort();
                                    } else if (charCode == 92) {
                                        // A reverse solidus (`\`) marks the beginning of an escaped
                                        // control character (including `"`, `\`, and `/`) or Unicode
                                        // escape sequence.
                                        charCode = source.charCodeAt(++Index);
                                        switch (charCode) {
                                            case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                                            // Revive escaped control characters.
                                            value += Unescapes[charCode];
                                            Index++;
                                            break;
                                            case 117:
                                                // `\u` marks the beginning of a Unicode escape sequence.
                                                // Advance to the first character and validate the
                                                // four-digit code point.
                                                begin = ++Index;
                                                for (position = Index + 4; Index < position; Index++) {
                                                    charCode = source.charCodeAt(Index);
                                                    // A valid sequence comprises four hexdigits (case-
                                                    // insensitive) that form a single hexadecimal value.
                                                    if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                                        // Invalid Unicode escape sequence.
                                                        abort();
                                                    }
                                                }
                                                // Revive the escaped character.
                                                value += fromCharCode("0x" + source.slice(begin, Index));
                                                break;
                                            default:
                                                // Invalid escape sequence.
                                                abort();
                                        }
                                    } else {
                                        if (charCode == 34) {
                                            // An unescaped double-quote character marks the end of the
                                            // string.
                                            break;
                                        }
                                        charCode = source.charCodeAt(Index);
                                        begin = Index;
                                        // Optimize for the common case where a string is valid.
                                        while (charCode >= 32 && charCode != 92 && charCode != 34) {
                                            charCode = source.charCodeAt(++Index);
                                        }
                                        // Append the string as-is.
                                        value += source.slice(begin, Index);
                                    }
                                }
                                if (source.charCodeAt(Index) == 34) {
                                    // Advance to the next character and return the revived string.
                                    Index++;
                                    return value;
                                }
                                // Unterminated string.
                                abort();
                            default:
                                // Parse numbers and literals.
                                begin = Index;
                                // Advance past the negative sign, if one is specified.
                                if (charCode == 45) {
                                    isSigned = true;
                                    charCode = source.charCodeAt(++Index);
                                }
                                // Parse an integer or floating-point value.
                                if (charCode >= 48 && charCode <= 57) {
                                    // Leading zeroes are interpreted as octal literals.
                                    if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                                        // Illegal octal literal.
                                        abort();
                                    }
                                    isSigned = false;
                                    // Parse the integer component.
                                    for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                                    // Floats cannot contain a leading decimal point; however, this
                                    // case is already accounted for by the parser.
                                    if (source.charCodeAt(Index) == 46) {
                                        position = ++Index;
                                        // Parse the decimal component.
                                        for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                                        if (position == Index) {
                                            // Illegal trailing decimal.
                                            abort();
                                        }
                                        Index = position;
                                    }
                                    // Parse exponents. The `e` denoting the exponent is
                                    // case-insensitive.
                                    charCode = source.charCodeAt(Index);
                                    if (charCode == 101 || charCode == 69) {
                                        charCode = source.charCodeAt(++Index);
                                        // Skip past the sign following the exponent, if one is
                                        // specified.
                                        if (charCode == 43 || charCode == 45) {
                                            Index++;
                                        }
                                        // Parse the exponential component.
                                        for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                                        if (position == Index) {
                                            // Illegal empty exponent.
                                            abort();
                                        }
                                        Index = position;
                                    }
                                    // Coerce the parsed value to a JavaScript number.
                                    return +source.slice(begin, Index);
                                }
                                // A negative sign may only precede numbers.
                                if (isSigned) {
                                    abort();
                                }
                                // `true`, `false`, and `null` literals.
                                if (source.slice(Index, Index + 4) == "true") {
                                    Index += 4;
                                    return true;
                                } else if (source.slice(Index, Index + 5) == "false") {
                                    Index += 5;
                                    return false;
                                } else if (source.slice(Index, Index + 4) == "null") {
                                    Index += 4;
                                    return null;
                                }
                                // Unrecognized token.
                                abort();
                        }
                    }
                    // Return the sentinel `$` character if the parser has reached the end
                    // of the source string.
                    return "$";
                };
                
                // Internal: Parses a JSON `value` token.
                var get = function (value) {
                    var results, hasMembers;
                    if (value == "$") {
                        // Unexpected end of input.
                        abort();
                    }
                    if (typeof value == "string") {
                        if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                            // Remove the sentinel `@` character.
                            return value.slice(1);
                        }
                        // Parse object and array literals.
                        if (value == "[") {
                            // Parses a JSON array, returning a new JavaScript array.
                            results = [];
                            for (;; hasMembers || (hasMembers = true)) {
                                value = lex();
                                // A closing square bracket marks the end of the array literal.
                                if (value == "]") {
                                    break;
                                }
                                // If the array literal contains elements, the current token
                                // should be a comma separating the previous element from the
                                // next.
                                if (hasMembers) {
                                    if (value == ",") {
                                        value = lex();
                                        if (value == "]") {
                                            // Unexpected trailing `,` in array literal.
                                            abort();
                                        }
                                    } else {
                                        // A `,` must separate each array element.
                                        abort();
                                    }
                                }
                                // Elisions and leading commas are not permitted.
                                if (value == ",") {
                                    abort();
                                }
                                results.push(get(value));
                            }
                            return results;
                        } else if (value == "{") {
                            // Parses a JSON object, returning a new JavaScript object.
                            results = {};
                            for (;; hasMembers || (hasMembers = true)) {
                                value = lex();
                                // A closing curly brace marks the end of the object literal.
                                if (value == "}") {
                                    break;
                                }
                                // If the object literal contains members, the current token
                                // should be a comma separator.
                                if (hasMembers) {
                                    if (value == ",") {
                                        value = lex();
                                        if (value == "}") {
                                            // Unexpected trailing `,` in object literal.
                                            abort();
                                        }
                                    } else {
                                        // A `,` must separate each object member.
                                        abort();
                                    }
                                }
                                // Leading commas are not permitted, object property names must be
                                // double-quoted strings, and a `:` must separate each property
                                // name and value.
                                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                                    abort();
                                }
                                results[value.slice(1)] = get(lex());
                            }
                            return results;
                        }
                        // Unexpected token encountered.
                        abort();
                    }
                    return value;
                };
                
                // Internal: Updates a traversed object member.
                var update = function(source, property, callback) {
                    var element = walk(source, property, callback);
                    if (element === undef) {
                        delete source[property];
                    } else {
                        source[property] = element;
                    }
                };
                
                // Internal: Recursively traverses a parsed JSON object, invoking the
                // `callback` function for each value. This is an implementation of the
                // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
                var walk = function (source, property, callback) {
                    var value = source[property], length;
                    if (typeof value == "object" && value) {
                        // `forEach` can't be used to traverse an array in Opera <= 8.54
                        // because its `Object#hasOwnProperty` implementation returns `false`
                        // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                        if (getClass.call(value) == arrayClass) {
                            for (length = value.length; length--;) {
                                update(value, length, callback);
                            }
                        } else {
                            forEach(value, function (property) {
                                update(value, property, callback);
                            });
                        }
                    }
                    return callback.call(source, property, value);
                };
                
                // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
                JSON3.parse = function (source, callback) {
                    var result, value;
                    Index = 0;
                    Source = "" + source;
                    result = get(lex());
                    // If a JSON string contains multiple tokens, it is invalid.
                    if (lex() != "$") {
                        abort();
                    }
                    // Reset the parser state.
                    Index = Source = null;
                    return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
                };
            }
        }
        
        // Export for asynchronous module loaders.
        if (isLoader) {
            define(function () {
                return JSON3;
            });
        }
    }(this));
    
},{}],172:[function(require,module,exports){
    module.exports = toArray
    
    function toArray(list, index) {
        var array = []
        
        index = index || 0
        
        for (var i = index || 0; i < list.length; i++) {
            array[i - index] = list[i]
        }
        
        return array
    }
    
},{}],173:[function(require,module,exports){
    (function (global){
        
        ; $ = global.$ = require("/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js");
        ; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
            /** File: strophe.js
             *  A JavaScript library for XMPP BOSH/XMPP over Websocket.
             *
             *  This is the JavaScript version of the Strophe library.  Since JavaScript
             *  had no facilities for persistent TCP connections, this library uses
             *  Bidirectional-streams Over Synchronous HTTP (BOSH) to emulate
             *  a persistent, stateful, two-way connection to an XMPP server.  More
             *  information on BOSH can be found in XEP 124.
             *
             *  This version of Strophe also works with WebSockets.
             *  For more information on XMPP-over WebSocket see this RFC:
             *  http://tools.ietf.org/html/rfc7395
             */
            
            /* All of the Strophe globals are defined in this special function below so
             * that references to the globals become closures.  This will ensure that
             * on page reload, these references will still be available to callbacks
             * that are still executing.
             */
            
            /* jshint ignore:start */
            (function (callback) {
                /* jshint ignore:end */
                
                // This code was written by Tyler Akins and has been placed in the
                // public domain.  It would be nice if you left this header intact.
                // Base64 code from Tyler Akins -- http://rumkin.com
                
                (function (root, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define('strophe-base64', function () {
                            return factory();
                        });
                    } else {
                        // Browser globals
                        root.Base64 = factory();
                    }
                }(this, function () {
                    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                    
                    var obj = {
                        /**
                         * Encodes a string in base64
                         * @param {String} input The string to encode in base64.
                         */
                        encode: function (input) {
                            var output = "";
                            var chr1, chr2, chr3;
                            var enc1, enc2, enc3, enc4;
                            var i = 0;
                            
                            do {
                                chr1 = input.charCodeAt(i++);
                                chr2 = input.charCodeAt(i++);
                                chr3 = input.charCodeAt(i++);
                                
                                enc1 = chr1 >> 2;
                                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                                enc4 = chr3 & 63;
                                
                                if (isNaN(chr2)) {
                                    enc2 = ((chr1 & 3) << 4);
                                    enc3 = enc4 = 64;
                                } else if (isNaN(chr3)) {
                                    enc4 = 64;
                                }
                                
                                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
                            } while (i < input.length);
                            
                            return output;
                        },
                        
                        /**
                         * Decodes a base64 string.
                         * @param {String} input The string to decode.
                         */
                        decode: function (input) {
                            var output = "";
                            var chr1, chr2, chr3;
                            var enc1, enc2, enc3, enc4;
                            var i = 0;
                            
                            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                            
                            do {
                                enc1 = keyStr.indexOf(input.charAt(i++));
                                enc2 = keyStr.indexOf(input.charAt(i++));
                                enc3 = keyStr.indexOf(input.charAt(i++));
                                enc4 = keyStr.indexOf(input.charAt(i++));
                                
                                chr1 = (enc1 << 2) | (enc2 >> 4);
                                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                                chr3 = ((enc3 & 3) << 6) | enc4;
                                
                                output = output + String.fromCharCode(chr1);
                                
                                if (enc3 != 64) {
                                    output = output + String.fromCharCode(chr2);
                                }
                                if (enc4 != 64) {
                                    output = output + String.fromCharCode(chr3);
                                }
                            } while (i < input.length);
                            
                            return output;
                        }
                    };
                    return obj;
                }));
                
                /*
                 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
                 * in FIPS PUB 180-1
                 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
                 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                 * Distributed under the BSD License
                 * See http://pajhome.org.uk/crypt/md5 for details.
                 */
                
                /* jshint undef: true, unused: true:, noarg: true, latedef: true */
                /* global define */
                
                /* Some functions and variables have been stripped for use with Strophe */
                
                (function (root, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define('strophe-sha1', function () {
                            return factory();
                        });
                    } else {
                        // Browser globals
                        root.SHA1 = factory();
                    }
                }(this, function () {
                    
                    /*
                     * Calculate the SHA-1 of an array of big-endian words, and a bit length
                     */
                    function core_sha1(x, len)
                    {
                        /* append padding */
                        x[len >> 5] |= 0x80 << (24 - len % 32);
                        x[((len + 64 >> 9) << 4) + 15] = len;
                        
                        var w = new Array(80);
                        var a =  1732584193;
                        var b = -271733879;
                        var c = -1732584194;
                        var d =  271733878;
                        var e = -1009589776;
                        
                        var i, j, t, olda, oldb, oldc, oldd, olde;
                        for (i = 0; i < x.length; i += 16)
                        {
                            olda = a;
                            oldb = b;
                            oldc = c;
                            oldd = d;
                            olde = e;
                            
                            for (j = 0; j < 80; j++)
                            {
                                if (j < 16) { w[j] = x[i + j]; }
                                else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
                                t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                                    safe_add(safe_add(e, w[j]), sha1_kt(j)));
                                e = d;
                                d = c;
                                c = rol(b, 30);
                                b = a;
                                a = t;
                            }
                            
                            a = safe_add(a, olda);
                            b = safe_add(b, oldb);
                            c = safe_add(c, oldc);
                            d = safe_add(d, oldd);
                            e = safe_add(e, olde);
                        }
                        return [a, b, c, d, e];
                    }
                    
                    /*
                     * Perform the appropriate triplet combination function for the current
                     * iteration
                     */
                    function sha1_ft(t, b, c, d)
                    {
                        if (t < 20) { return (b & c) | ((~b) & d); }
                        if (t < 40) { return b ^ c ^ d; }
                        if (t < 60) { return (b & c) | (b & d) | (c & d); }
                        return b ^ c ^ d;
                    }
                    
                    /*
                     * Determine the appropriate additive constant for the current iteration
                     */
                    function sha1_kt(t)
                    {
                        return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
                            (t < 60) ? -1894007588 : -899497514;
                    }
                    
                    /*
                     * Calculate the HMAC-SHA1 of a key and some data
                     */
                    function core_hmac_sha1(key, data)
                    {
                        var bkey = str2binb(key);
                        if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }
                        
                        var ipad = new Array(16), opad = new Array(16);
                        for (var i = 0; i < 16; i++)
                        {
                            ipad[i] = bkey[i] ^ 0x36363636;
                            opad[i] = bkey[i] ^ 0x5C5C5C5C;
                        }
                        
                        var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
                        return core_sha1(opad.concat(hash), 512 + 160);
                    }
                    
                    /*
                     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
                     * to work around bugs in some JS interpreters.
                     */
                    function safe_add(x, y)
                    {
                        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
                        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                        return (msw << 16) | (lsw & 0xFFFF);
                    }
                    
                    /*
                     * Bitwise rotate a 32-bit number to the left.
                     */
                    function rol(num, cnt)
                    {
                        return (num << cnt) | (num >>> (32 - cnt));
                    }
                    
                    /*
                     * Convert an 8-bit or 16-bit string to an array of big-endian words
                     * In 8-bit function, characters >255 have their hi-byte silently ignored.
                     */
                    function str2binb(str)
                    {
                        var bin = [];
                        var mask = 255;
                        for (var i = 0; i < str.length * 8; i += 8)
                        {
                            bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);
                        }
                        return bin;
                    }
                    
                    /*
                     * Convert an array of big-endian words to a string
                     */
                    function binb2str(bin)
                    {
                        var str = "";
                        var mask = 255;
                        for (var i = 0; i < bin.length * 32; i += 8)
                        {
                            str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
                        }
                        return str;
                    }
                    
                    /*
                     * Convert an array of big-endian words to a base-64 string
                     */
                    function binb2b64(binarray)
                    {
                        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                        var str = "";
                        var triplet, j;
                        for (var i = 0; i < binarray.length * 4; i += 3)
                        {
                            triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
                                (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
                                ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
                            for (j = 0; j < 4; j++)
                            {
                                if (i * 8 + j * 6 > binarray.length * 32) { str += "="; }
                                else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
                            }
                        }
                        return str;
                    }
                    
                    /*
                     * These are the functions you'll usually want to call
                     * They take string arguments and return either hex or base-64 encoded strings
                     */
                    return {
                        b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },
                        b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },
                        binb2str:       binb2str,
                        core_hmac_sha1: core_hmac_sha1,
                        str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },
                        str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },
                    };
                }));
                
                /*
                 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
                 * Digest Algorithm, as defined in RFC 1321.
                 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
                 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                 * Distributed under the BSD License
                 * See http://pajhome.org.uk/crypt/md5 for more info.
                 */
                
                /*
                 * Everything that isn't used by Strophe has been stripped here!
                 */
                
                (function (root, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define('strophe-md5', function () {
                            return factory();
                        });
                    } else {
                        // Browser globals
                        root.MD5 = factory();
                    }
                }(this, function (b) {
                    /*
                     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
                     * to work around bugs in some JS interpreters.
                     */
                    var safe_add = function (x, y) {
                        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
                        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                        return (msw << 16) | (lsw & 0xFFFF);
                    };
                    
                    /*
                     * Bitwise rotate a 32-bit number to the left.
                     */
                    var bit_rol = function (num, cnt) {
                        return (num << cnt) | (num >>> (32 - cnt));
                    };
                    
                    /*
                     * Convert a string to an array of little-endian words
                     */
                    var str2binl = function (str) {
                        var bin = [];
                        for(var i = 0; i < str.length * 8; i += 8)
                        {
                            bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);
                        }
                        return bin;
                    };
                    
                    /*
                     * Convert an array of little-endian words to a string
                     */
                    var binl2str = function (bin) {
                        var str = "";
                        for(var i = 0; i < bin.length * 32; i += 8)
                        {
                            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);
                        }
                        return str;
                    };
                    
                    /*
                     * Convert an array of little-endian words to a hex string.
                     */
                    var binl2hex = function (binarray) {
                        var hex_tab = "0123456789abcdef";
                        var str = "";
                        for(var i = 0; i < binarray.length * 4; i++)
                        {
                            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
                        }
                        return str;
                    };
                    
                    /*
                     * These functions implement the four basic operations the algorithm uses.
                     */
                    var md5_cmn = function (q, a, b, x, s, t) {
                        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
                    };
                    
                    var md5_ff = function (a, b, c, d, x, s, t) {
                        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
                    };
                    
                    var md5_gg = function (a, b, c, d, x, s, t) {
                        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
                    };
                    
                    var md5_hh = function (a, b, c, d, x, s, t) {
                        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
                    };
                    
                    var md5_ii = function (a, b, c, d, x, s, t) {
                        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
                    };
                    
                    /*
                     * Calculate the MD5 of an array of little-endian words, and a bit length
                     */
                    var core_md5 = function (x, len) {
                        /* append padding */
                        x[len >> 5] |= 0x80 << ((len) % 32);
                        x[(((len + 64) >>> 9) << 4) + 14] = len;
                        
                        var a =  1732584193;
                        var b = -271733879;
                        var c = -1732584194;
                        var d =  271733878;
                        
                        var olda, oldb, oldc, oldd;
                        for (var i = 0; i < x.length; i += 16)
                        {
                            olda = a;
                            oldb = b;
                            oldc = c;
                            oldd = d;
                            
                            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
                            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
                            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
                            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
                            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
                            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
                            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
                            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
                            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
                            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
                            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
                            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
                            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
                            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
                            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
                            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
                            
                            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
                            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
                            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
                            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
                            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
                            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
                            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
                            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
                            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
                            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
                            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
                            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
                            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
                            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
                            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
                            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
                            
                            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
                            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
                            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
                            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
                            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
                            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
                            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
                            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
                            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
                            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
                            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
                            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
                            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
                            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
                            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
                            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
                            
                            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
                            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
                            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
                            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
                            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
                            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
                            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
                            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
                            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
                            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
                            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
                            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
                            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
                            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
                            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
                            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
                            
                            a = safe_add(a, olda);
                            b = safe_add(b, oldb);
                            c = safe_add(c, oldc);
                            d = safe_add(d, oldd);
                        }
                        return [a, b, c, d];
                    };
                    
                    var obj = {
                        /*
                         * These are the functions you'll usually want to call.
                         * They take string arguments and return either hex or base-64 encoded
                         * strings.
                         */
                        hexdigest: function (s) {
                            return binl2hex(core_md5(str2binl(s), s.length * 8));
                        },
                        
                        hash: function (s) {
                            return binl2str(core_md5(str2binl(s), s.length * 8));
                        }
                    };
                    return obj;
                }));
                
                /*
                 This program is distributed under the terms of the MIT license.
                 Please see the LICENSE file for details.
                
                 Copyright 2006-2008, OGG, LLC
                 */
                
                /* jshint undef: true, unused: true:, noarg: true, latedef: true */
                
                /** PrivateFunction: Function.prototype.bind
                 *  Bind a function to an instance.
                 *
                 *  This Function object extension method creates a bound method similar
                 *  to those in Python.  This means that the 'this' object will point
                 *  to the instance you want.  See
                 *  <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind'>MDC's bind() documentation</a> and
                 *  <a href='http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/'>Bound Functions and Function Imports in JavaScript</a>
                 *  for a complete explanation.
                 *
                 *  This extension already exists in some browsers (namely, Firefox 3), but
                 *  we provide it to support those that don't.
                 *
                 *  Parameters:
                 *    (Object) obj - The object that will become 'this' in the bound function.
                 *    (Object) argN - An option argument that will be prepended to the
                 *      arguments given for the function call
                 *
                 *  Returns:
                 *    The bound function.
                 */
                if (!Function.prototype.bind) {
                    Function.prototype.bind = function (obj /*, arg1, arg2, ... */)
                    {
                        var func = this;
                        var _slice = Array.prototype.slice;
                        var _concat = Array.prototype.concat;
                        var _args = _slice.call(arguments, 1);
                        
                        return function () {
                            return func.apply(obj ? obj : this,
                                _concat.call(_args,
                                    _slice.call(arguments, 0)));
                        };
                    };
                }
                
                /** PrivateFunction: Array.isArray
                 *  This is a polyfill for the ES5 Array.isArray method.
                 */
                if (!Array.isArray) {
                    Array.isArray = function(arg) {
                        return Object.prototype.toString.call(arg) === '[object Array]';
                    };
                }
                
                /** PrivateFunction: Array.prototype.indexOf
                 *  Return the index of an object in an array.
                 *
                 *  This function is not supplied by some JavaScript implementations, so
                 *  we provide it if it is missing.  This code is from:
                 *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
                 *
                 *  Parameters:
                 *    (Object) elt - The object to look for.
                 *    (Integer) from - The index from which to start looking. (optional).
                 *
                 *  Returns:
                 *    The index of elt in the array or -1 if not found.
                 */
                if (!Array.prototype.indexOf)
                {
                    Array.prototype.indexOf = function(elt /*, from*/)
                    {
                        var len = this.length;
                        
                        var from = Number(arguments[1]) || 0;
                        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
                        if (from < 0) {
                            from += len;
                        }
                        
                        for (; from < len; from++) {
                            if (from in this && this[from] === elt) {
                                return from;
                            }
                        }
                        
                        return -1;
                    };
                }
                
                /*
                 This program is distributed under the terms of the MIT license.
                 Please see the LICENSE file for details.
                
                 Copyright 2006-2008, OGG, LLC
                 */
                
                /* jshint undef: true, unused: true:, noarg: true, latedef: true */
                /*global define, document, window, setTimeout, clearTimeout, console, ActiveXObject, DOMParser */
                
                (function (root, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define('strophe-core', [
                            'strophe-sha1',
                            'strophe-base64',
                            'strophe-md5',
                            "strophe-polyfill"
                        ], function () {
                            return factory.apply(this, arguments);
                        });
                    } else {
                        // Browser globals
                        var o = factory(root.SHA1, root.Base64, root.MD5);
                        window.Strophe =        o.Strophe;
                        window.$build =         o.$build;
                        window.$iq =            o.$iq;
                        window.$msg =           o.$msg;
                        window.$pres =          o.$pres;
                        window.SHA1 =           o.SHA1;
                        window.Base64 =         o.Base64;
                        window.MD5 =            o.MD5;
                        window.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;
                        window.b64_sha1 =       o.SHA1.b64_sha1;
                        window.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;
                        window.str_sha1 =       o.SHA1.str_sha1;
                    }
                }(this, function (SHA1, Base64, MD5) {
                    
                    var Strophe;
                    
                    /** Function: $build
                     *  Create a Strophe.Builder.
                     *  This is an alias for 'new Strophe.Builder(name, attrs)'.
                     *
                     *  Parameters:
                     *    (String) name - The root element name.
                     *    (Object) attrs - The attributes for the root element in object notation.
                     *
                     *  Returns:
                     *    A new Strophe.Builder object.
                     */
                    function $build(name, attrs) { return new Strophe.Builder(name, attrs); }
                    
                    /** Function: $msg
                     *  Create a Strophe.Builder with a <message/> element as the root.
                     *
                     *  Parmaeters:
                     *    (Object) attrs - The <message/> element attributes in object notation.
                     *
                     *  Returns:
                     *    A new Strophe.Builder object.
                     */
                    function $msg(attrs) { return new Strophe.Builder("message", attrs); }
                    
                    /** Function: $iq
                     *  Create a Strophe.Builder with an <iq/> element as the root.
                     *
                     *  Parameters:
                     *    (Object) attrs - The <iq/> element attributes in object notation.
                     *
                     *  Returns:
                     *    A new Strophe.Builder object.
                     */
                    function $iq(attrs) { return new Strophe.Builder("iq", attrs); }
                    
                    /** Function: $pres
                     *  Create a Strophe.Builder with a <presence/> element as the root.
                     *
                     *  Parameters:
                     *    (Object) attrs - The <presence/> element attributes in object notation.
                     *
                     *  Returns:
                     *    A new Strophe.Builder object.
                     */
                    function $pres(attrs) { return new Strophe.Builder("presence", attrs); }
                    
                    /** Class: Strophe
                     *  An object container for all Strophe library functions.
                     *
                     *  This class is just a container for all the objects and constants
                     *  used in the library.  It is not meant to be instantiated, but to
                     *  provide a namespace for library objects, constants, and functions.
                     */
                    Strophe = {
                        /** Constant: VERSION
                         *  The version of the Strophe library. Unreleased builds will have
                         *  a version of head-HASH where HASH is a partial revision.
                         */
                        VERSION: "1.2.2",
                        
                        /** Constants: XMPP Namespace Constants
                         *  Common namespace constants from the XMPP RFCs and XEPs.
                         *
                         *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
                         *  NS.BOSH - BOSH namespace from XEP 206.
                         *  NS.CLIENT - Main XMPP client namespace.
                         *  NS.AUTH - Legacy authentication namespace.
                         *  NS.ROSTER - Roster operations namespace.
                         *  NS.PROFILE - Profile namespace.
                         *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
                         *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
                         *  NS.MUC - Multi-User Chat namespace from XEP 45.
                         *  NS.SASL - XMPP SASL namespace from RFC 3920.
                         *  NS.STREAM - XMPP Streams namespace from RFC 3920.
                         *  NS.BIND - XMPP Binding namespace from RFC 3920.
                         *  NS.SESSION - XMPP Session namespace from RFC 3920.
                         *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
                         *  NS.XHTML - XHTML body namespace from XEP 71.
                         */
                        NS: {
                            HTTPBIND: "http://jabber.org/protocol/httpbind",
                            BOSH: "urn:xmpp:xbosh",
                            CLIENT: "jabber:client",
                            AUTH: "jabber:iq:auth",
                            ROSTER: "jabber:iq:roster",
                            PROFILE: "jabber:iq:profile",
                            DISCO_INFO: "http://jabber.org/protocol/disco#info",
                            DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                            MUC: "http://jabber.org/protocol/muc",
                            SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                            STREAM: "http://etherx.jabber.org/streams",
                            FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                            BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                            SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                            VERSION: "jabber:iq:version",
                            STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                            XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                            XHTML: "http://www.w3.org/1999/xhtml"
                        },
                        
                        
                        /** Constants: XHTML_IM Namespace
                         *  contains allowed tags, tag attributes, and css properties.
                         *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
                         *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
                         *  allowed tags and their attributes.
                         */
                        XHTML: {
                            tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],
                            attributes: {
                                'a':          ['href'],
                                'blockquote': ['style'],
                                'br':         [],
                                'cite':       ['style'],
                                'em':         [],
                                'img':        ['src', 'alt', 'style', 'height', 'width'],
                                'li':         ['style'],
                                'ol':         ['style'],
                                'p':          ['style'],
                                'span':       ['style'],
                                'strong':     [],
                                'ul':         ['style'],
                                'body':       []
                            },
                            css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],
                            /** Function: XHTML.validTag
                             *
                             * Utility method to determine whether a tag is allowed
                             * in the XHTML_IM namespace.
                             *
                             * XHTML tag names are case sensitive and must be lower case.
                             */
                            validTag: function(tag) {
                                for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                                    if (tag == Strophe.XHTML.tags[i]) {
                                        return true;
                                    }
                                }
                                return false;
                            },
                            /** Function: XHTML.validAttribute
                             *
                             * Utility method to determine whether an attribute is allowed
                             * as recommended per XEP-0071
                             *
                             * XHTML attribute names are case sensitive and must be lower case.
                             */
                            validAttribute: function(tag, attribute) {
                                if(typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                                    for(var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                                        if(attribute == Strophe.XHTML.attributes[tag][i]) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            },
                            validCSS: function(style)
                            {
                                for(var i = 0; i < Strophe.XHTML.css.length; i++) {
                                    if(style == Strophe.XHTML.css[i]) {
                                        return true;
                                    }
                                }
                                return false;
                            }
                        },
                        
                        /** Constants: Connection Status Constants
                         *  Connection status constants for use by the connection handler
                         *  callback.
                         *
                         *  Status.ERROR - An error has occurred
                         *  Status.CONNECTING - The connection is currently being made
                         *  Status.CONNFAIL - The connection attempt failed
                         *  Status.AUTHENTICATING - The connection is authenticating
                         *  Status.AUTHFAIL - The authentication attempt failed
                         *  Status.CONNECTED - The connection has succeeded
                         *  Status.DISCONNECTED - The connection has been terminated
                         *  Status.DISCONNECTING - The connection is currently being terminated
                         *  Status.ATTACHED - The connection has been attached
                         */
                        Status: {
                            ERROR: 0,
                            CONNECTING: 1,
                            CONNFAIL: 2,
                            AUTHENTICATING: 3,
                            AUTHFAIL: 4,
                            CONNECTED: 5,
                            DISCONNECTED: 6,
                            DISCONNECTING: 7,
                            ATTACHED: 8,
                            REDIRECT: 9
                        },
                        
                        /** Constants: Log Level Constants
                         *  Logging level indicators.
                         *
                         *  LogLevel.DEBUG - Debug output
                         *  LogLevel.INFO - Informational output
                         *  LogLevel.WARN - Warnings
                         *  LogLevel.ERROR - Errors
                         *  LogLevel.FATAL - Fatal errors
                         */
                        LogLevel: {
                            DEBUG: 0,
                            INFO: 1,
                            WARN: 2,
                            ERROR: 3,
                            FATAL: 4
                        },
                        
                        /** PrivateConstants: DOM Element Type Constants
                         *  DOM element types.
                         *
                         *  ElementType.NORMAL - Normal element.
                         *  ElementType.TEXT - Text data element.
                         *  ElementType.FRAGMENT - XHTML fragment element.
                         */
                        ElementType: {
                            NORMAL: 1,
                            TEXT: 3,
                            CDATA: 4,
                            FRAGMENT: 11
                        },
                        
                        /** PrivateConstants: Timeout Values
                         *  Timeout values for error states.  These values are in seconds.
                         *  These should not be changed unless you know exactly what you are
                         *  doing.
                         *
                         *  TIMEOUT - Timeout multiplier. A waiting request will be considered
                         *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
                         *      This defaults to 1.1, and with default wait, 66 seconds.
                         *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
                         *      Strophe can detect early failure, it will consider the request
                         *      failed if it doesn't return after
                         *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
                         *      This defaults to 0.1, and with default wait, 6 seconds.
                         */
                        TIMEOUT: 1.1,
                        SECONDARY_TIMEOUT: 0.1,
                        
                        /** Function: addNamespace
                         *  This function is used to extend the current namespaces in
                         *  Strophe.NS.  It takes a key and a value with the key being the
                         *  name of the new namespace, with its actual value.
                         *  For example:
                         *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
                         *
                         *  Parameters:
                         *    (String) name - The name under which the namespace will be
                         *      referenced under Strophe.NS
                         *    (String) value - The actual namespace.
                         */
                        addNamespace: function (name, value)
                        {
                            Strophe.NS[name] = value;
                        },
                        
                        /** Function: forEachChild
                         *  Map a function over some or all child elements of a given element.
                         *
                         *  This is a small convenience function for mapping a function over
                         *  some or all of the children of an element.  If elemName is null, all
                         *  children will be passed to the function, otherwise only children
                         *  whose tag names match elemName will be passed.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The element to operate on.
                         *    (String) elemName - The child element tag name filter.
                         *    (Function) func - The function to apply to each child.  This
                         *      function should take a single argument, a DOM element.
                         */
                        forEachChild: function (elem, elemName, func)
                        {
                            var i, childNode;
                            
                            for (i = 0; i < elem.childNodes.length; i++) {
                                childNode = elem.childNodes[i];
                                if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                                    (!elemName || this.isTagEqual(childNode, elemName))) {
                                    func(childNode);
                                }
                            }
                        },
                        
                        /** Function: isTagEqual
                         *  Compare an element's tag name with a string.
                         *
                         *  This function is case sensitive.
                         *
                         *  Parameters:
                         *    (XMLElement) el - A DOM element.
                         *    (String) name - The element name.
                         *
                         *  Returns:
                         *    true if the element's tag name matches _el_, and false
                         *    otherwise.
                         */
                        isTagEqual: function (el, name)
                        {
                            return el.tagName == name;
                        },
                        
                        /** PrivateVariable: _xmlGenerator
                         *  _Private_ variable that caches a DOM document to
                         *  generate elements.
                         */
                        _xmlGenerator: null,
                        
                        /** PrivateFunction: _makeGenerator
                         *  _Private_ function that creates a dummy XML DOM document to serve as
                         *  an element and text node generator.
                         */
                        _makeGenerator: function () {
                            var doc;
                            
                            // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.
                            // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be
                            // less than 10 in the case of IE9 and below.
                            if (document.implementation.createDocument === undefined ||
                                document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                                doc = this._getIEXmlDom();
                                doc.appendChild(doc.createElement('strophe'));
                            } else {
                                doc = document.implementation
                                    .createDocument('jabber:client', 'strophe', null);
                            }
                            
                            return doc;
                        },
                        
                        /** Function: xmlGenerator
                         *  Get the DOM document to generate elements.
                         *
                         *  Returns:
                         *    The currently used DOM document.
                         */
                        xmlGenerator: function () {
                            if (!Strophe._xmlGenerator) {
                                Strophe._xmlGenerator = Strophe._makeGenerator();
                            }
                            return Strophe._xmlGenerator;
                        },
                        
                        /** PrivateFunction: _getIEXmlDom
                         *  Gets IE xml doc object
                         *
                         *  Returns:
                         *    A Microsoft XML DOM Object
                         *  See Also:
                         *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
                         */
                        _getIEXmlDom : function() {
                            var doc = null;
                            var docStrings = [
                                "Msxml2.DOMDocument.6.0",
                                "Msxml2.DOMDocument.5.0",
                                "Msxml2.DOMDocument.4.0",
                                "MSXML2.DOMDocument.3.0",
                                "MSXML2.DOMDocument",
                                "MSXML.DOMDocument",
                                "Microsoft.XMLDOM"
                            ];
                            
                            for (var d = 0; d < docStrings.length; d++) {
                                if (doc === null) {
                                    try {
                                        doc = new ActiveXObject(docStrings[d]);
                                    } catch (e) {
                                        doc = null;
                                    }
                                } else {
                                    break;
                                }
                            }
                            
                            return doc;
                        },
                        
                        /** Function: xmlElement
                         *  Create an XML DOM element.
                         *
                         *  This function creates an XML DOM element correctly across all
                         *  implementations. Note that these are not HTML DOM elements, which
                         *  aren't appropriate for XMPP stanzas.
                         *
                         *  Parameters:
                         *    (String) name - The name for the element.
                         *    (Array|Object) attrs - An optional array or object containing
                         *      key/value pairs to use as element attributes. The object should
                         *      be in the format {'key': 'value'} or {key: 'value'}. The array
                         *      should have the format [['key1', 'value1'], ['key2', 'value2']].
                         *    (String) text - The text child data for the element.
                         *
                         *  Returns:
                         *    A new XML DOM element.
                         */
                        xmlElement: function (name)
                        {
                            if (!name) { return null; }
                            
                            var node = Strophe.xmlGenerator().createElement(name);
                            
                            // FIXME: this should throw errors if args are the wrong type or
                            // there are more than two optional args
                            var a, i, k;
                            for (a = 1; a < arguments.length; a++) {
                                var arg = arguments[a];
                                if (!arg) { continue; }
                                if (typeof(arg) == "string" ||
                                    typeof(arg) == "number") {
                                    node.appendChild(Strophe.xmlTextNode(arg));
                                } else if (typeof(arg) == "object" &&
                                    typeof(arg.sort) == "function") {
                                    for (i = 0; i < arg.length; i++) {
                                        var attr = arg[i];
                                        if (typeof(attr) == "object" &&
                                            typeof(attr.sort) == "function" &&
                                            attr[1] !== undefined) {
                                            node.setAttribute(attr[0], attr[1]);
                                        }
                                    }
                                } else if (typeof(arg) == "object") {
                                    for (k in arg) {
                                        if (arg.hasOwnProperty(k)) {
                                            if (arg[k] !== undefined) {
                                                node.setAttribute(k, arg[k]);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            return node;
                        },
                        
                        /*  Function: xmlescape
                         *  Excapes invalid xml characters.
                         *
                         *  Parameters:
                         *     (String) text - text to escape.
                         *
                         *  Returns:
                         *      Escaped text.
                         */
                        xmlescape: function(text)
                        {
                            text = text.replace(/\&/g, "&amp;");
                            text = text.replace(/</g,  "&lt;");
                            text = text.replace(/>/g,  "&gt;");
                            text = text.replace(/'/g,  "&apos;");
                            text = text.replace(/"/g,  "&quot;");
                            return text;
                        },
                        
                        /*  Function: xmlunescape
                         *  Unexcapes invalid xml characters.
                         *
                         *  Parameters:
                         *     (String) text - text to unescape.
                         *
                         *  Returns:
                         *      Unescaped text.
                         */
                        xmlunescape: function(text)
                        {
                            text = text.replace(/\&amp;/g, "&");
                            text = text.replace(/&lt;/g,  "<");
                            text = text.replace(/&gt;/g,  ">");
                            text = text.replace(/&apos;/g,  "'");
                            text = text.replace(/&quot;/g,  "\"");
                            return text;
                        },
                        
                        /** Function: xmlTextNode
                         *  Creates an XML DOM text node.
                         *
                         *  Provides a cross implementation version of document.createTextNode.
                         *
                         *  Parameters:
                         *    (String) text - The content of the text node.
                         *
                         *  Returns:
                         *    A new XML DOM text node.
                         */
                        xmlTextNode: function (text)
                        {
                            return Strophe.xmlGenerator().createTextNode(text);
                        },
                        
                        /** Function: xmlHtmlNode
                         *  Creates an XML DOM html node.
                         *
                         *  Parameters:
                         *    (String) html - The content of the html node.
                         *
                         *  Returns:
                         *    A new XML DOM text node.
                         */
                        xmlHtmlNode: function (html)
                        {
                            var node;
                            //ensure text is escaped
                            if (window.DOMParser) {
                                var parser = new DOMParser();
                                node = parser.parseFromString(html, "text/xml");
                            } else {
                                node = new ActiveXObject("Microsoft.XMLDOM");
                                node.async="false";
                                node.loadXML(html);
                            }
                            return node;
                        },
                        
                        /** Function: getText
                         *  Get the concatenation of all text children of an element.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - A DOM element.
                         *
                         *  Returns:
                         *    A String with the concatenated text of all text element children.
                         */
                        getText: function (elem)
                        {
                            if (!elem) { return null; }
                            
                            var str = "";
                            if (elem.childNodes.length === 0 && elem.nodeType ==
                                Strophe.ElementType.TEXT) {
                                str += elem.nodeValue;
                            }
                            
                            for (var i = 0; i < elem.childNodes.length; i++) {
                                if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                                    str += elem.childNodes[i].nodeValue;
                                }
                            }
                            
                            return Strophe.xmlescape(str);
                        },
                        
                        /** Function: copyElement
                         *  Copy an XML DOM element.
                         *
                         *  This function copies a DOM element and all its descendants and returns
                         *  the new copy.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - A DOM element.
                         *
                         *  Returns:
                         *    A new, copied DOM element tree.
                         */
                        copyElement: function (elem)
                        {
                            var i, el;
                            if (elem.nodeType == Strophe.ElementType.NORMAL) {
                                el = Strophe.xmlElement(elem.tagName);
                                
                                for (i = 0; i < elem.attributes.length; i++) {
                                    el.setAttribute(elem.attributes[i].nodeName,
                                        elem.attributes[i].value);
                                }
                                
                                for (i = 0; i < elem.childNodes.length; i++) {
                                    el.appendChild(Strophe.copyElement(elem.childNodes[i]));
                                }
                            } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                                el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
                            }
                            
                            return el;
                        },
                        
                        
                        /** Function: createHtml
                         *  Copy an HTML DOM element into an XML DOM.
                         *
                         *  This function copies a DOM element and all its descendants and returns
                         *  the new copy.
                         *
                         *  Parameters:
                         *    (HTMLElement) elem - A DOM element.
                         *
                         *  Returns:
                         *    A new, copied DOM element tree.
                         */
                        createHtml: function (elem)
                        {
                            var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
                            if (elem.nodeType == Strophe.ElementType.NORMAL) {
                                tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.
                                if(Strophe.XHTML.validTag(tag)) {
                                    try {
                                        el = Strophe.xmlElement(tag);
                                        for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                                            attribute = Strophe.XHTML.attributes[tag][i];
                                            value = elem.getAttribute(attribute);
                                            if(typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                                                continue;
                                            }
                                            if(attribute == 'style' && typeof value == 'object') {
                                                if(typeof value.cssText != 'undefined') {
                                                    value = value.cssText; // we're dealing with IE, need to get CSS out
                                                }
                                            }
                                            // filter out invalid css styles
                                            if(attribute == 'style') {
                                                css = [];
                                                cssAttrs = value.split(';');
                                                for(j = 0; j < cssAttrs.length; j++) {
                                                    attr = cssAttrs[j].split(':');
                                                    cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                                    if(Strophe.XHTML.validCSS(cssName)) {
                                                        cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                                        css.push(cssName + ': ' + cssValue);
                                                    }
                                                }
                                                if(css.length > 0) {
                                                    value = css.join('; ');
                                                    el.setAttribute(attribute, value);
                                                }
                                            } else {
                                                el.setAttribute(attribute, value);
                                            }
                                        }
                                        
                                        for (i = 0; i < elem.childNodes.length; i++) {
                                            el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                                        }
                                    } catch(e) { // invalid elements
                                        el = Strophe.xmlTextNode('');
                                    }
                                } else {
                                    el = Strophe.xmlGenerator().createDocumentFragment();
                                    for (i = 0; i < elem.childNodes.length; i++) {
                                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                                    }
                                }
                            } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
                                el = Strophe.xmlGenerator().createDocumentFragment();
                                for (i = 0; i < elem.childNodes.length; i++) {
                                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                                }
                            } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                                el = Strophe.xmlTextNode(elem.nodeValue);
                            }
                            
                            return el;
                        },
                        
                        /** Function: escapeNode
                         *  Escape the node part (also called local part) of a JID.
                         *
                         *  Parameters:
                         *    (String) node - A node (or local part).
                         *
                         *  Returns:
                         *    An escaped node (or local part).
                         */
                        escapeNode: function (node)
                        {
                            if (typeof node !== "string") { return node; }
                            return node.replace(/^\s+|\s+$/g, '')
                                .replace(/\\/g,  "\\5c")
                                .replace(/ /g,   "\\20")
                                .replace(/\"/g,  "\\22")
                                .replace(/\&/g,  "\\26")
                                .replace(/\'/g,  "\\27")
                                .replace(/\//g,  "\\2f")
                                .replace(/:/g,   "\\3a")
                                .replace(/</g,   "\\3c")
                                .replace(/>/g,   "\\3e")
                                .replace(/@/g,   "\\40");
                        },
                        
                        /** Function: unescapeNode
                         *  Unescape a node part (also called local part) of a JID.
                         *
                         *  Parameters:
                         *    (String) node - A node (or local part).
                         *
                         *  Returns:
                         *    An unescaped node (or local part).
                         */
                        unescapeNode: function (node)
                        {
                            if (typeof node !== "string") { return node; }
                            return node.replace(/\\20/g, " ")
                                .replace(/\\22/g, '"')
                                .replace(/\\26/g, "&")
                                .replace(/\\27/g, "'")
                                .replace(/\\2f/g, "/")
                                .replace(/\\3a/g, ":")
                                .replace(/\\3c/g, "<")
                                .replace(/\\3e/g, ">")
                                .replace(/\\40/g, "@")
                                .replace(/\\5c/g, "\\");
                        },
                        
                        /** Function: getNodeFromJid
                         *  Get the node portion of a JID String.
                         *
                         *  Parameters:
                         *    (String) jid - A JID.
                         *
                         *  Returns:
                         *    A String containing the node.
                         */
                        getNodeFromJid: function (jid)
                        {
                            if (jid.indexOf("@") < 0) { return null; }
                            return jid.split("@")[0];
                        },
                        
                        /** Function: getDomainFromJid
                         *  Get the domain portion of a JID String.
                         *
                         *  Parameters:
                         *    (String) jid - A JID.
                         *
                         *  Returns:
                         *    A String containing the domain.
                         */
                        getDomainFromJid: function (jid)
                        {
                            var bare = Strophe.getBareJidFromJid(jid);
                            if (bare.indexOf("@") < 0) {
                                return bare;
                            } else {
                                var parts = bare.split("@");
                                parts.splice(0, 1);
                                return parts.join('@');
                            }
                        },
                        
                        /** Function: getResourceFromJid
                         *  Get the resource portion of a JID String.
                         *
                         *  Parameters:
                         *    (String) jid - A JID.
                         *
                         *  Returns:
                         *    A String containing the resource.
                         */
                        getResourceFromJid: function (jid)
                        {
                            var s = jid.split("/");
                            if (s.length < 2) { return null; }
                            s.splice(0, 1);
                            return s.join('/');
                        },
                        
                        /** Function: getBareJidFromJid
                         *  Get the bare JID from a JID String.
                         *
                         *  Parameters:
                         *    (String) jid - A JID.
                         *
                         *  Returns:
                         *    A String containing the bare JID.
                         */
                        getBareJidFromJid: function (jid)
                        {
                            return jid ? jid.split("/")[0] : null;
                        },
                        
                        /** Function: log
                         *  User overrideable logging function.
                         *
                         *  This function is called whenever the Strophe library calls any
                         *  of the logging functions.  The default implementation of this
                         *  function does nothing.  If client code wishes to handle the logging
                         *  messages, it should override this with
                         *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
                         *
                         *  Please note that data sent and received over the wire is logged
                         *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
                         *
                         *  The different levels and their meanings are
                         *
                         *    DEBUG - Messages useful for debugging purposes.
                         *    INFO - Informational messages.  This is mostly information like
                         *      'disconnect was called' or 'SASL auth succeeded'.
                         *    WARN - Warnings about potential problems.  This is mostly used
                         *      to report transient connection errors like request timeouts.
                         *    ERROR - Some error occurred.
                         *    FATAL - A non-recoverable fatal error occurred.
                         *
                         *  Parameters:
                         *    (Integer) level - The log level of the log message.  This will
                         *      be one of the values in Strophe.LogLevel.
                         *    (String) msg - The log message.
                         */
                        /* jshint ignore:start */
                        log: function (level, msg)
                        {
                            return;
                        },
                        /* jshint ignore:end */
                        
                        /** Function: debug
                         *  Log a message at the Strophe.LogLevel.DEBUG level.
                         *
                         *  Parameters:
                         *    (String) msg - The log message.
                         */
                        debug: function(msg)
                        {
                            this.log(this.LogLevel.DEBUG, msg);
                        },
                        
                        /** Function: info
                         *  Log a message at the Strophe.LogLevel.INFO level.
                         *
                         *  Parameters:
                         *    (String) msg - The log message.
                         */
                        info: function (msg)
                        {
                            this.log(this.LogLevel.INFO, msg);
                        },
                        
                        /** Function: warn
                         *  Log a message at the Strophe.LogLevel.WARN level.
                         *
                         *  Parameters:
                         *    (String) msg - The log message.
                         */
                        warn: function (msg)
                        {
                            this.log(this.LogLevel.WARN, msg);
                        },
                        
                        /** Function: error
                         *  Log a message at the Strophe.LogLevel.ERROR level.
                         *
                         *  Parameters:
                         *    (String) msg - The log message.
                         */
                        error: function (msg)
                        {
                            this.log(this.LogLevel.ERROR, msg);
                        },
                        
                        /** Function: fatal
                         *  Log a message at the Strophe.LogLevel.FATAL level.
                         *
                         *  Parameters:
                         *    (String) msg - The log message.
                         */
                        fatal: function (msg)
                        {
                            this.log(this.LogLevel.FATAL, msg);
                        },
                        
                        /** Function: serialize
                         *  Render a DOM element and all descendants to a String.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - A DOM element.
                         *
                         *  Returns:
                         *    The serialized element tree as a String.
                         */
                        serialize: function (elem)
                        {
                            var result;
                            
                            if (!elem) { return null; }
                            
                            if (typeof(elem.tree) === "function") {
                                elem = elem.tree();
                            }
                            
                            var nodeName = elem.nodeName;
                            var i, child;
                            
                            if (elem.getAttribute("_realname")) {
                                nodeName = elem.getAttribute("_realname");
                            }
                            
                            result = "<" + nodeName;
                            for (i = 0; i < elem.attributes.length; i++) {
                                if(elem.attributes[i].nodeName != "_realname") {
                                    result += " " + elem.attributes[i].nodeName +
                                        "='" + elem.attributes[i].value
                                            .replace(/&/g, "&amp;")
                                            .replace(/\'/g, "&apos;")
                                            .replace(/>/g, "&gt;")
                                            .replace(/</g, "&lt;") + "'";
                                }
                            }
                            
                            if (elem.childNodes.length > 0) {
                                result += ">";
                                for (i = 0; i < elem.childNodes.length; i++) {
                                    child = elem.childNodes[i];
                                    switch( child.nodeType ){
                                        case Strophe.ElementType.NORMAL:
                                            // normal element, so recurse
                                            result += Strophe.serialize(child);
                                            break;
                                        case Strophe.ElementType.TEXT:
                                            // text element to escape values
                                            result += Strophe.xmlescape(child.nodeValue);
                                            break;
                                        case Strophe.ElementType.CDATA:
                                            // cdata section so don't escape values
                                            result += "<![CDATA["+child.nodeValue+"]]>";
                                    }
                                }
                                result += "</" + nodeName + ">";
                            } else {
                                result += "/>";
                            }
                            
                            return result;
                        },
                        
                        /** PrivateVariable: _requestId
                         *  _Private_ variable that keeps track of the request ids for
                         *  connections.
                         */
                        _requestId: 0,
                        
                        /** PrivateVariable: Strophe.connectionPlugins
                         *  _Private_ variable Used to store plugin names that need
                         *  initialization on Strophe.Connection construction.
                         */
                        _connectionPlugins: {},
                        
                        /** Function: addConnectionPlugin
                         *  Extends the Strophe.Connection object with the given plugin.
                         *
                         *  Parameters:
                         *    (String) name - The name of the extension.
                         *    (Object) ptype - The plugin's prototype.
                         */
                        addConnectionPlugin: function (name, ptype)
                        {
                            Strophe._connectionPlugins[name] = ptype;
                        }
                    };
                    
                    /** Class: Strophe.Builder
                     *  XML DOM builder.
                     *
                     *  This object provides an interface similar to JQuery but for building
                     *  DOM element easily and rapidly.  All the functions except for toString()
                     *  and tree() return the object, so calls can be chained.  Here's an
                     *  example using the $iq() builder helper.
                     *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
                     *  >     .c('query', {xmlns: 'strophe:example'})
                     *  >     .c('example')
                     *  >     .toString()
                     *  The above generates this XML fragment
                     *  > <iq to='you' from='me' type='get' id='1'>
                     *  >   <query xmlns='strophe:example'>
                     *  >     <example/>
                     *  >   </query>
                     *  > </iq>
                     *  The corresponding DOM manipulations to get a similar fragment would be
                     *  a lot more tedious and probably involve several helper variables.
                     *
                     *  Since adding children makes new operations operate on the child, up()
                     *  is provided to traverse up the tree.  To add two children, do
                     *  > builder.c('child1', ...).up().c('child2', ...)
                     *  The next operation on the Builder will be relative to the second child.
                     */
                    
                    /** Constructor: Strophe.Builder
                     *  Create a Strophe.Builder object.
                     *
                     *  The attributes should be passed in object notation.  For example
                     *  > var b = new Builder('message', {to: 'you', from: 'me'});
                     *  or
                     *  > var b = new Builder('messsage', {'xml:lang': 'en'});
                     *
                     *  Parameters:
                     *    (String) name - The name of the root element.
                     *    (Object) attrs - The attributes for the root element in object notation.
                     *
                     *  Returns:
                     *    A new Strophe.Builder.
                     */
                    Strophe.Builder = function (name, attrs)
                    {
                        // Set correct namespace for jabber:client elements
                        if (name == "presence" || name == "message" || name == "iq") {
                            if (attrs && !attrs.xmlns) {
                                attrs.xmlns = Strophe.NS.CLIENT;
                            } else if (!attrs) {
                                attrs = {xmlns: Strophe.NS.CLIENT};
                            }
                        }
                        
                        // Holds the tree being built.
                        this.nodeTree = Strophe.xmlElement(name, attrs);
                        
                        // Points to the current operation node.
                        this.node = this.nodeTree;
                    };
                    
                    Strophe.Builder.prototype = {
                        /** Function: tree
                         *  Return the DOM tree.
                         *
                         *  This function returns the current DOM tree as an element object.  This
                         *  is suitable for passing to functions like Strophe.Connection.send().
                         *
                         *  Returns:
                         *    The DOM tree as a element object.
                         */
                        tree: function ()
                        {
                            return this.nodeTree;
                        },
                        
                        /** Function: toString
                         *  Serialize the DOM tree to a String.
                         *
                         *  This function returns a string serialization of the current DOM
                         *  tree.  It is often used internally to pass data to a
                         *  Strophe.Request object.
                         *
                         *  Returns:
                         *    The serialized DOM tree in a String.
                         */
                        toString: function ()
                        {
                            return Strophe.serialize(this.nodeTree);
                        },
                        
                        /** Function: up
                         *  Make the current parent element the new current element.
                         *
                         *  This function is often used after c() to traverse back up the tree.
                         *  For example, to add two children to the same element
                         *  > builder.c('child1', {}).up().c('child2', {});
                         *
                         *  Returns:
                         *    The Stophe.Builder object.
                         */
                        up: function ()
                        {
                            this.node = this.node.parentNode;
                            return this;
                        },
                        
                        /** Function: attrs
                         *  Add or modify attributes of the current element.
                         *
                         *  The attributes should be passed in object notation.  This function
                         *  does not move the current element pointer.
                         *
                         *  Parameters:
                         *    (Object) moreattrs - The attributes to add/modify in object notation.
                         *
                         *  Returns:
                         *    The Strophe.Builder object.
                         */
                        attrs: function (moreattrs)
                        {
                            for (var k in moreattrs) {
                                if (moreattrs.hasOwnProperty(k)) {
                                    if (moreattrs[k] === undefined) {
                                        this.node.removeAttribute(k);
                                    } else {
                                        this.node.setAttribute(k, moreattrs[k]);
                                    }
                                }
                            }
                            return this;
                        },
                        
                        /** Function: c
                         *  Add a child to the current element and make it the new current
                         *  element.
                         *
                         *  This function moves the current element pointer to the child,
                         *  unless text is provided.  If you need to add another child, it
                         *  is necessary to use up() to go back to the parent in the tree.
                         *
                         *  Parameters:
                         *    (String) name - The name of the child.
                         *    (Object) attrs - The attributes of the child in object notation.
                         *    (String) text - The text to add to the child.
                         *
                         *  Returns:
                         *    The Strophe.Builder object.
                         */
                        c: function (name, attrs, text)
                        {
                            var child = Strophe.xmlElement(name, attrs, text);
                            this.node.appendChild(child);
                            if (typeof text !== "string") {
                                this.node = child;
                            }
                            return this;
                        },
                        
                        /** Function: cnode
                         *  Add a child to the current element and make it the new current
                         *  element.
                         *
                         *  This function is the same as c() except that instead of using a
                         *  name and an attributes object to create the child it uses an
                         *  existing DOM element object.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - A DOM element.
                         *
                         *  Returns:
                         *    The Strophe.Builder object.
                         */
                        cnode: function (elem)
                        {
                            var impNode;
                            var xmlGen = Strophe.xmlGenerator();
                            try {
                                impNode = (xmlGen.importNode !== undefined);
                            }
                            catch (e) {
                                impNode = false;
                            }
                            var newElem = impNode ?
                                xmlGen.importNode(elem, true) :
                                Strophe.copyElement(elem);
                            this.node.appendChild(newElem);
                            this.node = newElem;
                            return this;
                        },
                        
                        /** Function: t
                         *  Add a child text element.
                         *
                         *  This *does not* make the child the new current element since there
                         *  are no children of text elements.
                         *
                         *  Parameters:
                         *    (String) text - The text data to append to the current element.
                         *
                         *  Returns:
                         *    The Strophe.Builder object.
                         */
                        t: function (text)
                        {
                            var child = Strophe.xmlTextNode(text);
                            this.node.appendChild(child);
                            return this;
                        },
                        
                        /** Function: h
                         *  Replace current element contents with the HTML passed in.
                         *
                         *  This *does not* make the child the new current element
                         *
                         *  Parameters:
                         *    (String) html - The html to insert as contents of current element.
                         *
                         *  Returns:
                         *    The Strophe.Builder object.
                         */
                        h: function (html)
                        {
                            var fragment = document.createElement('body');
                            
                            // force the browser to try and fix any invalid HTML tags
                            fragment.innerHTML = html;
                            
                            // copy cleaned html into an xml dom
                            var xhtml = Strophe.createHtml(fragment);
                            
                            while(xhtml.childNodes.length > 0) {
                                this.node.appendChild(xhtml.childNodes[0]);
                            }
                            return this;
                        }
                    };
                    
                    /** PrivateClass: Strophe.Handler
                     *  _Private_ helper class for managing stanza handlers.
                     *
                     *  A Strophe.Handler encapsulates a user provided callback function to be
                     *  executed when matching stanzas are received by the connection.
                     *  Handlers can be either one-off or persistant depending on their
                     *  return value. Returning true will cause a Handler to remain active, and
                     *  returning false will remove the Handler.
                     *
                     *  Users will not use Strophe.Handler objects directly, but instead they
                     *  will use Strophe.Connection.addHandler() and
                     *  Strophe.Connection.deleteHandler().
                     */
                    
                    /** PrivateConstructor: Strophe.Handler
                     *  Create and initialize a new Strophe.Handler.
                     *
                     *  Parameters:
                     *    (Function) handler - A function to be executed when the handler is run.
                     *    (String) ns - The namespace to match.
                     *    (String) name - The element name to match.
                     *    (String) type - The element type to match.
                     *    (String) id - The element id attribute to match.
                     *    (String) from - The element from attribute to match.
                     *    (Object) options - Handler options
                     *
                     *  Returns:
                     *    A new Strophe.Handler object.
                     */
                    Strophe.Handler = function (handler, ns, name, type, id, from, options)
                    {
                        this.handler = handler;
                        this.ns = ns;
                        this.name = name;
                        this.type = type;
                        this.id = id;
                        this.options = options || {matchBare: false};
                        
                        // default matchBare to false if undefined
                        if (!this.options.matchBare) {
                            this.options.matchBare = false;
                        }
                        
                        if (this.options.matchBare) {
                            this.from = from ? Strophe.getBareJidFromJid(from) : null;
                        } else {
                            this.from = from;
                        }
                        
                        // whether the handler is a user handler or a system handler
                        this.user = true;
                    };
                    
                    Strophe.Handler.prototype = {
                        /** PrivateFunction: isMatch
                         *  Tests if a stanza matches the Strophe.Handler.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The XML element to test.
                         *
                         *  Returns:
                         *    true if the stanza matches and false otherwise.
                         */
                        isMatch: function (elem)
                        {
                            var nsMatch;
                            var from = null;
                            
                            if (this.options.matchBare) {
                                from = Strophe.getBareJidFromJid(elem.getAttribute('from'));
                            } else {
                                from = elem.getAttribute('from');
                            }
                            
                            nsMatch = false;
                            if (!this.ns) {
                                nsMatch = true;
                            } else {
                                var that = this;
                                Strophe.forEachChild(elem, null, function (elem) {
                                    if (elem.getAttribute("xmlns") == that.ns) {
                                        nsMatch = true;
                                    }
                                });
                                
                                nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns;
                            }
                            
                            var elem_type = elem.getAttribute("type");
                            if (nsMatch &&
                                (!this.name || Strophe.isTagEqual(elem, this.name)) &&
                                (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) &&
                                (!this.id || elem.getAttribute("id") == this.id) &&
                                (!this.from || from == this.from)) {
                                return true;
                            }
                            
                            return false;
                        },
                        
                        /** PrivateFunction: run
                         *  Run the callback on a matching stanza.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The DOM element that triggered the
                         *      Strophe.Handler.
                         *
                         *  Returns:
                         *    A boolean indicating if the handler should remain active.
                         */
                        run: function (elem)
                        {
                            var result = null;
                            try {
                                result = this.handler(elem);
                            } catch (e) {
                                if (e.sourceURL) {
                                    Strophe.fatal("error: " + this.handler +
                                        " " + e.sourceURL + ":" +
                                        e.line + " - " + e.name + ": " + e.message);
                                } else if (e.fileName) {
                                    if (typeof(console) != "undefined") {
                                        console.trace();
                                        console.error(this.handler, " - error - ", e, e.message);
                                    }
                                    Strophe.fatal("error: " + this.handler + " " +
                                        e.fileName + ":" + e.lineNumber + " - " +
                                        e.name + ": " + e.message);
                                } else {
                                    Strophe.fatal("error: " + e.message + "\n" + e.stack);
                                }
                                
                                throw e;
                            }
                            
                            return result;
                        },
                        
                        /** PrivateFunction: toString
                         *  Get a String representation of the Strophe.Handler object.
                         *
                         *  Returns:
                         *    A String.
                         */
                        toString: function ()
                        {
                            return "{Handler: " + this.handler + "(" + this.name + "," +
                                this.id + "," + this.ns + ")}";
                        }
                    };
                    
                    /** PrivateClass: Strophe.TimedHandler
                     *  _Private_ helper class for managing timed handlers.
                     *
                     *  A Strophe.TimedHandler encapsulates a user provided callback that
                     *  should be called after a certain period of time or at regular
                     *  intervals.  The return value of the callback determines whether the
                     *  Strophe.TimedHandler will continue to fire.
                     *
                     *  Users will not use Strophe.TimedHandler objects directly, but instead
                     *  they will use Strophe.Connection.addTimedHandler() and
                     *  Strophe.Connection.deleteTimedHandler().
                     */
                    
                    /** PrivateConstructor: Strophe.TimedHandler
                     *  Create and initialize a new Strophe.TimedHandler object.
                     *
                     *  Parameters:
                     *    (Integer) period - The number of milliseconds to wait before the
                     *      handler is called.
                     *    (Function) handler - The callback to run when the handler fires.  This
                     *      function should take no arguments.
                     *
                     *  Returns:
                     *    A new Strophe.TimedHandler object.
                     */
                    Strophe.TimedHandler = function (period, handler)
                    {
                        this.period = period;
                        this.handler = handler;
                        
                        this.lastCalled = new Date().getTime();
                        this.user = true;
                    };
                    
                    Strophe.TimedHandler.prototype = {
                        /** PrivateFunction: run
                         *  Run the callback for the Strophe.TimedHandler.
                         *
                         *  Returns:
                         *    true if the Strophe.TimedHandler should be called again, and false
                         *      otherwise.
                         */
                        run: function ()
                        {
                            this.lastCalled = new Date().getTime();
                            return this.handler();
                        },
                        
                        /** PrivateFunction: reset
                         *  Reset the last called time for the Strophe.TimedHandler.
                         */
                        reset: function ()
                        {
                            this.lastCalled = new Date().getTime();
                        },
                        
                        /** PrivateFunction: toString
                         *  Get a string representation of the Strophe.TimedHandler object.
                         *
                         *  Returns:
                         *    The string representation.
                         */
                        toString: function ()
                        {
                            return "{TimedHandler: " + this.handler + "(" + this.period +")}";
                        }
                    };
                    
                    /** Class: Strophe.Connection
                     *  XMPP Connection manager.
                     *
                     *  This class is the main part of Strophe.  It manages a BOSH or websocket
                     *  connection to an XMPP server and dispatches events to the user callbacks
                     *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1
                     *  and legacy authentication.
                     *
                     *  After creating a Strophe.Connection object, the user will typically
                     *  call connect() with a user supplied callback to handle connection level
                     *  events like authentication failure, disconnection, or connection
                     *  complete.
                     *
                     *  The user will also have several event handlers defined by using
                     *  addHandler() and addTimedHandler().  These will allow the user code to
                     *  respond to interesting stanzas or do something periodically with the
                     *  connection. These handlers will be active once authentication is
                     *  finished.
                     *
                     *  To send data to the connection, use send().
                     */
                    
                    /** Constructor: Strophe.Connection
                     *  Create and initialize a Strophe.Connection object.
                     *
                     *  The transport-protocol for this connection will be chosen automatically
                     *  based on the given service parameter. URLs starting with "ws://" or
                     *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
                     *  or without a protocol will use BOSH.
                     *
                     *  To make Strophe connect to the current host you can leave out the protocol
                     *  and host part and just pass the path, e.g.
                     *
                     *  > var conn = new Strophe.Connection("/http-bind/");
                     *
                     *  WebSocket options:
                     *
                     *  If you want to connect to the current host with a WebSocket connection you
                     *  can tell Strophe to use WebSockets through a "protocol" attribute in the
                     *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
                     *  for Secure WebSocket.
                     *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
                     *
                     *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
                     *
                     *  Note that relative URLs _NOT_ starting with a "/" will also include the path
                     *  of the current site.
                     *
                     *  Also because downgrading security is not permitted by browsers, when using
                     *  relative URLs both BOSH and WebSocket connections will use their secure
                     *  variants if the current connection to the site is also secure (https).
                     *
                     *  BOSH options:
                     *
                     *  By adding "sync" to the options, you can control if requests will
                     *  be made synchronously or not. The default behaviour is asynchronous.
                     *  If you want to make requests synchronous, make "sync" evaluate to true:
                     *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
                     *
                     *  You can also toggle this on an already established connection:
                     *  > conn.options.sync = true;
                     *
                     *  The "customHeaders" option can be used to provide custom HTTP headers to be
                     *  included in the XMLHttpRequests made.
                     *
                     *  The "keepalive" option can be used to instruct Strophe to maintain the
                     *  current BOSH session across interruptions such as webpage reloads.
                     *
                     *  It will do this by caching the sessions tokens in sessionStorage, and when
                     *  "restore" is called it will check whether there are cached tokens with
                     *  which it can resume an existing session.
                     *
                     *  Parameters:
                     *    (String) service - The BOSH or WebSocket service URL.
                     *    (Object) options - A hash of configuration options
                     *
                     *  Returns:
                     *    A new Strophe.Connection object.
                     */
                    Strophe.Connection = function (service, options)
                    {
                        // The service URL
                        this.service = service;
                        
                        // Configuration options
                        this.options = options || {};
                        var proto = this.options.protocol || "";
                        
                        // Select protocal based on service or options
                        if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 ||
                            proto.indexOf("ws") === 0) {
                            this._proto = new Strophe.Websocket(this);
                        } else {
                            this._proto = new Strophe.Bosh(this);
                        }
                        
                        /* The connected JID. */
                        this.jid = "";
                        /* the JIDs domain */
                        this.domain = null;
                        /* stream:features */
                        this.features = null;
                        
                        // SASL
                        this._sasl_data = {};
                        this.do_session = false;
                        this.do_bind = false;
                        
                        // handler lists
                        this.timedHandlers = [];
                        this.handlers = [];
                        this.removeTimeds = [];
                        this.removeHandlers = [];
                        this.addTimeds = [];
                        this.addHandlers = [];
                        
                        this._authentication = {};
                        this._idleTimeout = null;
                        this._disconnectTimeout = null;
                        
                        this.authenticated = false;
                        this.connected = false;
                        this.disconnecting = false;
                        this.do_authentication = true;
                        this.paused = false;
                        this.restored = false;
                        
                        this._data = [];
                        this._uniqueId = 0;
                        
                        this._sasl_success_handler = null;
                        this._sasl_failure_handler = null;
                        this._sasl_challenge_handler = null;
                        
                        // Max retries before disconnecting
                        this.maxRetries = 5;
                        
                        // setup onIdle callback every 1/10th of a second
                        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
                        
                        // initialize plugins
                        for (var k in Strophe._connectionPlugins) {
                            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                                var ptype = Strophe._connectionPlugins[k];
                                // jslint complaints about the below line, but this is fine
                                var F = function () {}; // jshint ignore:line
                                F.prototype = ptype;
                                this[k] = new F();
                                this[k].init(this);
                            }
                        }
                    };
                    
                    Strophe.Connection.prototype = {
                        /** Function: reset
                         *  Reset the connection.
                         *
                         *  This function should be called after a connection is disconnected
                         *  before that connection is reused.
                         */
                        reset: function ()
                        {
                            this._proto._reset();
                            
                            // SASL
                            this.do_session = false;
                            this.do_bind = false;
                            
                            // handler lists
                            this.timedHandlers = [];
                            this.handlers = [];
                            this.removeTimeds = [];
                            this.removeHandlers = [];
                            this.addTimeds = [];
                            this.addHandlers = [];
                            this._authentication = {};
                            
                            this.authenticated = false;
                            this.connected = false;
                            this.disconnecting = false;
                            this.restored = false;
                            
                            this._data = [];
                            this._requests = [];
                            this._uniqueId = 0;
                        },
                        
                        /** Function: pause
                         *  Pause the request manager.
                         *
                         *  This will prevent Strophe from sending any more requests to the
                         *  server.  This is very useful for temporarily pausing
                         *  BOSH-Connections while a lot of send() calls are happening quickly.
                         *  This causes Strophe to send the data in a single request, saving
                         *  many request trips.
                         */
                        pause: function ()
                        {
                            this.paused = true;
                        },
                        
                        /** Function: resume
                         *  Resume the request manager.
                         *
                         *  This resumes after pause() has been called.
                         */
                        resume: function ()
                        {
                            this.paused = false;
                        },
                        
                        /** Function: getUniqueId
                         *  Generate a unique ID for use in <iq/> elements.
                         *
                         *  All <iq/> stanzas are required to have unique id attributes.  This
                         *  function makes creating these easy.  Each connection instance has
                         *  a counter which starts from zero, and the value of this counter
                         *  plus a colon followed by the suffix becomes the unique id. If no
                         *  suffix is supplied, the counter is used as the unique id.
                         *
                         *  Suffixes are used to make debugging easier when reading the stream
                         *  data, and their use is recommended.  The counter resets to 0 for
                         *  every new connection for the same reason.  For connections to the
                         *  same server that authenticate the same way, all the ids should be
                         *  the same, which makes it easy to see changes.  This is useful for
                         *  automated testing as well.
                         *
                         *  Parameters:
                         *    (String) suffix - A optional suffix to append to the id.
                         *
                         *  Returns:
                         *    A unique string to be used for the id attribute.
                         */
                        getUniqueId: function (suffix)
                        {
                            if (typeof(suffix) == "string" || typeof(suffix) == "number") {
                                return ++this._uniqueId + ":" + suffix;
                            } else {
                                return ++this._uniqueId + "";
                            }
                        },
                        
                        /** Function: connect
                         *  Starts the connection process.
                         *
                         *  As the connection process proceeds, the user supplied callback will
                         *  be triggered multiple times with status updates.  The callback
                         *  should take two arguments - the status code and the error condition.
                         *
                         *  The status code will be one of the values in the Strophe.Status
                         *  constants.  The error condition will be one of the conditions
                         *  defined in RFC 3920 or the condition 'strophe-parsererror'.
                         *
                         *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
                         *  for BOSH connections. Please see XEP 124 for a more detailed explanation
                         *  of the optional parameters.
                         *
                         *  Parameters:
                         *    (String) jid - The user's JID.  This may be a bare JID,
                         *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
                         *      authentication will be attempted.
                         *    (String) pass - The user's password.
                         *    (Function) callback - The connect callback function.
                         *    (Integer) wait - The optional HTTPBIND wait value.  This is the
                         *      time the server will wait before returning an empty result for
                         *      a request.  The default setting of 60 seconds is recommended.
                         *    (Integer) hold - The optional HTTPBIND hold value.  This is the
                         *      number of connections the server will hold at one time.  This
                         *      should almost always be set to 1 (the default).
                         *    (String) route - The optional route value.
                         *    (String) authcid - The optional alternative authentication identity
                         *      (username) if intending to impersonate another user.
                         */
                        connect: function (jid, pass, callback, wait, hold, route, authcid)
                        {
                            this.jid = jid;
                            /** Variable: authzid
                             *  Authorization identity.
                             */
                            this.authzid = Strophe.getBareJidFromJid(this.jid);
                            /** Variable: authcid
                             *  Authentication identity (User name).
                             */
                            this.authcid = authcid || Strophe.getNodeFromJid(this.jid);
                            /** Variable: pass
                             *  Authentication identity (User password).
                             */
                            this.pass = pass;
                            /** Variable: servtype
                             *  Digest MD5 compatibility.
                             */
                            this.servtype = "xmpp";
                            this.connect_callback = callback;
                            this.disconnecting = false;
                            this.connected = false;
                            this.authenticated = false;
                            this.restored = false;
                            
                            // parse jid for domain
                            this.domain = Strophe.getDomainFromJid(this.jid);
                            
                            this._changeConnectStatus(Strophe.Status.CONNECTING, null);
                            
                            this._proto._connect(wait, hold, route);
                        },
                        
                        /** Function: attach
                         *  Attach to an already created and authenticated BOSH session.
                         *
                         *  This function is provided to allow Strophe to attach to BOSH
                         *  sessions which have been created externally, perhaps by a Web
                         *  application.  This is often used to support auto-login type features
                         *  without putting user credentials into the page.
                         *
                         *  Parameters:
                         *    (String) jid - The full JID that is bound by the session.
                         *    (String) sid - The SID of the BOSH session.
                         *    (String) rid - The current RID of the BOSH session.  This RID
                         *      will be used by the next request.
                         *    (Function) callback The connect callback function.
                         *    (Integer) wait - The optional HTTPBIND wait value.  This is the
                         *      time the server will wait before returning an empty result for
                         *      a request.  The default setting of 60 seconds is recommended.
                         *      Other settings will require tweaks to the Strophe.TIMEOUT value.
                         *    (Integer) hold - The optional HTTPBIND hold value.  This is the
                         *      number of connections the server will hold at one time.  This
                         *      should almost always be set to 1 (the default).
                         *    (Integer) wind - The optional HTTBIND window value.  This is the
                         *      allowed range of request ids that are valid.  The default is 5.
                         */
                        attach: function (jid, sid, rid, callback, wait, hold, wind)
                        {
                            if (this._proto instanceof Strophe.Bosh) {
                                this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
                            } else {
                                throw {
                                    name: 'StropheSessionError',
                                    message: 'The "attach" method can only be used with a BOSH connection.'
                                };
                            }
                        },
                        
                        /** Function: restore
                         *  Attempt to restore a cached BOSH session.
                         *
                         *  This function is only useful in conjunction with providing the
                         *  "keepalive":true option when instantiating a new Strophe.Connection.
                         *
                         *  When "keepalive" is set to true, Strophe will cache the BOSH tokens
                         *  RID (Request ID) and SID (Session ID) and then when this function is
                         *  called, it will attempt to restore the session from those cached
                         *  tokens.
                         *
                         *  This function must therefore be called instead of connect or attach.
                         *
                         *  For an example on how to use it, please see examples/restore.js
                         *
                         *  Parameters:
                         *    (String) jid - The user's JID.  This may be a bare JID or a full JID.
                         *    (Function) callback - The connect callback function.
                         *    (Integer) wait - The optional HTTPBIND wait value.  This is the
                         *      time the server will wait before returning an empty result for
                         *      a request.  The default setting of 60 seconds is recommended.
                         *    (Integer) hold - The optional HTTPBIND hold value.  This is the
                         *      number of connections the server will hold at one time.  This
                         *      should almost always be set to 1 (the default).
                         *    (Integer) wind - The optional HTTBIND window value.  This is the
                         *      allowed range of request ids that are valid.  The default is 5.
                         */
                        restore: function (jid, callback, wait, hold, wind)
                        {
                            if (this._sessionCachingSupported()) {
                                this._proto._restore(jid, callback, wait, hold, wind);
                            } else {
                                throw {
                                    name: 'StropheSessionError',
                                    message: 'The "restore" method can only be used with a BOSH connection.'
                                };
                            }
                        },
                        
                        /** PrivateFunction: _sessionCachingSupported
                         * Checks whether sessionStorage and JSON are supported and whether we're
                         * using BOSH.
                         */
                        _sessionCachingSupported: function ()
                        {
                            if (this._proto instanceof Strophe.Bosh) {
                                if (!JSON) { return false; }
                                try {
                                    window.sessionStorage.setItem('_strophe_', '_strophe_');
                                    window.sessionStorage.removeItem('_strophe_');
                                } catch (e) {
                                    return false;
                                }
                                return true;
                            }
                            return false;
                        },
                        
                        /** Function: xmlInput
                         *  User overrideable function that receives XML data coming into the
                         *  connection.
                         *
                         *  The default function does nothing.  User code can override this with
                         *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
                         *
                         *  Due to limitations of current Browsers' XML-Parsers the opening and closing
                         *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
                         *
                         *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
                         *  <Strophe.Bosh.strip> if you want to strip this tag.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The XML data received by the connection.
                         */
                        /* jshint unused:false */
                        xmlInput: function (elem)
                        {
                            return;
                        },
                        /* jshint unused:true */
                        
                        /** Function: xmlOutput
                         *  User overrideable function that receives XML data sent to the
                         *  connection.
                         *
                         *  The default function does nothing.  User code can override this with
                         *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
                         *
                         *  Due to limitations of current Browsers' XML-Parsers the opening and closing
                         *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
                         *
                         *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
                         *  <Strophe.Bosh.strip> if you want to strip this tag.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The XMLdata sent by the connection.
                         */
                        /* jshint unused:false */
                        xmlOutput: function (elem)
                        {
                            return;
                        },
                        /* jshint unused:true */
                        
                        /** Function: rawInput
                         *  User overrideable function that receives raw data coming into the
                         *  connection.
                         *
                         *  The default function does nothing.  User code can override this with
                         *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
                         *
                         *  Parameters:
                         *    (String) data - The data received by the connection.
                         */
                        /* jshint unused:false */
                        rawInput: function (data)
                        {
                            return;
                        },
                        /* jshint unused:true */
                        
                        /** Function: rawOutput
                         *  User overrideable function that receives raw data sent to the
                         *  connection.
                         *
                         *  The default function does nothing.  User code can override this with
                         *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
                         *
                         *  Parameters:
                         *    (String) data - The data sent by the connection.
                         */
                        /* jshint unused:false */
                        rawOutput: function (data)
                        {
                            return;
                        },
                        /* jshint unused:true */
                        
                        /** Function: send
                         *  Send a stanza.
                         *
                         *  This function is called to push data onto the send queue to
                         *  go out over the wire.  Whenever a request is sent to the BOSH
                         *  server, all pending data is sent and the queue is flushed.
                         *
                         *  Parameters:
                         *    (XMLElement |
                         *     [XMLElement] |
                         *     Strophe.Builder) elem - The stanza to send.
                         */
                        send: function (elem)
                        {
                            if (elem === null) { return ; }
                            if (typeof(elem.sort) === "function") {
                                for (var i = 0; i < elem.length; i++) {
                                    this._queueData(elem[i]);
                                }
                            } else if (typeof(elem.tree) === "function") {
                                this._queueData(elem.tree());
                            } else {
                                this._queueData(elem);
                            }
                            
                            this._proto._send();
                        },
                        
                        /** Function: flush
                         *  Immediately send any pending outgoing data.
                         *
                         *  Normally send() queues outgoing data until the next idle period
                         *  (100ms), which optimizes network use in the common cases when
                         *  several send()s are called in succession. flush() can be used to
                         *  immediately send all pending data.
                         */
                        flush: function ()
                        {
                            // cancel the pending idle period and run the idle function
                            // immediately
                            clearTimeout(this._idleTimeout);
                            this._onIdle();
                        },
                        
                        /** Function: sendIQ
                         *  Helper function to send IQ stanzas.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The stanza to send.
                         *    (Function) callback - The callback function for a successful request.
                         *    (Function) errback - The callback function for a failed or timed
                         *      out request.  On timeout, the stanza will be null.
                         *    (Integer) timeout - The time specified in milliseconds for a
                         *      timeout to occur.
                         *
                         *  Returns:
                         *    The id used to send the IQ.
                         */
                        sendIQ: function(elem, callback, errback, timeout) {
                            var timeoutHandler = null;
                            var that = this;
                            
                            if (typeof(elem.tree) === "function") {
                                elem = elem.tree();
                            }
                            var id = elem.getAttribute('id');
                            
                            // inject id if not found
                            if (!id) {
                                id = this.getUniqueId("sendIQ");
                                elem.setAttribute("id", id);
                            }
                            
                            var expectedFrom = elem.getAttribute("to");
                            var fulljid = this.jid;
                            
                            var handler = this.addHandler(function (stanza) {
                                // remove timeout handler if there is one
                                if (timeoutHandler) {
                                    that.deleteTimedHandler(timeoutHandler);
                                }
                                
                                var acceptable = false;
                                var from = stanza.getAttribute("from");
                                if (from === expectedFrom ||
                                    (expectedFrom === null &&
                                    (from === Strophe.getBareJidFromJid(fulljid) ||
                                    from === Strophe.getDomainFromJid(fulljid) ||
                                    from === fulljid))) {
                                    acceptable = true;
                                }
                                
                                if (!acceptable) {
                                    throw {
                                        name: "StropheError",
                                        message: "Got answer to IQ from wrong jid:" + from +
                                        "\nExpected jid: " + expectedFrom
                                    };
                                }
                                
                                var iqtype = stanza.getAttribute('type');
                                if (iqtype == 'result') {
                                    if (callback) {
                                        callback(stanza);
                                    }
                                } else if (iqtype == 'error') {
                                    if (errback) {
                                        errback(stanza);
                                    }
                                } else {
                                    throw {
                                        name: "StropheError",
                                        message: "Got bad IQ type of " + iqtype
                                    };
                                }
                            }, null, 'iq', ['error', 'result'], id);
                            
                            // if timeout specified, setup timeout handler.
                            if (timeout) {
                                timeoutHandler = this.addTimedHandler(timeout, function () {
                                    // get rid of normal handler
                                    that.deleteHandler(handler);
                                    // call errback on timeout with null stanza
                                    if (errback) {
                                        errback(null);
                                    }
                                    return false;
                                });
                            }
                            this.send(elem);
                            return id;
                        },
                        
                        /** PrivateFunction: _queueData
                         *  Queue outgoing data for later sending.  Also ensures that the data
                         *  is a DOMElement.
                         */
                        _queueData: function (element) {
                            if (element === null ||
                                !element.tagName ||
                                !element.childNodes) {
                                throw {
                                    name: "StropheError",
                                    message: "Cannot queue non-DOMElement."
                                };
                            }
                            
                            this._data.push(element);
                        },
                        
                        /** PrivateFunction: _sendRestart
                         *  Send an xmpp:restart stanza.
                         */
                        _sendRestart: function ()
                        {
                            this._data.push("restart");
                            
                            this._proto._sendRestart();
                            
                            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
                        },
                        
                        /** Function: addTimedHandler
                         *  Add a timed handler to the connection.
                         *
                         *  This function adds a timed handler.  The provided handler will
                         *  be called every period milliseconds until it returns false,
                         *  the connection is terminated, or the handler is removed.  Handlers
                         *  that wish to continue being invoked should return true.
                         *
                         *  Because of method binding it is necessary to save the result of
                         *  this function if you wish to remove a handler with
                         *  deleteTimedHandler().
                         *
                         *  Note that user handlers are not active until authentication is
                         *  successful.
                         *
                         *  Parameters:
                         *    (Integer) period - The period of the handler.
                         *    (Function) handler - The callback function.
                         *
                         *  Returns:
                         *    A reference to the handler that can be used to remove it.
                         */
                        addTimedHandler: function (period, handler)
                        {
                            var thand = new Strophe.TimedHandler(period, handler);
                            this.addTimeds.push(thand);
                            return thand;
                        },
                        
                        /** Function: deleteTimedHandler
                         *  Delete a timed handler for a connection.
                         *
                         *  This function removes a timed handler from the connection.  The
                         *  handRef parameter is *not* the function passed to addTimedHandler(),
                         *  but is the reference returned from addTimedHandler().
                         *
                         *  Parameters:
                         *    (Strophe.TimedHandler) handRef - The handler reference.
                         */
                        deleteTimedHandler: function (handRef)
                        {
                            // this must be done in the Idle loop so that we don't change
                            // the handlers during iteration
                            this.removeTimeds.push(handRef);
                        },
                        
                        /** Function: addHandler
                         *  Add a stanza handler for the connection.
                         *
                         *  This function adds a stanza handler to the connection.  The
                         *  handler callback will be called for any stanza that matches
                         *  the parameters.  Note that if multiple parameters are supplied,
                         *  they must all match for the handler to be invoked.
                         *
                         *  The handler will receive the stanza that triggered it as its argument.
                         *  *The handler should return true if it is to be invoked again;
                         *  returning false will remove the handler after it returns.*
                         *
                         *  As a convenience, the ns parameters applies to the top level element
                         *  and also any of its immediate children.  This is primarily to make
                         *  matching /iq/query elements easy.
                         *
                         *  The options argument contains handler matching flags that affect how
                         *  matches are determined. Currently the only flag is matchBare (a
                         *  boolean). When matchBare is true, the from parameter and the from
                         *  attribute on the stanza will be matched as bare JIDs instead of
                         *  full JIDs. To use this, pass {matchBare: true} as the value of
                         *  options. The default value for matchBare is false.
                         *
                         *  The return value should be saved if you wish to remove the handler
                         *  with deleteHandler().
                         *
                         *  Parameters:
                         *    (Function) handler - The user callback.
                         *    (String) ns - The namespace to match.
                         *    (String) name - The stanza name to match.
                         *    (String) type - The stanza type attribute to match.
                         *    (String) id - The stanza id attribute to match.
                         *    (String) from - The stanza from attribute to match.
                         *    (String) options - The handler options
                         *
                         *  Returns:
                         *    A reference to the handler that can be used to remove it.
                         */
                        addHandler: function (handler, ns, name, type, id, from, options)
                        {
                            var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
                            this.addHandlers.push(hand);
                            return hand;
                        },
                        
                        /** Function: deleteHandler
                         *  Delete a stanza handler for a connection.
                         *
                         *  This function removes a stanza handler from the connection.  The
                         *  handRef parameter is *not* the function passed to addHandler(),
                         *  but is the reference returned from addHandler().
                         *
                         *  Parameters:
                         *    (Strophe.Handler) handRef - The handler reference.
                         */
                        deleteHandler: function (handRef)
                        {
                            // this must be done in the Idle loop so that we don't change
                            // the handlers during iteration
                            this.removeHandlers.push(handRef);
                            // If a handler is being deleted while it is being added,
                            // prevent it from getting added
                            var i = this.addHandlers.indexOf(handRef);
                            if (i >= 0) {
                                this.addHandlers.splice(i, 1);
                            }
                        },
                        
                        /** Function: disconnect
                         *  Start the graceful disconnection process.
                         *
                         *  This function starts the disconnection process.  This process starts
                         *  by sending unavailable presence and sending BOSH body of type
                         *  terminate.  A timeout handler makes sure that disconnection happens
                         *  even if the BOSH server does not respond.
                         *  If the Connection object isn't connected, at least tries to abort all pending requests
                         *  so the connection object won't generate successful requests (which were already opened).
                         *
                         *  The user supplied connection callback will be notified of the
                         *  progress as this process happens.
                         *
                         *  Parameters:
                         *    (String) reason - The reason the disconnect is occuring.
                         */
                        disconnect: function (reason)
                        {
                            this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);
                            
                            Strophe.info("Disconnect was called because: " + reason);
                            if (this.connected) {
                                var pres = false;
                                this.disconnecting = true;
                                if (this.authenticated) {
                                    pres = $pres({
                                        xmlns: Strophe.NS.CLIENT,
                                        type: 'unavailable'
                                    });
                                }
                                // setup timeout handler
                                this._disconnectTimeout = this._addSysTimedHandler(
                                    3000, this._onDisconnectTimeout.bind(this));
                                this._proto._disconnect(pres);
                            } else {
                                Strophe.info("Disconnect was called before Strophe connected to the server");
                                this._proto._abortAllRequests();
                            }
                        },
                        
                        /** PrivateFunction: _changeConnectStatus
                         *  _Private_ helper function that makes sure plugins and the user's
                         *  callback are notified of connection status changes.
                         *
                         *  Parameters:
                         *    (Integer) status - the new connection status, one of the values
                         *      in Strophe.Status
                         *    (String) condition - the error condition or null
                         */
                        _changeConnectStatus: function (status, condition)
                        {
                            // notify all plugins listening for status changes
                            for (var k in Strophe._connectionPlugins) {
                                if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                                    var plugin = this[k];
                                    if (plugin.statusChanged) {
                                        try {
                                            plugin.statusChanged(status, condition);
                                        } catch (err) {
                                            Strophe.error("" + k + " plugin caused an exception " +
                                                "changing status: " + err);
                                        }
                                    }
                                }
                            }
                            
                            // notify the user's callback
                            if (this.connect_callback) {
                                try {
                                    this.connect_callback(status, condition);
                                } catch (e) {
                                    Strophe.error("User connection callback caused an " +
                                        "exception: " + e);
                                }
                            }
                        },
                        
                        /** PrivateFunction: _doDisconnect
                         *  _Private_ function to disconnect.
                         *
                         *  This is the last piece of the disconnection logic.  This resets the
                         *  connection and alerts the user's connection callback.
                         */
                        _doDisconnect: function (condition)
                        {
                            if (typeof this._idleTimeout == "number") {
                                clearTimeout(this._idleTimeout);
                            }
                            
                            // Cancel Disconnect Timeout
                            if (this._disconnectTimeout !== null) {
                                this.deleteTimedHandler(this._disconnectTimeout);
                                this._disconnectTimeout = null;
                            }
                            
                            Strophe.info("_doDisconnect was called");
                            this._proto._doDisconnect();
                            
                            this.authenticated = false;
                            this.disconnecting = false;
                            this.restored = false;
                            
                            // delete handlers
                            this.handlers = [];
                            this.timedHandlers = [];
                            this.removeTimeds = [];
                            this.removeHandlers = [];
                            this.addTimeds = [];
                            this.addHandlers = [];
                            
                            // tell the parent we disconnected
                            this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
                            this.connected = false;
                        },
                        
                        /** PrivateFunction: _dataRecv
                         *  _Private_ handler to processes incoming data from the the connection.
                         *
                         *  Except for _connect_cb handling the initial connection request,
                         *  this function handles the incoming data for all requests.  This
                         *  function also fires stanza handlers that match each incoming
                         *  stanza.
                         *
                         *  Parameters:
                         *    (Strophe.Request) req - The request that has data ready.
                         *    (string) req - The stanza a raw string (optiona).
                         */
                        _dataRecv: function (req, raw)
                        {
                            Strophe.info("_dataRecv called");
                            var elem = this._proto._reqToData(req);
                            if (elem === null) { return; }
                            
                            if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                                if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                                    this.xmlInput(elem.childNodes[0]);
                                } else {
                                    this.xmlInput(elem);
                                }
                            }
                            if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                                if (raw) {
                                    this.rawInput(raw);
                                } else {
                                    this.rawInput(Strophe.serialize(elem));
                                }
                            }
                            
                            // remove handlers scheduled for deletion
                            var i, hand;
                            while (this.removeHandlers.length > 0) {
                                hand = this.removeHandlers.pop();
                                i = this.handlers.indexOf(hand);
                                if (i >= 0) {
                                    this.handlers.splice(i, 1);
                                }
                            }
                            
                            // add handlers scheduled for addition
                            while (this.addHandlers.length > 0) {
                                this.handlers.push(this.addHandlers.pop());
                            }
                            
                            // handle graceful disconnect
                            if (this.disconnecting && this._proto._emptyQueue()) {
                                this._doDisconnect();
                                return;
                            }
                            
                            var type = elem.getAttribute("type");
                            var cond, conflict;
                            if (type !== null && type == "terminate") {
                                // Don't process stanzas that come in after disconnect
                                if (this.disconnecting) {
                                    return;
                                }
                                
                                // an error occurred
                                cond = elem.getAttribute("condition");
                                conflict = elem.getElementsByTagName("conflict");
                                if (cond !== null) {
                                    if (cond == "remote-stream-error" && conflict.length > 0) {
                                        cond = "conflict";
                                    }
                                    this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                                } else {
                                    this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                                }
                                this._doDisconnect(cond);
                                return;
                            }
                            
                            // send each incoming stanza through the handler chain
                            var that = this;
                            Strophe.forEachChild(elem, null, function (child) {
                                var i, newList;
                                // process handlers
                                newList = that.handlers;
                                that.handlers = [];
                                for (i = 0; i < newList.length; i++) {
                                    var hand = newList[i];
                                    // encapsulate 'handler.run' not to lose the whole handler list if
                                    // one of the handlers throws an exception
                                    try {
                                        if (hand.isMatch(child) &&
                                            (that.authenticated || !hand.user)) {
                                            if (hand.run(child)) {
                                                that.handlers.push(hand);
                                            }
                                        } else {
                                            that.handlers.push(hand);
                                        }
                                    } catch(e) {
                                        // if the handler throws an exception, we consider it as false
                                        Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);
                                    }
                                }
                            });
                        },
                        
                        
                        /** Attribute: mechanisms
                         *  SASL Mechanisms available for Conncection.
                         */
                        mechanisms: {},
                        
                        /** PrivateFunction: _connect_cb
                         *  _Private_ handler for initial connection request.
                         *
                         *  This handler is used to process the initial connection request
                         *  response from the BOSH server. It is used to set up authentication
                         *  handlers and start the authentication process.
                         *
                         *  SASL authentication will be attempted if available, otherwise
                         *  the code will fall back to legacy authentication.
                         *
                         *  Parameters:
                         *    (Strophe.Request) req - The current request.
                         *    (Function) _callback - low level (xmpp) connect callback function.
                         *      Useful for plugins with their own xmpp connect callback (when their)
                         *      want to do something special).
                         */
                        _connect_cb: function (req, _callback, raw)
                        {
                            Strophe.info("_connect_cb was called");
                            
                            this.connected = true;
                            
                            var bodyWrap = this._proto._reqToData(req);
                            if (!bodyWrap) { return; }
                            
                            if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                                if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                                    this.xmlInput(bodyWrap.childNodes[0]);
                                } else {
                                    this.xmlInput(bodyWrap);
                                }
                            }
                            if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                                if (raw) {
                                    this.rawInput(raw);
                                } else {
                                    this.rawInput(Strophe.serialize(bodyWrap));
                                }
                            }
                            
                            var conncheck = this._proto._connect_cb(bodyWrap);
                            if (conncheck === Strophe.Status.CONNFAIL) {
                                return;
                            }
                            
                            this._authentication.sasl_scram_sha1 = false;
                            this._authentication.sasl_plain = false;
                            this._authentication.sasl_digest_md5 = false;
                            this._authentication.sasl_anonymous = false;
                            
                            this._authentication.legacy_auth = false;
                            
                            // Check for the stream:features tag
                            var hasFeatures;
                            if (bodyWrap.getElementsByTagNameNS) {
                                hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0;
                            } else {
                                hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0;
                            }
                            var mechanisms = bodyWrap.getElementsByTagName("mechanism");
                            var matched = [];
                            var i, mech, found_authentication = false;
                            if (!hasFeatures) {
                                this._proto._no_auth_received(_callback);
                                return;
                            }
                            if (mechanisms.length > 0) {
                                for (i = 0; i < mechanisms.length; i++) {
                                    mech = Strophe.getText(mechanisms[i]);
                                    if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);
                                }
                            }
                            this._authentication.legacy_auth =
                                bodyWrap.getElementsByTagName("auth").length > 0;
                            found_authentication = this._authentication.legacy_auth ||
                                matched.length > 0;
                            if (!found_authentication) {
                                this._proto._no_auth_received(_callback);
                                return;
                            }
                            if (this.do_authentication !== false)
                                this.authenticate(matched);
                        },
                        
                        /** Function: authenticate
                         * Set up authentication
                         *
                         *  Contiunues the initial connection request by setting up authentication
                         *  handlers and start the authentication process.
                         *
                         *  SASL authentication will be attempted if available, otherwise
                         *  the code will fall back to legacy authentication.
                         *
                         */
                        authenticate: function (matched)
                        {
                            var i;
                            // Sorting matched mechanisms according to priority.
                            for (i = 0; i < matched.length - 1; ++i) {
                                var higher = i;
                                for (var j = i + 1; j < matched.length; ++j) {
                                    if (matched[j].prototype.priority > matched[higher].prototype.priority) {
                                        higher = j;
                                    }
                                }
                                if (higher != i) {
                                    var swap = matched[i];
                                    matched[i] = matched[higher];
                                    matched[higher] = swap;
                                }
                            }
                            
                            // run each mechanism
                            var mechanism_found = false;
                            for (i = 0; i < matched.length; ++i) {
                                if (!matched[i].test(this)) continue;
                                
                                this._sasl_success_handler = this._addSysHandler(
                                    this._sasl_success_cb.bind(this), null,
                                    "success", null, null);
                                this._sasl_failure_handler = this._addSysHandler(
                                    this._sasl_failure_cb.bind(this), null,
                                    "failure", null, null);
                                this._sasl_challenge_handler = this._addSysHandler(
                                    this._sasl_challenge_cb.bind(this), null,
                                    "challenge", null, null);
                                
                                this._sasl_mechanism = new matched[i]();
                                this._sasl_mechanism.onStart(this);
                                
                                var request_auth_exchange = $build("auth", {
                                    xmlns: Strophe.NS.SASL,
                                    mechanism: this._sasl_mechanism.name
                                });
                                
                                if (this._sasl_mechanism.isClientFirst) {
                                    var response = this._sasl_mechanism.onChallenge(this, null);
                                    request_auth_exchange.t(Base64.encode(response));
                                }
                                
                                this.send(request_auth_exchange.tree());
                                
                                mechanism_found = true;
                                break;
                            }
                            
                            if (!mechanism_found) {
                                // if none of the mechanism worked
                                if (Strophe.getNodeFromJid(this.jid) === null) {
                                    // we don't have a node, which is required for non-anonymous
                                    // client connections
                                    this._changeConnectStatus(Strophe.Status.CONNFAIL,
                                        'x-strophe-bad-non-anon-jid');
                                    this.disconnect('x-strophe-bad-non-anon-jid');
                                } else {
                                    // fall back to legacy authentication
                                    this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                                    this._addSysHandler(this._auth1_cb.bind(this), null, null,
                                        null, "_auth_1");
                                    
                                    this.send($iq({
                                        type: "get",
                                        to: this.domain,
                                        id: "_auth_1"
                                    }).c("query", {
                                        xmlns: Strophe.NS.AUTH
                                    }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree());
                                }
                            }
                            
                        },
                        
                        _sasl_challenge_cb: function(elem) {
                            var challenge = Base64.decode(Strophe.getText(elem));
                            var response = this._sasl_mechanism.onChallenge(this, challenge);
                            
                            var stanza = $build('response', {
                                xmlns: Strophe.NS.SASL
                            });
                            if (response !== "") {
                                stanza.t(Base64.encode(response));
                            }
                            this.send(stanza.tree());
                            
                            return true;
                        },
                        
                        /** PrivateFunction: _auth1_cb
                         *  _Private_ handler for legacy authentication.
                         *
                         *  This handler is called in response to the initial <iq type='get'/>
                         *  for legacy authentication.  It builds an authentication <iq/> and
                         *  sends it, creating a handler (calling back to _auth2_cb()) to
                         *  handle the result
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The stanza that triggered the callback.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        /* jshint unused:false */
                        _auth1_cb: function (elem)
                        {
                            // build plaintext auth iq
                            var iq = $iq({type: "set", id: "_auth_2"})
                                .c('query', {xmlns: Strophe.NS.AUTH})
                                .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
                                .up()
                                .c('password').t(this.pass);
                            
                            if (!Strophe.getResourceFromJid(this.jid)) {
                                // since the user has not supplied a resource, we pick
                                // a default one here.  unlike other auth methods, the server
                                // cannot do this for us.
                                this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
                            }
                            iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));
                            
                            this._addSysHandler(this._auth2_cb.bind(this), null,
                                null, null, "_auth_2");
                            
                            this.send(iq.tree());
                            
                            return false;
                        },
                        /* jshint unused:true */
                        
                        /** PrivateFunction: _sasl_success_cb
                         *  _Private_ handler for succesful SASL authentication.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The matching stanza.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        _sasl_success_cb: function (elem)
                        {
                            if (this._sasl_data["server-signature"]) {
                                var serverSignature;
                                var success = Base64.decode(Strophe.getText(elem));
                                var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
                                var matches = success.match(attribMatch);
                                if (matches[1] == "v") {
                                    serverSignature = matches[2];
                                }
                                
                                if (serverSignature != this._sasl_data["server-signature"]) {
                                    // remove old handlers
                                    this.deleteHandler(this._sasl_failure_handler);
                                    this._sasl_failure_handler = null;
                                    if (this._sasl_challenge_handler) {
                                        this.deleteHandler(this._sasl_challenge_handler);
                                        this._sasl_challenge_handler = null;
                                    }
                                    
                                    this._sasl_data = {};
                                    return this._sasl_failure_cb(null);
                                }
                            }
                            
                            Strophe.info("SASL authentication succeeded.");
                            
                            if(this._sasl_mechanism)
                                this._sasl_mechanism.onSuccess();
                            
                            // remove old handlers
                            this.deleteHandler(this._sasl_failure_handler);
                            this._sasl_failure_handler = null;
                            if (this._sasl_challenge_handler) {
                                this.deleteHandler(this._sasl_challenge_handler);
                                this._sasl_challenge_handler = null;
                            }
                            
                            var streamfeature_handlers = [];
                            var wrapper = function(handlers, elem) {
                                while (handlers.length) {
                                    this.deleteHandler(handlers.pop());
                                }
                                this._sasl_auth1_cb.bind(this)(elem);
                                return false;
                            };
                            streamfeature_handlers.push(this._addSysHandler(function(elem) {
                                wrapper.bind(this)(streamfeature_handlers, elem);
                            }.bind(this), null, "stream:features", null, null));
                            streamfeature_handlers.push(this._addSysHandler(function(elem) {
                                wrapper.bind(this)(streamfeature_handlers, elem);
                            }.bind(this), Strophe.NS.STREAM, "features", null, null));
                            
                            // we must send an xmpp:restart now
                            this._sendRestart();
                            
                            return false;
                        },
                        
                        /** PrivateFunction: _sasl_auth1_cb
                         *  _Private_ handler to start stream binding.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The matching stanza.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        _sasl_auth1_cb: function (elem)
                        {
                            // save stream:features for future usage
                            this.features = elem;
                            
                            var i, child;
                            
                            for (i = 0; i < elem.childNodes.length; i++) {
                                child = elem.childNodes[i];
                                if (child.nodeName == 'bind') {
                                    this.do_bind = true;
                                }
                                
                                if (child.nodeName == 'session') {
                                    this.do_session = true;
                                }
                            }
                            
                            if (!this.do_bind) {
                                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                                return false;
                            } else {
                                this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                                    null, "_bind_auth_2");
                                
                                var resource = Strophe.getResourceFromJid(this.jid);
                                if (resource) {
                                    this.send($iq({type: "set", id: "_bind_auth_2"})
                                        .c('bind', {xmlns: Strophe.NS.BIND})
                                        .c('resource', {}).t(resource).tree());
                                } else {
                                    this.send($iq({type: "set", id: "_bind_auth_2"})
                                        .c('bind', {xmlns: Strophe.NS.BIND})
                                        .tree());
                                }
                            }
                            
                            return false;
                        },
                        
                        /** PrivateFunction: _sasl_bind_cb
                         *  _Private_ handler for binding result and session start.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The matching stanza.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        _sasl_bind_cb: function (elem)
                        {
                            if (elem.getAttribute("type") == "error") {
                                Strophe.info("SASL binding failed.");
                                var conflict = elem.getElementsByTagName("conflict"), condition;
                                if (conflict.length > 0) {
                                    condition = 'conflict';
                                }
                                this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
                                return false;
                            }
                            
                            // TODO - need to grab errors
                            var bind = elem.getElementsByTagName("bind");
                            var jidNode;
                            if (bind.length > 0) {
                                // Grab jid
                                jidNode = bind[0].getElementsByTagName("jid");
                                if (jidNode.length > 0) {
                                    this.jid = Strophe.getText(jidNode[0]);
                                    
                                    if (this.do_session) {
                                        this._addSysHandler(this._sasl_session_cb.bind(this),
                                            null, null, null, "_session_auth_2");
                                        
                                        this.send($iq({type: "set", id: "_session_auth_2"})
                                            .c('session', {xmlns: Strophe.NS.SESSION})
                                            .tree());
                                    } else {
                                        this.authenticated = true;
                                        this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                                    }
                                }
                            } else {
                                Strophe.info("SASL binding failed.");
                                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                                return false;
                            }
                        },
                        
                        /** PrivateFunction: _sasl_session_cb
                         *  _Private_ handler to finish successful SASL connection.
                         *
                         *  This sets Connection.authenticated to true on success, which
                         *  starts the processing of user handlers.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The matching stanza.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        _sasl_session_cb: function (elem)
                        {
                            if (elem.getAttribute("type") == "result") {
                                this.authenticated = true;
                                this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                            } else if (elem.getAttribute("type") == "error") {
                                Strophe.info("Session creation failed.");
                                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                                return false;
                            }
                            
                            return false;
                        },
                        
                        /** PrivateFunction: _sasl_failure_cb
                         *  _Private_ handler for SASL authentication failure.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The matching stanza.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        /* jshint unused:false */
                        _sasl_failure_cb: function (elem)
                        {
                            // delete unneeded handlers
                            if (this._sasl_success_handler) {
                                this.deleteHandler(this._sasl_success_handler);
                                this._sasl_success_handler = null;
                            }
                            if (this._sasl_challenge_handler) {
                                this.deleteHandler(this._sasl_challenge_handler);
                                this._sasl_challenge_handler = null;
                            }
                            
                            if(this._sasl_mechanism)
                                this._sasl_mechanism.onFailure();
                            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                            return false;
                        },
                        /* jshint unused:true */
                        
                        /** PrivateFunction: _auth2_cb
                         *  _Private_ handler to finish legacy authentication.
                         *
                         *  This handler is called when the result from the jabber:iq:auth
                         *  <iq/> stanza is returned.
                         *
                         *  Parameters:
                         *    (XMLElement) elem - The stanza that triggered the callback.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        _auth2_cb: function (elem)
                        {
                            if (elem.getAttribute("type") == "result") {
                                this.authenticated = true;
                                this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                            } else if (elem.getAttribute("type") == "error") {
                                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                                this.disconnect('authentication failed');
                            }
                            
                            return false;
                        },
                        
                        /** PrivateFunction: _addSysTimedHandler
                         *  _Private_ function to add a system level timed handler.
                         *
                         *  This function is used to add a Strophe.TimedHandler for the
                         *  library code.  System timed handlers are allowed to run before
                         *  authentication is complete.
                         *
                         *  Parameters:
                         *    (Integer) period - The period of the handler.
                         *    (Function) handler - The callback function.
                         */
                        _addSysTimedHandler: function (period, handler)
                        {
                            var thand = new Strophe.TimedHandler(period, handler);
                            thand.user = false;
                            this.addTimeds.push(thand);
                            return thand;
                        },
                        
                        /** PrivateFunction: _addSysHandler
                         *  _Private_ function to add a system level stanza handler.
                         *
                         *  This function is used to add a Strophe.Handler for the
                         *  library code.  System stanza handlers are allowed to run before
                         *  authentication is complete.
                         *
                         *  Parameters:
                         *    (Function) handler - The callback function.
                         *    (String) ns - The namespace to match.
                         *    (String) name - The stanza name to match.
                         *    (String) type - The stanza type attribute to match.
                         *    (String) id - The stanza id attribute to match.
                         */
                        _addSysHandler: function (handler, ns, name, type, id)
                        {
                            var hand = new Strophe.Handler(handler, ns, name, type, id);
                            hand.user = false;
                            this.addHandlers.push(hand);
                            return hand;
                        },
                        
                        /** PrivateFunction: _onDisconnectTimeout
                         *  _Private_ timeout handler for handling non-graceful disconnection.
                         *
                         *  If the graceful disconnect process does not complete within the
                         *  time allotted, this handler finishes the disconnect anyway.
                         *
                         *  Returns:
                         *    false to remove the handler.
                         */
                        _onDisconnectTimeout: function ()
                        {
                            Strophe.info("_onDisconnectTimeout was called");
                            
                            this._proto._onDisconnectTimeout();
                            
                            // actually disconnect
                            this._doDisconnect();
                            
                            return false;
                        },
                        
                        /** PrivateFunction: _onIdle
                         *  _Private_ handler to process events during idle cycle.
                         *
                         *  This handler is called every 100ms to fire timed handlers that
                         *  are ready and keep poll requests going.
                         */
                        _onIdle: function ()
                        {
                            var i, thand, since, newList;
                            
                            // add timed handlers scheduled for addition
                            // NOTE: we add before remove in the case a timed handler is
                            // added and then deleted before the next _onIdle() call.
                            while (this.addTimeds.length > 0) {
                                this.timedHandlers.push(this.addTimeds.pop());
                            }
                            
                            // remove timed handlers that have been scheduled for deletion
                            while (this.removeTimeds.length > 0) {
                                thand = this.removeTimeds.pop();
                                i = this.timedHandlers.indexOf(thand);
                                if (i >= 0) {
                                    this.timedHandlers.splice(i, 1);
                                }
                            }
                            
                            // call ready timed handlers
                            var now = new Date().getTime();
                            newList = [];
                            for (i = 0; i < this.timedHandlers.length; i++) {
                                thand = this.timedHandlers[i];
                                if (this.authenticated || !thand.user) {
                                    since = thand.lastCalled + thand.period;
                                    if (since - now <= 0) {
                                        if (thand.run()) {
                                            newList.push(thand);
                                        }
                                    } else {
                                        newList.push(thand);
                                    }
                                }
                            }
                            this.timedHandlers = newList;
                            
                            clearTimeout(this._idleTimeout);
                            
                            this._proto._onIdle();
                            
                            // reactivate the timer only if connected
                            if (this.connected) {
                                this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
                            }
                        }
                    };
                    
                    /** Class: Strophe.SASLMechanism
                     *
                     *  encapsulates SASL authentication mechanisms.
                     *
                     *  User code may override the priority for each mechanism or disable it completely.
                     *  See <priority> for information about changing priority and <test> for informatian on
                     *  how to disable a mechanism.
                     *
                     *  By default, all mechanisms are enabled and the priorities are
                     *
                     *  SCRAM-SHA1 - 40
                     *  DIGEST-MD5 - 30
                     *  Plain - 20
                     */
                    
                    /**
                     * PrivateConstructor: Strophe.SASLMechanism
                     * SASL auth mechanism abstraction.
                     *
                     *  Parameters:
                     *    (String) name - SASL Mechanism name.
                     *    (Boolean) isClientFirst - If client should send response first without challenge.
                     *    (Number) priority - Priority.
                     *
                     *  Returns:
                     *    A new Strophe.SASLMechanism object.
                     */
                    Strophe.SASLMechanism = function(name, isClientFirst, priority) {
                        /** PrivateVariable: name
                         *  Mechanism name.
                         */
                        this.name = name;
                        /** PrivateVariable: isClientFirst
                         *  If client sends response without initial server challenge.
                         */
                        this.isClientFirst = isClientFirst;
                        /** Variable: priority
                         *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
                         *  Users may override this to prioritize mechanisms differently.
                         *
                         *  In the default configuration the priorities are
                         *
                         *  SCRAM-SHA1 - 40
                         *  DIGEST-MD5 - 30
                         *  Plain - 20
                         *
                         *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
                         *
                         *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;
                         *
                         *  See <SASL mechanisms> for a list of available mechanisms.
                         *
                         */
                        this.priority = priority;
                    };
                    
                    Strophe.SASLMechanism.prototype = {
                        /**
                         *  Function: test
                         *  Checks if mechanism able to run.
                         *  To disable a mechanism, make this return false;
                         *
                         *  To disable plain authentication run
                         *  > Strophe.SASLPlain.test = function() {
   *  >   return false;
   *  > }
                         *
                         *  See <SASL mechanisms> for a list of available mechanisms.
                         *
                         *  Parameters:
                         *    (Strophe.Connection) connection - Target Connection.
                         *
                         *  Returns:
                         *    (Boolean) If mechanism was able to run.
                         */
                        /* jshint unused:false */
                        test: function(connection) {
                            return true;
                        },
                        /* jshint unused:true */
                        
                        /** PrivateFunction: onStart
                         *  Called before starting mechanism on some connection.
                         *
                         *  Parameters:
                         *    (Strophe.Connection) connection - Target Connection.
                         */
                        onStart: function(connection)
                        {
                            this._connection = connection;
                        },
                        
                        /** PrivateFunction: onChallenge
                         *  Called by protocol implementation on incoming challenge. If client is
                         *  first (isClientFirst == true) challenge will be null on the first call.
                         *
                         *  Parameters:
                         *    (Strophe.Connection) connection - Target Connection.
                         *    (String) challenge - current challenge to handle.
                         *
                         *  Returns:
                         *    (String) Mechanism response.
                         */
                        /* jshint unused:false */
                        onChallenge: function(connection, challenge) {
                            throw new Error("You should implement challenge handling!");
                        },
                        /* jshint unused:true */
                        
                        /** PrivateFunction: onFailure
                         *  Protocol informs mechanism implementation about SASL failure.
                         */
                        onFailure: function() {
                            this._connection = null;
                        },
                        
                        /** PrivateFunction: onSuccess
                         *  Protocol informs mechanism implementation about SASL success.
                         */
                        onSuccess: function() {
                            this._connection = null;
                        }
                    };
                    
                    /** Constants: SASL mechanisms
                     *  Available authentication mechanisms
                     *
                     *  Strophe.SASLAnonymous - SASL Anonymous authentication.
                     *  Strophe.SASLPlain - SASL Plain authentication.
                     *  Strophe.SASLMD5 - SASL Digest-MD5 authentication
                     *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication
                     */
                    
                    // Building SASL callbacks
                    
                    /** PrivateConstructor: SASLAnonymous
                     *  SASL Anonymous authentication.
                     */
                    Strophe.SASLAnonymous = function() {};
                    
                    Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 10);
                    
                    Strophe.SASLAnonymous.test = function(connection) {
                        return connection.authcid === null;
                    };
                    
                    Strophe.Connection.prototype.mechanisms[Strophe.SASLAnonymous.prototype.name] = Strophe.SASLAnonymous;
                    
                    /** PrivateConstructor: SASLPlain
                     *  SASL Plain authentication.
                     */
                    Strophe.SASLPlain = function() {};
                    
                    Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 20);
                    
                    Strophe.SASLPlain.test = function(connection) {
                        return connection.authcid !== null;
                    };
                    
                    Strophe.SASLPlain.prototype.onChallenge = function(connection) {
                        var auth_str = connection.authzid;
                        auth_str = auth_str + "\u0000";
                        auth_str = auth_str + connection.authcid;
                        auth_str = auth_str + "\u0000";
                        auth_str = auth_str + connection.pass;
                        return auth_str;
                    };
                    
                    Strophe.Connection.prototype.mechanisms[Strophe.SASLPlain.prototype.name] = Strophe.SASLPlain;
                    
                    /** PrivateConstructor: SASLSHA1
                     *  SASL SCRAM SHA 1 authentication.
                     */
                    Strophe.SASLSHA1 = function() {};
                    
                    /* TEST:
                     * This is a simple example of a SCRAM-SHA-1 authentication exchange
                     * when the client doesn't support channel bindings (username 'user' and
                     * password 'pencil' are used):
                     *
                     * C: n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL
                     * S: r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,s=QSXCR+Q6sek8bf92,
                     * i=4096
                     * C: c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
                     * p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=
                     * S: v=rmF9pqV8S7suAoZWja4dJRkFsKQ=
                     *
                     */
                    
                    Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 40);
                    
                    Strophe.SASLSHA1.test = function(connection) {
                        return connection.authcid !== null;
                    };
                    
                    Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
                        var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
                        
                        var auth_str = "n=" + connection.authcid;
                        auth_str += ",r=";
                        auth_str += cnonce;
                        
                        connection._sasl_data.cnonce = cnonce;
                        connection._sasl_data["client-first-message-bare"] = auth_str;
                        
                        auth_str = "n,," + auth_str;
                        
                        this.onChallenge = function (connection, challenge)
                        {
                            var nonce, salt, iter, Hi, U, U_old, i, k;
                            var clientKey, serverKey, clientSignature;
                            var responseText = "c=biws,";
                            var authMessage = connection._sasl_data["client-first-message-bare"] + "," +
                                challenge + ",";
                            var cnonce = connection._sasl_data.cnonce;
                            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
                            
                            while (challenge.match(attribMatch)) {
                                var matches = challenge.match(attribMatch);
                                challenge = challenge.replace(matches[0], "");
                                switch (matches[1]) {
                                    case "r":
                                        nonce = matches[2];
                                        break;
                                    case "s":
                                        salt = matches[2];
                                        break;
                                    case "i":
                                        iter = matches[2];
                                        break;
                                }
                            }
                            
                            if (nonce.substr(0, cnonce.length) !== cnonce) {
                                connection._sasl_data = {};
                                return connection._sasl_failure_cb();
                            }
                            
                            responseText += "r=" + nonce;
                            authMessage += responseText;
                            
                            salt = Base64.decode(salt);
                            salt += "\x00\x00\x00\x01";
                            
                            Hi = U_old = SHA1.core_hmac_sha1(connection.pass, salt);
                            for (i = 1; i < iter; i++) {
                                U = SHA1.core_hmac_sha1(connection.pass, SHA1.binb2str(U_old));
                                for (k = 0; k < 5; k++) {
                                    Hi[k] ^= U[k];
                                }
                                U_old = U;
                            }
                            Hi = SHA1.binb2str(Hi);
                            
                            clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
                            serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
                            clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
                            connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);
                            
                            for (k = 0; k < 5; k++) {
                                clientKey[k] ^= clientSignature[k];
                            }
                            
                            responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
                            
                            return responseText;
                        }.bind(this);
                        
                        return auth_str;
                    };
                    
                    Strophe.Connection.prototype.mechanisms[Strophe.SASLSHA1.prototype.name] = Strophe.SASLSHA1;
                    
                    /** PrivateConstructor: SASLMD5
                     *  SASL DIGEST MD5 authentication.
                     */
                    Strophe.SASLMD5 = function() {};
                    
                    Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 30);
                    
                    Strophe.SASLMD5.test = function(connection) {
                        return connection.authcid !== null;
                    };
                    
                    /** PrivateFunction: _quote
                     *  _Private_ utility function to backslash escape and quote strings.
                     *
                     *  Parameters:
                     *    (String) str - The string to be quoted.
                     *
                     *  Returns:
                     *    quoted string
                     */
                    Strophe.SASLMD5.prototype._quote = function (str)
                    {
                        return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
                        //" end string workaround for emacs
                    };
                    
                    
                    Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
                        var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
                        var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
                        var realm = "";
                        var host = null;
                        var nonce = "";
                        var qop = "";
                        var matches;
                        
                        while (challenge.match(attribMatch)) {
                            matches = challenge.match(attribMatch);
                            challenge = challenge.replace(matches[0], "");
                            matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
                            switch (matches[1]) {
                                case "realm":
                                    realm = matches[2];
                                    break;
                                case "nonce":
                                    nonce = matches[2];
                                    break;
                                case "qop":
                                    qop = matches[2];
                                    break;
                                case "host":
                                    host = matches[2];
                                    break;
                            }
                        }
                        
                        var digest_uri = connection.servtype + "/" + connection.domain;
                        if (host !== null) {
                            digest_uri = digest_uri + "/" + host;
                        }
                        
                        var A1 = MD5.hash(connection.authcid +
                                ":" + realm + ":" + this._connection.pass) +
                            ":" + nonce + ":" + cnonce;
                        var A2 = 'AUTHENTICATE:' + digest_uri;
                        
                        var responseText = "";
                        responseText += 'charset=utf-8,';
                        responseText += 'username=' +
                            this._quote(connection.authcid) + ',';
                        responseText += 'realm=' + this._quote(realm) + ',';
                        responseText += 'nonce=' + this._quote(nonce) + ',';
                        responseText += 'nc=00000001,';
                        responseText += 'cnonce=' + this._quote(cnonce) + ',';
                        responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
                        responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" +
                                nonce + ":00000001:" +
                                cnonce + ":auth:" +
                                MD5.hexdigest(A2)) + ",";
                        responseText += 'qop=auth';
                        
                        this.onChallenge = function ()
                        {
                            return "";
                        }.bind(this);
                        
                        return responseText;
                    };
                    
                    Strophe.Connection.prototype.mechanisms[Strophe.SASLMD5.prototype.name] = Strophe.SASLMD5;
                    
                    return {
                        Strophe:        Strophe,
                        $build:         $build,
                        $msg:           $msg,
                        $iq:            $iq,
                        $pres:          $pres,
                        SHA1:           SHA1,
                        Base64:         Base64,
                        MD5:            MD5,
                    };
                }));
                
                /*
                 This program is distributed under the terms of the MIT license.
                 Please see the LICENSE file for details.
                
                 Copyright 2006-2008, OGG, LLC
                 */
                
                /* jshint undef: true, unused: true:, noarg: true, latedef: true */
                /* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */
                
                (function (root, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define('strophe-bosh', ['strophe-core'], function (core) {
                            return factory(
                                core.Strophe,
                                core.$build
                            );
                        });
                    } else {
                        // Browser globals
                        return factory(Strophe, $build);
                    }
                }(this, function (Strophe, $build) {
                    
                    /** PrivateClass: Strophe.Request
                     *  _Private_ helper class that provides a cross implementation abstraction
                     *  for a BOSH related XMLHttpRequest.
                     *
                     *  The Strophe.Request class is used internally to encapsulate BOSH request
                     *  information.  It is not meant to be used from user's code.
                     */
                    
                    /** PrivateConstructor: Strophe.Request
                     *  Create and initialize a new Strophe.Request object.
                     *
                     *  Parameters:
                     *    (XMLElement) elem - The XML data to be sent in the request.
                     *    (Function) func - The function that will be called when the
                     *      XMLHttpRequest readyState changes.
                     *    (Integer) rid - The BOSH rid attribute associated with this request.
                     *    (Integer) sends - The number of times this same request has been
                     *      sent.
                     */
                    Strophe.Request = function (elem, func, rid, sends)
                    {
                        this.id = ++Strophe._requestId;
                        this.xmlData = elem;
                        this.data = Strophe.serialize(elem);
                        // save original function in case we need to make a new request
                        // from this one.
                        this.origFunc = func;
                        this.func = func;
                        this.rid = rid;
                        this.date = NaN;
                        this.sends = sends || 0;
                        this.abort = false;
                        this.dead = null;
                        
                        this.age = function () {
                            if (!this.date) { return 0; }
                            var now = new Date();
                            return (now - this.date) / 1000;
                        };
                        this.timeDead = function () {
                            if (!this.dead) { return 0; }
                            var now = new Date();
                            return (now - this.dead) / 1000;
                        };
                        this.xhr = this._newXHR();
                    };
                    
                    Strophe.Request.prototype = {
                        /** PrivateFunction: getResponse
                         *  Get a response from the underlying XMLHttpRequest.
                         *
                         *  This function attempts to get a response from the request and checks
                         *  for errors.
                         *
                         *  Throws:
                         *    "parsererror" - A parser error occured.
                         *
                         *  Returns:
                         *    The DOM element tree of the response.
                         */
                        getResponse: function ()
                        {
                            var node = null;
                            if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                                node = this.xhr.responseXML.documentElement;
                                if (node.tagName == "parsererror") {
                                    Strophe.error("invalid response received");
                                    Strophe.error("responseText: " + this.xhr.responseText);
                                    Strophe.error("responseXML: " +
                                        Strophe.serialize(this.xhr.responseXML));
                                    throw "parsererror";
                                }
                            } else if (this.xhr.responseText) {
                                Strophe.error("invalid response received");
                                Strophe.error("responseText: " + this.xhr.responseText);
                                Strophe.error("responseXML: " +
                                    Strophe.serialize(this.xhr.responseXML));
                            }
                            
                            return node;
                        },
                        
                        /** PrivateFunction: _newXHR
                         *  _Private_ helper function to create XMLHttpRequests.
                         *
                         *  This function creates XMLHttpRequests across all implementations.
                         *
                         *  Returns:
                         *    A new XMLHttpRequest.
                         */
                        _newXHR: function ()
                        {
                            var xhr = null;
                            if (window.XMLHttpRequest) {
                                xhr = new XMLHttpRequest();
                                if (xhr.overrideMimeType) {
                                    xhr.overrideMimeType("text/xml; charset=utf-8");
                                }
                            } else if (window.ActiveXObject) {
                                xhr = new ActiveXObject("Microsoft.XMLHTTP");
                            }
                            
                            // use Function.bind() to prepend ourselves as an argument
                            xhr.onreadystatechange = this.func.bind(null, this);
                            
                            return xhr;
                        }
                    };
                    
                    /** Class: Strophe.Bosh
                     *  _Private_ helper class that handles BOSH Connections
                     *
                     *  The Strophe.Bosh class is used internally by Strophe.Connection
                     *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
                     */
                    
                    /** File: bosh.js
                     *  A JavaScript library to enable BOSH in Strophejs.
                     *
                     *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
                     *  to emulate a persistent, stateful, two-way connection to an XMPP server.
                     *  More information on BOSH can be found in XEP 124.
                     */
                    
                    /** PrivateConstructor: Strophe.Bosh
                     *  Create and initialize a Strophe.Bosh object.
                     *
                     *  Parameters:
                     *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
                     *
                     *  Returns:
                     *    A new Strophe.Bosh object.
                     */
                    Strophe.Bosh = function(connection) {
                        this._conn = connection;
                        /* request id for body tags */
                        this.rid = Math.floor(Math.random() * 4294967295);
                        /* The current session ID. */
                        this.sid = null;
                        
                        // default BOSH values
                        this.hold = 1;
                        this.wait = 60;
                        this.window = 5;
                        this.errors = 0;
                        
                        this._requests = [];
                    };
                    
                    Strophe.Bosh.prototype = {
                        /** Variable: strip
                         *
                         *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
                         *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
                         *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
                         *
                         *  > Strophe.Bosh.prototype.strip = "body";
                         *
                         *  This will enable stripping of the body tag in both
                         *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
                         */
                        strip: null,
                        
                        /** PrivateFunction: _buildBody
                         *  _Private_ helper function to generate the <body/> wrapper for BOSH.
                         *
                         *  Returns:
                         *    A Strophe.Builder with a <body/> element.
                         */
                        _buildBody: function ()
                        {
                            var bodyWrap = $build('body', {
                                rid: this.rid++,
                                xmlns: Strophe.NS.HTTPBIND
                            });
                            if (this.sid !== null) {
                                bodyWrap.attrs({sid: this.sid});
                            }
                            if (this._conn.options.keepalive) {
                                this._cacheSession();
                            }
                            return bodyWrap;
                        },
                        
                        /** PrivateFunction: _reset
                         *  Reset the connection.
                         *
                         *  This function is called by the reset function of the Strophe Connection
                         */
                        _reset: function ()
                        {
                            this.rid = Math.floor(Math.random() * 4294967295);
                            this.sid = null;
                            this.errors = 0;
                            window.sessionStorage.removeItem('strophe-bosh-session');
                        },
                        
                        /** PrivateFunction: _connect
                         *  _Private_ function that initializes the BOSH connection.
                         *
                         *  Creates and sends the Request that initializes the BOSH connection.
                         */
                        _connect: function (wait, hold, route)
                        {
                            this.wait = wait || this.wait;
                            this.hold = hold || this.hold;
                            this.errors = 0;
                            
                            // build the body tag
                            var body = this._buildBody().attrs({
                                to: this._conn.domain,
                                "xml:lang": "en",
                                wait: this.wait,
                                hold: this.hold,
                                content: "text/xml; charset=utf-8",
                                ver: "1.6",
                                "xmpp:version": "1.0",
                                "xmlns:xmpp": Strophe.NS.BOSH
                            });
                            
                            if(route){
                                body.attrs({
                                    route: route
                                });
                            }
                            
                            var _connect_cb = this._conn._connect_cb;
                            
                            this._requests.push(
                                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, _connect_cb.bind(this._conn)),
                                    body.tree().getAttribute("rid")));
                            this._throttledRequestHandler();
                        },
                        
                        /** PrivateFunction: _attach
                         *  Attach to an already created and authenticated BOSH session.
                         *
                         *  This function is provided to allow Strophe to attach to BOSH
                         *  sessions which have been created externally, perhaps by a Web
                         *  application.  This is often used to support auto-login type features
                         *  without putting user credentials into the page.
                         *
                         *  Parameters:
                         *    (String) jid - The full JID that is bound by the session.
                         *    (String) sid - The SID of the BOSH session.
                         *    (String) rid - The current RID of the BOSH session.  This RID
                         *      will be used by the next request.
                         *    (Function) callback The connect callback function.
                         *    (Integer) wait - The optional HTTPBIND wait value.  This is the
                         *      time the server will wait before returning an empty result for
                         *      a request.  The default setting of 60 seconds is recommended.
                         *      Other settings will require tweaks to the Strophe.TIMEOUT value.
                         *    (Integer) hold - The optional HTTPBIND hold value.  This is the
                         *      number of connections the server will hold at one time.  This
                         *      should almost always be set to 1 (the default).
                         *    (Integer) wind - The optional HTTBIND window value.  This is the
                         *      allowed range of request ids that are valid.  The default is 5.
                         */
                        _attach: function (jid, sid, rid, callback, wait, hold, wind)
                        {
                            this._conn.jid = jid;
                            this.sid = sid;
                            this.rid = rid;
                            
                            this._conn.connect_callback = callback;
                            
                            this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);
                            
                            this._conn.authenticated = true;
                            this._conn.connected = true;
                            
                            this.wait = wait || this.wait;
                            this.hold = hold || this.hold;
                            this.window = wind || this.window;
                            
                            this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
                        },
                        
                        /** PrivateFunction: _restore
                         *  Attempt to restore a cached BOSH session
                         *
                         *  Parameters:
                         *    (String) jid - The full JID that is bound by the session.
                         *      This parameter is optional but recommended, specifically in cases
                         *      where prebinded BOSH sessions are used where it's important to know
                         *      that the right session is being restored.
                         *    (Function) callback The connect callback function.
                         *    (Integer) wait - The optional HTTPBIND wait value.  This is the
                         *      time the server will wait before returning an empty result for
                         *      a request.  The default setting of 60 seconds is recommended.
                         *      Other settings will require tweaks to the Strophe.TIMEOUT value.
                         *    (Integer) hold - The optional HTTPBIND hold value.  This is the
                         *      number of connections the server will hold at one time.  This
                         *      should almost always be set to 1 (the default).
                         *    (Integer) wind - The optional HTTBIND window value.  This is the
                         *      allowed range of request ids that are valid.  The default is 5.
                         */
                        _restore: function (jid, callback, wait, hold, wind)
                        {
                            var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
                            if (typeof session !== "undefined" &&
                                session !== null &&
                                session.rid &&
                                session.sid &&
                                session.jid &&
                                (typeof jid === "undefined" || Strophe.getBareJidFromJid(session.jid) == Strophe.getBareJidFromJid(jid)))
                            {
                                this._conn.restored = true;
                                this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
                            } else {
                                throw { name: "StropheSessionError", message: "_restore: no restoreable session." };
                            }
                        },
                        
                        /** PrivateFunction: _cacheSession
                         *  _Private_ handler for the beforeunload event.
                         *
                         *  This handler is used to process the Bosh-part of the initial request.
                         *  Parameters:
                         *    (Strophe.Request) bodyWrap - The received stanza.
                         */
                        _cacheSession: function ()
                        {
                            if (this._conn.authenticated) {
                                if (this._conn.jid && this.rid && this.sid) {
                                    window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                                        'jid': this._conn.jid,
                                        'rid': this.rid,
                                        'sid': this.sid
                                    }));
                                }
                            } else {
                                window.sessionStorage.removeItem('strophe-bosh-session');
                            }
                        },
                        
                        /** PrivateFunction: _connect_cb
                         *  _Private_ handler for initial connection request.
                         *
                         *  This handler is used to process the Bosh-part of the initial request.
                         *  Parameters:
                         *    (Strophe.Request) bodyWrap - The received stanza.
                         */
                        _connect_cb: function (bodyWrap)
                        {
                            var typ = bodyWrap.getAttribute("type");
                            var cond, conflict;
                            if (typ !== null && typ == "terminate") {
                                // an error occurred
                                cond = bodyWrap.getAttribute("condition");
                                Strophe.error("BOSH-Connection failed: " + cond);
                                conflict = bodyWrap.getElementsByTagName("conflict");
                                if (cond !== null) {
                                    if (cond == "remote-stream-error" && conflict.length > 0) {
                                        cond = "conflict";
                                    }
                                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                                } else {
                                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                                }
                                this._conn._doDisconnect(cond);
                                return Strophe.Status.CONNFAIL;
                            }
                            
                            // check to make sure we don't overwrite these if _connect_cb is
                            // called multiple times in the case of missing stream:features
                            if (!this.sid) {
                                this.sid = bodyWrap.getAttribute("sid");
                            }
                            var wind = bodyWrap.getAttribute('requests');
                            if (wind) { this.window = parseInt(wind, 10); }
                            var hold = bodyWrap.getAttribute('hold');
                            if (hold) { this.hold = parseInt(hold, 10); }
                            var wait = bodyWrap.getAttribute('wait');
                            if (wait) { this.wait = parseInt(wait, 10); }
                        },
                        
                        /** PrivateFunction: _disconnect
                         *  _Private_ part of Connection.disconnect for Bosh
                         *
                         *  Parameters:
                         *    (Request) pres - This stanza will be sent before disconnecting.
                         */
                        _disconnect: function (pres)
                        {
                            this._sendTerminate(pres);
                        },
                        
                        /** PrivateFunction: _doDisconnect
                         *  _Private_ function to disconnect.
                         *
                         *  Resets the SID and RID.
                         */
                        _doDisconnect: function ()
                        {
                            this.sid = null;
                            this.rid = Math.floor(Math.random() * 4294967295);
                            window.sessionStorage.removeItem('strophe-bosh-session');
                        },
                        
                        /** PrivateFunction: _emptyQueue
                         * _Private_ function to check if the Request queue is empty.
                         *
                         *  Returns:
                         *    True, if there are no Requests queued, False otherwise.
                         */
                        _emptyQueue: function ()
                        {
                            return this._requests.length === 0;
                        },
                        
                        /** PrivateFunction: _hitError
                         *  _Private_ function to handle the error count.
                         *
                         *  Requests are resent automatically until their error count reaches
                         *  5.  Each time an error is encountered, this function is called to
                         *  increment the count and disconnect if the count is too high.
                         *
                         *  Parameters:
                         *    (Integer) reqStatus - The request status.
                         */
                        _hitError: function (reqStatus)
                        {
                            this.errors++;
                            Strophe.warn("request errored, status: " + reqStatus +
                                ", number of errors: " + this.errors);
                            if (this.errors > 4) {
                                this._conn._onDisconnectTimeout();
                            }
                        },
                        
                        /** PrivateFunction: _no_auth_received
                         *
                         * Called on stream start/restart when no stream:features
                         * has been received and sends a blank poll request.
                         */
                        _no_auth_received: function (_callback)
                        {
                            if (_callback) {
                                _callback = _callback.bind(this._conn);
                            } else {
                                _callback = this._conn._connect_cb.bind(this._conn);
                            }
                            var body = this._buildBody();
                            this._requests.push(
                                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, _callback.bind(this._conn)),
                                    body.tree().getAttribute("rid")));
                            this._throttledRequestHandler();
                        },
                        
                        /** PrivateFunction: _onDisconnectTimeout
                         *  _Private_ timeout handler for handling non-graceful disconnection.
                         *
                         *  Cancels all remaining Requests and clears the queue.
                         */
                        _onDisconnectTimeout: function () {
                            this._abortAllRequests();
                        },
                        
                        /** PrivateFunction: _abortAllRequests
                         *  _Private_ helper function that makes sure all pending requests are aborted.
                         */
                        _abortAllRequests: function _abortAllRequests() {
                            var req;
                            while (this._requests.length > 0) {
                                req = this._requests.pop();
                                req.abort = true;
                                req.xhr.abort();
                                // jslint complains, but this is fine. setting to empty func
                                // is necessary for IE6
                                req.xhr.onreadystatechange = function () {}; // jshint ignore:line
                            }
                        },
                        
                        /** PrivateFunction: _onIdle
                         *  _Private_ handler called by Strophe.Connection._onIdle
                         *
                         *  Sends all queued Requests or polls with empty Request if there are none.
                         */
                        _onIdle: function () {
                            var data = this._conn._data;
                            
                            // if no requests are in progress, poll
                            if (this._conn.authenticated && this._requests.length === 0 &&
                                data.length === 0 && !this._conn.disconnecting) {
                                Strophe.info("no requests during idle cycle, sending " +
                                    "blank request");
                                data.push(null);
                            }
                            
                            if (this._conn.paused) {
                                return;
                            }
                            
                            if (this._requests.length < 2 && data.length > 0) {
                                var body = this._buildBody();
                                for (var i = 0; i < data.length; i++) {
                                    if (data[i] !== null) {
                                        if (data[i] === "restart") {
                                            body.attrs({
                                                to: this._conn.domain,
                                                "xml:lang": "en",
                                                "xmpp:restart": "true",
                                                "xmlns:xmpp": Strophe.NS.BOSH
                                            });
                                        } else {
                                            body.cnode(data[i]).up();
                                        }
                                    }
                                }
                                delete this._conn._data;
                                this._conn._data = [];
                                this._requests.push(
                                    new Strophe.Request(body.tree(),
                                        this._onRequestStateChange.bind(
                                            this, this._conn._dataRecv.bind(this._conn)),
                                        body.tree().getAttribute("rid")));
                                this._throttledRequestHandler();
                            }
                            
                            if (this._requests.length > 0) {
                                var time_elapsed = this._requests[0].age();
                                if (this._requests[0].dead !== null) {
                                    if (this._requests[0].timeDead() >
                                        Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                                        this._throttledRequestHandler();
                                    }
                                }
                                
                                if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                                    Strophe.warn("Request " +
                                        this._requests[0].id +
                                        " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                                        " seconds since last activity");
                                    this._throttledRequestHandler();
                                }
                            }
                        },
                        
                        /** PrivateFunction: _onRequestStateChange
                         *  _Private_ handler for Strophe.Request state changes.
                         *
                         *  This function is called when the XMLHttpRequest readyState changes.
                         *  It contains a lot of error handling logic for the many ways that
                         *  requests can fail, and calls the request callback when requests
                         *  succeed.
                         *
                         *  Parameters:
                         *    (Function) func - The handler for the request.
                         *    (Strophe.Request) req - The request that is changing readyState.
                         */
                        _onRequestStateChange: function (func, req)
                        {
                            Strophe.debug("request id " + req.id +
                                "." + req.sends + " state changed to " +
                                req.xhr.readyState);
                            
                            if (req.abort) {
                                req.abort = false;
                                return;
                            }
                            
                            // request complete
                            var reqStatus;
                            if (req.xhr.readyState == 4) {
                                reqStatus = 0;
                                try {
                                    reqStatus = req.xhr.status;
                                } catch (e) {
                                    // ignore errors from undefined status attribute.  works
                                    // around a browser bug
                                }
                                
                                if (typeof(reqStatus) == "undefined") {
                                    reqStatus = 0;
                                }
                                
                                if (this.disconnecting) {
                                    if (reqStatus >= 400) {
                                        this._hitError(reqStatus);
                                        return;
                                    }
                                }
                                
                                var reqIs0 = (this._requests[0] == req);
                                var reqIs1 = (this._requests[1] == req);
                                
                                if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                                    // remove from internal queue
                                    this._removeRequest(req);
                                    Strophe.debug("request id " +
                                        req.id +
                                        " should now be removed");
                                }
                                
                                // request succeeded
                                if (reqStatus == 200) {
                                    // if request 1 finished, or request 0 finished and request
                                    // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                                    // restart the other - both will be in the first spot, as the
                                    // completed request has been removed from the queue already
                                    if (reqIs1 ||
                                        (reqIs0 && this._requests.length > 0 &&
                                        this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                                        this._restartRequest(0);
                                    }
                                    // call handler
                                    Strophe.debug("request id " +
                                        req.id + "." +
                                        req.sends + " got 200");
                                    func(req);
                                    this.errors = 0;
                                } else {
                                    Strophe.error("request id " +
                                        req.id + "." +
                                        req.sends + " error " + reqStatus +
                                        " happened");
                                    if (reqStatus === 0 ||
                                        (reqStatus >= 400 && reqStatus < 600) ||
                                        reqStatus >= 12000) {
                                        this._hitError(reqStatus);
                                        if (reqStatus >= 400 && reqStatus < 500) {
                                            this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
                                            this._conn._doDisconnect();
                                        }
                                    }
                                }
                                
                                if (!((reqStatus > 0 && reqStatus < 500) ||
                                    req.sends > 5)) {
                                    this._throttledRequestHandler();
                                }
                            }
                        },
                        
                        /** PrivateFunction: _processRequest
                         *  _Private_ function to process a request in the queue.
                         *
                         *  This function takes requests off the queue and sends them and
                         *  restarts dead requests.
                         *
                         *  Parameters:
                         *    (Integer) i - The index of the request in the queue.
                         */
                        _processRequest: function (i)
                        {
                            var self = this;
                            var req = this._requests[i];
                            var reqStatus = -1;
                            
                            try {
                                if (req.xhr.readyState == 4) {
                                    reqStatus = req.xhr.status;
                                }
                            } catch (e) {
                                Strophe.error("caught an error in _requests[" + i +
                                    "], reqStatus: " + reqStatus);
                            }
                            
                            if (typeof(reqStatus) == "undefined") {
                                reqStatus = -1;
                            }
                            
                            // make sure we limit the number of retries
                            if (req.sends > this._conn.maxRetries) {
                                this._conn._onDisconnectTimeout();
                                return;
                            }
                            
                            var time_elapsed = req.age();
                            var primaryTimeout = (!isNaN(time_elapsed) &&
                            time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
                            var secondaryTimeout = (req.dead !== null &&
                            req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
                            var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                            (reqStatus < 1 ||
                            reqStatus >= 500));
                            if (primaryTimeout || secondaryTimeout ||
                                requestCompletedWithServerError) {
                                if (secondaryTimeout) {
                                    Strophe.error("Request " +
                                        this._requests[i].id +
                                        " timed out (secondary), restarting");
                                }
                                req.abort = true;
                                req.xhr.abort();
                                // setting to null fails on IE6, so set to empty function
                                req.xhr.onreadystatechange = function () {};
                                this._requests[i] = new Strophe.Request(req.xmlData,
                                    req.origFunc,
                                    req.rid,
                                    req.sends);
                                req = this._requests[i];
                            }
                            
                            if (req.xhr.readyState === 0) {
                                Strophe.debug("request id " + req.id +
                                    "." + req.sends + " posting");
                                
                                try {
                                    req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
                                    req.xhr.setRequestHeader("Content-Type", "text/xml; charset=utf-8");
                                } catch (e2) {
                                    Strophe.error("XHR open failed.");
                                    if (!this._conn.connected) {
                                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL,
                                            "bad-service");
                                    }
                                    this._conn.disconnect();
                                    return;
                                }
                                
                                // Fires the XHR request -- may be invoked immediately
                                // or on a gradually expanding retry window for reconnects
                                var sendFunc = function () {
                                    req.date = new Date();
                                    if (self._conn.options.customHeaders){
                                        var headers = self._conn.options.customHeaders;
                                        for (var header in headers) {
                                            if (headers.hasOwnProperty(header)) {
                                                req.xhr.setRequestHeader(header, headers[header]);
                                            }
                                        }
                                    }
                                    req.xhr.send(req.data);
                                };
                                
                                // Implement progressive backoff for reconnects --
                                // First retry (send == 1) should also be instantaneous
                                if (req.sends > 1) {
                                    // Using a cube of the retry number creates a nicely
                                    // expanding retry window
                                    var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                            Math.pow(req.sends, 3)) * 1000;
                                    setTimeout(sendFunc, backoff);
                                } else {
                                    sendFunc();
                                }
                                
                                req.sends++;
                                
                                if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                                    if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                                        this._conn.xmlOutput(req.xmlData.childNodes[0]);
                                    } else {
                                        this._conn.xmlOutput(req.xmlData);
                                    }
                                }
                                if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                                    this._conn.rawOutput(req.data);
                                }
                            } else {
                                Strophe.debug("_processRequest: " +
                                    (i === 0 ? "first" : "second") +
                                    " request has readyState of " +
                                    req.xhr.readyState);
                            }
                        },
                        
                        /** PrivateFunction: _removeRequest
                         *  _Private_ function to remove a request from the queue.
                         *
                         *  Parameters:
                         *    (Strophe.Request) req - The request to remove.
                         */
                        _removeRequest: function (req)
                        {
                            Strophe.debug("removing request");
                            
                            var i;
                            for (i = this._requests.length - 1; i >= 0; i--) {
                                if (req == this._requests[i]) {
                                    this._requests.splice(i, 1);
                                }
                            }
                            
                            // IE6 fails on setting to null, so set to empty function
                            req.xhr.onreadystatechange = function () {};
                            
                            this._throttledRequestHandler();
                        },
                        
                        /** PrivateFunction: _restartRequest
                         *  _Private_ function to restart a request that is presumed dead.
                         *
                         *  Parameters:
                         *    (Integer) i - The index of the request in the queue.
                         */
                        _restartRequest: function (i)
                        {
                            var req = this._requests[i];
                            if (req.dead === null) {
                                req.dead = new Date();
                            }
                            
                            this._processRequest(i);
                        },
                        
                        /** PrivateFunction: _reqToData
                         * _Private_ function to get a stanza out of a request.
                         *
                         * Tries to extract a stanza out of a Request Object.
                         * When this fails the current connection will be disconnected.
                         *
                         *  Parameters:
                         *    (Object) req - The Request.
                         *
                         *  Returns:
                         *    The stanza that was passed.
                         */
                        _reqToData: function (req)
                        {
                            try {
                                return req.getResponse();
                            } catch (e) {
                                if (e != "parsererror") { throw e; }
                                this._conn.disconnect("strophe-parsererror");
                            }
                        },
                        
                        /** PrivateFunction: _sendTerminate
                         *  _Private_ function to send initial disconnect sequence.
                         *
                         *  This is the first step in a graceful disconnect.  It sends
                         *  the BOSH server a terminate body and includes an unavailable
                         *  presence if authentication has completed.
                         */
                        _sendTerminate: function (pres)
                        {
                            Strophe.info("_sendTerminate was called");
                            var body = this._buildBody().attrs({type: "terminate"});
                            
                            if (pres) {
                                body.cnode(pres.tree());
                            }
                            
                            var req = new Strophe.Request(body.tree(),
                                this._onRequestStateChange.bind(
                                    this, this._conn._dataRecv.bind(this._conn)),
                                body.tree().getAttribute("rid"));
                            
                            this._requests.push(req);
                            this._throttledRequestHandler();
                        },
                        
                        /** PrivateFunction: _send
                         *  _Private_ part of the Connection.send function for BOSH
                         *
                         * Just triggers the RequestHandler to send the messages that are in the queue
                         */
                        _send: function () {
                            clearTimeout(this._conn._idleTimeout);
                            this._throttledRequestHandler();
                            this._conn._idleTimeout = setTimeout(this._conn._onIdle.bind(this._conn), 100);
                        },
                        
                        /** PrivateFunction: _sendRestart
                         *
                         *  Send an xmpp:restart stanza.
                         */
                        _sendRestart: function ()
                        {
                            this._throttledRequestHandler();
                            clearTimeout(this._conn._idleTimeout);
                        },
                        
                        /** PrivateFunction: _throttledRequestHandler
                         *  _Private_ function to throttle requests to the connection window.
                         *
                         *  This function makes sure we don't send requests so fast that the
                         *  request ids overflow the connection window in the case that one
                         *  request died.
                         */
                        _throttledRequestHandler: function ()
                        {
                            if (!this._requests) {
                                Strophe.debug("_throttledRequestHandler called with " +
                                    "undefined requests");
                            } else {
                                Strophe.debug("_throttledRequestHandler called with " +
                                    this._requests.length + " requests");
                            }
                            
                            if (!this._requests || this._requests.length === 0) {
                                return;
                            }
                            
                            if (this._requests.length > 0) {
                                this._processRequest(0);
                            }
                            
                            if (this._requests.length > 1 &&
                                Math.abs(this._requests[0].rid -
                                    this._requests[1].rid) < this.window) {
                                this._processRequest(1);
                            }
                        }
                    };
                    return Strophe;
                }));
                
                /*
                 This program is distributed under the terms of the MIT license.
                 Please see the LICENSE file for details.
                
                 Copyright 2006-2008, OGG, LLC
                 */
                
                /* jshint undef: true, unused: true:, noarg: true, latedef: true */
                /* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */
                
                (function (root, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define('strophe-websocket', ['strophe-core'], function (core) {
                            return factory(
                                core.Strophe,
                                core.$build
                            );
                        });
                    } else {
                        // Browser globals
                        return factory(Strophe, $build);
                    }
                }(this, function (Strophe, $build) {
                    
                    /** Class: Strophe.WebSocket
                     *  _Private_ helper class that handles WebSocket Connections
                     *
                     *  The Strophe.WebSocket class is used internally by Strophe.Connection
                     *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
                     */
                    
                    /** File: websocket.js
                     *  A JavaScript library to enable XMPP over Websocket in Strophejs.
                     *
                     *  This file implements XMPP over WebSockets for Strophejs.
                     *  If a Connection is established with a Websocket url (ws://...)
                     *  Strophe will use WebSockets.
                     *  For more information on XMPP-over-WebSocket see RFC 7395:
                     *  http://tools.ietf.org/html/rfc7395
                     *
                     *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
                     */
                    
                    /** PrivateConstructor: Strophe.Websocket
                     *  Create and initialize a Strophe.WebSocket object.
                     *  Currently only sets the connection Object.
                     *
                     *  Parameters:
                     *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
                     *
                     *  Returns:
                     *    A new Strophe.WebSocket object.
                     */
                    Strophe.Websocket = function(connection) {
                        this._conn = connection;
                        this.strip = "wrapper";
                        
                        var service = connection.service;
                        if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
                            // If the service is not an absolute URL, assume it is a path and put the absolute
                            // URL together from options, current URL and the path.
                            var new_service = "";
                            
                            if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
                                new_service += "ws";
                            } else {
                                new_service += "wss";
                            }
                            
                            new_service += "://" + window.location.host;
                            
                            if (service.indexOf("/") !== 0) {
                                new_service += window.location.pathname + service;
                            } else {
                                new_service += service;
                            }
                            
                            connection.service = new_service;
                        }
                    };
                    
                    Strophe.Websocket.prototype = {
                        /** PrivateFunction: _buildStream
                         *  _Private_ helper function to generate the <stream> start tag for WebSockets
                         *
                         *  Returns:
                         *    A Strophe.Builder with a <stream> element.
                         */
                        _buildStream: function ()
                        {
                            return $build("open", {
                                "xmlns": Strophe.NS.FRAMING,
                                "to": this._conn.domain,
                                "version": '1.0'
                            });
                        },
                        
                        /** PrivateFunction: _check_streamerror
                         * _Private_ checks a message for stream:error
                         *
                         *  Parameters:
                         *    (Strophe.Request) bodyWrap - The received stanza.
                         *    connectstatus - The ConnectStatus that will be set on error.
                         *  Returns:
                         *     true if there was a streamerror, false otherwise.
                         */
                        _check_streamerror: function (bodyWrap, connectstatus) {
                            var errors;
                            if (bodyWrap.getElementsByTagNameNS) {
                                errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error");
                            } else {
                                errors = bodyWrap.getElementsByTagName("stream:error");
                            }
                            if (errors.length === 0) {
                                return false;
                            }
                            var error = errors[0];
                            
                            var condition = "";
                            var text = "";
                            
                            var ns = "urn:ietf:params:xml:ns:xmpp-streams";
                            for (var i = 0; i < error.childNodes.length; i++) {
                                var e = error.childNodes[i];
                                if (e.getAttribute("xmlns") !== ns) {
                                    break;
                                } if (e.nodeName === "text") {
                                    text = e.textContent;
                                } else {
                                    condition = e.nodeName;
                                }
                            }
                            
                            var errorString = "WebSocket stream error: ";
                            
                            if (condition) {
                                errorString += condition;
                            } else {
                                errorString += "unknown";
                            }
                            
                            if (text) {
                                errorString += " - " + condition;
                            }
                            
                            Strophe.error(errorString);
                            
                            // close the connection on stream_error
                            this._conn._changeConnectStatus(connectstatus, condition);
                            this._conn._doDisconnect();
                            return true;
                        },
                        
                        /** PrivateFunction: _reset
                         *  Reset the connection.
                         *
                         *  This function is called by the reset function of the Strophe Connection.
                         *  Is not needed by WebSockets.
                         */
                        _reset: function ()
                        {
                            return;
                        },
                        
                        /** PrivateFunction: _connect
                         *  _Private_ function called by Strophe.Connection.connect
                         *
                         *  Creates a WebSocket for a connection and assigns Callbacks to it.
                         *  Does nothing if there already is a WebSocket.
                         */
                        _connect: function () {
                            // Ensure that there is no open WebSocket from a previous Connection.
                            this._closeSocket();
                            
                            // Create the new WobSocket
                            this.socket = new WebSocket(this._conn.service, "xmpp");
                            this.socket.onopen = this._onOpen.bind(this);
                            this.socket.onerror = this._onError.bind(this);
                            this.socket.onclose = this._onClose.bind(this);
                            this.socket.onmessage = this._connect_cb_wrapper.bind(this);
                        },
                        
                        /** PrivateFunction: _connect_cb
                         *  _Private_ function called by Strophe.Connection._connect_cb
                         *
                         * checks for stream:error
                         *
                         *  Parameters:
                         *    (Strophe.Request) bodyWrap - The received stanza.
                         */
                        _connect_cb: function(bodyWrap) {
                            var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
                            if (error) {
                                return Strophe.Status.CONNFAIL;
                            }
                        },
                        
                        /** PrivateFunction: _handleStreamStart
                         * _Private_ function that checks the opening <open /> tag for errors.
                         *
                         * Disconnects if there is an error and returns false, true otherwise.
                         *
                         *  Parameters:
                         *    (Node) message - Stanza containing the <open /> tag.
                         */
                        _handleStreamStart: function(message) {
                            var error = false;
                            
                            // Check for errors in the <open /> tag
                            var ns = message.getAttribute("xmlns");
                            if (typeof ns !== "string") {
                                error = "Missing xmlns in <open />";
                            } else if (ns !== Strophe.NS.FRAMING) {
                                error = "Wrong xmlns in <open />: " + ns;
                            }
                            
                            var ver = message.getAttribute("version");
                            if (typeof ver !== "string") {
                                error = "Missing version in <open />";
                            } else if (ver !== "1.0") {
                                error = "Wrong version in <open />: " + ver;
                            }
                            
                            if (error) {
                                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
                                this._conn._doDisconnect();
                                return false;
                            }
                            
                            return true;
                        },
                        
                        /** PrivateFunction: _connect_cb_wrapper
                         * _Private_ function that handles the first connection messages.
                         *
                         * On receiving an opening stream tag this callback replaces itself with the real
                         * message handler. On receiving a stream error the connection is terminated.
                         */
                        _connect_cb_wrapper: function(message) {
                            if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
                                // Strip the XML Declaration, if there is one
                                var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
                                if (data === '') return;
                                
                                var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
                                this._conn.xmlInput(streamStart);
                                this._conn.rawInput(message.data);
                                
                                //_handleStreamSteart will check for XML errors and disconnect on error
                                if (this._handleStreamStart(streamStart)) {
                                    //_connect_cb will check for stream:error and disconnect on error
                                    this._connect_cb(streamStart);
                                }
                            } else if (message.data.indexOf("<close ") === 0) { //'<close xmlns="urn:ietf:params:xml:ns:xmpp-framing />') {
                                this._conn.rawInput(message.data);
                                this._conn.xmlInput(message);
                                var see_uri = message.getAttribute("see-other-uri");
                                if (see_uri) {
                                    this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
                                    this._conn.reset();
                                    this._conn.service = see_uri;
                                    this._connect();
                                } else {
                                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
                                    this._conn._doDisconnect();
                                }
                            } else {
                                var string = this._streamWrap(message.data);
                                var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
                                this.socket.onmessage = this._onMessage.bind(this);
                                this._conn._connect_cb(elem, null, message.data);
                            }
                        },
                        
                        /** PrivateFunction: _disconnect
                         *  _Private_ function called by Strophe.Connection.disconnect
                         *
                         *  Disconnects and sends a last stanza if one is given
                         *
                         *  Parameters:
                         *    (Request) pres - This stanza will be sent before disconnecting.
                         */
                        _disconnect: function (pres)
                        {
                            if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                                if (pres) {
                                    this._conn.send(pres);
                                }
                                var close = $build("close", { "xmlns": Strophe.NS.FRAMING, });
                                this._conn.xmlOutput(close);
                                var closeString = Strophe.serialize(close);
                                this._conn.rawOutput(closeString);
                                try {
                                    this.socket.send(closeString);
                                } catch (e) {
                                    Strophe.info("Couldn't send <close /> tag.");
                                }
                            }
                            this._conn._doDisconnect();
                        },
                        
                        /** PrivateFunction: _doDisconnect
                         *  _Private_ function to disconnect.
                         *
                         *  Just closes the Socket for WebSockets
                         */
                        _doDisconnect: function ()
                        {
                            Strophe.info("WebSockets _doDisconnect was called");
                            this._closeSocket();
                        },
                        
                        /** PrivateFunction _streamWrap
                         *  _Private_ helper function to wrap a stanza in a <stream> tag.
                         *  This is used so Strophe can process stanzas from WebSockets like BOSH
                         */
                        _streamWrap: function (stanza)
                        {
                            return "<wrapper>" + stanza + '</wrapper>';
                        },
                        
                        
                        /** PrivateFunction: _closeSocket
                         *  _Private_ function to close the WebSocket.
                         *
                         *  Closes the socket if it is still open and deletes it
                         */
                        _closeSocket: function ()
                        {
                            if (this.socket) { try {
                                this.socket.close();
                            } catch (e) {} }
                            this.socket = null;
                        },
                        
                        /** PrivateFunction: _emptyQueue
                         * _Private_ function to check if the message queue is empty.
                         *
                         *  Returns:
                         *    True, because WebSocket messages are send immediately after queueing.
                         */
                        _emptyQueue: function ()
                        {
                            return true;
                        },
                        
                        /** PrivateFunction: _onClose
                         * _Private_ function to handle websockets closing.
                         *
                         * Nothing to do here for WebSockets
                         */
                        _onClose: function() {
                            if(this._conn.connected && !this._conn.disconnecting) {
                                Strophe.error("Websocket closed unexcectedly");
                                this._conn._doDisconnect();
                            } else {
                                Strophe.info("Websocket closed");
                            }
                        },
                        
                        /** PrivateFunction: _no_auth_received
                         *
                         * Called on stream start/restart when no stream:features
                         * has been received.
                         */
                        _no_auth_received: function (_callback)
                        {
                            Strophe.error("Server did not send any auth methods");
                            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
                            if (_callback) {
                                _callback = _callback.bind(this._conn);
                                _callback();
                            }
                            this._conn._doDisconnect();
                        },
                        
                        /** PrivateFunction: _onDisconnectTimeout
                         *  _Private_ timeout handler for handling non-graceful disconnection.
                         *
                         *  This does nothing for WebSockets
                         */
                        _onDisconnectTimeout: function () {},
                        
                        /** PrivateFunction: _abortAllRequests
                         *  _Private_ helper function that makes sure all pending requests are aborted.
                         */
                        _abortAllRequests: function () {},
                        
                        /** PrivateFunction: _onError
                         * _Private_ function to handle websockets errors.
                         *
                         * Parameters:
                         * (Object) error - The websocket error.
                         */
                        _onError: function(error) {
                            Strophe.error("Websocket error " + error);
                            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established was disconnected.");
                            this._disconnect();
                        },
                        
                        /** PrivateFunction: _onIdle
                         *  _Private_ function called by Strophe.Connection._onIdle
                         *
                         *  sends all queued stanzas
                         */
                        _onIdle: function () {
                            var data = this._conn._data;
                            if (data.length > 0 && !this._conn.paused) {
                                for (var i = 0; i < data.length; i++) {
                                    if (data[i] !== null) {
                                        var stanza, rawStanza;
                                        if (data[i] === "restart") {
                                            stanza = this._buildStream().tree();
                                        } else {
                                            stanza = data[i];
                                        }
                                        rawStanza = Strophe.serialize(stanza);
                                        this._conn.xmlOutput(stanza);
                                        this._conn.rawOutput(rawStanza);
                                        this.socket.send(rawStanza);
                                    }
                                }
                                this._conn._data = [];
                            }
                        },
                        
                        /** PrivateFunction: _onMessage
                         * _Private_ function to handle websockets messages.
                         *
                         * This function parses each of the messages as if they are full documents. [TODO : We may actually want to use a SAX Push parser].
                         *
                         * Since all XMPP traffic starts with "<stream:stream version='1.0' xml:lang='en' xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' id='3697395463' from='SERVER'>"
                         * The first stanza will always fail to be parsed...
                         * Addtionnaly, the seconds stanza will always be a <stream:features> with the stream NS defined in the previous stanza... so we need to 'force' the inclusion of the NS in this stanza!
                         *
                         * Parameters:
                         * (string) message - The websocket message.
                         */
                        _onMessage: function(message) {
                            var elem, data;
                            // check for closing stream
                            var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                            if (message.data === close) {
                                this._conn.rawInput(close);
                                this._conn.xmlInput(message);
                                if (!this._conn.disconnecting) {
                                    this._conn._doDisconnect();
                                }
                                return;
                            } else if (message.data.search("<open ") === 0) {
                                // This handles stream restarts
                                elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
                                
                                if (!this._handleStreamStart(elem)) {
                                    return;
                                }
                            } else {
                                data = this._streamWrap(message.data);
                                elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
                            }
                            
                            if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
                                return;
                            }
                            
                            //handle unavailable presence stanza before disconnecting
                            if (this._conn.disconnecting &&
                                elem.firstChild.nodeName === "presence" &&
                                elem.firstChild.getAttribute("type") === "unavailable") {
                                this._conn.xmlInput(elem);
                                this._conn.rawInput(Strophe.serialize(elem));
                                // if we are already disconnecting we will ignore the unavailable stanza and
                                // wait for the </stream:stream> tag before we close the connection
                                return;
                            }
                            this._conn._dataRecv(elem, message.data);
                        },
                        
                        /** PrivateFunction: _onOpen
                         * _Private_ function to handle websockets connection setup.
                         *
                         * The opening stream tag is sent here.
                         */
                        _onOpen: function() {
                            Strophe.info("Websocket open");
                            var start = this._buildStream();
                            this._conn.xmlOutput(start.tree());
                            
                            var startString = Strophe.serialize(start);
                            this._conn.rawOutput(startString);
                            this.socket.send(startString);
                        },
                        
                        /** PrivateFunction: _reqToData
                         * _Private_ function to get a stanza out of a request.
                         *
                         * WebSockets don't use requests, so the passed argument is just returned.
                         *
                         *  Parameters:
                         *    (Object) stanza - The stanza.
                         *
                         *  Returns:
                         *    The stanza that was passed.
                         */
                        _reqToData: function (stanza)
                        {
                            return stanza;
                        },
                        
                        /** PrivateFunction: _send
                         *  _Private_ part of the Connection.send function for WebSocket
                         *
                         * Just flushes the messages that are in the queue
                         */
                        _send: function () {
                            this._conn.flush();
                        },
                        
                        /** PrivateFunction: _sendRestart
                         *
                         *  Send an xmpp:restart stanza.
                         */
                        _sendRestart: function ()
                        {
                            clearTimeout(this._conn._idleTimeout);
                            this._conn._onIdle.bind(this._conn)();
                        }
                    };
                    return Strophe;
                }));
                
                /* jshint ignore:start */
                if (callback) {
                    return callback(Strophe, $build, $msg, $iq, $pres);
                }
                
                
            })(function (Strophe, build, msg, iq, pres) {
                window.Strophe = Strophe;
                window.$build = build;
                window.$msg = msg;
                window.$iq = iq;
                window.$pres = pres;
            });
            /* jshint ignore:end */
            
            ; browserify_shim__define__module__export__(typeof Strophe != "undefined" ? Strophe : window.Strophe);
            
        }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"/Users/cody/Desktop/jitsi-meet-723/node_modules/jquery/dist/jquery.js":84}],174:[function(require,module,exports){
    /**
     * Entity Capabilities (XEP-0115)
     *
     * Depends on disco plugin.
     *
     * See: http://xmpp.org/extensions/xep-0115.html
     *
     * Authors:
     *   - Michael Weibel <michael.weibel@gmail.com>
     *
     * Copyright:
     *   - Michael Weibel <michael.weibel@gmail.com>
     */
    
    Strophe.addConnectionPlugin('caps', {
        /** Constant: HASH
         * Hash used
         *
         * Currently only sha-1 is supported.
         */
        HASH: 'sha-1',
        /** Variable: node
         * Client which is being used.
         *
         * Can be overwritten as soon as Strophe has been initialized.
         */
        node: 'http://strophe.im/strophejs/',
        /** PrivateVariable: _ver
         * Own generated version string
         */
        _ver: '',
        /** PrivateVariable: _connection
         * Strophe connection
         */
        _connection: null,
        /** PrivateVariable: _knownCapabilities
         * A hashtable containing version-strings and their capabilities, serialized
         * as string.
         *
         * TODO: Maybe those caps shouldn't be serialized.
         */
        _knownCapabilities: {},
        /** PrivateVariable: _jidVerIndex
         * A hashtable containing jids and their versions for better lookup of capabilities.
         */
        _jidVerIndex: {},
        
        /** Function: init
         * Initialize plugin:
         *   - Add caps namespace
         *   - Add caps feature to disco plugin
         *   - Add handler for caps stanzas
         *
         * Parameters:
         *   (Strophe.Connection) conn - Strophe connection
         */
        init: function(conn) {
            this._connection = conn;
            
            Strophe.addNamespace('CAPS', 'http://jabber.org/protocol/caps');
            
            if (!this._connection.disco) {
                throw "Caps plugin requires the disco plugin to be installed.";
            }
            
            this._connection.disco.addFeature(Strophe.NS.CAPS);
            this._connection.addHandler(this._delegateCapabilities.bind(this), Strophe.NS.CAPS);
        },
        
        /** Function: generateCapsAttrs
         * Returns the attributes for generating the "c"-stanza containing the own version
         *
         * Returns:
         *   (Object) - attributes
         */
        generateCapsAttrs: function() {
            return {
                'xmlns': Strophe.NS.CAPS,
                'hash': this.HASH,
                'node': this.node,
                'ver': this.generateVer()
            };
        },
        
        /** Function: generateVer
         * Returns the base64 encoded version string (encoded itself with sha1)
         *
         * Returns:
         *   (String) - version
         */
        generateVer: function() {
            if (this._ver !== "") {
                return this._ver;
            }
            
            var ver = "",
                identities = this._connection.disco._identities.sort(this._sortIdentities),
                identitiesLen = identities.length,
                features = this._connection.disco._features.sort(),
                featuresLen = features.length;
            for(var i = 0; i < identitiesLen; i++) {
                var curIdent = identities[i];
                ver += curIdent.category + "/" + curIdent.type + "/" + curIdent.lang + "/" + curIdent.name + "<";
            }
            for(var i = 0; i < featuresLen; i++) {
                ver += features[i] + '<';
            }
            
            this._ver = b64_sha1(ver);
            return this._ver;
        },
        
        /** Function: getCapabilitiesByJid
         * Returns serialized capabilities of a jid (if available).
         * Otherwise null.
         *
         * Parameters:
         *   (String) jid - Jabber id
         *
         * Returns:
         *   (String|null) - capabilities, serialized; or null when not available.
         */
        getCapabilitiesByJid: function(jid) {
            if (this._jidVerIndex[jid]) {
                return this._knownCapabilities[this._jidVerIndex[jid]];
            }
            return null;
        },
        
        /** PrivateFunction: _delegateCapabilities
         * Checks if the version has already been saved.
         * If yes: do nothing.
         * If no: Request capabilities
         *
         * Parameters:
         *   (Strophe.Builder) stanza - Stanza
         *
         * Returns:
         *   (Boolean)
         */
        _delegateCapabilities: function(stanza) {
            var from = stanza.getAttribute('from'),
                c = stanza.querySelector('c'),
                ver = c.getAttribute('ver'),
                node = c.getAttribute('node');
            if (!this._knownCapabilities[ver]) {
                return this._requestCapabilities(from, node, ver);
            } else {
                this._jidVerIndex[from] = ver;
            }
            if (!this._jidVerIndex[from] || !this._jidVerIndex[from] !== ver) {
                this._jidVerIndex[from] = ver;
            }
            return true;
        },
        
        /** PrivateFunction: _requestCapabilities
         * Requests capabilities from the one which sent the caps-info stanza.
         * This is done using disco info.
         *
         * Additionally, it registers a handler for handling the reply.
         *
         * Parameters:
         *   (String) to - Destination jid
         *   (String) node - Node attribute of the caps-stanza
         *   (String) ver - Version of the caps-stanza
         *
         * Returns:
         *   (Boolean) - true
         */
        _requestCapabilities: function(to, node, ver) {
            if (to !== this._connection.jid) {
                var id = this._connection.disco.info(to, node + '#' + ver);
                this._connection.addHandler(this._handleDiscoInfoReply.bind(this), Strophe.NS.DISCO_INFO, 'iq', 'result', id, to);
            }
            return true;
        },
        
        /** PrivateFunction: _handleDiscoInfoReply
         * Parses the disco info reply and adds the version & it's capabilities to the _knownCapabilities variable.
         * Additionally, it adds the jid & the version to the _jidVerIndex variable for a better lookup.
         *
         * Parameters:
         *   (Strophe.Builder) stanza - Disco info stanza
         *
         * Returns:
         *   (Boolean) - false, to automatically remove the handler.
         */
        _handleDiscoInfoReply: function(stanza) {
            var query = stanza.querySelector('query'),
                node = query.getAttribute('node').split('#'),
                ver = node[1],
                from = stanza.getAttribute('from');
            if (!this._knownCapabilities[ver]) {
                var childNodes = query.childNodes,
                    childNodesLen = childNodes.length;
                this._knownCapabilities[ver] = [];
                for(var i = 0; i < childNodesLen; i++) {
                    var node = childNodes[i];
                    this._knownCapabilities[ver].push({name: node.nodeName, attributes: node.attributes});
                }
                this._jidVerIndex[from] = ver;
            } else if (!this._jidVerIndex[from] || !this._jidVerIndex[from] !== ver) {
                this._jidVerIndex[from] = ver;
            }
            return false;
        },
        
        /** PrivateFunction: _sortIdentities
         * Sorts two identities according the sorting requirements in XEP-0115.
         *
         * Parameters:
         *   (Object) a - Identity a
         *   (Object) b - Identity b
         *
         * Returns:
         *   (Integer) - 1, 0 or -1; according to which one's greater.
         */
        _sortIdentities: function(a, b) {
            if (a.category > b.category) {
                return 1;
            }
            if (a.category < b.category) {
                return -1;
            }
            if (a.type > b.type) {
                return 1;
            }
            if (a.type < b.type) {
                return -1;
            }
            if (a.lang > b.lang) {
                return 1;
            }
            if (a.lang < b.lang) {
                return -1;
            }
            return 0;
        }
    });
    
},{}],175:[function(require,module,exports){
    (function (global){
        
        ; Strophe = global.Strophe = require("/Users/cody/Desktop/jitsi-meet-723/node_modules/strophe/strophe.js");
        ; var __browserify_shim_require__=require;(function browserifyShim(module, define, require) {
            /*
             Copyright 2010, François de Metz <francois@2metz.fr>
             */
            
            /**
             * Disco Strophe Plugin
             * Implement http://xmpp.org/extensions/xep-0030.html
             * TODO: manage node hierarchies, and node on info request
             */
            
            (function (root, factory) {
                if (typeof define === 'function' && define.amd) {
                    // AMD. Register as an anonymous module.
                    define("strophe.disco", [
                        "strophe"
                    ], function (Strophe) {
                        factory(
                            Strophe.Strophe,
                            Strophe.$build,
                            Strophe.$iq ,
                            Strophe.$msg,
                            Strophe.$pres
                        );
                        return Strophe;
                    });
                } else {
                    // Browser globals
                    factory(
                        root.Strophe,
                        root.$build,
                        root.$iq ,
                        root.$msg,
                        root.$pres
                    );
                }
            }(this, function (Strophe, $build, $iq, $msg, $pres) {
                
                Strophe.addConnectionPlugin('disco',
                    {
                        _connection: null,
                        _identities : [],
                        _features : [],
                        _items : [],
                        /** Function: init
                         * Plugin init
                         *
                         * Parameters:
                         *   (Strophe.Connection) conn - Strophe connection
                         */
                        init: function(conn)
                        {
                            this._connection = conn;
                            this._identities = [];
                            this._features   = [];
                            this._items      = [];
                            // disco info
                            conn.addHandler(this._onDiscoInfo.bind(this), Strophe.NS.DISCO_INFO, 'iq', 'get', null, null);
                            // disco items
                            conn.addHandler(this._onDiscoItems.bind(this), Strophe.NS.DISCO_ITEMS, 'iq', 'get', null, null);
                        },
                        /** Function: addIdentity
                         * See http://xmpp.org/registrar/disco-categories.html
                         * Parameters:
                         *   (String) category - category of identity (like client, automation, etc ...)
                         *   (String) type - type of identity (like pc, web, bot , etc ...)
                         *   (String) name - name of identity in natural language
                         *   (String) lang - lang of name parameter
                         *
                         * Returns:
                         *   Boolean
                         */
                        addIdentity: function(category, type, name, lang)
                        {
                            for (var i=0; i<this._identities.length; i++)
                            {
                                if (this._identities[i].category == category &&
                                    this._identities[i].type == type &&
                                    this._identities[i].name == name &&
                                    this._identities[i].lang == lang)
                                {
                                    return false;
                                }
                            }
                            this._identities.push({category: category, type: type, name: name, lang: lang});
                            return true;
                        },
                        /** Function: addFeature
                         *
                         * Parameters:
                         *   (String) var_name - feature name (like jabber:iq:version)
                         *
                         * Returns:
                         *   boolean
                         */
                        addFeature: function(var_name)
                        {
                            for (var i=0; i<this._features.length; i++)
                            {
                                if (this._features[i] == var_name)
                                    return false;
                            }
                            this._features.push(var_name);
                            return true;
                        },
                        /** Function: removeFeature
                         *
                         * Parameters:
                         *   (String) var_name - feature name (like jabber:iq:version)
                         *
                         * Returns:
                         *   boolean
                         */
                        removeFeature: function(var_name)
                        {
                            for (var i=0; i<this._features.length; i++)
                            {
                                if (this._features[i] === var_name){
                                    this._features.splice(i,1);
                                    return true;
                                }
                            }
                            return false;
                        },
                        /** Function: addItem
                         *
                         * Parameters:
                         *   (String) jid
                         *   (String) name
                         *   (String) node
                         *   (Function) call_back
                         *
                         * Returns:
                         *   boolean
                         */
                        addItem: function(jid, name, node, call_back)
                        {
                            if (node && !call_back)
                                return false;
                            this._items.push({jid: jid, name: name, node: node, call_back: call_back});
                            return true;
                        },
                        /** Function: info
                         * Info query
                         *
                         * Parameters:
                         *   (Function) call_back
                         *   (String) jid
                         *   (String) node
                         */
                        info: function(jid, node, success, error, timeout)
                        {
                            var attrs = {xmlns: Strophe.NS.DISCO_INFO};
                            if (node)
                                attrs.node = node;
                            
                            var info = $iq({from:this._connection.jid,
                                to:jid, type:'get'}).c('query', attrs);
                            this._connection.sendIQ(info, success, error, timeout);
                        },
                        /** Function: items
                         * Items query
                         *
                         * Parameters:
                         *   (Function) call_back
                         *   (String) jid
                         *   (String) node
                         */
                        items: function(jid, node, success, error, timeout)
                        {
                            var attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
                            if (node)
                                attrs.node = node;
                            
                            var items = $iq({from:this._connection.jid,
                                to:jid, type:'get'}).c('query', attrs);
                            this._connection.sendIQ(items, success, error, timeout);
                        },
                        
                        /** PrivateFunction: _buildIQResult
                         */
                        _buildIQResult: function(stanza, query_attrs)
                        {
                            var id   =  stanza.getAttribute('id');
                            var from = stanza.getAttribute('from');
                            var iqresult = $iq({type: 'result', id: id});
                            
                            if (from !== null) {
                                iqresult.attrs({to: from});
                            }
                            
                            return iqresult.c('query', query_attrs);
                        },
                        
                        /** PrivateFunction: _onDiscoInfo
                         * Called when receive info request
                         */
                        _onDiscoInfo: function(stanza)
                        {
                            var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
                            var attrs = {xmlns: Strophe.NS.DISCO_INFO};
                            var i;
                            if (node)
                            {
                                attrs.node = node;
                            }
                            var iqresult = this._buildIQResult(stanza, attrs);
                            for (i=0; i<this._identities.length; i++)
                            {
                                attrs = {category: this._identities[i].category,
                                    type    : this._identities[i].type};
                                if (this._identities[i].name)
                                    attrs.name = this._identities[i].name;
                                if (this._identities[i].lang)
                                    attrs['xml:lang'] = this._identities[i].lang;
                                iqresult.c('identity', attrs).up();
                            }
                            for (i=0; i<this._features.length; i++)
                            {
                                iqresult.c('feature', {'var':this._features[i]}).up();
                            }
                            this._connection.send(iqresult.tree());
                            return true;
                        },
                        /** PrivateFunction: _onDiscoItems
                         * Called when receive items request
                         */
                        _onDiscoItems: function(stanza)
                        {
                            var query_attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
                            var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
                            var items, i;
                            if (node)
                            {
                                query_attrs.node = node;
                                items = [];
                                for (i = 0; i < this._items.length; i++)
                                {
                                    if (this._items[i].node == node)
                                    {
                                        items = this._items[i].call_back(stanza);
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                items = this._items;
                            }
                            var iqresult = this._buildIQResult(stanza, query_attrs);
                            for (i = 0; i < items.length; i++)
                            {
                                var attrs = {jid:  items[i].jid};
                                if (items[i].name)
                                    attrs.name = items[i].name;
                                if (items[i].node)
                                    attrs.node = items[i].node;
                                iqresult.c('item', attrs).up();
                            }
                            this._connection.send(iqresult.tree());
                            return true;
                        }
                    });
            }));
            
        }).call(global, module, undefined, undefined);
        
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    
},{"/Users/cody/Desktop/jitsi-meet-723/node_modules/strophe/strophe.js":173}],176:[function(require,module,exports){
    /*
     * Toastr
     * Copyright 2012-2015
     * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
     * All Rights Reserved.
     * Use, reproduction, distribution, and modification of this code is subject to the terms and
     * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
     *
     * ARIA Support: Greta Krafsig
     *
     * Project: https://github.com/CodeSeven/toastr
     */
    /* global define */
    ; (function (define) {
        define(['jquery'], function ($) {
            return (function () {
                var $container;
                var listener;
                var toastId = 0;
                var toastType = {
                    error: 'error',
                    info: 'info',
                    success: 'success',
                    warning: 'warning'
                };
                
                var toastr = {
                    clear: clear,
                    remove: remove,
                    error: error,
                    getContainer: getContainer,
                    info: info,
                    options: {},
                    subscribe: subscribe,
                    success: success,
                    version: '2.1.2',
                    warning: warning
                };
                
                var previousToast;
                
                return toastr;
                
                ////////////////
                
                function error(message, title, optionsOverride) {
                    return notify({
                        type: toastType.error,
                        iconClass: getOptions().iconClasses.error,
                        message: message,
                        optionsOverride: optionsOverride,
                        title: title
                    });
                }
                
                function getContainer(options, create) {
                    if (!options) { options = getOptions(); }
                    $container = $('#' + options.containerId);
                    if ($container.length) {
                        return $container;
                    }
                    if (create) {
                        $container = createContainer(options);
                    }
                    return $container;
                }
                
                function info(message, title, optionsOverride) {
                    return notify({
                        type: toastType.info,
                        iconClass: getOptions().iconClasses.info,
                        message: message,
                        optionsOverride: optionsOverride,
                        title: title
                    });
                }
                
                function subscribe(callback) {
                    listener = callback;
                }
                
                function success(message, title, optionsOverride) {
                    return notify({
                        type: toastType.success,
                        iconClass: getOptions().iconClasses.success,
                        message: message,
                        optionsOverride: optionsOverride,
                        title: title
                    });
                }
                
                function warning(message, title, optionsOverride) {
                    return notify({
                        type: toastType.warning,
                        iconClass: getOptions().iconClasses.warning,
                        message: message,
                        optionsOverride: optionsOverride,
                        title: title
                    });
                }
                
                function clear($toastElement, clearOptions) {
                    var options = getOptions();
                    if (!$container) { getContainer(options); }
                    if (!clearToast($toastElement, options, clearOptions)) {
                        clearContainer(options);
                    }
                }
                
                function remove($toastElement) {
                    var options = getOptions();
                    if (!$container) { getContainer(options); }
                    if ($toastElement && $(':focus', $toastElement).length === 0) {
                        removeToast($toastElement);
                        return;
                    }
                    if ($container.children().length) {
                        $container.remove();
                    }
                }
                
                // internal functions
                
                function clearContainer (options) {
                    var toastsToClear = $container.children();
                    for (var i = toastsToClear.length - 1; i >= 0; i--) {
                        clearToast($(toastsToClear[i]), options);
                    }
                }
                
                function clearToast ($toastElement, options, clearOptions) {
                    var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                    if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                        $toastElement[options.hideMethod]({
                            duration: options.hideDuration,
                            easing: options.hideEasing,
                            complete: function () { removeToast($toastElement); }
                        });
                        return true;
                    }
                    return false;
                }
                
                function createContainer(options) {
                    $container = $('<div/>')
                        .attr('id', options.containerId)
                        .addClass(options.positionClass)
                        .attr('aria-live', 'polite')
                        .attr('role', 'alert');
                    
                    $container.appendTo($(options.target));
                    return $container;
                }
                
                function getDefaults() {
                    return {
                        tapToDismiss: true,
                        toastClass: 'toast',
                        containerId: 'toast-container',
                        debug: false,
                        
                        showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                        showDuration: 300,
                        showEasing: 'swing', //swing and linear are built into jQuery
                        onShown: undefined,
                        hideMethod: 'fadeOut',
                        hideDuration: 1000,
                        hideEasing: 'swing',
                        onHidden: undefined,
                        closeMethod: false,
                        closeDuration: false,
                        closeEasing: false,
                        
                        extendedTimeOut: 1000,
                        iconClasses: {
                            error: 'toast-error',
                            info: 'toast-info',
                            success: 'toast-success',
                            warning: 'toast-warning'
                        },
                        iconClass: 'toast-info',
                        positionClass: 'toast-top-right',
                        timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                        titleClass: 'toast-title',
                        messageClass: 'toast-message',
                        escapeHtml: false,
                        target: 'body',
                        closeHtml: '<button type="button">&times;</button>',
                        newestOnTop: true,
                        preventDuplicates: false,
                        progressBar: false
                    };
                }
                
                function publish(args) {
                    if (!listener) { return; }
                    listener(args);
                }
                
                function notify(map) {
                    var options = getOptions();
                    var iconClass = map.iconClass || options.iconClass;
                    
                    if (typeof (map.optionsOverride) !== 'undefined') {
                        options = $.extend(options, map.optionsOverride);
                        iconClass = map.optionsOverride.iconClass || iconClass;
                    }
                    
                    if (shouldExit(options, map)) { return; }
                    
                    toastId++;
                    
                    $container = getContainer(options, true);
                    
                    var intervalId = null;
                    var $toastElement = $('<div/>');
                    var $titleElement = $('<div/>');
                    var $messageElement = $('<div/>');
                    var $progressElement = $('<div/>');
                    var $closeElement = $(options.closeHtml);
                    var progressBar = {
                        intervalId: null,
                        hideEta: null,
                        maxHideTime: null
                    };
                    var response = {
                        toastId: toastId,
                        state: 'visible',
                        startTime: new Date(),
                        options: options,
                        map: map
                    };
                    
                    personalizeToast();
                    
                    displayToast();
                    
                    handleEvents();
                    
                    publish(response);
                    
                    if (options.debug && console) {
                        console.log(response);
                    }
                    
                    return $toastElement;
                    
                    function escapeHtml(source) {
                        if (source == null)
                            source = "";
                        
                        return new String(source)
                            .replace(/&/g, '&amp;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#39;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;');
                    }
                    
                    function personalizeToast() {
                        setIcon();
                        setTitle();
                        setMessage();
                        setCloseButton();
                        setProgressBar();
                        setSequence();
                    }
                    
                    function handleEvents() {
                        $toastElement.hover(stickAround, delayedHideToast);
                        if (!options.onclick && options.tapToDismiss) {
                            $toastElement.click(hideToast);
                        }
                        
                        if (options.closeButton && $closeElement) {
                            $closeElement.click(function (event) {
                                if (event.stopPropagation) {
                                    event.stopPropagation();
                                } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                    event.cancelBubble = true;
                                }
                                hideToast(true);
                            });
                        }
                        
                        if (options.onclick) {
                            $toastElement.click(function (event) {
                                options.onclick(event);
                                hideToast();
                            });
                        }
                    }
                    
                    function displayToast() {
                        $toastElement.hide();
                        
                        $toastElement[options.showMethod](
                            {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                        );
                        
                        if (options.timeOut > 0) {
                            intervalId = setTimeout(hideToast, options.timeOut);
                            progressBar.maxHideTime = parseFloat(options.timeOut);
                            progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                            if (options.progressBar) {
                                progressBar.intervalId = setInterval(updateProgress, 10);
                            }
                        }
                    }
                    
                    function setIcon() {
                        if (map.iconClass) {
                            $toastElement.addClass(options.toastClass).addClass(iconClass);
                        }
                    }
                    
                    function setSequence() {
                        if (options.newestOnTop) {
                            $container.prepend($toastElement);
                        } else {
                            $container.append($toastElement);
                        }
                    }
                    
                    function setTitle() {
                        if (map.title) {
                            $titleElement.append(!options.escapeHtml ? map.title : escapeHtml(map.title)).addClass(options.titleClass);
                            $toastElement.append($titleElement);
                        }
                    }
                    
                    function setMessage() {
                        if (map.message) {
                            $messageElement.append(!options.escapeHtml ? map.message : escapeHtml(map.message)).addClass(options.messageClass);
                            $toastElement.append($messageElement);
                        }
                    }
                    
                    function setCloseButton() {
                        if (options.closeButton) {
                            $closeElement.addClass('toast-close-button').attr('role', 'button');
                            $toastElement.prepend($closeElement);
                        }
                    }
                    
                    function setProgressBar() {
                        if (options.progressBar) {
                            $progressElement.addClass('toast-progress');
                            $toastElement.prepend($progressElement);
                        }
                    }
                    
                    function shouldExit(options, map) {
                        if (options.preventDuplicates) {
                            if (map.message === previousToast) {
                                return true;
                            } else {
                                previousToast = map.message;
                            }
                        }
                        return false;
                    }
                    
                    function hideToast(override) {
                        var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                        var duration = override && options.closeDuration !== false ?
                            options.closeDuration : options.hideDuration;
                        var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                        if ($(':focus', $toastElement).length && !override) {
                            return;
                        }
                        clearTimeout(progressBar.intervalId);
                        return $toastElement[method]({
                            duration: duration,
                            easing: easing,
                            complete: function () {
                                removeToast($toastElement);
                                if (options.onHidden && response.state !== 'hidden') {
                                    options.onHidden();
                                }
                                response.state = 'hidden';
                                response.endTime = new Date();
                                publish(response);
                            }
                        });
                    }
                    
                    function delayedHideToast() {
                        if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                            intervalId = setTimeout(hideToast, options.extendedTimeOut);
                            progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                            progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        }
                    }
                    
                    function stickAround() {
                        clearTimeout(intervalId);
                        progressBar.hideEta = 0;
                        $toastElement.stop(true, true)[options.showMethod](
                            {duration: options.showDuration, easing: options.showEasing}
                        );
                    }
                    
                    function updateProgress() {
                        var percentage = ((progressBar.hideEta - (new Date().getTime())) / progressBar.maxHideTime) * 100;
                        $progressElement.width(percentage + '%');
                    }
                }
                
                function getOptions() {
                    return $.extend({}, getDefaults(), toastr.options);
                }
                
                function removeToast($toastElement) {
                    if (!$container) { $container = getContainer(); }
                    if ($toastElement.is(':visible')) {
                        return;
                    }
                    $toastElement.remove();
                    $toastElement = null;
                    if ($container.children().length === 0) {
                        $container.remove();
                        previousToast = undefined;
                    }
                }
                
            })();
        });
    }(typeof define === 'function' && define.amd ? define : function (deps, factory) {
        if (typeof module !== 'undefined' && module.exports) { //Node
            module.exports = factory(require('jquery'));
        } else {
            window.toastr = factory(window.jQuery);
        }
    }));
    
},{"jquery":84}],177:[function(require,module,exports){
    var MediaStreamType = {
        VIDEO_TYPE: "Video",
        
        AUDIO_TYPE: "Audio"
    };
    module.exports = MediaStreamType;
},{}],178:[function(require,module,exports){
    var RTCEvents = {
        RTC_READY: "rtc.ready",
        DATA_CHANNEL_OPEN: "rtc.data_channel_open",
        LASTN_CHANGED: "rtc.lastn_changed",
        DOMINANTSPEAKER_CHANGED: "rtc.dominantspeaker_changed",
        LASTN_ENDPOINT_CHANGED: "rtc.lastn_endpoint_changed",
        AVAILABLE_DEVICES_CHANGED: "rtc.available_devices_changed",
        AUDIO_MUTE: "rtc.audio_mute",
        VIDEO_MUTE: "rtc.video_mute"
    };
    
    module.exports = RTCEvents;
},{}],179:[function(require,module,exports){
    var Resolutions = {
        "1080": {
            width: 1920,
            height: 1080,
            order: 7
        },
        "fullhd": {
            width: 1920,
            height: 1080,
            order: 7
        },
        "720": {
            width: 1280,
            height: 720,
            order: 6
        },
        "hd": {
            width: 1280,
            height: 720,
            order: 6
        },
        "960": {
            width: 960,
            height: 720,
            order: 5
        },
        "640": {
            width: 640,
            height: 480,
            order: 4
        },
        "vga": {
            width: 640,
            height: 480,
            order: 4
        },
        "360": {
            width: 640,
            height: 360,
            order: 3
        },
        "320": {
            width: 320,
            height: 240,
            order: 2
        },
        "180": {
            width: 320,
            height: 180,
            order: 1
        }
    };
    module.exports = Resolutions;
},{}],180:[function(require,module,exports){
    var StreamEventTypes = {
        EVENT_TYPE_LOCAL_CREATED: "stream.local_created",
        
        EVENT_TYPE_LOCAL_CHANGED: "stream.local_changed",
        
        EVENT_TYPE_LOCAL_ENDED: "stream.local_ended",
        
        EVENT_TYPE_REMOTE_CREATED: "stream.remote_created",
        
        EVENT_TYPE_REMOTE_ENDED: "stream.remote_ended"
    };
    
    module.exports = StreamEventTypes;
},{}],181:[function(require,module,exports){
    var UIEvents = {
        NICKNAME_CHANGED: "UI.nickname_changed",
        SELECTED_ENDPOINT: "UI.selected_endpoint",
        PINNED_ENDPOINT: "UI.pinned_endpoint",
        LARGEVIDEO_INIT: "UI.largevideo_init"
    };
    module.exports = UIEvents;
},{}],182:[function(require,module,exports){
    var AuthenticationEvents = {
        /**
         * Event callback arguments:
         * function(authenticationEnabled, userIdentity)
         * authenticationEnabled - indicates whether authentication has been enabled
         *                         in this session
         * userIdentity - if user has been logged in then it contains user name. If
         *                contains 'null' or 'undefined' then user is not logged in.
         */
        IDENTITY_UPDATED: "authentication.identity_updated"
    };
    module.exports = AuthenticationEvents;
    
},{}],183:[function(require,module,exports){
    var CQEvents = {
        LOCALSTATS_UPDATED: "cq.localstats_updated",
        REMOTESTATS_UPDATED: "cq.remotestats_updated",
        STOP: "cq.stop"
    };
    
    module.exports = CQEvents;
},{}],184:[function(require,module,exports){
    var DesktopSharingEventTypes = {
        INIT: "ds.init",
        
        SWITCHING_DONE: "ds.switching_done",
        
        NEW_STREAM_CREATED: "ds.new_stream_created",
        
        /**
         * An event which indicates that the jidesha extension for Firefox is
         * needed to proceed with screen sharing, and that it is not installed.
         */
        FIREFOX_EXTENSION_NEEDED: "ds.firefox_extension_needed"
    };
    
    module.exports = DesktopSharingEventTypes;
},{}],185:[function(require,module,exports){
    var Events = {
        DTMF_SUPPORT_CHANGED: "members.dtmf_support_changed"
    };
    
    module.exports = Events;
    
},{}],186:[function(require,module,exports){
    module.exports = {
        /**
         * An event carrying connection statistics.
         */
        CONNECTION_STATS: "statistics.connectionstats",
        /**
         * FIXME: needs documentation.
         */
        AUDIO_LEVEL: "statistics.audioLevel",
        /**
         * FIXME: needs documentation.
         */
        STOP: "statistics.stop"
    };
    
},{}],187:[function(require,module,exports){
    module.exports = {
        getLanguages : function () {
            var languages = [];
            for (var lang in this)
            {
                if (typeof this[lang] === "string")
                    languages.push(this[lang]);
            }
            return languages;
        },
        EN: "en",
        BG: "bg",
        DE: "de",
        TR: "tr",
        FR: "fr"
    };
},{}],188:[function(require,module,exports){
    var XMPPEvents = {
        // Designates an event indicating that the connection to the XMPP server
        // failed.
        CONNECTION_FAILED: "xmpp.connection.failed",
        // Designates an event indicating that the media (ICE) connection was
        // interrupted. This should go to the RTC module.
        CONNECTION_INTERRUPTED: "xmpp.connection.interrupted",
        // Designates an event indicating that the media (ICE) connection was
        // restored. This should go to the RTC module.
        CONNECTION_RESTORED: "xmpp.connection.restored",
        // Designates an event indicating that an offer (e.g. Jingle
        // session-initiate) was received.
        CALL_INCOMING: "xmpp.callincoming.jingle",
        // Designates an event indicating that we were kicked from the XMPP MUC.
        KICKED: "xmpp.kicked",
        // Designates an event indicating that the userID for a specific JID has
        // changed.
        // Note: currently this event fires every time we receive presence from
        // someone (regardless of whether or not the "userID" changed).
        USER_ID_CHANGED: "xmpp.user_id_changed",
        // Designates an event indicating that we have joined the XMPP MUC.
        MUC_JOINED: "xmpp.muc_joined",
        // Designates an event indicating that a participant joined the XMPP MUC.
        MUC_MEMBER_JOINED: "xmpp.muc_member_joined",
        // Designates an event indicating that a participant left the XMPP MUC.
        MUC_MEMBER_LEFT: "xmpp.muc_member_left",
        // Designates an event indicating that the MUC role of a participant has
        // changed.
        MUC_ROLE_CHANGED: "xmpp.muc_role_changed",
        // Designates an event indicating that the XMPP MUC was destroyed.
        MUC_DESTROYED: "xmpp.muc_destroyed",
        // Designates an event indicating that the display name of a participant
        // has changed.
        DISPLAY_NAME_CHANGED: "xmpp.display_name_changed",
        // Designates an event indicating that we received statistics from a
        // participant in the MUC.
        REMOTE_STATS: "xmpp.remote_stats",
        // Designates an event indicating that our role in the XMPP MUC has changed.
        LOCAL_ROLE_CHANGED: "xmpp.localrole_changed",
        // Designates an event indicating that the subject of the XMPP MUC has
        // changed.
        SUBJECT_CHANGED: "xmpp.subject_changed",
        // Designates an event indicating that an XMPP message in the MUC was
        // received.
        MESSAGE_RECEIVED: "xmpp.message_received",
        // Designates an event indicating that we sent an XMPP message to the MUC.
        SENDING_CHAT_MESSAGE: "xmpp.sending_chat_message",
        // Designates an event indicating that the video type (e.g. 'camera' or
        // 'screen') for a participant has changed.
        // Note: currently this event fires every time we receive presence from
        // someone (regardless of whether or not the "video type" changed).
        PARTICIPANT_VIDEO_TYPE_CHANGED: "xmpp.video_type",
        // Designates an event indicating that a participant in the XMPP MUC has
        // advertised that they have audio muted (or unmuted).
        PARTICIPANT_AUDIO_MUTED: "xmpp.audio_muted",
        // Designates an event indicating that a participant in the XMPP MUC has
        // advertised that they have video muted (or unmuted).
        PARTICIPANT_VIDEO_MUTED: "xmpp.video_muted",
        // Designates an event indicating that the focus has asked us to mute our
        // audio.
        AUDIO_MUTED_BY_FOCUS: "xmpp.audio_muted_by_focus",
        // Designates an event indicating that a moderator in the room changed the
        // "start muted" settings for the conference.
        START_MUTED_SETTING_CHANGED: "xmpp.start_muted_setting_changed",
        // Designates an event indicating that we should join the conference with
        // audio and/or video muted.
        START_MUTED_FROM_FOCUS: "xmpp.start_muted_from_focus",
        // Designates an event indicating that a remote participant's available
        // devices (whether he supports a audio and/or video) changed.
        // Note: currently this event fires every time we receive presence from
        // someone (regardless of whether or not the devices changed).
        DEVICE_AVAILABLE: "xmpp.device_available",
        
        
        PEERCONNECTION_READY: "xmpp.peerconnection_ready",
        CONFERENCE_SETUP_FAILED: "xmpp.conference_setup_failed",
        PASSWORD_REQUIRED: "xmpp.password_required",
        AUTHENTICATION_REQUIRED: "xmpp.authentication_required",
        CHAT_ERROR_RECEIVED: "xmpp.chat_error_received",
        ETHERPAD: "xmpp.etherpad",
        BRIDGE_DOWN: "xmpp.bridge_down",
        PRESENCE_STATUS: "xmpp.presence_status",
        RESERVATION_ERROR: "xmpp.room_reservation_error",
        DISPOSE_CONFERENCE: "xmpp.dispose_conference",
        GRACEFUL_SHUTDOWN: "xmpp.graceful_shutdown",
        // TODO: only used in a hack, should probably be removed.
        SET_LOCAL_DESCRIPTION_ERROR: 'xmpp.set_local_description_error',
        // TODO: only used in a hack, should probably be removed.
        SET_REMOTE_DESCRIPTION_ERROR: 'xmpp.set_remote_description_error',
        // TODO: only used in a hack, should probably be removed.
        CREATE_ANSWER_ERROR: 'xmpp.create_answer_error',
        JINGLE_FATAL_ERROR: 'xmpp.jingle_fatal_error',
        PROMPT_FOR_LOGIN: 'xmpp.prompt_for_login',
        FOCUS_DISCONNECTED: 'xmpp.focus_disconnected',
        ROOM_JOIN_ERROR: 'xmpp.room_join_error',
        ROOM_CONNECT_ERROR: 'xmpp.room_connect_error',
        // xmpp is connected and obtained user media
        READY_TO_JOIN: 'xmpp.ready_to_join'
    };
    module.exports = XMPPEvents;
},{}]},{},[1])(1)
});
//# sourceMappingURL=app.bundle.js.map
